// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: points.proto
// Protobuf C++ Version: 6.33.0

#ifndef points_2eproto_2epb_2eh
#define points_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "collections.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "json_with_int.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_points_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_points_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_points_2eproto;
}  // extern "C"
namespace qdrant {
enum Direction : int;
extern const uint32_t Direction_internal_data_[];
enum FieldType : int;
extern const uint32_t FieldType_internal_data_[];
enum Fusion : int;
extern const uint32_t Fusion_internal_data_[];
enum ReadConsistencyType : int;
extern const uint32_t ReadConsistencyType_internal_data_[];
enum RecommendStrategy : int;
extern const uint32_t RecommendStrategy_internal_data_[];
enum Sample : int;
extern const uint32_t Sample_internal_data_[];
enum UpdateStatus : int;
extern const uint32_t UpdateStatus_internal_data_[];
enum WriteOrderingType : int;
extern const uint32_t WriteOrderingType_internal_data_[];
class BatchResult;
struct BatchResultDefaultTypeInternal;
extern BatchResultDefaultTypeInternal _BatchResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BatchResult_class_data_;
class ClearPayloadPoints;
struct ClearPayloadPointsDefaultTypeInternal;
extern ClearPayloadPointsDefaultTypeInternal _ClearPayloadPoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ClearPayloadPoints_class_data_;
class Condition;
struct ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Condition_class_data_;
class ContextExamplePair;
struct ContextExamplePairDefaultTypeInternal;
extern ContextExamplePairDefaultTypeInternal _ContextExamplePair_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ContextExamplePair_class_data_;
class ContextInput;
struct ContextInputDefaultTypeInternal;
extern ContextInputDefaultTypeInternal _ContextInput_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ContextInput_class_data_;
class ContextInputPair;
struct ContextInputPairDefaultTypeInternal;
extern ContextInputPairDefaultTypeInternal _ContextInputPair_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ContextInputPair_class_data_;
class CountPoints;
struct CountPointsDefaultTypeInternal;
extern CountPointsDefaultTypeInternal _CountPoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CountPoints_class_data_;
class CountResponse;
struct CountResponseDefaultTypeInternal;
extern CountResponseDefaultTypeInternal _CountResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CountResponse_class_data_;
class CountResult;
struct CountResultDefaultTypeInternal;
extern CountResultDefaultTypeInternal _CountResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CountResult_class_data_;
class CreateFieldIndexCollection;
struct CreateFieldIndexCollectionDefaultTypeInternal;
extern CreateFieldIndexCollectionDefaultTypeInternal _CreateFieldIndexCollection_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CreateFieldIndexCollection_class_data_;
class DatetimeRange;
struct DatetimeRangeDefaultTypeInternal;
extern DatetimeRangeDefaultTypeInternal _DatetimeRange_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DatetimeRange_class_data_;
class DecayParamsExpression;
struct DecayParamsExpressionDefaultTypeInternal;
extern DecayParamsExpressionDefaultTypeInternal _DecayParamsExpression_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DecayParamsExpression_class_data_;
class DeleteFieldIndexCollection;
struct DeleteFieldIndexCollectionDefaultTypeInternal;
extern DeleteFieldIndexCollectionDefaultTypeInternal _DeleteFieldIndexCollection_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeleteFieldIndexCollection_class_data_;
class DeletePayloadPoints;
struct DeletePayloadPointsDefaultTypeInternal;
extern DeletePayloadPointsDefaultTypeInternal _DeletePayloadPoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeletePayloadPoints_class_data_;
class DeletePointVectors;
struct DeletePointVectorsDefaultTypeInternal;
extern DeletePointVectorsDefaultTypeInternal _DeletePointVectors_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeletePointVectors_class_data_;
class DeletePoints;
struct DeletePointsDefaultTypeInternal;
extern DeletePointsDefaultTypeInternal _DeletePoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeletePoints_class_data_;
class DenseVector;
struct DenseVectorDefaultTypeInternal;
extern DenseVectorDefaultTypeInternal _DenseVector_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DenseVector_class_data_;
class DiscoverBatchPoints;
struct DiscoverBatchPointsDefaultTypeInternal;
extern DiscoverBatchPointsDefaultTypeInternal _DiscoverBatchPoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DiscoverBatchPoints_class_data_;
class DiscoverBatchResponse;
struct DiscoverBatchResponseDefaultTypeInternal;
extern DiscoverBatchResponseDefaultTypeInternal _DiscoverBatchResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DiscoverBatchResponse_class_data_;
class DiscoverInput;
struct DiscoverInputDefaultTypeInternal;
extern DiscoverInputDefaultTypeInternal _DiscoverInput_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DiscoverInput_class_data_;
class DiscoverPoints;
struct DiscoverPointsDefaultTypeInternal;
extern DiscoverPointsDefaultTypeInternal _DiscoverPoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DiscoverPoints_class_data_;
class DiscoverResponse;
struct DiscoverResponseDefaultTypeInternal;
extern DiscoverResponseDefaultTypeInternal _DiscoverResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DiscoverResponse_class_data_;
class DivExpression;
struct DivExpressionDefaultTypeInternal;
extern DivExpressionDefaultTypeInternal _DivExpression_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DivExpression_class_data_;
class Document;
struct DocumentDefaultTypeInternal;
extern DocumentDefaultTypeInternal _Document_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Document_class_data_;
class Document_OptionsEntry_DoNotUse;
struct Document_OptionsEntry_DoNotUseDefaultTypeInternal;
extern Document_OptionsEntry_DoNotUseDefaultTypeInternal _Document_OptionsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Document_OptionsEntry_DoNotUse_class_data_;
class Expression;
struct ExpressionDefaultTypeInternal;
extern ExpressionDefaultTypeInternal _Expression_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_class_data_;
class FacetCounts;
struct FacetCountsDefaultTypeInternal;
extern FacetCountsDefaultTypeInternal _FacetCounts_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FacetCounts_class_data_;
class FacetHit;
struct FacetHitDefaultTypeInternal;
extern FacetHitDefaultTypeInternal _FacetHit_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FacetHit_class_data_;
class FacetResponse;
struct FacetResponseDefaultTypeInternal;
extern FacetResponseDefaultTypeInternal _FacetResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FacetResponse_class_data_;
class FacetValue;
struct FacetValueDefaultTypeInternal;
extern FacetValueDefaultTypeInternal _FacetValue_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FacetValue_class_data_;
class FieldCondition;
struct FieldConditionDefaultTypeInternal;
extern FieldConditionDefaultTypeInternal _FieldCondition_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FieldCondition_class_data_;
class Filter;
struct FilterDefaultTypeInternal;
extern FilterDefaultTypeInternal _Filter_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Filter_class_data_;
class Formula;
struct FormulaDefaultTypeInternal;
extern FormulaDefaultTypeInternal _Formula_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Formula_class_data_;
class Formula_DefaultsEntry_DoNotUse;
struct Formula_DefaultsEntry_DoNotUseDefaultTypeInternal;
extern Formula_DefaultsEntry_DoNotUseDefaultTypeInternal _Formula_DefaultsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Formula_DefaultsEntry_DoNotUse_class_data_;
class GeoBoundingBox;
struct GeoBoundingBoxDefaultTypeInternal;
extern GeoBoundingBoxDefaultTypeInternal _GeoBoundingBox_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GeoBoundingBox_class_data_;
class GeoDistance;
struct GeoDistanceDefaultTypeInternal;
extern GeoDistanceDefaultTypeInternal _GeoDistance_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GeoDistance_class_data_;
class GeoLineString;
struct GeoLineStringDefaultTypeInternal;
extern GeoLineStringDefaultTypeInternal _GeoLineString_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GeoLineString_class_data_;
class GeoPoint;
struct GeoPointDefaultTypeInternal;
extern GeoPointDefaultTypeInternal _GeoPoint_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GeoPoint_class_data_;
class GeoPolygon;
struct GeoPolygonDefaultTypeInternal;
extern GeoPolygonDefaultTypeInternal _GeoPolygon_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GeoPolygon_class_data_;
class GeoRadius;
struct GeoRadiusDefaultTypeInternal;
extern GeoRadiusDefaultTypeInternal _GeoRadius_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GeoRadius_class_data_;
class GetPoints;
struct GetPointsDefaultTypeInternal;
extern GetPointsDefaultTypeInternal _GetPoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetPoints_class_data_;
class GetResponse;
struct GetResponseDefaultTypeInternal;
extern GetResponseDefaultTypeInternal _GetResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetResponse_class_data_;
class GroupId;
struct GroupIdDefaultTypeInternal;
extern GroupIdDefaultTypeInternal _GroupId_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GroupId_class_data_;
class GroupsResult;
struct GroupsResultDefaultTypeInternal;
extern GroupsResultDefaultTypeInternal _GroupsResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GroupsResult_class_data_;
class HardwareUsage;
struct HardwareUsageDefaultTypeInternal;
extern HardwareUsageDefaultTypeInternal _HardwareUsage_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull HardwareUsage_class_data_;
class HasIdCondition;
struct HasIdConditionDefaultTypeInternal;
extern HasIdConditionDefaultTypeInternal _HasIdCondition_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull HasIdCondition_class_data_;
class HasVectorCondition;
struct HasVectorConditionDefaultTypeInternal;
extern HasVectorConditionDefaultTypeInternal _HasVectorCondition_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull HasVectorCondition_class_data_;
class Image;
struct ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Image_class_data_;
class Image_OptionsEntry_DoNotUse;
struct Image_OptionsEntry_DoNotUseDefaultTypeInternal;
extern Image_OptionsEntry_DoNotUseDefaultTypeInternal _Image_OptionsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Image_OptionsEntry_DoNotUse_class_data_;
class InferenceObject;
struct InferenceObjectDefaultTypeInternal;
extern InferenceObjectDefaultTypeInternal _InferenceObject_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InferenceObject_class_data_;
class InferenceObject_OptionsEntry_DoNotUse;
struct InferenceObject_OptionsEntry_DoNotUseDefaultTypeInternal;
extern InferenceObject_OptionsEntry_DoNotUseDefaultTypeInternal _InferenceObject_OptionsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InferenceObject_OptionsEntry_DoNotUse_class_data_;
class InferenceUsage;
struct InferenceUsageDefaultTypeInternal;
extern InferenceUsageDefaultTypeInternal _InferenceUsage_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InferenceUsage_class_data_;
class InferenceUsage_ModelsEntry_DoNotUse;
struct InferenceUsage_ModelsEntry_DoNotUseDefaultTypeInternal;
extern InferenceUsage_ModelsEntry_DoNotUseDefaultTypeInternal _InferenceUsage_ModelsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InferenceUsage_ModelsEntry_DoNotUse_class_data_;
class IsEmptyCondition;
struct IsEmptyConditionDefaultTypeInternal;
extern IsEmptyConditionDefaultTypeInternal _IsEmptyCondition_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull IsEmptyCondition_class_data_;
class IsNullCondition;
struct IsNullConditionDefaultTypeInternal;
extern IsNullConditionDefaultTypeInternal _IsNullCondition_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull IsNullCondition_class_data_;
class LookupLocation;
struct LookupLocationDefaultTypeInternal;
extern LookupLocationDefaultTypeInternal _LookupLocation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LookupLocation_class_data_;
class Match;
struct MatchDefaultTypeInternal;
extern MatchDefaultTypeInternal _Match_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Match_class_data_;
class MinShould;
struct MinShouldDefaultTypeInternal;
extern MinShouldDefaultTypeInternal _MinShould_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MinShould_class_data_;
class Mmr;
struct MmrDefaultTypeInternal;
extern MmrDefaultTypeInternal _Mmr_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Mmr_class_data_;
class ModelUsage;
struct ModelUsageDefaultTypeInternal;
extern ModelUsageDefaultTypeInternal _ModelUsage_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ModelUsage_class_data_;
class MultExpression;
struct MultExpressionDefaultTypeInternal;
extern MultExpressionDefaultTypeInternal _MultExpression_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MultExpression_class_data_;
class MultiDenseVector;
struct MultiDenseVectorDefaultTypeInternal;
extern MultiDenseVectorDefaultTypeInternal _MultiDenseVector_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MultiDenseVector_class_data_;
class NamedVectors;
struct NamedVectorsDefaultTypeInternal;
extern NamedVectorsDefaultTypeInternal _NamedVectors_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NamedVectors_class_data_;
class NamedVectorsOutput;
struct NamedVectorsOutputDefaultTypeInternal;
extern NamedVectorsOutputDefaultTypeInternal _NamedVectorsOutput_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NamedVectorsOutput_class_data_;
class NamedVectorsOutput_VectorsEntry_DoNotUse;
struct NamedVectorsOutput_VectorsEntry_DoNotUseDefaultTypeInternal;
extern NamedVectorsOutput_VectorsEntry_DoNotUseDefaultTypeInternal _NamedVectorsOutput_VectorsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NamedVectorsOutput_VectorsEntry_DoNotUse_class_data_;
class NamedVectors_VectorsEntry_DoNotUse;
struct NamedVectors_VectorsEntry_DoNotUseDefaultTypeInternal;
extern NamedVectors_VectorsEntry_DoNotUseDefaultTypeInternal _NamedVectors_VectorsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NamedVectors_VectorsEntry_DoNotUse_class_data_;
class NearestInputWithMmr;
struct NearestInputWithMmrDefaultTypeInternal;
extern NearestInputWithMmrDefaultTypeInternal _NearestInputWithMmr_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NearestInputWithMmr_class_data_;
class NestedCondition;
struct NestedConditionDefaultTypeInternal;
extern NestedConditionDefaultTypeInternal _NestedCondition_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NestedCondition_class_data_;
class OrderBy;
struct OrderByDefaultTypeInternal;
extern OrderByDefaultTypeInternal _OrderBy_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull OrderBy_class_data_;
class OrderValue;
struct OrderValueDefaultTypeInternal;
extern OrderValueDefaultTypeInternal _OrderValue_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull OrderValue_class_data_;
class PayloadExcludeSelector;
struct PayloadExcludeSelectorDefaultTypeInternal;
extern PayloadExcludeSelectorDefaultTypeInternal _PayloadExcludeSelector_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PayloadExcludeSelector_class_data_;
class PayloadIncludeSelector;
struct PayloadIncludeSelectorDefaultTypeInternal;
extern PayloadIncludeSelectorDefaultTypeInternal _PayloadIncludeSelector_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PayloadIncludeSelector_class_data_;
class PointGroup;
struct PointGroupDefaultTypeInternal;
extern PointGroupDefaultTypeInternal _PointGroup_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointGroup_class_data_;
class PointId;
struct PointIdDefaultTypeInternal;
extern PointIdDefaultTypeInternal _PointId_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointId_class_data_;
class PointStruct;
struct PointStructDefaultTypeInternal;
extern PointStructDefaultTypeInternal _PointStruct_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointStruct_class_data_;
class PointStruct_PayloadEntry_DoNotUse;
struct PointStruct_PayloadEntry_DoNotUseDefaultTypeInternal;
extern PointStruct_PayloadEntry_DoNotUseDefaultTypeInternal _PointStruct_PayloadEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointStruct_PayloadEntry_DoNotUse_class_data_;
class PointVectors;
struct PointVectorsDefaultTypeInternal;
extern PointVectorsDefaultTypeInternal _PointVectors_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointVectors_class_data_;
class PointsIdsList;
struct PointsIdsListDefaultTypeInternal;
extern PointsIdsListDefaultTypeInternal _PointsIdsList_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointsIdsList_class_data_;
class PointsOperationResponse;
struct PointsOperationResponseDefaultTypeInternal;
extern PointsOperationResponseDefaultTypeInternal _PointsOperationResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointsOperationResponse_class_data_;
class PointsSelector;
struct PointsSelectorDefaultTypeInternal;
extern PointsSelectorDefaultTypeInternal _PointsSelector_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointsSelector_class_data_;
class PointsUpdateOperation;
struct PointsUpdateOperationDefaultTypeInternal;
extern PointsUpdateOperationDefaultTypeInternal _PointsUpdateOperation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_class_data_;
class PointsUpdateOperation_ClearPayload;
struct PointsUpdateOperation_ClearPayloadDefaultTypeInternal;
extern PointsUpdateOperation_ClearPayloadDefaultTypeInternal _PointsUpdateOperation_ClearPayload_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_ClearPayload_class_data_;
class PointsUpdateOperation_DeletePayload;
struct PointsUpdateOperation_DeletePayloadDefaultTypeInternal;
extern PointsUpdateOperation_DeletePayloadDefaultTypeInternal _PointsUpdateOperation_DeletePayload_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_DeletePayload_class_data_;
class PointsUpdateOperation_DeletePoints;
struct PointsUpdateOperation_DeletePointsDefaultTypeInternal;
extern PointsUpdateOperation_DeletePointsDefaultTypeInternal _PointsUpdateOperation_DeletePoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_DeletePoints_class_data_;
class PointsUpdateOperation_DeleteVectors;
struct PointsUpdateOperation_DeleteVectorsDefaultTypeInternal;
extern PointsUpdateOperation_DeleteVectorsDefaultTypeInternal _PointsUpdateOperation_DeleteVectors_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_DeleteVectors_class_data_;
class PointsUpdateOperation_OverwritePayload;
struct PointsUpdateOperation_OverwritePayloadDefaultTypeInternal;
extern PointsUpdateOperation_OverwritePayloadDefaultTypeInternal _PointsUpdateOperation_OverwritePayload_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_OverwritePayload_class_data_;
class PointsUpdateOperation_OverwritePayload_PayloadEntry_DoNotUse;
struct PointsUpdateOperation_OverwritePayload_PayloadEntry_DoNotUseDefaultTypeInternal;
extern PointsUpdateOperation_OverwritePayload_PayloadEntry_DoNotUseDefaultTypeInternal _PointsUpdateOperation_OverwritePayload_PayloadEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_OverwritePayload_PayloadEntry_DoNotUse_class_data_;
class PointsUpdateOperation_PointStructList;
struct PointsUpdateOperation_PointStructListDefaultTypeInternal;
extern PointsUpdateOperation_PointStructListDefaultTypeInternal _PointsUpdateOperation_PointStructList_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_PointStructList_class_data_;
class PointsUpdateOperation_SetPayload;
struct PointsUpdateOperation_SetPayloadDefaultTypeInternal;
extern PointsUpdateOperation_SetPayloadDefaultTypeInternal _PointsUpdateOperation_SetPayload_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_SetPayload_class_data_;
class PointsUpdateOperation_SetPayload_PayloadEntry_DoNotUse;
struct PointsUpdateOperation_SetPayload_PayloadEntry_DoNotUseDefaultTypeInternal;
extern PointsUpdateOperation_SetPayload_PayloadEntry_DoNotUseDefaultTypeInternal _PointsUpdateOperation_SetPayload_PayloadEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_SetPayload_PayloadEntry_DoNotUse_class_data_;
class PointsUpdateOperation_UpdateVectors;
struct PointsUpdateOperation_UpdateVectorsDefaultTypeInternal;
extern PointsUpdateOperation_UpdateVectorsDefaultTypeInternal _PointsUpdateOperation_UpdateVectors_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_UpdateVectors_class_data_;
class PowExpression;
struct PowExpressionDefaultTypeInternal;
extern PowExpressionDefaultTypeInternal _PowExpression_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PowExpression_class_data_;
class PrefetchQuery;
struct PrefetchQueryDefaultTypeInternal;
extern PrefetchQueryDefaultTypeInternal _PrefetchQuery_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PrefetchQuery_class_data_;
class QuantizationSearchParams;
struct QuantizationSearchParamsDefaultTypeInternal;
extern QuantizationSearchParamsDefaultTypeInternal _QuantizationSearchParams_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QuantizationSearchParams_class_data_;
class Query;
struct QueryDefaultTypeInternal;
extern QueryDefaultTypeInternal _Query_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Query_class_data_;
class QueryBatchPoints;
struct QueryBatchPointsDefaultTypeInternal;
extern QueryBatchPointsDefaultTypeInternal _QueryBatchPoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QueryBatchPoints_class_data_;
class QueryBatchResponse;
struct QueryBatchResponseDefaultTypeInternal;
extern QueryBatchResponseDefaultTypeInternal _QueryBatchResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QueryBatchResponse_class_data_;
class QueryGroupsResponse;
struct QueryGroupsResponseDefaultTypeInternal;
extern QueryGroupsResponseDefaultTypeInternal _QueryGroupsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QueryGroupsResponse_class_data_;
class QueryPointGroups;
struct QueryPointGroupsDefaultTypeInternal;
extern QueryPointGroupsDefaultTypeInternal _QueryPointGroups_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QueryPointGroups_class_data_;
class QueryPoints;
struct QueryPointsDefaultTypeInternal;
extern QueryPointsDefaultTypeInternal _QueryPoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QueryPoints_class_data_;
class QueryResponse;
struct QueryResponseDefaultTypeInternal;
extern QueryResponseDefaultTypeInternal _QueryResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QueryResponse_class_data_;
class Range;
struct RangeDefaultTypeInternal;
extern RangeDefaultTypeInternal _Range_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Range_class_data_;
class ReadConsistency;
struct ReadConsistencyDefaultTypeInternal;
extern ReadConsistencyDefaultTypeInternal _ReadConsistency_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReadConsistency_class_data_;
class RecommendBatchPoints;
struct RecommendBatchPointsDefaultTypeInternal;
extern RecommendBatchPointsDefaultTypeInternal _RecommendBatchPoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RecommendBatchPoints_class_data_;
class RecommendBatchResponse;
struct RecommendBatchResponseDefaultTypeInternal;
extern RecommendBatchResponseDefaultTypeInternal _RecommendBatchResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RecommendBatchResponse_class_data_;
class RecommendGroupsResponse;
struct RecommendGroupsResponseDefaultTypeInternal;
extern RecommendGroupsResponseDefaultTypeInternal _RecommendGroupsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RecommendGroupsResponse_class_data_;
class RecommendInput;
struct RecommendInputDefaultTypeInternal;
extern RecommendInputDefaultTypeInternal _RecommendInput_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RecommendInput_class_data_;
class RecommendPointGroups;
struct RecommendPointGroupsDefaultTypeInternal;
extern RecommendPointGroupsDefaultTypeInternal _RecommendPointGroups_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RecommendPointGroups_class_data_;
class RecommendPoints;
struct RecommendPointsDefaultTypeInternal;
extern RecommendPointsDefaultTypeInternal _RecommendPoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RecommendPoints_class_data_;
class RecommendResponse;
struct RecommendResponseDefaultTypeInternal;
extern RecommendResponseDefaultTypeInternal _RecommendResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RecommendResponse_class_data_;
class RepeatedIntegers;
struct RepeatedIntegersDefaultTypeInternal;
extern RepeatedIntegersDefaultTypeInternal _RepeatedIntegers_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RepeatedIntegers_class_data_;
class RepeatedStrings;
struct RepeatedStringsDefaultTypeInternal;
extern RepeatedStringsDefaultTypeInternal _RepeatedStrings_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RepeatedStrings_class_data_;
class RetrievedPoint;
struct RetrievedPointDefaultTypeInternal;
extern RetrievedPointDefaultTypeInternal _RetrievedPoint_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RetrievedPoint_class_data_;
class RetrievedPoint_PayloadEntry_DoNotUse;
struct RetrievedPoint_PayloadEntry_DoNotUseDefaultTypeInternal;
extern RetrievedPoint_PayloadEntry_DoNotUseDefaultTypeInternal _RetrievedPoint_PayloadEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RetrievedPoint_PayloadEntry_DoNotUse_class_data_;
class Rrf;
struct RrfDefaultTypeInternal;
extern RrfDefaultTypeInternal _Rrf_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Rrf_class_data_;
class ScoredPoint;
struct ScoredPointDefaultTypeInternal;
extern ScoredPointDefaultTypeInternal _ScoredPoint_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ScoredPoint_class_data_;
class ScoredPoint_PayloadEntry_DoNotUse;
struct ScoredPoint_PayloadEntry_DoNotUseDefaultTypeInternal;
extern ScoredPoint_PayloadEntry_DoNotUseDefaultTypeInternal _ScoredPoint_PayloadEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ScoredPoint_PayloadEntry_DoNotUse_class_data_;
class ScrollPoints;
struct ScrollPointsDefaultTypeInternal;
extern ScrollPointsDefaultTypeInternal _ScrollPoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ScrollPoints_class_data_;
class ScrollResponse;
struct ScrollResponseDefaultTypeInternal;
extern ScrollResponseDefaultTypeInternal _ScrollResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ScrollResponse_class_data_;
class SearchBatchPoints;
struct SearchBatchPointsDefaultTypeInternal;
extern SearchBatchPointsDefaultTypeInternal _SearchBatchPoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SearchBatchPoints_class_data_;
class SearchBatchResponse;
struct SearchBatchResponseDefaultTypeInternal;
extern SearchBatchResponseDefaultTypeInternal _SearchBatchResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SearchBatchResponse_class_data_;
class SearchGroupsResponse;
struct SearchGroupsResponseDefaultTypeInternal;
extern SearchGroupsResponseDefaultTypeInternal _SearchGroupsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SearchGroupsResponse_class_data_;
class SearchMatrixOffsets;
struct SearchMatrixOffsetsDefaultTypeInternal;
extern SearchMatrixOffsetsDefaultTypeInternal _SearchMatrixOffsets_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SearchMatrixOffsets_class_data_;
class SearchMatrixOffsetsResponse;
struct SearchMatrixOffsetsResponseDefaultTypeInternal;
extern SearchMatrixOffsetsResponseDefaultTypeInternal _SearchMatrixOffsetsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SearchMatrixOffsetsResponse_class_data_;
class SearchMatrixPair;
struct SearchMatrixPairDefaultTypeInternal;
extern SearchMatrixPairDefaultTypeInternal _SearchMatrixPair_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SearchMatrixPair_class_data_;
class SearchMatrixPairs;
struct SearchMatrixPairsDefaultTypeInternal;
extern SearchMatrixPairsDefaultTypeInternal _SearchMatrixPairs_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SearchMatrixPairs_class_data_;
class SearchMatrixPairsResponse;
struct SearchMatrixPairsResponseDefaultTypeInternal;
extern SearchMatrixPairsResponseDefaultTypeInternal _SearchMatrixPairsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SearchMatrixPairsResponse_class_data_;
class SearchMatrixPoints;
struct SearchMatrixPointsDefaultTypeInternal;
extern SearchMatrixPointsDefaultTypeInternal _SearchMatrixPoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SearchMatrixPoints_class_data_;
class SearchParams;
struct SearchParamsDefaultTypeInternal;
extern SearchParamsDefaultTypeInternal _SearchParams_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SearchParams_class_data_;
class SearchPointGroups;
struct SearchPointGroupsDefaultTypeInternal;
extern SearchPointGroupsDefaultTypeInternal _SearchPointGroups_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SearchPointGroups_class_data_;
class SearchPoints;
struct SearchPointsDefaultTypeInternal;
extern SearchPointsDefaultTypeInternal _SearchPoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SearchPoints_class_data_;
class SearchResponse;
struct SearchResponseDefaultTypeInternal;
extern SearchResponseDefaultTypeInternal _SearchResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SearchResponse_class_data_;
class SetPayloadPoints;
struct SetPayloadPointsDefaultTypeInternal;
extern SetPayloadPointsDefaultTypeInternal _SetPayloadPoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SetPayloadPoints_class_data_;
class SetPayloadPoints_PayloadEntry_DoNotUse;
struct SetPayloadPoints_PayloadEntry_DoNotUseDefaultTypeInternal;
extern SetPayloadPoints_PayloadEntry_DoNotUseDefaultTypeInternal _SetPayloadPoints_PayloadEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SetPayloadPoints_PayloadEntry_DoNotUse_class_data_;
class ShardKeySelector;
struct ShardKeySelectorDefaultTypeInternal;
extern ShardKeySelectorDefaultTypeInternal _ShardKeySelector_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ShardKeySelector_class_data_;
class SparseIndices;
struct SparseIndicesDefaultTypeInternal;
extern SparseIndicesDefaultTypeInternal _SparseIndices_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SparseIndices_class_data_;
class SparseVector;
struct SparseVectorDefaultTypeInternal;
extern SparseVectorDefaultTypeInternal _SparseVector_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SparseVector_class_data_;
class StartFrom;
struct StartFromDefaultTypeInternal;
extern StartFromDefaultTypeInternal _StartFrom_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StartFrom_class_data_;
class SumExpression;
struct SumExpressionDefaultTypeInternal;
extern SumExpressionDefaultTypeInternal _SumExpression_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SumExpression_class_data_;
class TargetVector;
struct TargetVectorDefaultTypeInternal;
extern TargetVectorDefaultTypeInternal _TargetVector_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TargetVector_class_data_;
class UpdateBatchPoints;
struct UpdateBatchPointsDefaultTypeInternal;
extern UpdateBatchPointsDefaultTypeInternal _UpdateBatchPoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateBatchPoints_class_data_;
class UpdateBatchResponse;
struct UpdateBatchResponseDefaultTypeInternal;
extern UpdateBatchResponseDefaultTypeInternal _UpdateBatchResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateBatchResponse_class_data_;
class UpdatePointVectors;
struct UpdatePointVectorsDefaultTypeInternal;
extern UpdatePointVectorsDefaultTypeInternal _UpdatePointVectors_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdatePointVectors_class_data_;
class UpdateResult;
struct UpdateResultDefaultTypeInternal;
extern UpdateResultDefaultTypeInternal _UpdateResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateResult_class_data_;
class UpsertPoints;
struct UpsertPointsDefaultTypeInternal;
extern UpsertPointsDefaultTypeInternal _UpsertPoints_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpsertPoints_class_data_;
class Usage;
struct UsageDefaultTypeInternal;
extern UsageDefaultTypeInternal _Usage_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Usage_class_data_;
class ValuesCount;
struct ValuesCountDefaultTypeInternal;
extern ValuesCountDefaultTypeInternal _ValuesCount_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ValuesCount_class_data_;
class Vector;
struct VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Vector_class_data_;
class VectorExample;
struct VectorExampleDefaultTypeInternal;
extern VectorExampleDefaultTypeInternal _VectorExample_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VectorExample_class_data_;
class VectorInput;
struct VectorInputDefaultTypeInternal;
extern VectorInputDefaultTypeInternal _VectorInput_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VectorInput_class_data_;
class VectorOutput;
struct VectorOutputDefaultTypeInternal;
extern VectorOutputDefaultTypeInternal _VectorOutput_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VectorOutput_class_data_;
class Vectors;
struct VectorsDefaultTypeInternal;
extern VectorsDefaultTypeInternal _Vectors_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Vectors_class_data_;
class VectorsOutput;
struct VectorsOutputDefaultTypeInternal;
extern VectorsOutputDefaultTypeInternal _VectorsOutput_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VectorsOutput_class_data_;
class VectorsSelector;
struct VectorsSelectorDefaultTypeInternal;
extern VectorsSelectorDefaultTypeInternal _VectorsSelector_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VectorsSelector_class_data_;
class WithLookup;
struct WithLookupDefaultTypeInternal;
extern WithLookupDefaultTypeInternal _WithLookup_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull WithLookup_class_data_;
class WithPayloadSelector;
struct WithPayloadSelectorDefaultTypeInternal;
extern WithPayloadSelectorDefaultTypeInternal _WithPayloadSelector_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull WithPayloadSelector_class_data_;
class WithVectorsSelector;
struct WithVectorsSelectorDefaultTypeInternal;
extern WithVectorsSelectorDefaultTypeInternal _WithVectorsSelector_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull WithVectorsSelector_class_data_;
class WriteOrdering;
struct WriteOrderingDefaultTypeInternal;
extern WriteOrderingDefaultTypeInternal _WriteOrdering_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull WriteOrdering_class_data_;
}  // namespace qdrant
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::qdrant::Direction_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::Direction>;
template <>
internal::EnumTraitsT<::qdrant::FieldType_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::FieldType>;
template <>
internal::EnumTraitsT<::qdrant::Fusion_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::Fusion>;
template <>
internal::EnumTraitsT<::qdrant::ReadConsistencyType_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::ReadConsistencyType>;
template <>
internal::EnumTraitsT<::qdrant::RecommendStrategy_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::RecommendStrategy>;
template <>
internal::EnumTraitsT<::qdrant::Sample_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::Sample>;
template <>
internal::EnumTraitsT<::qdrant::UpdateStatus_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::UpdateStatus>;
template <>
internal::EnumTraitsT<::qdrant::WriteOrderingType_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::WriteOrderingType>;
}  // namespace protobuf
}  // namespace google

namespace qdrant {
enum WriteOrderingType : int {
  Weak = 0,
  Medium = 1,
  Strong = 2,
  WriteOrderingType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  WriteOrderingType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t WriteOrderingType_internal_data_[];
inline constexpr WriteOrderingType WriteOrderingType_MIN =
    static_cast<WriteOrderingType>(0);
inline constexpr WriteOrderingType WriteOrderingType_MAX =
    static_cast<WriteOrderingType>(2);
inline bool WriteOrderingType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int WriteOrderingType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL WriteOrderingType_descriptor();
template <typename T>
const ::std::string& WriteOrderingType_Name(T value) {
  static_assert(::std::is_same<T, WriteOrderingType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to WriteOrderingType_Name().");
  return WriteOrderingType_Name(static_cast<WriteOrderingType>(value));
}
template <>
inline const ::std::string& WriteOrderingType_Name(WriteOrderingType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<WriteOrderingType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool WriteOrderingType_Parse(
    ::absl::string_view name, WriteOrderingType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<WriteOrderingType>(WriteOrderingType_descriptor(), name,
                                           value);
}
enum ReadConsistencyType : int {
  All = 0,
  Majority = 1,
  Quorum = 2,
  ReadConsistencyType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ReadConsistencyType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ReadConsistencyType_internal_data_[];
inline constexpr ReadConsistencyType ReadConsistencyType_MIN =
    static_cast<ReadConsistencyType>(0);
inline constexpr ReadConsistencyType ReadConsistencyType_MAX =
    static_cast<ReadConsistencyType>(2);
inline bool ReadConsistencyType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ReadConsistencyType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ReadConsistencyType_descriptor();
template <typename T>
const ::std::string& ReadConsistencyType_Name(T value) {
  static_assert(::std::is_same<T, ReadConsistencyType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ReadConsistencyType_Name().");
  return ReadConsistencyType_Name(static_cast<ReadConsistencyType>(value));
}
template <>
inline const ::std::string& ReadConsistencyType_Name(ReadConsistencyType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ReadConsistencyType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool ReadConsistencyType_Parse(
    ::absl::string_view name, ReadConsistencyType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReadConsistencyType>(ReadConsistencyType_descriptor(), name,
                                           value);
}
enum FieldType : int {
  FieldTypeKeyword = 0,
  FieldTypeInteger = 1,
  FieldTypeFloat = 2,
  FieldTypeGeo = 3,
  FieldTypeText = 4,
  FieldTypeBool = 5,
  FieldTypeDatetime = 6,
  FieldTypeUuid = 7,
  FieldType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  FieldType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t FieldType_internal_data_[];
inline constexpr FieldType FieldType_MIN =
    static_cast<FieldType>(0);
inline constexpr FieldType FieldType_MAX =
    static_cast<FieldType>(7);
inline bool FieldType_IsValid(int value) {
  return 0 <= value && value <= 7;
}
inline constexpr int FieldType_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL FieldType_descriptor();
template <typename T>
const ::std::string& FieldType_Name(T value) {
  static_assert(::std::is_same<T, FieldType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to FieldType_Name().");
  return FieldType_Name(static_cast<FieldType>(value));
}
template <>
inline const ::std::string& FieldType_Name(FieldType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FieldType_descriptor, 0, 7>(
      static_cast<int>(value));
}
inline bool FieldType_Parse(
    ::absl::string_view name, FieldType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<FieldType>(FieldType_descriptor(), name,
                                           value);
}
enum Direction : int {
  Asc = 0,
  Desc = 1,
  Direction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Direction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Direction_internal_data_[];
inline constexpr Direction Direction_MIN =
    static_cast<Direction>(0);
inline constexpr Direction Direction_MAX =
    static_cast<Direction>(1);
inline bool Direction_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int Direction_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Direction_descriptor();
template <typename T>
const ::std::string& Direction_Name(T value) {
  static_assert(::std::is_same<T, Direction>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Direction_Name().");
  return Direction_Name(static_cast<Direction>(value));
}
template <>
inline const ::std::string& Direction_Name(Direction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Direction_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool Direction_Parse(
    ::absl::string_view name, Direction* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Direction>(Direction_descriptor(), name,
                                           value);
}
enum RecommendStrategy : int {
  AverageVector = 0,
  BestScore = 1,
  SumScores = 2,
  RecommendStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RecommendStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RecommendStrategy_internal_data_[];
inline constexpr RecommendStrategy RecommendStrategy_MIN =
    static_cast<RecommendStrategy>(0);
inline constexpr RecommendStrategy RecommendStrategy_MAX =
    static_cast<RecommendStrategy>(2);
inline bool RecommendStrategy_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int RecommendStrategy_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RecommendStrategy_descriptor();
template <typename T>
const ::std::string& RecommendStrategy_Name(T value) {
  static_assert(::std::is_same<T, RecommendStrategy>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to RecommendStrategy_Name().");
  return RecommendStrategy_Name(static_cast<RecommendStrategy>(value));
}
template <>
inline const ::std::string& RecommendStrategy_Name(RecommendStrategy value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RecommendStrategy_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool RecommendStrategy_Parse(
    ::absl::string_view name, RecommendStrategy* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecommendStrategy>(RecommendStrategy_descriptor(), name,
                                           value);
}
enum Fusion : int {
  RRF = 0,
  DBSF = 1,
  Fusion_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Fusion_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Fusion_internal_data_[];
inline constexpr Fusion Fusion_MIN =
    static_cast<Fusion>(0);
inline constexpr Fusion Fusion_MAX =
    static_cast<Fusion>(1);
inline bool Fusion_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int Fusion_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Fusion_descriptor();
template <typename T>
const ::std::string& Fusion_Name(T value) {
  static_assert(::std::is_same<T, Fusion>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Fusion_Name().");
  return Fusion_Name(static_cast<Fusion>(value));
}
template <>
inline const ::std::string& Fusion_Name(Fusion value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Fusion_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool Fusion_Parse(
    ::absl::string_view name, Fusion* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Fusion>(Fusion_descriptor(), name,
                                           value);
}
enum Sample : int {
  Random = 0,
  Sample_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Sample_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Sample_internal_data_[];
inline constexpr Sample Sample_MIN =
    static_cast<Sample>(0);
inline constexpr Sample Sample_MAX =
    static_cast<Sample>(0);
inline bool Sample_IsValid(int value) {
  return 0 <= value && value <= 0;
}
inline constexpr int Sample_ARRAYSIZE = 0 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Sample_descriptor();
template <typename T>
const ::std::string& Sample_Name(T value) {
  static_assert(::std::is_same<T, Sample>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Sample_Name().");
  return Sample_Name(static_cast<Sample>(value));
}
template <>
inline const ::std::string& Sample_Name(Sample value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Sample_descriptor, 0, 0>(
      static_cast<int>(value));
}
inline bool Sample_Parse(
    ::absl::string_view name, Sample* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Sample>(Sample_descriptor(), name,
                                           value);
}
enum UpdateStatus : int {
  UnknownUpdateStatus = 0,
  Acknowledged = 1,
  Completed = 2,
  ClockRejected = 3,
  UpdateStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  UpdateStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t UpdateStatus_internal_data_[];
inline constexpr UpdateStatus UpdateStatus_MIN =
    static_cast<UpdateStatus>(0);
inline constexpr UpdateStatus UpdateStatus_MAX =
    static_cast<UpdateStatus>(3);
inline bool UpdateStatus_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int UpdateStatus_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL UpdateStatus_descriptor();
template <typename T>
const ::std::string& UpdateStatus_Name(T value) {
  static_assert(::std::is_same<T, UpdateStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to UpdateStatus_Name().");
  return UpdateStatus_Name(static_cast<UpdateStatus>(value));
}
template <>
inline const ::std::string& UpdateStatus_Name(UpdateStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UpdateStatus_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool UpdateStatus_Parse(
    ::absl::string_view name, UpdateStatus* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpdateStatus>(UpdateStatus_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class WriteOrdering final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.WriteOrdering) */ {
 public:
  inline WriteOrdering() : WriteOrdering(nullptr) {}
  ~WriteOrdering() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WriteOrdering* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WriteOrdering));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WriteOrdering(::google::protobuf::internal::ConstantInitialized);

  inline WriteOrdering(const WriteOrdering& from) : WriteOrdering(nullptr, from) {}
  inline WriteOrdering(WriteOrdering&& from) noexcept
      : WriteOrdering(nullptr, ::std::move(from)) {}
  inline WriteOrdering& operator=(const WriteOrdering& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteOrdering& operator=(WriteOrdering&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteOrdering& default_instance() {
    return *reinterpret_cast<const WriteOrdering*>(
        &_WriteOrdering_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(WriteOrdering& a, WriteOrdering& b) { a.Swap(&b); }
  inline void Swap(WriteOrdering* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteOrdering* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteOrdering* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WriteOrdering>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WriteOrdering& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WriteOrdering& from) { WriteOrdering::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WriteOrdering* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.WriteOrdering"; }

  explicit WriteOrdering(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  WriteOrdering(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const WriteOrdering& from);
  WriteOrdering(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, WriteOrdering&& from) noexcept
      : WriteOrdering(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
  };
  // .qdrant.WriteOrderingType type = 1;
  void clear_type() ;
  ::qdrant::WriteOrderingType type() const;
  void set_type(::qdrant::WriteOrderingType value);

  private:
  ::qdrant::WriteOrderingType _internal_type() const;
  void _internal_set_type(::qdrant::WriteOrderingType value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.WriteOrdering)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const WriteOrdering& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull WriteOrdering_class_data_;
// -------------------------------------------------------------------

class VectorsSelector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.VectorsSelector) */ {
 public:
  inline VectorsSelector() : VectorsSelector(nullptr) {}
  ~VectorsSelector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VectorsSelector* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VectorsSelector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VectorsSelector(::google::protobuf::internal::ConstantInitialized);

  inline VectorsSelector(const VectorsSelector& from) : VectorsSelector(nullptr, from) {}
  inline VectorsSelector(VectorsSelector&& from) noexcept
      : VectorsSelector(nullptr, ::std::move(from)) {}
  inline VectorsSelector& operator=(const VectorsSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorsSelector& operator=(VectorsSelector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorsSelector& default_instance() {
    return *reinterpret_cast<const VectorsSelector*>(
        &_VectorsSelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(VectorsSelector& a, VectorsSelector& b) { a.Swap(&b); }
  inline void Swap(VectorsSelector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorsSelector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorsSelector* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VectorsSelector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorsSelector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VectorsSelector& from) { VectorsSelector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VectorsSelector* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.VectorsSelector"; }

  explicit VectorsSelector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  VectorsSelector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const VectorsSelector& from);
  VectorsSelector(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, VectorsSelector&& from) noexcept
      : VectorsSelector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNamesFieldNumber = 1,
  };
  // repeated string names = 1;
  int names_size() const;
  private:
  int _internal_names_size() const;

  public:
  void clear_names() ;
  const ::std::string& names(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_names(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_names(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_names();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_names(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& names() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_names();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_names() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_names();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.VectorsSelector)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 36,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const VectorsSelector& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> names_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull VectorsSelector_class_data_;
// -------------------------------------------------------------------

class ValuesCount final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ValuesCount) */ {
 public:
  inline ValuesCount() : ValuesCount(nullptr) {}
  ~ValuesCount() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ValuesCount* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ValuesCount));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ValuesCount(::google::protobuf::internal::ConstantInitialized);

  inline ValuesCount(const ValuesCount& from) : ValuesCount(nullptr, from) {}
  inline ValuesCount(ValuesCount&& from) noexcept
      : ValuesCount(nullptr, ::std::move(from)) {}
  inline ValuesCount& operator=(const ValuesCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValuesCount& operator=(ValuesCount&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValuesCount& default_instance() {
    return *reinterpret_cast<const ValuesCount*>(
        &_ValuesCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 147;
  friend void swap(ValuesCount& a, ValuesCount& b) { a.Swap(&b); }
  inline void Swap(ValuesCount* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValuesCount* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValuesCount* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ValuesCount>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ValuesCount& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ValuesCount& from) { ValuesCount::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ValuesCount* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ValuesCount"; }

  explicit ValuesCount(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ValuesCount(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ValuesCount& from);
  ValuesCount(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ValuesCount&& from) noexcept
      : ValuesCount(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLtFieldNumber = 1,
    kGtFieldNumber = 2,
    kGteFieldNumber = 3,
    kLteFieldNumber = 4,
  };
  // optional uint64 lt = 1;
  bool has_lt() const;
  void clear_lt() ;
  ::uint64_t lt() const;
  void set_lt(::uint64_t value);

  private:
  ::uint64_t _internal_lt() const;
  void _internal_set_lt(::uint64_t value);

  public:
  // optional uint64 gt = 2;
  bool has_gt() const;
  void clear_gt() ;
  ::uint64_t gt() const;
  void set_gt(::uint64_t value);

  private:
  ::uint64_t _internal_gt() const;
  void _internal_set_gt(::uint64_t value);

  public:
  // optional uint64 gte = 3;
  bool has_gte() const;
  void clear_gte() ;
  ::uint64_t gte() const;
  void set_gte(::uint64_t value);

  private:
  ::uint64_t _internal_gte() const;
  void _internal_set_gte(::uint64_t value);

  public:
  // optional uint64 lte = 4;
  bool has_lte() const;
  void clear_lte() ;
  ::uint64_t lte() const;
  void set_lte(::uint64_t value);

  private:
  ::uint64_t _internal_lte() const;
  void _internal_set_lte(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.ValuesCount)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ValuesCount& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t lt_;
    ::uint64_t gt_;
    ::uint64_t gte_;
    ::uint64_t lte_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ValuesCount_class_data_;
// -------------------------------------------------------------------

class UpdateResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.UpdateResult) */ {
 public:
  inline UpdateResult() : UpdateResult(nullptr) {}
  ~UpdateResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateResult* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateResult(::google::protobuf::internal::ConstantInitialized);

  inline UpdateResult(const UpdateResult& from) : UpdateResult(nullptr, from) {}
  inline UpdateResult(UpdateResult&& from) noexcept
      : UpdateResult(nullptr, ::std::move(from)) {}
  inline UpdateResult& operator=(const UpdateResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateResult& operator=(UpdateResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateResult& default_instance() {
    return *reinterpret_cast<const UpdateResult*>(
        &_UpdateResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 100;
  friend void swap(UpdateResult& a, UpdateResult& b) { a.Swap(&b); }
  inline void Swap(UpdateResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateResult* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateResult& from) { UpdateResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateResult* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.UpdateResult"; }

  explicit UpdateResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateResult& from);
  UpdateResult(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateResult&& from) noexcept
      : UpdateResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOperationIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // optional uint64 operation_id = 1;
  bool has_operation_id() const;
  void clear_operation_id() ;
  ::uint64_t operation_id() const;
  void set_operation_id(::uint64_t value);

  private:
  ::uint64_t _internal_operation_id() const;
  void _internal_set_operation_id(::uint64_t value);

  public:
  // .qdrant.UpdateStatus status = 2;
  void clear_status() ;
  ::qdrant::UpdateStatus status() const;
  void set_status(::qdrant::UpdateStatus value);

  private:
  ::qdrant::UpdateStatus _internal_status() const;
  void _internal_set_status(::qdrant::UpdateStatus value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.UpdateResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t operation_id_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateResult_class_data_;
// -------------------------------------------------------------------

class SparseVector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SparseVector) */ {
 public:
  inline SparseVector() : SparseVector(nullptr) {}
  ~SparseVector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SparseVector* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SparseVector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SparseVector(::google::protobuf::internal::ConstantInitialized);

  inline SparseVector(const SparseVector& from) : SparseVector(nullptr, from) {}
  inline SparseVector(SparseVector&& from) noexcept
      : SparseVector(nullptr, ::std::move(from)) {}
  inline SparseVector& operator=(const SparseVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline SparseVector& operator=(SparseVector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SparseVector& default_instance() {
    return *reinterpret_cast<const SparseVector*>(
        &_SparseVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(SparseVector& a, SparseVector& b) { a.Swap(&b); }
  inline void Swap(SparseVector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SparseVector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SparseVector* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SparseVector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SparseVector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SparseVector& from) { SparseVector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SparseVector* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SparseVector"; }

  explicit SparseVector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SparseVector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SparseVector& from);
  SparseVector(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SparseVector&& from) noexcept
      : SparseVector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesFieldNumber = 1,
    kIndicesFieldNumber = 2,
  };
  // repeated float values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::google::protobuf::RepeatedField<float>& values() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL mutable_values();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_values() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL _internal_mutable_values();

  public:
  // repeated uint32 indices = 2;
  int indices_size() const;
  private:
  int _internal_indices_size() const;

  public:
  void clear_indices() ;
  ::uint32_t indices(int index) const;
  void set_indices(int index, ::uint32_t value);
  void add_indices(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& indices() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_indices();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_indices() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_indices();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SparseVector)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SparseVector& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> values_;
    ::google::protobuf::RepeatedField<::uint32_t> indices_;
    ::google::protobuf::internal::CachedSize _indices_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SparseVector_class_data_;
// -------------------------------------------------------------------

class SparseIndices final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SparseIndices) */ {
 public:
  inline SparseIndices() : SparseIndices(nullptr) {}
  ~SparseIndices() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SparseIndices* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SparseIndices));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SparseIndices(::google::protobuf::internal::ConstantInitialized);

  inline SparseIndices(const SparseIndices& from) : SparseIndices(nullptr, from) {}
  inline SparseIndices(SparseIndices&& from) noexcept
      : SparseIndices(nullptr, ::std::move(from)) {}
  inline SparseIndices& operator=(const SparseIndices& from) {
    CopyFrom(from);
    return *this;
  }
  inline SparseIndices& operator=(SparseIndices&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SparseIndices& default_instance() {
    return *reinterpret_cast<const SparseIndices*>(
        &_SparseIndices_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(SparseIndices& a, SparseIndices& b) { a.Swap(&b); }
  inline void Swap(SparseIndices* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SparseIndices* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SparseIndices* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SparseIndices>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SparseIndices& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SparseIndices& from) { SparseIndices::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SparseIndices* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SparseIndices"; }

  explicit SparseIndices(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SparseIndices(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SparseIndices& from);
  SparseIndices(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SparseIndices&& from) noexcept
      : SparseIndices(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated uint32 data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::uint32_t data(int index) const;
  void set_data(int index, ::uint32_t value);
  void add_data(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& data() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_data();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_data() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SparseIndices)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SparseIndices& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> data_;
    ::google::protobuf::internal::CachedSize _data_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SparseIndices_class_data_;
// -------------------------------------------------------------------

class Rrf final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.Rrf) */ {
 public:
  inline Rrf() : Rrf(nullptr) {}
  ~Rrf() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Rrf* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Rrf));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Rrf(::google::protobuf::internal::ConstantInitialized);

  inline Rrf(const Rrf& from) : Rrf(nullptr, from) {}
  inline Rrf(Rrf&& from) noexcept
      : Rrf(nullptr, ::std::move(from)) {}
  inline Rrf& operator=(const Rrf& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rrf& operator=(Rrf&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rrf& default_instance() {
    return *reinterpret_cast<const Rrf*>(
        &_Rrf_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 74;
  friend void swap(Rrf& a, Rrf& b) { a.Swap(&b); }
  inline void Swap(Rrf* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rrf* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rrf* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Rrf>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rrf& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Rrf& from) { Rrf::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Rrf* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.Rrf"; }

  explicit Rrf(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Rrf(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Rrf& from);
  Rrf(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Rrf&& from) noexcept
      : Rrf(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKFieldNumber = 1,
  };
  // optional uint32 k = 1;
  bool has_k() const;
  void clear_k() ;
  ::uint32_t k() const;
  void set_k(::uint32_t value);

  private:
  ::uint32_t _internal_k() const;
  void _internal_set_k(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.Rrf)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Rrf& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t k_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Rrf_class_data_;
// -------------------------------------------------------------------

class RepeatedStrings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.RepeatedStrings) */ {
 public:
  inline RepeatedStrings() : RepeatedStrings(nullptr) {}
  ~RepeatedStrings() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RepeatedStrings* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RepeatedStrings));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RepeatedStrings(::google::protobuf::internal::ConstantInitialized);

  inline RepeatedStrings(const RepeatedStrings& from) : RepeatedStrings(nullptr, from) {}
  inline RepeatedStrings(RepeatedStrings&& from) noexcept
      : RepeatedStrings(nullptr, ::std::move(from)) {}
  inline RepeatedStrings& operator=(const RepeatedStrings& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepeatedStrings& operator=(RepeatedStrings&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepeatedStrings& default_instance() {
    return *reinterpret_cast<const RepeatedStrings*>(
        &_RepeatedStrings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 139;
  friend void swap(RepeatedStrings& a, RepeatedStrings& b) { a.Swap(&b); }
  inline void Swap(RepeatedStrings* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepeatedStrings* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepeatedStrings* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RepeatedStrings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepeatedStrings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RepeatedStrings& from) { RepeatedStrings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RepeatedStrings* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.RepeatedStrings"; }

  explicit RepeatedStrings(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RepeatedStrings(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RepeatedStrings& from);
  RepeatedStrings(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RepeatedStrings&& from) noexcept
      : RepeatedStrings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStringsFieldNumber = 1,
  };
  // repeated string strings = 1;
  int strings_size() const;
  private:
  int _internal_strings_size() const;

  public:
  void clear_strings() ;
  const ::std::string& strings(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_strings(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_strings(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_strings();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_strings(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& strings() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_strings();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_strings() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_strings();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.RepeatedStrings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 38,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RepeatedStrings& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> strings_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RepeatedStrings_class_data_;
// -------------------------------------------------------------------

class RepeatedIntegers final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.RepeatedIntegers) */ {
 public:
  inline RepeatedIntegers() : RepeatedIntegers(nullptr) {}
  ~RepeatedIntegers() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RepeatedIntegers* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RepeatedIntegers));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RepeatedIntegers(::google::protobuf::internal::ConstantInitialized);

  inline RepeatedIntegers(const RepeatedIntegers& from) : RepeatedIntegers(nullptr, from) {}
  inline RepeatedIntegers(RepeatedIntegers&& from) noexcept
      : RepeatedIntegers(nullptr, ::std::move(from)) {}
  inline RepeatedIntegers& operator=(const RepeatedIntegers& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepeatedIntegers& operator=(RepeatedIntegers&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepeatedIntegers& default_instance() {
    return *reinterpret_cast<const RepeatedIntegers*>(
        &_RepeatedIntegers_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 140;
  friend void swap(RepeatedIntegers& a, RepeatedIntegers& b) { a.Swap(&b); }
  inline void Swap(RepeatedIntegers* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepeatedIntegers* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepeatedIntegers* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RepeatedIntegers>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepeatedIntegers& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RepeatedIntegers& from) { RepeatedIntegers::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RepeatedIntegers* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.RepeatedIntegers"; }

  explicit RepeatedIntegers(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RepeatedIntegers(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RepeatedIntegers& from);
  RepeatedIntegers(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RepeatedIntegers&& from) noexcept
      : RepeatedIntegers(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIntegersFieldNumber = 1,
  };
  // repeated int64 integers = 1;
  int integers_size() const;
  private:
  int _internal_integers_size() const;

  public:
  void clear_integers() ;
  ::int64_t integers(int index) const;
  void set_integers(int index, ::int64_t value);
  void add_integers(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& integers() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_integers();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_integers() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_integers();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.RepeatedIntegers)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RepeatedIntegers& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> integers_;
    ::google::protobuf::internal::CachedSize _integers_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RepeatedIntegers_class_data_;
// -------------------------------------------------------------------

class ReadConsistency final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ReadConsistency) */ {
 public:
  inline ReadConsistency() : ReadConsistency(nullptr) {}
  ~ReadConsistency() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReadConsistency* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReadConsistency));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReadConsistency(::google::protobuf::internal::ConstantInitialized);

  inline ReadConsistency(const ReadConsistency& from) : ReadConsistency(nullptr, from) {}
  inline ReadConsistency(ReadConsistency&& from) noexcept
      : ReadConsistency(nullptr, ::std::move(from)) {}
  inline ReadConsistency& operator=(const ReadConsistency& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadConsistency& operator=(ReadConsistency&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadConsistency& default_instance() {
    return *reinterpret_cast<const ReadConsistency*>(
        &_ReadConsistency_default_instance_);
  }
  enum ValueCase {
    kType = 1,
    kFactor = 2,
    VALUE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ReadConsistency& a, ReadConsistency& b) { a.Swap(&b); }
  inline void Swap(ReadConsistency* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadConsistency* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadConsistency* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReadConsistency>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReadConsistency& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReadConsistency& from) { ReadConsistency::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReadConsistency* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ReadConsistency"; }

  explicit ReadConsistency(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReadConsistency(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReadConsistency& from);
  ReadConsistency(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReadConsistency&& from) noexcept
      : ReadConsistency(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kFactorFieldNumber = 2,
  };
  // .qdrant.ReadConsistencyType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::qdrant::ReadConsistencyType type() const;
  void set_type(::qdrant::ReadConsistencyType value);

  private:
  ::qdrant::ReadConsistencyType _internal_type() const;
  void _internal_set_type(::qdrant::ReadConsistencyType value);

  public:
  // uint64 factor = 2;
  bool has_factor() const;
  void clear_factor() ;
  ::uint64_t factor() const;
  void set_factor(::uint64_t value);

  private:
  ::uint64_t _internal_factor() const;
  void _internal_set_factor(::uint64_t value);

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.ReadConsistency)
 private:
  class _Internal;
  void set_has_type();
  void set_has_factor();
  inline bool has_value() const;
  inline void clear_has_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReadConsistency& from_msg);
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int type_;
      ::uint64_t factor_;
    } value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReadConsistency_class_data_;
// -------------------------------------------------------------------

class Range final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.Range) */ {
 public:
  inline Range() : Range(nullptr) {}
  ~Range() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Range* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Range));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Range(::google::protobuf::internal::ConstantInitialized);

  inline Range(const Range& from) : Range(nullptr, from) {}
  inline Range(Range&& from) noexcept
      : Range(nullptr, ::std::move(from)) {}
  inline Range& operator=(const Range& from) {
    CopyFrom(from);
    return *this;
  }
  inline Range& operator=(Range&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Range& default_instance() {
    return *reinterpret_cast<const Range*>(
        &_Range_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 141;
  friend void swap(Range& a, Range& b) { a.Swap(&b); }
  inline void Swap(Range* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Range* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Range* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Range>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Range& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Range& from) { Range::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Range* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.Range"; }

  explicit Range(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Range(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Range& from);
  Range(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Range&& from) noexcept
      : Range(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLtFieldNumber = 1,
    kGtFieldNumber = 2,
    kGteFieldNumber = 3,
    kLteFieldNumber = 4,
  };
  // optional double lt = 1;
  bool has_lt() const;
  void clear_lt() ;
  double lt() const;
  void set_lt(double value);

  private:
  double _internal_lt() const;
  void _internal_set_lt(double value);

  public:
  // optional double gt = 2;
  bool has_gt() const;
  void clear_gt() ;
  double gt() const;
  void set_gt(double value);

  private:
  double _internal_gt() const;
  void _internal_set_gt(double value);

  public:
  // optional double gte = 3;
  bool has_gte() const;
  void clear_gte() ;
  double gte() const;
  void set_gte(double value);

  private:
  double _internal_gte() const;
  void _internal_set_gte(double value);

  public:
  // optional double lte = 4;
  bool has_lte() const;
  void clear_lte() ;
  double lte() const;
  void set_lte(double value);

  private:
  double _internal_lte() const;
  void _internal_set_lte(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.Range)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Range& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double lt_;
    double gt_;
    double gte_;
    double lte_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Range_class_data_;
// -------------------------------------------------------------------

class QuantizationSearchParams final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.QuantizationSearchParams) */ {
 public:
  inline QuantizationSearchParams() : QuantizationSearchParams(nullptr) {}
  ~QuantizationSearchParams() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QuantizationSearchParams* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QuantizationSearchParams));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QuantizationSearchParams(::google::protobuf::internal::ConstantInitialized);

  inline QuantizationSearchParams(const QuantizationSearchParams& from) : QuantizationSearchParams(nullptr, from) {}
  inline QuantizationSearchParams(QuantizationSearchParams&& from) noexcept
      : QuantizationSearchParams(nullptr, ::std::move(from)) {}
  inline QuantizationSearchParams& operator=(const QuantizationSearchParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuantizationSearchParams& operator=(QuantizationSearchParams&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuantizationSearchParams& default_instance() {
    return *reinterpret_cast<const QuantizationSearchParams*>(
        &_QuantizationSearchParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(QuantizationSearchParams& a, QuantizationSearchParams& b) { a.Swap(&b); }
  inline void Swap(QuantizationSearchParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuantizationSearchParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuantizationSearchParams* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QuantizationSearchParams>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QuantizationSearchParams& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QuantizationSearchParams& from) { QuantizationSearchParams::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QuantizationSearchParams* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.QuantizationSearchParams"; }

  explicit QuantizationSearchParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QuantizationSearchParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QuantizationSearchParams& from);
  QuantizationSearchParams(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QuantizationSearchParams&& from) noexcept
      : QuantizationSearchParams(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOversamplingFieldNumber = 3,
    kIgnoreFieldNumber = 1,
    kRescoreFieldNumber = 2,
  };
  // optional double oversampling = 3;
  bool has_oversampling() const;
  void clear_oversampling() ;
  double oversampling() const;
  void set_oversampling(double value);

  private:
  double _internal_oversampling() const;
  void _internal_set_oversampling(double value);

  public:
  // optional bool ignore = 1;
  bool has_ignore() const;
  void clear_ignore() ;
  bool ignore() const;
  void set_ignore(bool value);

  private:
  bool _internal_ignore() const;
  void _internal_set_ignore(bool value);

  public:
  // optional bool rescore = 2;
  bool has_rescore() const;
  void clear_rescore() ;
  bool rescore() const;
  void set_rescore(bool value);

  private:
  bool _internal_rescore() const;
  void _internal_set_rescore(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.QuantizationSearchParams)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QuantizationSearchParams& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double oversampling_;
    bool ignore_;
    bool rescore_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QuantizationSearchParams_class_data_;
// -------------------------------------------------------------------

class PointId final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PointId) */ {
 public:
  inline PointId() : PointId(nullptr) {}
  ~PointId() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointId* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointId));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointId(::google::protobuf::internal::ConstantInitialized);

  inline PointId(const PointId& from) : PointId(nullptr, from) {}
  inline PointId(PointId&& from) noexcept
      : PointId(nullptr, ::std::move(from)) {}
  inline PointId& operator=(const PointId& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointId& operator=(PointId&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointId& default_instance() {
    return *reinterpret_cast<const PointId*>(
        &_PointId_default_instance_);
  }
  enum PointIdOptionsCase {
    kNum = 1,
    kUuid = 2,
    POINT_ID_OPTIONS_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(PointId& a, PointId& b) { a.Swap(&b); }
  inline void Swap(PointId* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointId* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointId* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointId>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointId& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointId& from) { PointId::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointId* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PointId"; }

  explicit PointId(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointId(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointId& from);
  PointId(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointId&& from) noexcept
      : PointId(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNumFieldNumber = 1,
    kUuidFieldNumber = 2,
  };
  // uint64 num = 1;
  bool has_num() const;
  void clear_num() ;
  ::uint64_t num() const;
  void set_num(::uint64_t value);

  private:
  ::uint64_t _internal_num() const;
  void _internal_set_num(::uint64_t value);

  public:
  // string uuid = 2;
  bool has_uuid() const;
  void clear_uuid() ;
  const ::std::string& uuid() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_uuid(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_uuid();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_uuid();
  void set_allocated_uuid(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_uuid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_uuid();

  public:
  void clear_point_id_options();
  PointIdOptionsCase point_id_options_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.PointId)
 private:
  class _Internal;
  void set_has_num();
  void set_has_uuid();
  inline bool has_point_id_options() const;
  inline void clear_has_point_id_options();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   0, 27,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointId& from_msg);
    union PointIdOptionsUnion {
      constexpr PointIdOptionsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint64_t num_;
      ::google::protobuf::internal::ArenaStringPtr uuid_;
    } point_id_options_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointId_class_data_;
// -------------------------------------------------------------------

class PayloadIncludeSelector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PayloadIncludeSelector) */ {
 public:
  inline PayloadIncludeSelector() : PayloadIncludeSelector(nullptr) {}
  ~PayloadIncludeSelector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PayloadIncludeSelector* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PayloadIncludeSelector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PayloadIncludeSelector(::google::protobuf::internal::ConstantInitialized);

  inline PayloadIncludeSelector(const PayloadIncludeSelector& from) : PayloadIncludeSelector(nullptr, from) {}
  inline PayloadIncludeSelector(PayloadIncludeSelector&& from) noexcept
      : PayloadIncludeSelector(nullptr, ::std::move(from)) {}
  inline PayloadIncludeSelector& operator=(const PayloadIncludeSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadIncludeSelector& operator=(PayloadIncludeSelector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PayloadIncludeSelector& default_instance() {
    return *reinterpret_cast<const PayloadIncludeSelector*>(
        &_PayloadIncludeSelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(PayloadIncludeSelector& a, PayloadIncludeSelector& b) { a.Swap(&b); }
  inline void Swap(PayloadIncludeSelector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadIncludeSelector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadIncludeSelector* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PayloadIncludeSelector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PayloadIncludeSelector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PayloadIncludeSelector& from) { PayloadIncludeSelector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PayloadIncludeSelector* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PayloadIncludeSelector"; }

  explicit PayloadIncludeSelector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PayloadIncludeSelector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PayloadIncludeSelector& from);
  PayloadIncludeSelector(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PayloadIncludeSelector&& from) noexcept
      : PayloadIncludeSelector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFieldsFieldNumber = 1,
  };
  // repeated string fields = 1;
  int fields_size() const;
  private:
  int _internal_fields_size() const;

  public:
  void clear_fields() ;
  const ::std::string& fields(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_fields(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_fields(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_fields();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_fields(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_fields();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_fields() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_fields();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.PayloadIncludeSelector)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 44,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PayloadIncludeSelector& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> fields_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PayloadIncludeSelector_class_data_;
// -------------------------------------------------------------------

class PayloadExcludeSelector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PayloadExcludeSelector) */ {
 public:
  inline PayloadExcludeSelector() : PayloadExcludeSelector(nullptr) {}
  ~PayloadExcludeSelector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PayloadExcludeSelector* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PayloadExcludeSelector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PayloadExcludeSelector(::google::protobuf::internal::ConstantInitialized);

  inline PayloadExcludeSelector(const PayloadExcludeSelector& from) : PayloadExcludeSelector(nullptr, from) {}
  inline PayloadExcludeSelector(PayloadExcludeSelector&& from) noexcept
      : PayloadExcludeSelector(nullptr, ::std::move(from)) {}
  inline PayloadExcludeSelector& operator=(const PayloadExcludeSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadExcludeSelector& operator=(PayloadExcludeSelector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PayloadExcludeSelector& default_instance() {
    return *reinterpret_cast<const PayloadExcludeSelector*>(
        &_PayloadExcludeSelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(PayloadExcludeSelector& a, PayloadExcludeSelector& b) { a.Swap(&b); }
  inline void Swap(PayloadExcludeSelector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadExcludeSelector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadExcludeSelector* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PayloadExcludeSelector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PayloadExcludeSelector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PayloadExcludeSelector& from) { PayloadExcludeSelector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PayloadExcludeSelector* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PayloadExcludeSelector"; }

  explicit PayloadExcludeSelector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PayloadExcludeSelector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PayloadExcludeSelector& from);
  PayloadExcludeSelector(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PayloadExcludeSelector&& from) noexcept
      : PayloadExcludeSelector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFieldsFieldNumber = 1,
  };
  // repeated string fields = 1;
  int fields_size() const;
  private:
  int _internal_fields_size() const;

  public:
  void clear_fields() ;
  const ::std::string& fields(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_fields(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_fields(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_fields();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_fields(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_fields();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_fields() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_fields();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.PayloadExcludeSelector)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 44,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PayloadExcludeSelector& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> fields_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PayloadExcludeSelector_class_data_;
// -------------------------------------------------------------------

class OrderValue final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.OrderValue) */ {
 public:
  inline OrderValue() : OrderValue(nullptr) {}
  ~OrderValue() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OrderValue* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OrderValue));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OrderValue(::google::protobuf::internal::ConstantInitialized);

  inline OrderValue(const OrderValue& from) : OrderValue(nullptr, from) {}
  inline OrderValue(OrderValue&& from) noexcept
      : OrderValue(nullptr, ::std::move(from)) {}
  inline OrderValue& operator=(const OrderValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderValue& operator=(OrderValue&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderValue& default_instance() {
    return *reinterpret_cast<const OrderValue*>(
        &_OrderValue_default_instance_);
  }
  enum VariantCase {
    kInt = 1,
    kFloat = 2,
    VARIANT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 101;
  friend void swap(OrderValue& a, OrderValue& b) { a.Swap(&b); }
  inline void Swap(OrderValue* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderValue* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderValue* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OrderValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OrderValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OrderValue& from) { OrderValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OrderValue* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.OrderValue"; }

  explicit OrderValue(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  OrderValue(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const OrderValue& from);
  OrderValue(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, OrderValue&& from) noexcept
      : OrderValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIntFieldNumber = 1,
    kFloatFieldNumber = 2,
  };
  // int64 int = 1;
  bool has_int_() const;
  void clear_int_() ;
  ::int64_t int_() const;
  void set_int_(::int64_t value);

  private:
  ::int64_t _internal_int_() const;
  void _internal_set_int_(::int64_t value);

  public:
  // double float = 2;
  bool has_float_() const;
  void clear_float_() ;
  double float_() const;
  void set_float_(double value);

  private:
  double _internal_float_() const;
  void _internal_set_float_(double value);

  public:
  void clear_variant();
  VariantCase variant_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.OrderValue)
 private:
  class _Internal;
  void set_has_int_();
  void set_has_float_();
  inline bool has_variant() const;
  inline void clear_has_variant();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const OrderValue& from_msg);
    union VariantUnion {
      constexpr VariantUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t int__;
      double float__;
    } variant_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull OrderValue_class_data_;
// -------------------------------------------------------------------

class ModelUsage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ModelUsage) */ {
 public:
  inline ModelUsage() : ModelUsage(nullptr) {}
  ~ModelUsage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ModelUsage* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ModelUsage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelUsage(::google::protobuf::internal::ConstantInitialized);

  inline ModelUsage(const ModelUsage& from) : ModelUsage(nullptr, from) {}
  inline ModelUsage(ModelUsage&& from) noexcept
      : ModelUsage(nullptr, ::std::move(from)) {}
  inline ModelUsage& operator=(const ModelUsage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelUsage& operator=(ModelUsage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelUsage& default_instance() {
    return *reinterpret_cast<const ModelUsage*>(
        &_ModelUsage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 156;
  friend void swap(ModelUsage& a, ModelUsage& b) { a.Swap(&b); }
  inline void Swap(ModelUsage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelUsage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelUsage* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ModelUsage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModelUsage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ModelUsage& from) { ModelUsage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ModelUsage* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ModelUsage"; }

  explicit ModelUsage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ModelUsage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ModelUsage& from);
  ModelUsage(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ModelUsage&& from) noexcept
      : ModelUsage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTokensFieldNumber = 1,
  };
  // uint64 tokens = 1;
  void clear_tokens() ;
  ::uint64_t tokens() const;
  void set_tokens(::uint64_t value);

  private:
  ::uint64_t _internal_tokens() const;
  void _internal_set_tokens(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.ModelUsage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ModelUsage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t tokens_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ModelUsage_class_data_;
// -------------------------------------------------------------------

class Mmr final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.Mmr) */ {
 public:
  inline Mmr() : Mmr(nullptr) {}
  ~Mmr() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Mmr* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Mmr));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Mmr(::google::protobuf::internal::ConstantInitialized);

  inline Mmr(const Mmr& from) : Mmr(nullptr, from) {}
  inline Mmr(Mmr&& from) noexcept
      : Mmr(nullptr, ::std::move(from)) {}
  inline Mmr& operator=(const Mmr& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mmr& operator=(Mmr&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mmr& default_instance() {
    return *reinterpret_cast<const Mmr*>(
        &_Mmr_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 73;
  friend void swap(Mmr& a, Mmr& b) { a.Swap(&b); }
  inline void Swap(Mmr* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mmr* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mmr* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Mmr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Mmr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Mmr& from) { Mmr::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Mmr* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.Mmr"; }

  explicit Mmr(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Mmr(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Mmr& from);
  Mmr(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Mmr&& from) noexcept
      : Mmr(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDiversityFieldNumber = 2,
    kCandidatesLimitFieldNumber = 3,
  };
  // optional float diversity = 2;
  bool has_diversity() const;
  void clear_diversity() ;
  float diversity() const;
  void set_diversity(float value);

  private:
  float _internal_diversity() const;
  void _internal_set_diversity(float value);

  public:
  // optional uint32 candidates_limit = 3;
  bool has_candidates_limit() const;
  void clear_candidates_limit() ;
  ::uint32_t candidates_limit() const;
  void set_candidates_limit(::uint32_t value);

  private:
  ::uint32_t _internal_candidates_limit() const;
  void _internal_set_candidates_limit(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.Mmr)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Mmr& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    float diversity_;
    ::uint32_t candidates_limit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Mmr_class_data_;
// -------------------------------------------------------------------

class IsNullCondition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.IsNullCondition) */ {
 public:
  inline IsNullCondition() : IsNullCondition(nullptr) {}
  ~IsNullCondition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IsNullCondition* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IsNullCondition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IsNullCondition(::google::protobuf::internal::ConstantInitialized);

  inline IsNullCondition(const IsNullCondition& from) : IsNullCondition(nullptr, from) {}
  inline IsNullCondition(IsNullCondition&& from) noexcept
      : IsNullCondition(nullptr, ::std::move(from)) {}
  inline IsNullCondition& operator=(const IsNullCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsNullCondition& operator=(IsNullCondition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsNullCondition& default_instance() {
    return *reinterpret_cast<const IsNullCondition*>(
        &_IsNullCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 133;
  friend void swap(IsNullCondition& a, IsNullCondition& b) { a.Swap(&b); }
  inline void Swap(IsNullCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsNullCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsNullCondition* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IsNullCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IsNullCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IsNullCondition& from) { IsNullCondition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IsNullCondition* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.IsNullCondition"; }

  explicit IsNullCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  IsNullCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const IsNullCondition& from);
  IsNullCondition(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, IsNullCondition&& from) noexcept
      : IsNullCondition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
  };
  // string key = 1;
  void clear_key() ;
  const ::std::string& key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_key();
  void set_allocated_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_key();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.IsNullCondition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 34,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const IsNullCondition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull IsNullCondition_class_data_;
// -------------------------------------------------------------------

class IsEmptyCondition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.IsEmptyCondition) */ {
 public:
  inline IsEmptyCondition() : IsEmptyCondition(nullptr) {}
  ~IsEmptyCondition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IsEmptyCondition* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IsEmptyCondition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IsEmptyCondition(::google::protobuf::internal::ConstantInitialized);

  inline IsEmptyCondition(const IsEmptyCondition& from) : IsEmptyCondition(nullptr, from) {}
  inline IsEmptyCondition(IsEmptyCondition&& from) noexcept
      : IsEmptyCondition(nullptr, ::std::move(from)) {}
  inline IsEmptyCondition& operator=(const IsEmptyCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsEmptyCondition& operator=(IsEmptyCondition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsEmptyCondition& default_instance() {
    return *reinterpret_cast<const IsEmptyCondition*>(
        &_IsEmptyCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 132;
  friend void swap(IsEmptyCondition& a, IsEmptyCondition& b) { a.Swap(&b); }
  inline void Swap(IsEmptyCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsEmptyCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsEmptyCondition* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IsEmptyCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IsEmptyCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IsEmptyCondition& from) { IsEmptyCondition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IsEmptyCondition* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.IsEmptyCondition"; }

  explicit IsEmptyCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  IsEmptyCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const IsEmptyCondition& from);
  IsEmptyCondition(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, IsEmptyCondition&& from) noexcept
      : IsEmptyCondition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
  };
  // string key = 1;
  void clear_key() ;
  const ::std::string& key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_key();
  void set_allocated_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_key();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.IsEmptyCondition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 35,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const IsEmptyCondition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull IsEmptyCondition_class_data_;
// -------------------------------------------------------------------

class HasVectorCondition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.HasVectorCondition) */ {
 public:
  inline HasVectorCondition() : HasVectorCondition(nullptr) {}
  ~HasVectorCondition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HasVectorCondition* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HasVectorCondition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HasVectorCondition(::google::protobuf::internal::ConstantInitialized);

  inline HasVectorCondition(const HasVectorCondition& from) : HasVectorCondition(nullptr, from) {}
  inline HasVectorCondition(HasVectorCondition&& from) noexcept
      : HasVectorCondition(nullptr, ::std::move(from)) {}
  inline HasVectorCondition& operator=(const HasVectorCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline HasVectorCondition& operator=(HasVectorCondition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HasVectorCondition& default_instance() {
    return *reinterpret_cast<const HasVectorCondition*>(
        &_HasVectorCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 135;
  friend void swap(HasVectorCondition& a, HasVectorCondition& b) { a.Swap(&b); }
  inline void Swap(HasVectorCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HasVectorCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HasVectorCondition* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HasVectorCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HasVectorCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HasVectorCondition& from) { HasVectorCondition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HasVectorCondition* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.HasVectorCondition"; }

  explicit HasVectorCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  HasVectorCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HasVectorCondition& from);
  HasVectorCondition(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, HasVectorCondition&& from) noexcept
      : HasVectorCondition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHasVectorFieldNumber = 1,
  };
  // string has_vector = 1;
  void clear_has_vector() ;
  const ::std::string& has_vector() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_has_vector(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_has_vector();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_has_vector();
  void set_allocated_has_vector(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_has_vector() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_has_vector(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_has_vector();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.HasVectorCondition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 44,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const HasVectorCondition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr has_vector_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull HasVectorCondition_class_data_;
// -------------------------------------------------------------------

class HardwareUsage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.HardwareUsage) */ {
 public:
  inline HardwareUsage() : HardwareUsage(nullptr) {}
  ~HardwareUsage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HardwareUsage* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HardwareUsage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HardwareUsage(::google::protobuf::internal::ConstantInitialized);

  inline HardwareUsage(const HardwareUsage& from) : HardwareUsage(nullptr, from) {}
  inline HardwareUsage(HardwareUsage&& from) noexcept
      : HardwareUsage(nullptr, ::std::move(from)) {}
  inline HardwareUsage& operator=(const HardwareUsage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HardwareUsage& operator=(HardwareUsage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HardwareUsage& default_instance() {
    return *reinterpret_cast<const HardwareUsage*>(
        &_HardwareUsage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 157;
  friend void swap(HardwareUsage& a, HardwareUsage& b) { a.Swap(&b); }
  inline void Swap(HardwareUsage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HardwareUsage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HardwareUsage* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HardwareUsage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HardwareUsage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HardwareUsage& from) { HardwareUsage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HardwareUsage* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.HardwareUsage"; }

  explicit HardwareUsage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  HardwareUsage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HardwareUsage& from);
  HardwareUsage(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, HardwareUsage&& from) noexcept
      : HardwareUsage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCpuFieldNumber = 1,
    kPayloadIoReadFieldNumber = 2,
    kPayloadIoWriteFieldNumber = 3,
    kPayloadIndexIoReadFieldNumber = 4,
    kPayloadIndexIoWriteFieldNumber = 5,
    kVectorIoReadFieldNumber = 6,
    kVectorIoWriteFieldNumber = 7,
  };
  // uint64 cpu = 1;
  void clear_cpu() ;
  ::uint64_t cpu() const;
  void set_cpu(::uint64_t value);

  private:
  ::uint64_t _internal_cpu() const;
  void _internal_set_cpu(::uint64_t value);

  public:
  // uint64 payload_io_read = 2;
  void clear_payload_io_read() ;
  ::uint64_t payload_io_read() const;
  void set_payload_io_read(::uint64_t value);

  private:
  ::uint64_t _internal_payload_io_read() const;
  void _internal_set_payload_io_read(::uint64_t value);

  public:
  // uint64 payload_io_write = 3;
  void clear_payload_io_write() ;
  ::uint64_t payload_io_write() const;
  void set_payload_io_write(::uint64_t value);

  private:
  ::uint64_t _internal_payload_io_write() const;
  void _internal_set_payload_io_write(::uint64_t value);

  public:
  // uint64 payload_index_io_read = 4;
  void clear_payload_index_io_read() ;
  ::uint64_t payload_index_io_read() const;
  void set_payload_index_io_read(::uint64_t value);

  private:
  ::uint64_t _internal_payload_index_io_read() const;
  void _internal_set_payload_index_io_read(::uint64_t value);

  public:
  // uint64 payload_index_io_write = 5;
  void clear_payload_index_io_write() ;
  ::uint64_t payload_index_io_write() const;
  void set_payload_index_io_write(::uint64_t value);

  private:
  ::uint64_t _internal_payload_index_io_write() const;
  void _internal_set_payload_index_io_write(::uint64_t value);

  public:
  // uint64 vector_io_read = 6;
  void clear_vector_io_read() ;
  ::uint64_t vector_io_read() const;
  void set_vector_io_read(::uint64_t value);

  private:
  ::uint64_t _internal_vector_io_read() const;
  void _internal_set_vector_io_read(::uint64_t value);

  public:
  // uint64 vector_io_write = 7;
  void clear_vector_io_write() ;
  ::uint64_t vector_io_write() const;
  void set_vector_io_write(::uint64_t value);

  private:
  ::uint64_t _internal_vector_io_write() const;
  void _internal_set_vector_io_write(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.HardwareUsage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const HardwareUsage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t cpu_;
    ::uint64_t payload_io_read_;
    ::uint64_t payload_io_write_;
    ::uint64_t payload_index_io_read_;
    ::uint64_t payload_index_io_write_;
    ::uint64_t vector_io_read_;
    ::uint64_t vector_io_write_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull HardwareUsage_class_data_;
// -------------------------------------------------------------------

class GroupId final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.GroupId) */ {
 public:
  inline GroupId() : GroupId(nullptr) {}
  ~GroupId() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GroupId* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GroupId));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GroupId(::google::protobuf::internal::ConstantInitialized);

  inline GroupId(const GroupId& from) : GroupId(nullptr, from) {}
  inline GroupId(GroupId&& from) noexcept
      : GroupId(nullptr, ::std::move(from)) {}
  inline GroupId& operator=(const GroupId& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupId& operator=(GroupId&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupId& default_instance() {
    return *reinterpret_cast<const GroupId*>(
        &_GroupId_default_instance_);
  }
  enum KindCase {
    kUnsignedValue = 1,
    kIntegerValue = 2,
    kStringValue = 3,
    KIND_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 104;
  friend void swap(GroupId& a, GroupId& b) { a.Swap(&b); }
  inline void Swap(GroupId* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupId* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupId* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GroupId>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GroupId& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GroupId& from) { GroupId::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GroupId* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.GroupId"; }

  explicit GroupId(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GroupId(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GroupId& from);
  GroupId(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GroupId&& from) noexcept
      : GroupId(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUnsignedValueFieldNumber = 1,
    kIntegerValueFieldNumber = 2,
    kStringValueFieldNumber = 3,
  };
  // uint64 unsigned_value = 1;
  bool has_unsigned_value() const;
  void clear_unsigned_value() ;
  ::uint64_t unsigned_value() const;
  void set_unsigned_value(::uint64_t value);

  private:
  ::uint64_t _internal_unsigned_value() const;
  void _internal_set_unsigned_value(::uint64_t value);

  public:
  // int64 integer_value = 2;
  bool has_integer_value() const;
  void clear_integer_value() ;
  ::int64_t integer_value() const;
  void set_integer_value(::int64_t value);

  private:
  ::int64_t _internal_integer_value() const;
  void _internal_set_integer_value(::int64_t value);

  public:
  // string string_value = 3;
  bool has_string_value() const;
  void clear_string_value() ;
  const ::std::string& string_value() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_string_value(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_string_value();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_string_value();
  void set_allocated_string_value(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_string_value() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_string_value();

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.GroupId)
 private:
  class _Internal;
  void set_has_unsigned_value();
  void set_has_integer_value();
  void set_has_string_value();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 3,
                                   0, 35,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GroupId& from_msg);
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint64_t unsigned_value_;
      ::int64_t integer_value_;
      ::google::protobuf::internal::ArenaStringPtr string_value_;
    } kind_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GroupId_class_data_;
// -------------------------------------------------------------------

class GeoPoint final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.GeoPoint) */ {
 public:
  inline GeoPoint() : GeoPoint(nullptr) {}
  ~GeoPoint() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GeoPoint* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GeoPoint));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoPoint(::google::protobuf::internal::ConstantInitialized);

  inline GeoPoint(const GeoPoint& from) : GeoPoint(nullptr, from) {}
  inline GeoPoint(GeoPoint&& from) noexcept
      : GeoPoint(nullptr, ::std::move(from)) {}
  inline GeoPoint& operator=(const GeoPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPoint& operator=(GeoPoint&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoPoint& default_instance() {
    return *reinterpret_cast<const GeoPoint*>(
        &_GeoPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 152;
  friend void swap(GeoPoint& a, GeoPoint& b) { a.Swap(&b); }
  inline void Swap(GeoPoint* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPoint* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoPoint* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GeoPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoPoint& from) { GeoPoint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GeoPoint* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.GeoPoint"; }

  explicit GeoPoint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GeoPoint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GeoPoint& from);
  GeoPoint(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GeoPoint&& from) noexcept
      : GeoPoint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLonFieldNumber = 1,
    kLatFieldNumber = 2,
  };
  // double lon = 1;
  void clear_lon() ;
  double lon() const;
  void set_lon(double value);

  private:
  double _internal_lon() const;
  void _internal_set_lon(double value);

  public:
  // double lat = 2;
  void clear_lat() ;
  double lat() const;
  void set_lat(double value);

  private:
  double _internal_lat() const;
  void _internal_set_lat(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.GeoPoint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GeoPoint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double lon_;
    double lat_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GeoPoint_class_data_;
// -------------------------------------------------------------------

class FacetValue final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.FacetValue) */ {
 public:
  inline FacetValue() : FacetValue(nullptr) {}
  ~FacetValue() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FacetValue* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FacetValue));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FacetValue(::google::protobuf::internal::ConstantInitialized);

  inline FacetValue(const FacetValue& from) : FacetValue(nullptr, from) {}
  inline FacetValue(FacetValue&& from) noexcept
      : FacetValue(nullptr, ::std::move(from)) {}
  inline FacetValue& operator=(const FacetValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline FacetValue& operator=(FacetValue&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FacetValue& default_instance() {
    return *reinterpret_cast<const FacetValue*>(
        &_FacetValue_default_instance_);
  }
  enum VariantCase {
    kStringValue = 1,
    kIntegerValue = 2,
    kBoolValue = 3,
    VARIANT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 81;
  friend void swap(FacetValue& a, FacetValue& b) { a.Swap(&b); }
  inline void Swap(FacetValue* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FacetValue* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FacetValue* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FacetValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FacetValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FacetValue& from) { FacetValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FacetValue* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.FacetValue"; }

  explicit FacetValue(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FacetValue(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FacetValue& from);
  FacetValue(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FacetValue&& from) noexcept
      : FacetValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStringValueFieldNumber = 1,
    kIntegerValueFieldNumber = 2,
    kBoolValueFieldNumber = 3,
  };
  // string string_value = 1;
  bool has_string_value() const;
  void clear_string_value() ;
  const ::std::string& string_value() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_string_value(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_string_value();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_string_value();
  void set_allocated_string_value(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_string_value() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_string_value();

  public:
  // int64 integer_value = 2;
  bool has_integer_value() const;
  void clear_integer_value() ;
  ::int64_t integer_value() const;
  void set_integer_value(::int64_t value);

  private:
  ::int64_t _internal_integer_value() const;
  void _internal_set_integer_value(::int64_t value);

  public:
  // bool bool_value = 3;
  bool has_bool_value() const;
  void clear_bool_value() ;
  bool bool_value() const;
  void set_bool_value(bool value);

  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);

  public:
  void clear_variant();
  VariantCase variant_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.FacetValue)
 private:
  class _Internal;
  void set_has_string_value();
  void set_has_integer_value();
  void set_has_bool_value();
  inline bool has_variant() const;
  inline void clear_has_variant();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 3,
                                   0, 38,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FacetValue& from_msg);
    union VariantUnion {
      constexpr VariantUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr string_value_;
      ::int64_t integer_value_;
      bool bool_value_;
    } variant_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FacetValue_class_data_;
// -------------------------------------------------------------------

class DenseVector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DenseVector) */ {
 public:
  inline DenseVector() : DenseVector(nullptr) {}
  ~DenseVector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DenseVector* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DenseVector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DenseVector(::google::protobuf::internal::ConstantInitialized);

  inline DenseVector(const DenseVector& from) : DenseVector(nullptr, from) {}
  inline DenseVector(DenseVector&& from) noexcept
      : DenseVector(nullptr, ::std::move(from)) {}
  inline DenseVector& operator=(const DenseVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline DenseVector& operator=(DenseVector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DenseVector& default_instance() {
    return *reinterpret_cast<const DenseVector*>(
        &_DenseVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(DenseVector& a, DenseVector& b) { a.Swap(&b); }
  inline void Swap(DenseVector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DenseVector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DenseVector* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DenseVector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DenseVector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DenseVector& from) { DenseVector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DenseVector* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DenseVector"; }

  explicit DenseVector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DenseVector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DenseVector& from);
  DenseVector(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DenseVector&& from) noexcept
      : DenseVector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated float data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::google::protobuf::RepeatedField<float>& data() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL mutable_data();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_data() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DenseVector)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DenseVector& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DenseVector_class_data_;
// -------------------------------------------------------------------

class CountResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CountResult) */ {
 public:
  inline CountResult() : CountResult(nullptr) {}
  ~CountResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CountResult* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CountResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CountResult(::google::protobuf::internal::ConstantInitialized);

  inline CountResult(const CountResult& from) : CountResult(nullptr, from) {}
  inline CountResult(CountResult&& from) noexcept
      : CountResult(nullptr, ::std::move(from)) {}
  inline CountResult& operator=(const CountResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CountResult& operator=(CountResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CountResult& default_instance() {
    return *reinterpret_cast<const CountResult*>(
        &_CountResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 116;
  friend void swap(CountResult& a, CountResult& b) { a.Swap(&b); }
  inline void Swap(CountResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CountResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CountResult* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CountResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CountResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CountResult& from) { CountResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CountResult* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CountResult"; }

  explicit CountResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CountResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CountResult& from);
  CountResult(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CountResult&& from) noexcept
      : CountResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCountFieldNumber = 1,
  };
  // uint64 count = 1;
  void clear_count() ;
  ::uint64_t count() const;
  void set_count(::uint64_t value);

  private:
  ::uint64_t _internal_count() const;
  void _internal_set_count(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CountResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CountResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CountResult_class_data_;
// -------------------------------------------------------------------

class WithVectorsSelector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.WithVectorsSelector) */ {
 public:
  inline WithVectorsSelector() : WithVectorsSelector(nullptr) {}
  ~WithVectorsSelector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WithVectorsSelector* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WithVectorsSelector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WithVectorsSelector(::google::protobuf::internal::ConstantInitialized);

  inline WithVectorsSelector(const WithVectorsSelector& from) : WithVectorsSelector(nullptr, from) {}
  inline WithVectorsSelector(WithVectorsSelector&& from) noexcept
      : WithVectorsSelector(nullptr, ::std::move(from)) {}
  inline WithVectorsSelector& operator=(const WithVectorsSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline WithVectorsSelector& operator=(WithVectorsSelector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WithVectorsSelector& default_instance() {
    return *reinterpret_cast<const WithVectorsSelector*>(
        &_WithVectorsSelector_default_instance_);
  }
  enum SelectorOptionsCase {
    kEnable = 1,
    kInclude = 2,
    SELECTOR_OPTIONS_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(WithVectorsSelector& a, WithVectorsSelector& b) { a.Swap(&b); }
  inline void Swap(WithVectorsSelector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WithVectorsSelector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WithVectorsSelector* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WithVectorsSelector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WithVectorsSelector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WithVectorsSelector& from) { WithVectorsSelector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WithVectorsSelector* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.WithVectorsSelector"; }

  explicit WithVectorsSelector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  WithVectorsSelector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const WithVectorsSelector& from);
  WithVectorsSelector(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, WithVectorsSelector&& from) noexcept
      : WithVectorsSelector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEnableFieldNumber = 1,
    kIncludeFieldNumber = 2,
  };
  // bool enable = 1;
  bool has_enable() const;
  void clear_enable() ;
  bool enable() const;
  void set_enable(bool value);

  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);

  public:
  // .qdrant.VectorsSelector include = 2;
  bool has_include() const;
  private:
  bool _internal_has_include() const;

  public:
  void clear_include() ;
  const ::qdrant::VectorsSelector& include() const;
  [[nodiscard]] ::qdrant::VectorsSelector* PROTOBUF_NULLABLE release_include();
  ::qdrant::VectorsSelector* PROTOBUF_NONNULL mutable_include();
  void set_allocated_include(::qdrant::VectorsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_include(::qdrant::VectorsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::VectorsSelector* PROTOBUF_NULLABLE unsafe_arena_release_include();

  private:
  const ::qdrant::VectorsSelector& _internal_include() const;
  ::qdrant::VectorsSelector* PROTOBUF_NONNULL _internal_mutable_include();

  public:
  void clear_selector_options();
  SelectorOptionsCase selector_options_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.WithVectorsSelector)
 private:
  class _Internal;
  void set_has_enable();
  void set_has_include();
  inline bool has_selector_options() const;
  inline void clear_has_selector_options();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const WithVectorsSelector& from_msg);
    union SelectorOptionsUnion {
      constexpr SelectorOptionsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool enable_;
      ::qdrant::VectorsSelector* PROTOBUF_NULLABLE include_;
    } selector_options_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull WithVectorsSelector_class_data_;
// -------------------------------------------------------------------

class WithPayloadSelector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.WithPayloadSelector) */ {
 public:
  inline WithPayloadSelector() : WithPayloadSelector(nullptr) {}
  ~WithPayloadSelector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WithPayloadSelector* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WithPayloadSelector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WithPayloadSelector(::google::protobuf::internal::ConstantInitialized);

  inline WithPayloadSelector(const WithPayloadSelector& from) : WithPayloadSelector(nullptr, from) {}
  inline WithPayloadSelector(WithPayloadSelector&& from) noexcept
      : WithPayloadSelector(nullptr, ::std::move(from)) {}
  inline WithPayloadSelector& operator=(const WithPayloadSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline WithPayloadSelector& operator=(WithPayloadSelector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WithPayloadSelector& default_instance() {
    return *reinterpret_cast<const WithPayloadSelector*>(
        &_WithPayloadSelector_default_instance_);
  }
  enum SelectorOptionsCase {
    kEnable = 1,
    kInclude = 2,
    kExclude = 3,
    SELECTOR_OPTIONS_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(WithPayloadSelector& a, WithPayloadSelector& b) { a.Swap(&b); }
  inline void Swap(WithPayloadSelector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WithPayloadSelector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WithPayloadSelector* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WithPayloadSelector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WithPayloadSelector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WithPayloadSelector& from) { WithPayloadSelector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WithPayloadSelector* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.WithPayloadSelector"; }

  explicit WithPayloadSelector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  WithPayloadSelector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const WithPayloadSelector& from);
  WithPayloadSelector(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, WithPayloadSelector&& from) noexcept
      : WithPayloadSelector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEnableFieldNumber = 1,
    kIncludeFieldNumber = 2,
    kExcludeFieldNumber = 3,
  };
  // bool enable = 1;
  bool has_enable() const;
  void clear_enable() ;
  bool enable() const;
  void set_enable(bool value);

  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);

  public:
  // .qdrant.PayloadIncludeSelector include = 2;
  bool has_include() const;
  private:
  bool _internal_has_include() const;

  public:
  void clear_include() ;
  const ::qdrant::PayloadIncludeSelector& include() const;
  [[nodiscard]] ::qdrant::PayloadIncludeSelector* PROTOBUF_NULLABLE release_include();
  ::qdrant::PayloadIncludeSelector* PROTOBUF_NONNULL mutable_include();
  void set_allocated_include(::qdrant::PayloadIncludeSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_include(::qdrant::PayloadIncludeSelector* PROTOBUF_NULLABLE value);
  ::qdrant::PayloadIncludeSelector* PROTOBUF_NULLABLE unsafe_arena_release_include();

  private:
  const ::qdrant::PayloadIncludeSelector& _internal_include() const;
  ::qdrant::PayloadIncludeSelector* PROTOBUF_NONNULL _internal_mutable_include();

  public:
  // .qdrant.PayloadExcludeSelector exclude = 3;
  bool has_exclude() const;
  private:
  bool _internal_has_exclude() const;

  public:
  void clear_exclude() ;
  const ::qdrant::PayloadExcludeSelector& exclude() const;
  [[nodiscard]] ::qdrant::PayloadExcludeSelector* PROTOBUF_NULLABLE release_exclude();
  ::qdrant::PayloadExcludeSelector* PROTOBUF_NONNULL mutable_exclude();
  void set_allocated_exclude(::qdrant::PayloadExcludeSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_exclude(::qdrant::PayloadExcludeSelector* PROTOBUF_NULLABLE value);
  ::qdrant::PayloadExcludeSelector* PROTOBUF_NULLABLE unsafe_arena_release_exclude();

  private:
  const ::qdrant::PayloadExcludeSelector& _internal_exclude() const;
  ::qdrant::PayloadExcludeSelector* PROTOBUF_NONNULL _internal_mutable_exclude();

  public:
  void clear_selector_options();
  SelectorOptionsCase selector_options_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.WithPayloadSelector)
 private:
  class _Internal;
  void set_has_enable();
  void set_has_include();
  void set_has_exclude();
  inline bool has_selector_options() const;
  inline void clear_has_selector_options();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const WithPayloadSelector& from_msg);
    union SelectorOptionsUnion {
      constexpr SelectorOptionsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool enable_;
      ::qdrant::PayloadIncludeSelector* PROTOBUF_NULLABLE include_;
      ::qdrant::PayloadExcludeSelector* PROTOBUF_NULLABLE exclude_;
    } selector_options_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull WithPayloadSelector_class_data_;
// -------------------------------------------------------------------

class StartFrom final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.StartFrom) */ {
 public:
  inline StartFrom() : StartFrom(nullptr) {}
  ~StartFrom() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StartFrom* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StartFrom));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StartFrom(::google::protobuf::internal::ConstantInitialized);

  inline StartFrom(const StartFrom& from) : StartFrom(nullptr, from) {}
  inline StartFrom(StartFrom&& from) noexcept
      : StartFrom(nullptr, ::std::move(from)) {}
  inline StartFrom& operator=(const StartFrom& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartFrom& operator=(StartFrom&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartFrom& default_instance() {
    return *reinterpret_cast<const StartFrom*>(
        &_StartFrom_default_instance_);
  }
  enum ValueCase {
    kFloat = 1,
    kInteger = 2,
    kTimestamp = 3,
    kDatetime = 4,
    VALUE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 46;
  friend void swap(StartFrom& a, StartFrom& b) { a.Swap(&b); }
  inline void Swap(StartFrom* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartFrom* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartFrom* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StartFrom>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StartFrom& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StartFrom& from) { StartFrom::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StartFrom* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.StartFrom"; }

  explicit StartFrom(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StartFrom(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StartFrom& from);
  StartFrom(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StartFrom&& from) noexcept
      : StartFrom(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFloatFieldNumber = 1,
    kIntegerFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kDatetimeFieldNumber = 4,
  };
  // double float = 1;
  bool has_float_() const;
  void clear_float_() ;
  double float_() const;
  void set_float_(double value);

  private:
  double _internal_float_() const;
  void _internal_set_float_(double value);

  public:
  // int64 integer = 2;
  bool has_integer() const;
  void clear_integer() ;
  ::int64_t integer() const;
  void set_integer(::int64_t value);

  private:
  ::int64_t _internal_integer() const;
  void _internal_set_integer(::int64_t value);

  public:
  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;

  public:
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  [[nodiscard]] ::google::protobuf::Timestamp* PROTOBUF_NULLABLE release_timestamp();
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  ::google::protobuf::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL _internal_mutable_timestamp();

  public:
  // string datetime = 4;
  bool has_datetime() const;
  void clear_datetime() ;
  const ::std::string& datetime() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_datetime(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_datetime();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_datetime();
  void set_allocated_datetime(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_datetime() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_datetime(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_datetime();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.StartFrom)
 private:
  class _Internal;
  void set_has_float_();
  void set_has_integer();
  void set_has_timestamp();
  void set_has_datetime();
  inline bool has_value() const;
  inline void clear_has_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 4,
                                   1, 33,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StartFrom& from_msg);
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      double float__;
      ::int64_t integer_;
      ::google::protobuf::Timestamp* PROTOBUF_NULLABLE timestamp_;
      ::google::protobuf::internal::ArenaStringPtr datetime_;
    } value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StartFrom_class_data_;
// -------------------------------------------------------------------

class ShardKeySelector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ShardKeySelector) */ {
 public:
  inline ShardKeySelector() : ShardKeySelector(nullptr) {}
  ~ShardKeySelector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ShardKeySelector* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ShardKeySelector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ShardKeySelector(::google::protobuf::internal::ConstantInitialized);

  inline ShardKeySelector(const ShardKeySelector& from) : ShardKeySelector(nullptr, from) {}
  inline ShardKeySelector(ShardKeySelector&& from) noexcept
      : ShardKeySelector(nullptr, ::std::move(from)) {}
  inline ShardKeySelector& operator=(const ShardKeySelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardKeySelector& operator=(ShardKeySelector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardKeySelector& default_instance() {
    return *reinterpret_cast<const ShardKeySelector*>(
        &_ShardKeySelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ShardKeySelector& a, ShardKeySelector& b) { a.Swap(&b); }
  inline void Swap(ShardKeySelector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardKeySelector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardKeySelector* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ShardKeySelector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ShardKeySelector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ShardKeySelector& from) { ShardKeySelector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ShardKeySelector* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ShardKeySelector"; }

  explicit ShardKeySelector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ShardKeySelector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ShardKeySelector& from);
  ShardKeySelector(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ShardKeySelector&& from) noexcept
      : ShardKeySelector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kShardKeysFieldNumber = 1,
  };
  // repeated .qdrant.ShardKey shard_keys = 1;
  int shard_keys_size() const;
  private:
  int _internal_shard_keys_size() const;

  public:
  void clear_shard_keys() ;
  ::qdrant::ShardKey* PROTOBUF_NONNULL mutable_shard_keys(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::ShardKey>* PROTOBUF_NONNULL mutable_shard_keys();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::ShardKey>& _internal_shard_keys() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::ShardKey>* PROTOBUF_NONNULL _internal_mutable_shard_keys();
  public:
  const ::qdrant::ShardKey& shard_keys(int index) const;
  ::qdrant::ShardKey* PROTOBUF_NONNULL add_shard_keys();
  const ::google::protobuf::RepeatedPtrField<::qdrant::ShardKey>& shard_keys() const;
  // @@protoc_insertion_point(class_scope:qdrant.ShardKeySelector)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ShardKeySelector& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::ShardKey > shard_keys_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ShardKeySelector_class_data_;
// -------------------------------------------------------------------

class SetPayloadPoints_PayloadEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SetPayloadPoints_PayloadEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetPayloadPoints_PayloadEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit SetPayloadPoints_PayloadEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_SetPayloadPoints_PayloadEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_points_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 48,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull SetPayloadPoints_PayloadEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class SearchParams final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SearchParams) */ {
 public:
  inline SearchParams() : SearchParams(nullptr) {}
  ~SearchParams() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SearchParams* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SearchParams));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SearchParams(::google::protobuf::internal::ConstantInitialized);

  inline SearchParams(const SearchParams& from) : SearchParams(nullptr, from) {}
  inline SearchParams(SearchParams&& from) noexcept
      : SearchParams(nullptr, ::std::move(from)) {}
  inline SearchParams& operator=(const SearchParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchParams& operator=(SearchParams&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchParams& default_instance() {
    return *reinterpret_cast<const SearchParams*>(
        &_SearchParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(SearchParams& a, SearchParams& b) { a.Swap(&b); }
  inline void Swap(SearchParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchParams* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SearchParams>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchParams& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SearchParams& from) { SearchParams::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SearchParams* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SearchParams"; }

  explicit SearchParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SearchParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SearchParams& from);
  SearchParams(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SearchParams&& from) noexcept
      : SearchParams(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQuantizationFieldNumber = 3,
    kHnswEfFieldNumber = 1,
    kExactFieldNumber = 2,
    kIndexedOnlyFieldNumber = 4,
  };
  // optional .qdrant.QuantizationSearchParams quantization = 3;
  bool has_quantization() const;
  void clear_quantization() ;
  const ::qdrant::QuantizationSearchParams& quantization() const;
  [[nodiscard]] ::qdrant::QuantizationSearchParams* PROTOBUF_NULLABLE release_quantization();
  ::qdrant::QuantizationSearchParams* PROTOBUF_NONNULL mutable_quantization();
  void set_allocated_quantization(::qdrant::QuantizationSearchParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_quantization(::qdrant::QuantizationSearchParams* PROTOBUF_NULLABLE value);
  ::qdrant::QuantizationSearchParams* PROTOBUF_NULLABLE unsafe_arena_release_quantization();

  private:
  const ::qdrant::QuantizationSearchParams& _internal_quantization() const;
  ::qdrant::QuantizationSearchParams* PROTOBUF_NONNULL _internal_mutable_quantization();

  public:
  // optional uint64 hnsw_ef = 1;
  bool has_hnsw_ef() const;
  void clear_hnsw_ef() ;
  ::uint64_t hnsw_ef() const;
  void set_hnsw_ef(::uint64_t value);

  private:
  ::uint64_t _internal_hnsw_ef() const;
  void _internal_set_hnsw_ef(::uint64_t value);

  public:
  // optional bool exact = 2;
  bool has_exact() const;
  void clear_exact() ;
  bool exact() const;
  void set_exact(bool value);

  private:
  bool _internal_exact() const;
  void _internal_set_exact(bool value);

  public:
  // optional bool indexed_only = 4;
  bool has_indexed_only() const;
  void clear_indexed_only() ;
  bool indexed_only() const;
  void set_indexed_only(bool value);

  private:
  bool _internal_indexed_only() const;
  void _internal_set_indexed_only(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SearchParams)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SearchParams& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::QuantizationSearchParams* PROTOBUF_NULLABLE quantization_;
    ::uint64_t hnsw_ef_;
    bool exact_;
    bool indexed_only_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SearchParams_class_data_;
// -------------------------------------------------------------------

class SearchMatrixPair final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SearchMatrixPair) */ {
 public:
  inline SearchMatrixPair() : SearchMatrixPair(nullptr) {}
  ~SearchMatrixPair() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SearchMatrixPair* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SearchMatrixPair));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SearchMatrixPair(::google::protobuf::internal::ConstantInitialized);

  inline SearchMatrixPair(const SearchMatrixPair& from) : SearchMatrixPair(nullptr, from) {}
  inline SearchMatrixPair(SearchMatrixPair&& from) noexcept
      : SearchMatrixPair(nullptr, ::std::move(from)) {}
  inline SearchMatrixPair& operator=(const SearchMatrixPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchMatrixPair& operator=(SearchMatrixPair&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchMatrixPair& default_instance() {
    return *reinterpret_cast<const SearchMatrixPair*>(
        &_SearchMatrixPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 85;
  friend void swap(SearchMatrixPair& a, SearchMatrixPair& b) { a.Swap(&b); }
  inline void Swap(SearchMatrixPair* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchMatrixPair* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchMatrixPair* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SearchMatrixPair>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchMatrixPair& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SearchMatrixPair& from) { SearchMatrixPair::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SearchMatrixPair* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SearchMatrixPair"; }

  explicit SearchMatrixPair(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SearchMatrixPair(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SearchMatrixPair& from);
  SearchMatrixPair(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SearchMatrixPair&& from) noexcept
      : SearchMatrixPair(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAFieldNumber = 1,
    kBFieldNumber = 2,
    kScoreFieldNumber = 3,
  };
  // .qdrant.PointId a = 1;
  bool has_a() const;
  void clear_a() ;
  const ::qdrant::PointId& a() const;
  [[nodiscard]] ::qdrant::PointId* PROTOBUF_NULLABLE release_a();
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_a();
  void set_allocated_a(::qdrant::PointId* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_a(::qdrant::PointId* PROTOBUF_NULLABLE value);
  ::qdrant::PointId* PROTOBUF_NULLABLE unsafe_arena_release_a();

  private:
  const ::qdrant::PointId& _internal_a() const;
  ::qdrant::PointId* PROTOBUF_NONNULL _internal_mutable_a();

  public:
  // .qdrant.PointId b = 2;
  bool has_b() const;
  void clear_b() ;
  const ::qdrant::PointId& b() const;
  [[nodiscard]] ::qdrant::PointId* PROTOBUF_NULLABLE release_b();
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_b();
  void set_allocated_b(::qdrant::PointId* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_b(::qdrant::PointId* PROTOBUF_NULLABLE value);
  ::qdrant::PointId* PROTOBUF_NULLABLE unsafe_arena_release_b();

  private:
  const ::qdrant::PointId& _internal_b() const;
  ::qdrant::PointId* PROTOBUF_NONNULL _internal_mutable_b();

  public:
  // float score = 3;
  void clear_score() ;
  float score() const;
  void set_score(float value);

  private:
  float _internal_score() const;
  void _internal_set_score(float value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SearchMatrixPair)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SearchMatrixPair& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::PointId* PROTOBUF_NULLABLE a_;
    ::qdrant::PointId* PROTOBUF_NULLABLE b_;
    float score_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SearchMatrixPair_class_data_;
// -------------------------------------------------------------------

class SearchMatrixOffsets final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SearchMatrixOffsets) */ {
 public:
  inline SearchMatrixOffsets() : SearchMatrixOffsets(nullptr) {}
  ~SearchMatrixOffsets() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SearchMatrixOffsets* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SearchMatrixOffsets));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SearchMatrixOffsets(::google::protobuf::internal::ConstantInitialized);

  inline SearchMatrixOffsets(const SearchMatrixOffsets& from) : SearchMatrixOffsets(nullptr, from) {}
  inline SearchMatrixOffsets(SearchMatrixOffsets&& from) noexcept
      : SearchMatrixOffsets(nullptr, ::std::move(from)) {}
  inline SearchMatrixOffsets& operator=(const SearchMatrixOffsets& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchMatrixOffsets& operator=(SearchMatrixOffsets&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchMatrixOffsets& default_instance() {
    return *reinterpret_cast<const SearchMatrixOffsets*>(
        &_SearchMatrixOffsets_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 86;
  friend void swap(SearchMatrixOffsets& a, SearchMatrixOffsets& b) { a.Swap(&b); }
  inline void Swap(SearchMatrixOffsets* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchMatrixOffsets* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchMatrixOffsets* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SearchMatrixOffsets>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchMatrixOffsets& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SearchMatrixOffsets& from) { SearchMatrixOffsets::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SearchMatrixOffsets* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SearchMatrixOffsets"; }

  explicit SearchMatrixOffsets(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SearchMatrixOffsets(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SearchMatrixOffsets& from);
  SearchMatrixOffsets(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SearchMatrixOffsets&& from) noexcept
      : SearchMatrixOffsets(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOffsetsRowFieldNumber = 1,
    kOffsetsColFieldNumber = 2,
    kScoresFieldNumber = 3,
    kIdsFieldNumber = 4,
  };
  // repeated uint64 offsets_row = 1;
  int offsets_row_size() const;
  private:
  int _internal_offsets_row_size() const;

  public:
  void clear_offsets_row() ;
  ::uint64_t offsets_row(int index) const;
  void set_offsets_row(int index, ::uint64_t value);
  void add_offsets_row(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& offsets_row() const;
  ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL mutable_offsets_row();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_offsets_row() const;
  ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL _internal_mutable_offsets_row();

  public:
  // repeated uint64 offsets_col = 2;
  int offsets_col_size() const;
  private:
  int _internal_offsets_col_size() const;

  public:
  void clear_offsets_col() ;
  ::uint64_t offsets_col(int index) const;
  void set_offsets_col(int index, ::uint64_t value);
  void add_offsets_col(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& offsets_col() const;
  ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL mutable_offsets_col();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_offsets_col() const;
  ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL _internal_mutable_offsets_col();

  public:
  // repeated float scores = 3;
  int scores_size() const;
  private:
  int _internal_scores_size() const;

  public:
  void clear_scores() ;
  float scores(int index) const;
  void set_scores(int index, float value);
  void add_scores(float value);
  const ::google::protobuf::RepeatedField<float>& scores() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL mutable_scores();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_scores() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL _internal_mutable_scores();

  public:
  // repeated .qdrant.PointId ids = 4;
  int ids_size() const;
  private:
  int _internal_ids_size() const;

  public:
  void clear_ids() ;
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_ids(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL mutable_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& _internal_ids() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL _internal_mutable_ids();
  public:
  const ::qdrant::PointId& ids(int index) const;
  ::qdrant::PointId* PROTOBUF_NONNULL add_ids();
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& ids() const;
  // @@protoc_insertion_point(class_scope:qdrant.SearchMatrixOffsets)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SearchMatrixOffsets& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint64_t> offsets_row_;
    ::google::protobuf::internal::CachedSize _offsets_row_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint64_t> offsets_col_;
    ::google::protobuf::internal::CachedSize _offsets_col_cached_byte_size_;
    ::google::protobuf::RepeatedField<float> scores_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::PointId > ids_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SearchMatrixOffsets_class_data_;
// -------------------------------------------------------------------

class ScoredPoint_PayloadEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  ScoredPoint_PayloadEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ScoredPoint_PayloadEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit ScoredPoint_PayloadEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_ScoredPoint_PayloadEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_points_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 43,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull ScoredPoint_PayloadEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class RetrievedPoint_PayloadEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  RetrievedPoint_PayloadEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RetrievedPoint_PayloadEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit RetrievedPoint_PayloadEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_RetrievedPoint_PayloadEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_points_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 46,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull RetrievedPoint_PayloadEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class PointsUpdateOperation_SetPayload_PayloadEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  PointsUpdateOperation_SetPayload_PayloadEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointsUpdateOperation_SetPayload_PayloadEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit PointsUpdateOperation_SetPayload_PayloadEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_PointsUpdateOperation_SetPayload_PayloadEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_points_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 64,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_SetPayload_PayloadEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class PointsUpdateOperation_OverwritePayload_PayloadEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  PointsUpdateOperation_OverwritePayload_PayloadEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointsUpdateOperation_OverwritePayload_PayloadEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit PointsUpdateOperation_OverwritePayload_PayloadEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_PointsUpdateOperation_OverwritePayload_PayloadEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_points_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 70,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_OverwritePayload_PayloadEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class PointsIdsList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PointsIdsList) */ {
 public:
  inline PointsIdsList() : PointsIdsList(nullptr) {}
  ~PointsIdsList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointsIdsList* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointsIdsList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointsIdsList(::google::protobuf::internal::ConstantInitialized);

  inline PointsIdsList(const PointsIdsList& from) : PointsIdsList(nullptr, from) {}
  inline PointsIdsList(PointsIdsList&& from) noexcept
      : PointsIdsList(nullptr, ::std::move(from)) {}
  inline PointsIdsList& operator=(const PointsIdsList& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointsIdsList& operator=(PointsIdsList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointsIdsList& default_instance() {
    return *reinterpret_cast<const PointsIdsList*>(
        &_PointsIdsList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 149;
  friend void swap(PointsIdsList& a, PointsIdsList& b) { a.Swap(&b); }
  inline void Swap(PointsIdsList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointsIdsList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointsIdsList* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointsIdsList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointsIdsList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointsIdsList& from) { PointsIdsList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointsIdsList* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PointsIdsList"; }

  explicit PointsIdsList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointsIdsList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointsIdsList& from);
  PointsIdsList(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointsIdsList&& from) noexcept
      : PointsIdsList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdsFieldNumber = 1,
  };
  // repeated .qdrant.PointId ids = 1;
  int ids_size() const;
  private:
  int _internal_ids_size() const;

  public:
  void clear_ids() ;
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_ids(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL mutable_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& _internal_ids() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL _internal_mutable_ids();
  public:
  const ::qdrant::PointId& ids(int index) const;
  ::qdrant::PointId* PROTOBUF_NONNULL add_ids();
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& ids() const;
  // @@protoc_insertion_point(class_scope:qdrant.PointsIdsList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointsIdsList& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::PointId > ids_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointsIdsList_class_data_;
// -------------------------------------------------------------------

class PointStruct_PayloadEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  PointStruct_PayloadEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointStruct_PayloadEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit PointStruct_PayloadEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_PointStruct_PayloadEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_points_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 43,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull PointStruct_PayloadEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class MultiDenseVector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.MultiDenseVector) */ {
 public:
  inline MultiDenseVector() : MultiDenseVector(nullptr) {}
  ~MultiDenseVector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MultiDenseVector* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MultiDenseVector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MultiDenseVector(::google::protobuf::internal::ConstantInitialized);

  inline MultiDenseVector(const MultiDenseVector& from) : MultiDenseVector(nullptr, from) {}
  inline MultiDenseVector(MultiDenseVector&& from) noexcept
      : MultiDenseVector(nullptr, ::std::move(from)) {}
  inline MultiDenseVector& operator=(const MultiDenseVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiDenseVector& operator=(MultiDenseVector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiDenseVector& default_instance() {
    return *reinterpret_cast<const MultiDenseVector*>(
        &_MultiDenseVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(MultiDenseVector& a, MultiDenseVector& b) { a.Swap(&b); }
  inline void Swap(MultiDenseVector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiDenseVector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiDenseVector* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MultiDenseVector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MultiDenseVector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MultiDenseVector& from) { MultiDenseVector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MultiDenseVector* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.MultiDenseVector"; }

  explicit MultiDenseVector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MultiDenseVector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MultiDenseVector& from);
  MultiDenseVector(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MultiDenseVector&& from) noexcept
      : MultiDenseVector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVectorsFieldNumber = 1,
  };
  // repeated .qdrant.DenseVector vectors = 1;
  int vectors_size() const;
  private:
  int _internal_vectors_size() const;

  public:
  void clear_vectors() ;
  ::qdrant::DenseVector* PROTOBUF_NONNULL mutable_vectors(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::DenseVector>* PROTOBUF_NONNULL mutable_vectors();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::DenseVector>& _internal_vectors() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::DenseVector>* PROTOBUF_NONNULL _internal_mutable_vectors();
  public:
  const ::qdrant::DenseVector& vectors(int index) const;
  ::qdrant::DenseVector* PROTOBUF_NONNULL add_vectors();
  const ::google::protobuf::RepeatedPtrField<::qdrant::DenseVector>& vectors() const;
  // @@protoc_insertion_point(class_scope:qdrant.MultiDenseVector)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MultiDenseVector& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::DenseVector > vectors_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MultiDenseVector_class_data_;
// -------------------------------------------------------------------

class Match final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.Match) */ {
 public:
  inline Match() : Match(nullptr) {}
  ~Match() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Match* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Match));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Match(::google::protobuf::internal::ConstantInitialized);

  inline Match(const Match& from) : Match(nullptr, from) {}
  inline Match(Match&& from) noexcept
      : Match(nullptr, ::std::move(from)) {}
  inline Match& operator=(const Match& from) {
    CopyFrom(from);
    return *this;
  }
  inline Match& operator=(Match&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Match& default_instance() {
    return *reinterpret_cast<const Match*>(
        &_Match_default_instance_);
  }
  enum MatchValueCase {
    kKeyword = 1,
    kInteger = 2,
    kBoolean = 3,
    kText = 4,
    kKeywords = 5,
    kIntegers = 6,
    kExceptIntegers = 7,
    kExceptKeywords = 8,
    kPhrase = 9,
    kTextAny = 10,
    MATCH_VALUE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 138;
  friend void swap(Match& a, Match& b) { a.Swap(&b); }
  inline void Swap(Match* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Match* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Match* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Match>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Match& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Match& from) { Match::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Match* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.Match"; }

  explicit Match(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Match(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Match& from);
  Match(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Match&& from) noexcept
      : Match(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeywordFieldNumber = 1,
    kIntegerFieldNumber = 2,
    kBooleanFieldNumber = 3,
    kTextFieldNumber = 4,
    kKeywordsFieldNumber = 5,
    kIntegersFieldNumber = 6,
    kExceptIntegersFieldNumber = 7,
    kExceptKeywordsFieldNumber = 8,
    kPhraseFieldNumber = 9,
    kTextAnyFieldNumber = 10,
  };
  // string keyword = 1;
  bool has_keyword() const;
  void clear_keyword() ;
  const ::std::string& keyword() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_keyword(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_keyword();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_keyword();
  void set_allocated_keyword(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_keyword() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_keyword(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_keyword();

  public:
  // int64 integer = 2;
  bool has_integer() const;
  void clear_integer() ;
  ::int64_t integer() const;
  void set_integer(::int64_t value);

  private:
  ::int64_t _internal_integer() const;
  void _internal_set_integer(::int64_t value);

  public:
  // bool boolean = 3;
  bool has_boolean() const;
  void clear_boolean() ;
  bool boolean() const;
  void set_boolean(bool value);

  private:
  bool _internal_boolean() const;
  void _internal_set_boolean(bool value);

  public:
  // string text = 4;
  bool has_text() const;
  void clear_text() ;
  const ::std::string& text() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_text();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_text();
  void set_allocated_text(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_text() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_text(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_text();

  public:
  // .qdrant.RepeatedStrings keywords = 5;
  bool has_keywords() const;
  private:
  bool _internal_has_keywords() const;

  public:
  void clear_keywords() ;
  const ::qdrant::RepeatedStrings& keywords() const;
  [[nodiscard]] ::qdrant::RepeatedStrings* PROTOBUF_NULLABLE release_keywords();
  ::qdrant::RepeatedStrings* PROTOBUF_NONNULL mutable_keywords();
  void set_allocated_keywords(::qdrant::RepeatedStrings* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_keywords(::qdrant::RepeatedStrings* PROTOBUF_NULLABLE value);
  ::qdrant::RepeatedStrings* PROTOBUF_NULLABLE unsafe_arena_release_keywords();

  private:
  const ::qdrant::RepeatedStrings& _internal_keywords() const;
  ::qdrant::RepeatedStrings* PROTOBUF_NONNULL _internal_mutable_keywords();

  public:
  // .qdrant.RepeatedIntegers integers = 6;
  bool has_integers() const;
  private:
  bool _internal_has_integers() const;

  public:
  void clear_integers() ;
  const ::qdrant::RepeatedIntegers& integers() const;
  [[nodiscard]] ::qdrant::RepeatedIntegers* PROTOBUF_NULLABLE release_integers();
  ::qdrant::RepeatedIntegers* PROTOBUF_NONNULL mutable_integers();
  void set_allocated_integers(::qdrant::RepeatedIntegers* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_integers(::qdrant::RepeatedIntegers* PROTOBUF_NULLABLE value);
  ::qdrant::RepeatedIntegers* PROTOBUF_NULLABLE unsafe_arena_release_integers();

  private:
  const ::qdrant::RepeatedIntegers& _internal_integers() const;
  ::qdrant::RepeatedIntegers* PROTOBUF_NONNULL _internal_mutable_integers();

  public:
  // .qdrant.RepeatedIntegers except_integers = 7;
  bool has_except_integers() const;
  private:
  bool _internal_has_except_integers() const;

  public:
  void clear_except_integers() ;
  const ::qdrant::RepeatedIntegers& except_integers() const;
  [[nodiscard]] ::qdrant::RepeatedIntegers* PROTOBUF_NULLABLE release_except_integers();
  ::qdrant::RepeatedIntegers* PROTOBUF_NONNULL mutable_except_integers();
  void set_allocated_except_integers(::qdrant::RepeatedIntegers* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_except_integers(::qdrant::RepeatedIntegers* PROTOBUF_NULLABLE value);
  ::qdrant::RepeatedIntegers* PROTOBUF_NULLABLE unsafe_arena_release_except_integers();

  private:
  const ::qdrant::RepeatedIntegers& _internal_except_integers() const;
  ::qdrant::RepeatedIntegers* PROTOBUF_NONNULL _internal_mutable_except_integers();

  public:
  // .qdrant.RepeatedStrings except_keywords = 8;
  bool has_except_keywords() const;
  private:
  bool _internal_has_except_keywords() const;

  public:
  void clear_except_keywords() ;
  const ::qdrant::RepeatedStrings& except_keywords() const;
  [[nodiscard]] ::qdrant::RepeatedStrings* PROTOBUF_NULLABLE release_except_keywords();
  ::qdrant::RepeatedStrings* PROTOBUF_NONNULL mutable_except_keywords();
  void set_allocated_except_keywords(::qdrant::RepeatedStrings* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_except_keywords(::qdrant::RepeatedStrings* PROTOBUF_NULLABLE value);
  ::qdrant::RepeatedStrings* PROTOBUF_NULLABLE unsafe_arena_release_except_keywords();

  private:
  const ::qdrant::RepeatedStrings& _internal_except_keywords() const;
  ::qdrant::RepeatedStrings* PROTOBUF_NONNULL _internal_mutable_except_keywords();

  public:
  // string phrase = 9;
  bool has_phrase() const;
  void clear_phrase() ;
  const ::std::string& phrase() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_phrase(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_phrase();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_phrase();
  void set_allocated_phrase(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_phrase() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_phrase(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_phrase();

  public:
  // string text_any = 10;
  bool has_text_any() const;
  void clear_text_any() ;
  const ::std::string& text_any() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_text_any(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_text_any();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_text_any();
  void set_allocated_text_any(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_text_any() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_text_any(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_text_any();

  public:
  void clear_match_value();
  MatchValueCase match_value_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.Match)
 private:
  class _Internal;
  void set_has_keyword();
  void set_has_integer();
  void set_has_boolean();
  void set_has_text();
  void set_has_keywords();
  void set_has_integers();
  void set_has_except_integers();
  void set_has_except_keywords();
  void set_has_phrase();
  void set_has_text_any();
  inline bool has_match_value() const;
  inline void clear_has_match_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 10,
                                   4, 54,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Match& from_msg);
    union MatchValueUnion {
      constexpr MatchValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr keyword_;
      ::int64_t integer_;
      bool boolean_;
      ::google::protobuf::internal::ArenaStringPtr text_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE keywords_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE integers_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE except_integers_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE except_keywords_;
      ::google::protobuf::internal::ArenaStringPtr phrase_;
      ::google::protobuf::internal::ArenaStringPtr text_any_;
    } match_value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Match_class_data_;
// -------------------------------------------------------------------

class InferenceUsage_ModelsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  InferenceUsage_ModelsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InferenceUsage_ModelsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit InferenceUsage_ModelsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_InferenceUsage_ModelsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_points_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 45,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull InferenceUsage_ModelsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class InferenceObject_OptionsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  InferenceObject_OptionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InferenceObject_OptionsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit InferenceObject_OptionsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_InferenceObject_OptionsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_points_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 47,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull InferenceObject_OptionsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class Image_OptionsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  Image_OptionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Image_OptionsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit Image_OptionsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_Image_OptionsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_points_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 37,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull Image_OptionsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class HasIdCondition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.HasIdCondition) */ {
 public:
  inline HasIdCondition() : HasIdCondition(nullptr) {}
  ~HasIdCondition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HasIdCondition* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HasIdCondition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HasIdCondition(::google::protobuf::internal::ConstantInitialized);

  inline HasIdCondition(const HasIdCondition& from) : HasIdCondition(nullptr, from) {}
  inline HasIdCondition(HasIdCondition&& from) noexcept
      : HasIdCondition(nullptr, ::std::move(from)) {}
  inline HasIdCondition& operator=(const HasIdCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline HasIdCondition& operator=(HasIdCondition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HasIdCondition& default_instance() {
    return *reinterpret_cast<const HasIdCondition*>(
        &_HasIdCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 134;
  friend void swap(HasIdCondition& a, HasIdCondition& b) { a.Swap(&b); }
  inline void Swap(HasIdCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HasIdCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HasIdCondition* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HasIdCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HasIdCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HasIdCondition& from) { HasIdCondition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HasIdCondition* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.HasIdCondition"; }

  explicit HasIdCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  HasIdCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HasIdCondition& from);
  HasIdCondition(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, HasIdCondition&& from) noexcept
      : HasIdCondition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHasIdFieldNumber = 1,
  };
  // repeated .qdrant.PointId has_id = 1;
  int has_id_size() const;
  private:
  int _internal_has_id_size() const;

  public:
  void clear_has_id() ;
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_has_id(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL mutable_has_id();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& _internal_has_id() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL _internal_mutable_has_id();
  public:
  const ::qdrant::PointId& has_id(int index) const;
  ::qdrant::PointId* PROTOBUF_NONNULL add_has_id();
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& has_id() const;
  // @@protoc_insertion_point(class_scope:qdrant.HasIdCondition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const HasIdCondition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::PointId > has_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull HasIdCondition_class_data_;
// -------------------------------------------------------------------

class GeoRadius final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.GeoRadius) */ {
 public:
  inline GeoRadius() : GeoRadius(nullptr) {}
  ~GeoRadius() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GeoRadius* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GeoRadius));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoRadius(::google::protobuf::internal::ConstantInitialized);

  inline GeoRadius(const GeoRadius& from) : GeoRadius(nullptr, from) {}
  inline GeoRadius(GeoRadius&& from) noexcept
      : GeoRadius(nullptr, ::std::move(from)) {}
  inline GeoRadius& operator=(const GeoRadius& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoRadius& operator=(GeoRadius&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoRadius& default_instance() {
    return *reinterpret_cast<const GeoRadius*>(
        &_GeoRadius_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 144;
  friend void swap(GeoRadius& a, GeoRadius& b) { a.Swap(&b); }
  inline void Swap(GeoRadius* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoRadius* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoRadius* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GeoRadius>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoRadius& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoRadius& from) { GeoRadius::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GeoRadius* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.GeoRadius"; }

  explicit GeoRadius(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GeoRadius(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GeoRadius& from);
  GeoRadius(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GeoRadius&& from) noexcept
      : GeoRadius(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCenterFieldNumber = 1,
    kRadiusFieldNumber = 2,
  };
  // .qdrant.GeoPoint center = 1;
  bool has_center() const;
  void clear_center() ;
  const ::qdrant::GeoPoint& center() const;
  [[nodiscard]] ::qdrant::GeoPoint* PROTOBUF_NULLABLE release_center();
  ::qdrant::GeoPoint* PROTOBUF_NONNULL mutable_center();
  void set_allocated_center(::qdrant::GeoPoint* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_center(::qdrant::GeoPoint* PROTOBUF_NULLABLE value);
  ::qdrant::GeoPoint* PROTOBUF_NULLABLE unsafe_arena_release_center();

  private:
  const ::qdrant::GeoPoint& _internal_center() const;
  ::qdrant::GeoPoint* PROTOBUF_NONNULL _internal_mutable_center();

  public:
  // float radius = 2;
  void clear_radius() ;
  float radius() const;
  void set_radius(float value);

  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.GeoRadius)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GeoRadius& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::GeoPoint* PROTOBUF_NULLABLE center_;
    float radius_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GeoRadius_class_data_;
// -------------------------------------------------------------------

class GeoLineString final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.GeoLineString) */ {
 public:
  inline GeoLineString() : GeoLineString(nullptr) {}
  ~GeoLineString() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GeoLineString* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GeoLineString));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoLineString(::google::protobuf::internal::ConstantInitialized);

  inline GeoLineString(const GeoLineString& from) : GeoLineString(nullptr, from) {}
  inline GeoLineString(GeoLineString&& from) noexcept
      : GeoLineString(nullptr, ::std::move(from)) {}
  inline GeoLineString& operator=(const GeoLineString& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoLineString& operator=(GeoLineString&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoLineString& default_instance() {
    return *reinterpret_cast<const GeoLineString*>(
        &_GeoLineString_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 145;
  friend void swap(GeoLineString& a, GeoLineString& b) { a.Swap(&b); }
  inline void Swap(GeoLineString* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoLineString* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoLineString* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GeoLineString>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoLineString& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoLineString& from) { GeoLineString::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GeoLineString* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.GeoLineString"; }

  explicit GeoLineString(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GeoLineString(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GeoLineString& from);
  GeoLineString(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GeoLineString&& from) noexcept
      : GeoLineString(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPointsFieldNumber = 1,
  };
  // repeated .qdrant.GeoPoint points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  void clear_points() ;
  ::qdrant::GeoPoint* PROTOBUF_NONNULL mutable_points(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::GeoPoint>* PROTOBUF_NONNULL mutable_points();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::GeoPoint>& _internal_points() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::GeoPoint>* PROTOBUF_NONNULL _internal_mutable_points();
  public:
  const ::qdrant::GeoPoint& points(int index) const;
  ::qdrant::GeoPoint* PROTOBUF_NONNULL add_points();
  const ::google::protobuf::RepeatedPtrField<::qdrant::GeoPoint>& points() const;
  // @@protoc_insertion_point(class_scope:qdrant.GeoLineString)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GeoLineString& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::GeoPoint > points_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GeoLineString_class_data_;
// -------------------------------------------------------------------

class GeoDistance final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.GeoDistance) */ {
 public:
  inline GeoDistance() : GeoDistance(nullptr) {}
  ~GeoDistance() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GeoDistance* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GeoDistance));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoDistance(::google::protobuf::internal::ConstantInitialized);

  inline GeoDistance(const GeoDistance& from) : GeoDistance(nullptr, from) {}
  inline GeoDistance(GeoDistance&& from) noexcept
      : GeoDistance(nullptr, ::std::move(from)) {}
  inline GeoDistance& operator=(const GeoDistance& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoDistance& operator=(GeoDistance&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoDistance& default_instance() {
    return *reinterpret_cast<const GeoDistance*>(
        &_GeoDistance_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 66;
  friend void swap(GeoDistance& a, GeoDistance& b) { a.Swap(&b); }
  inline void Swap(GeoDistance* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoDistance* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoDistance* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GeoDistance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoDistance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoDistance& from) { GeoDistance::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GeoDistance* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.GeoDistance"; }

  explicit GeoDistance(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GeoDistance(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GeoDistance& from);
  GeoDistance(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GeoDistance&& from) noexcept
      : GeoDistance(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kToFieldNumber = 2,
    kOriginFieldNumber = 1,
  };
  // string to = 2;
  void clear_to() ;
  const ::std::string& to() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_to(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_to();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_to();
  void set_allocated_to(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_to() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_to(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_to();

  public:
  // .qdrant.GeoPoint origin = 1;
  bool has_origin() const;
  void clear_origin() ;
  const ::qdrant::GeoPoint& origin() const;
  [[nodiscard]] ::qdrant::GeoPoint* PROTOBUF_NULLABLE release_origin();
  ::qdrant::GeoPoint* PROTOBUF_NONNULL mutable_origin();
  void set_allocated_origin(::qdrant::GeoPoint* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_origin(::qdrant::GeoPoint* PROTOBUF_NULLABLE value);
  ::qdrant::GeoPoint* PROTOBUF_NULLABLE unsafe_arena_release_origin();

  private:
  const ::qdrant::GeoPoint& _internal_origin() const;
  ::qdrant::GeoPoint* PROTOBUF_NONNULL _internal_mutable_origin();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.GeoDistance)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 29,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GeoDistance& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr to_;
    ::qdrant::GeoPoint* PROTOBUF_NULLABLE origin_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GeoDistance_class_data_;
// -------------------------------------------------------------------

class GeoBoundingBox final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.GeoBoundingBox) */ {
 public:
  inline GeoBoundingBox() : GeoBoundingBox(nullptr) {}
  ~GeoBoundingBox() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GeoBoundingBox* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GeoBoundingBox));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoBoundingBox(::google::protobuf::internal::ConstantInitialized);

  inline GeoBoundingBox(const GeoBoundingBox& from) : GeoBoundingBox(nullptr, from) {}
  inline GeoBoundingBox(GeoBoundingBox&& from) noexcept
      : GeoBoundingBox(nullptr, ::std::move(from)) {}
  inline GeoBoundingBox& operator=(const GeoBoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoBoundingBox& operator=(GeoBoundingBox&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoBoundingBox& default_instance() {
    return *reinterpret_cast<const GeoBoundingBox*>(
        &_GeoBoundingBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 143;
  friend void swap(GeoBoundingBox& a, GeoBoundingBox& b) { a.Swap(&b); }
  inline void Swap(GeoBoundingBox* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoBoundingBox* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoBoundingBox* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GeoBoundingBox>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoBoundingBox& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoBoundingBox& from) { GeoBoundingBox::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GeoBoundingBox* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.GeoBoundingBox"; }

  explicit GeoBoundingBox(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GeoBoundingBox(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GeoBoundingBox& from);
  GeoBoundingBox(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GeoBoundingBox&& from) noexcept
      : GeoBoundingBox(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTopLeftFieldNumber = 1,
    kBottomRightFieldNumber = 2,
  };
  // .qdrant.GeoPoint top_left = 1;
  bool has_top_left() const;
  void clear_top_left() ;
  const ::qdrant::GeoPoint& top_left() const;
  [[nodiscard]] ::qdrant::GeoPoint* PROTOBUF_NULLABLE release_top_left();
  ::qdrant::GeoPoint* PROTOBUF_NONNULL mutable_top_left();
  void set_allocated_top_left(::qdrant::GeoPoint* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_top_left(::qdrant::GeoPoint* PROTOBUF_NULLABLE value);
  ::qdrant::GeoPoint* PROTOBUF_NULLABLE unsafe_arena_release_top_left();

  private:
  const ::qdrant::GeoPoint& _internal_top_left() const;
  ::qdrant::GeoPoint* PROTOBUF_NONNULL _internal_mutable_top_left();

  public:
  // .qdrant.GeoPoint bottom_right = 2;
  bool has_bottom_right() const;
  void clear_bottom_right() ;
  const ::qdrant::GeoPoint& bottom_right() const;
  [[nodiscard]] ::qdrant::GeoPoint* PROTOBUF_NULLABLE release_bottom_right();
  ::qdrant::GeoPoint* PROTOBUF_NONNULL mutable_bottom_right();
  void set_allocated_bottom_right(::qdrant::GeoPoint* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bottom_right(::qdrant::GeoPoint* PROTOBUF_NULLABLE value);
  ::qdrant::GeoPoint* PROTOBUF_NULLABLE unsafe_arena_release_bottom_right();

  private:
  const ::qdrant::GeoPoint& _internal_bottom_right() const;
  ::qdrant::GeoPoint* PROTOBUF_NONNULL _internal_mutable_bottom_right();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.GeoBoundingBox)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GeoBoundingBox& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::GeoPoint* PROTOBUF_NULLABLE top_left_;
    ::qdrant::GeoPoint* PROTOBUF_NULLABLE bottom_right_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GeoBoundingBox_class_data_;
// -------------------------------------------------------------------

class Formula_DefaultsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  Formula_DefaultsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Formula_DefaultsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit Formula_DefaultsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_Formula_DefaultsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_points_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 40,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull Formula_DefaultsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class FacetHit final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.FacetHit) */ {
 public:
  inline FacetHit() : FacetHit(nullptr) {}
  ~FacetHit() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FacetHit* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FacetHit));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FacetHit(::google::protobuf::internal::ConstantInitialized);

  inline FacetHit(const FacetHit& from) : FacetHit(nullptr, from) {}
  inline FacetHit(FacetHit&& from) noexcept
      : FacetHit(nullptr, ::std::move(from)) {}
  inline FacetHit& operator=(const FacetHit& from) {
    CopyFrom(from);
    return *this;
  }
  inline FacetHit& operator=(FacetHit&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FacetHit& default_instance() {
    return *reinterpret_cast<const FacetHit*>(
        &_FacetHit_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 82;
  friend void swap(FacetHit& a, FacetHit& b) { a.Swap(&b); }
  inline void Swap(FacetHit* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FacetHit* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FacetHit* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FacetHit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FacetHit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FacetHit& from) { FacetHit::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FacetHit* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.FacetHit"; }

  explicit FacetHit(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FacetHit(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FacetHit& from);
  FacetHit(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FacetHit&& from) noexcept
      : FacetHit(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // .qdrant.FacetValue value = 1;
  bool has_value() const;
  void clear_value() ;
  const ::qdrant::FacetValue& value() const;
  [[nodiscard]] ::qdrant::FacetValue* PROTOBUF_NULLABLE release_value();
  ::qdrant::FacetValue* PROTOBUF_NONNULL mutable_value();
  void set_allocated_value(::qdrant::FacetValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_value(::qdrant::FacetValue* PROTOBUF_NULLABLE value);
  ::qdrant::FacetValue* PROTOBUF_NULLABLE unsafe_arena_release_value();

  private:
  const ::qdrant::FacetValue& _internal_value() const;
  ::qdrant::FacetValue* PROTOBUF_NONNULL _internal_mutable_value();

  public:
  // uint64 count = 2;
  void clear_count() ;
  ::uint64_t count() const;
  void set_count(::uint64_t value);

  private:
  ::uint64_t _internal_count() const;
  void _internal_set_count(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.FacetHit)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FacetHit& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::FacetValue* PROTOBUF_NULLABLE value_;
    ::uint64_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FacetHit_class_data_;
// -------------------------------------------------------------------

class Document_OptionsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  Document_OptionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Document_OptionsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit Document_OptionsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_Document_OptionsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_points_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 40,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull Document_OptionsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class DeleteFieldIndexCollection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DeleteFieldIndexCollection) */ {
 public:
  inline DeleteFieldIndexCollection() : DeleteFieldIndexCollection(nullptr) {}
  ~DeleteFieldIndexCollection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteFieldIndexCollection* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteFieldIndexCollection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteFieldIndexCollection(::google::protobuf::internal::ConstantInitialized);

  inline DeleteFieldIndexCollection(const DeleteFieldIndexCollection& from) : DeleteFieldIndexCollection(nullptr, from) {}
  inline DeleteFieldIndexCollection(DeleteFieldIndexCollection&& from) noexcept
      : DeleteFieldIndexCollection(nullptr, ::std::move(from)) {}
  inline DeleteFieldIndexCollection& operator=(const DeleteFieldIndexCollection& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFieldIndexCollection& operator=(DeleteFieldIndexCollection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFieldIndexCollection& default_instance() {
    return *reinterpret_cast<const DeleteFieldIndexCollection*>(
        &_DeleteFieldIndexCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(DeleteFieldIndexCollection& a, DeleteFieldIndexCollection& b) { a.Swap(&b); }
  inline void Swap(DeleteFieldIndexCollection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFieldIndexCollection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFieldIndexCollection* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteFieldIndexCollection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteFieldIndexCollection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteFieldIndexCollection& from) { DeleteFieldIndexCollection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteFieldIndexCollection* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DeleteFieldIndexCollection"; }

  explicit DeleteFieldIndexCollection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeleteFieldIndexCollection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeleteFieldIndexCollection& from);
  DeleteFieldIndexCollection(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeleteFieldIndexCollection&& from) noexcept
      : DeleteFieldIndexCollection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kFieldNameFieldNumber = 3,
    kOrderingFieldNumber = 4,
    kWaitFieldNumber = 2,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // string field_name = 3;
  void clear_field_name() ;
  const ::std::string& field_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_field_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_field_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_field_name();
  void set_allocated_field_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_field_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_field_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_field_name();

  public:
  // optional .qdrant.WriteOrdering ordering = 4;
  bool has_ordering() const;
  void clear_ordering() ;
  const ::qdrant::WriteOrdering& ordering() const;
  [[nodiscard]] ::qdrant::WriteOrdering* PROTOBUF_NULLABLE release_ordering();
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL mutable_ordering();
  void set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  ::qdrant::WriteOrdering* PROTOBUF_NULLABLE unsafe_arena_release_ordering();

  private:
  const ::qdrant::WriteOrdering& _internal_ordering() const;
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL _internal_mutable_ordering();

  public:
  // optional bool wait = 2;
  bool has_wait() const;
  void clear_wait() ;
  bool wait() const;
  void set_wait(bool value);

  private:
  bool _internal_wait() const;
  void _internal_set_wait(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DeleteFieldIndexCollection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 67,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeleteFieldIndexCollection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::google::protobuf::internal::ArenaStringPtr field_name_;
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE ordering_;
    bool wait_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeleteFieldIndexCollection_class_data_;
// -------------------------------------------------------------------

class DatetimeRange final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DatetimeRange) */ {
 public:
  inline DatetimeRange() : DatetimeRange(nullptr) {}
  ~DatetimeRange() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DatetimeRange* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DatetimeRange));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DatetimeRange(::google::protobuf::internal::ConstantInitialized);

  inline DatetimeRange(const DatetimeRange& from) : DatetimeRange(nullptr, from) {}
  inline DatetimeRange(DatetimeRange&& from) noexcept
      : DatetimeRange(nullptr, ::std::move(from)) {}
  inline DatetimeRange& operator=(const DatetimeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatetimeRange& operator=(DatetimeRange&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatetimeRange& default_instance() {
    return *reinterpret_cast<const DatetimeRange*>(
        &_DatetimeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 142;
  friend void swap(DatetimeRange& a, DatetimeRange& b) { a.Swap(&b); }
  inline void Swap(DatetimeRange* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatetimeRange* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatetimeRange* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DatetimeRange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DatetimeRange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DatetimeRange& from) { DatetimeRange::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DatetimeRange* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DatetimeRange"; }

  explicit DatetimeRange(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DatetimeRange(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DatetimeRange& from);
  DatetimeRange(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DatetimeRange&& from) noexcept
      : DatetimeRange(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLtFieldNumber = 1,
    kGtFieldNumber = 2,
    kGteFieldNumber = 3,
    kLteFieldNumber = 4,
  };
  // optional .google.protobuf.Timestamp lt = 1;
  bool has_lt() const;
  void clear_lt() ;
  const ::google::protobuf::Timestamp& lt() const;
  [[nodiscard]] ::google::protobuf::Timestamp* PROTOBUF_NULLABLE release_lt();
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL mutable_lt();
  void set_allocated_lt(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lt(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  ::google::protobuf::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_lt();

  private:
  const ::google::protobuf::Timestamp& _internal_lt() const;
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL _internal_mutable_lt();

  public:
  // optional .google.protobuf.Timestamp gt = 2;
  bool has_gt() const;
  void clear_gt() ;
  const ::google::protobuf::Timestamp& gt() const;
  [[nodiscard]] ::google::protobuf::Timestamp* PROTOBUF_NULLABLE release_gt();
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL mutable_gt();
  void set_allocated_gt(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gt(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  ::google::protobuf::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_gt();

  private:
  const ::google::protobuf::Timestamp& _internal_gt() const;
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL _internal_mutable_gt();

  public:
  // optional .google.protobuf.Timestamp gte = 3;
  bool has_gte() const;
  void clear_gte() ;
  const ::google::protobuf::Timestamp& gte() const;
  [[nodiscard]] ::google::protobuf::Timestamp* PROTOBUF_NULLABLE release_gte();
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL mutable_gte();
  void set_allocated_gte(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gte(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  ::google::protobuf::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_gte();

  private:
  const ::google::protobuf::Timestamp& _internal_gte() const;
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL _internal_mutable_gte();

  public:
  // optional .google.protobuf.Timestamp lte = 4;
  bool has_lte() const;
  void clear_lte() ;
  const ::google::protobuf::Timestamp& lte() const;
  [[nodiscard]] ::google::protobuf::Timestamp* PROTOBUF_NULLABLE release_lte();
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL mutable_lte();
  void set_allocated_lte(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lte(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  ::google::protobuf::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_lte();

  private:
  const ::google::protobuf::Timestamp& _internal_lte() const;
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL _internal_mutable_lte();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DatetimeRange)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DatetimeRange& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE lt_;
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE gt_;
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE gte_;
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE lte_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DatetimeRange_class_data_;
// -------------------------------------------------------------------

class WithLookup final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.WithLookup) */ {
 public:
  inline WithLookup() : WithLookup(nullptr) {}
  ~WithLookup() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WithLookup* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WithLookup));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WithLookup(::google::protobuf::internal::ConstantInitialized);

  inline WithLookup(const WithLookup& from) : WithLookup(nullptr, from) {}
  inline WithLookup(WithLookup&& from) noexcept
      : WithLookup(nullptr, ::std::move(from)) {}
  inline WithLookup& operator=(const WithLookup& from) {
    CopyFrom(from);
    return *this;
  }
  inline WithLookup& operator=(WithLookup&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WithLookup& default_instance() {
    return *reinterpret_cast<const WithLookup*>(
        &_WithLookup_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 44;
  friend void swap(WithLookup& a, WithLookup& b) { a.Swap(&b); }
  inline void Swap(WithLookup* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WithLookup* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WithLookup* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WithLookup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WithLookup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WithLookup& from) { WithLookup::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WithLookup* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.WithLookup"; }

  explicit WithLookup(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  WithLookup(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const WithLookup& from);
  WithLookup(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, WithLookup&& from) noexcept
      : WithLookup(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionFieldNumber = 1,
    kWithPayloadFieldNumber = 2,
    kWithVectorsFieldNumber = 3,
  };
  // string collection = 1;
  void clear_collection() ;
  const ::std::string& collection() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection();
  void set_allocated_collection(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection();

  public:
  // optional .qdrant.WithPayloadSelector with_payload = 2;
  bool has_with_payload() const;
  void clear_with_payload() ;
  const ::qdrant::WithPayloadSelector& with_payload() const;
  [[nodiscard]] ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE release_with_payload();
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL mutable_with_payload();
  void set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_payload();

  private:
  const ::qdrant::WithPayloadSelector& _internal_with_payload() const;
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL _internal_mutable_with_payload();

  public:
  // optional .qdrant.WithVectorsSelector with_vectors = 3;
  bool has_with_vectors() const;
  void clear_with_vectors() ;
  const ::qdrant::WithVectorsSelector& with_vectors() const;
  [[nodiscard]] ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE release_with_vectors();
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL mutable_with_vectors();
  void set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_vectors();

  private:
  const ::qdrant::WithVectorsSelector& _internal_with_vectors() const;
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL _internal_mutable_with_vectors();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.WithLookup)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 36,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const WithLookup& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_;
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE with_payload_;
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE with_vectors_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull WithLookup_class_data_;
// -------------------------------------------------------------------

class VectorOutput final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.VectorOutput) */ {
 public:
  inline VectorOutput() : VectorOutput(nullptr) {}
  ~VectorOutput() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VectorOutput* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VectorOutput));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VectorOutput(::google::protobuf::internal::ConstantInitialized);

  inline VectorOutput(const VectorOutput& from) : VectorOutput(nullptr, from) {}
  inline VectorOutput(VectorOutput&& from) noexcept
      : VectorOutput(nullptr, ::std::move(from)) {}
  inline VectorOutput& operator=(const VectorOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorOutput& operator=(VectorOutput&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorOutput& default_instance() {
    return *reinterpret_cast<const VectorOutput*>(
        &_VectorOutput_default_instance_);
  }
  enum VectorCase {
    kDense = 101,
    kSparse = 102,
    kMultiDense = 103,
    VECTOR_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(VectorOutput& a, VectorOutput& b) { a.Swap(&b); }
  inline void Swap(VectorOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorOutput* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VectorOutput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorOutput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VectorOutput& from) { VectorOutput::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VectorOutput* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.VectorOutput"; }

  explicit VectorOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  VectorOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const VectorOutput& from);
  VectorOutput(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, VectorOutput&& from) noexcept
      : VectorOutput(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
    kIndicesFieldNumber = 2,
    kVectorsCountFieldNumber = 3,
    kDenseFieldNumber = 101,
    kSparseFieldNumber = 102,
    kMultiDenseFieldNumber = 103,
  };
  // repeated float data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::google::protobuf::RepeatedField<float>& data() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL mutable_data();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_data() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL _internal_mutable_data();

  public:
  // optional .qdrant.SparseIndices indices = 2;
  bool has_indices() const;
  void clear_indices() ;
  const ::qdrant::SparseIndices& indices() const;
  [[nodiscard]] ::qdrant::SparseIndices* PROTOBUF_NULLABLE release_indices();
  ::qdrant::SparseIndices* PROTOBUF_NONNULL mutable_indices();
  void set_allocated_indices(::qdrant::SparseIndices* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_indices(::qdrant::SparseIndices* PROTOBUF_NULLABLE value);
  ::qdrant::SparseIndices* PROTOBUF_NULLABLE unsafe_arena_release_indices();

  private:
  const ::qdrant::SparseIndices& _internal_indices() const;
  ::qdrant::SparseIndices* PROTOBUF_NONNULL _internal_mutable_indices();

  public:
  // optional uint32 vectors_count = 3;
  bool has_vectors_count() const;
  void clear_vectors_count() ;
  ::uint32_t vectors_count() const;
  void set_vectors_count(::uint32_t value);

  private:
  ::uint32_t _internal_vectors_count() const;
  void _internal_set_vectors_count(::uint32_t value);

  public:
  // .qdrant.DenseVector dense = 101;
  bool has_dense() const;
  private:
  bool _internal_has_dense() const;

  public:
  void clear_dense() ;
  const ::qdrant::DenseVector& dense() const;
  [[nodiscard]] ::qdrant::DenseVector* PROTOBUF_NULLABLE release_dense();
  ::qdrant::DenseVector* PROTOBUF_NONNULL mutable_dense();
  void set_allocated_dense(::qdrant::DenseVector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dense(::qdrant::DenseVector* PROTOBUF_NULLABLE value);
  ::qdrant::DenseVector* PROTOBUF_NULLABLE unsafe_arena_release_dense();

  private:
  const ::qdrant::DenseVector& _internal_dense() const;
  ::qdrant::DenseVector* PROTOBUF_NONNULL _internal_mutable_dense();

  public:
  // .qdrant.SparseVector sparse = 102;
  bool has_sparse() const;
  private:
  bool _internal_has_sparse() const;

  public:
  void clear_sparse() ;
  const ::qdrant::SparseVector& sparse() const;
  [[nodiscard]] ::qdrant::SparseVector* PROTOBUF_NULLABLE release_sparse();
  ::qdrant::SparseVector* PROTOBUF_NONNULL mutable_sparse();
  void set_allocated_sparse(::qdrant::SparseVector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sparse(::qdrant::SparseVector* PROTOBUF_NULLABLE value);
  ::qdrant::SparseVector* PROTOBUF_NULLABLE unsafe_arena_release_sparse();

  private:
  const ::qdrant::SparseVector& _internal_sparse() const;
  ::qdrant::SparseVector* PROTOBUF_NONNULL _internal_mutable_sparse();

  public:
  // .qdrant.MultiDenseVector multi_dense = 103;
  bool has_multi_dense() const;
  private:
  bool _internal_has_multi_dense() const;

  public:
  void clear_multi_dense() ;
  const ::qdrant::MultiDenseVector& multi_dense() const;
  [[nodiscard]] ::qdrant::MultiDenseVector* PROTOBUF_NULLABLE release_multi_dense();
  ::qdrant::MultiDenseVector* PROTOBUF_NONNULL mutable_multi_dense();
  void set_allocated_multi_dense(::qdrant::MultiDenseVector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_multi_dense(::qdrant::MultiDenseVector* PROTOBUF_NULLABLE value);
  ::qdrant::MultiDenseVector* PROTOBUF_NULLABLE unsafe_arena_release_multi_dense();

  private:
  const ::qdrant::MultiDenseVector& _internal_multi_dense() const;
  ::qdrant::MultiDenseVector* PROTOBUF_NONNULL _internal_mutable_multi_dense();

  public:
  void clear_vector();
  VectorCase vector_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.VectorOutput)
 private:
  class _Internal;
  void set_has_dense();
  void set_has_sparse();
  void set_has_multi_dense();
  inline bool has_vector() const;
  inline void clear_has_vector();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 6,
                                   4, 0,
                                   7>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const VectorOutput& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> data_;
    ::qdrant::SparseIndices* PROTOBUF_NULLABLE indices_;
    ::uint32_t vectors_count_;
    union VectorUnion {
      constexpr VectorUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE dense_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE sparse_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE multi_dense_;
    } vector_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull VectorOutput_class_data_;
// -------------------------------------------------------------------

class SearchMatrixPairs final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SearchMatrixPairs) */ {
 public:
  inline SearchMatrixPairs() : SearchMatrixPairs(nullptr) {}
  ~SearchMatrixPairs() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SearchMatrixPairs* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SearchMatrixPairs));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SearchMatrixPairs(::google::protobuf::internal::ConstantInitialized);

  inline SearchMatrixPairs(const SearchMatrixPairs& from) : SearchMatrixPairs(nullptr, from) {}
  inline SearchMatrixPairs(SearchMatrixPairs&& from) noexcept
      : SearchMatrixPairs(nullptr, ::std::move(from)) {}
  inline SearchMatrixPairs& operator=(const SearchMatrixPairs& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchMatrixPairs& operator=(SearchMatrixPairs&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchMatrixPairs& default_instance() {
    return *reinterpret_cast<const SearchMatrixPairs*>(
        &_SearchMatrixPairs_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 84;
  friend void swap(SearchMatrixPairs& a, SearchMatrixPairs& b) { a.Swap(&b); }
  inline void Swap(SearchMatrixPairs* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchMatrixPairs* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchMatrixPairs* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SearchMatrixPairs>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchMatrixPairs& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SearchMatrixPairs& from) { SearchMatrixPairs::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SearchMatrixPairs* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SearchMatrixPairs"; }

  explicit SearchMatrixPairs(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SearchMatrixPairs(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SearchMatrixPairs& from);
  SearchMatrixPairs(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SearchMatrixPairs&& from) noexcept
      : SearchMatrixPairs(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPairsFieldNumber = 1,
  };
  // repeated .qdrant.SearchMatrixPair pairs = 1;
  int pairs_size() const;
  private:
  int _internal_pairs_size() const;

  public:
  void clear_pairs() ;
  ::qdrant::SearchMatrixPair* PROTOBUF_NONNULL mutable_pairs(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::SearchMatrixPair>* PROTOBUF_NONNULL mutable_pairs();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::SearchMatrixPair>& _internal_pairs() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::SearchMatrixPair>* PROTOBUF_NONNULL _internal_mutable_pairs();
  public:
  const ::qdrant::SearchMatrixPair& pairs(int index) const;
  ::qdrant::SearchMatrixPair* PROTOBUF_NONNULL add_pairs();
  const ::google::protobuf::RepeatedPtrField<::qdrant::SearchMatrixPair>& pairs() const;
  // @@protoc_insertion_point(class_scope:qdrant.SearchMatrixPairs)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SearchMatrixPairs& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::SearchMatrixPair > pairs_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SearchMatrixPairs_class_data_;
// -------------------------------------------------------------------

class OrderBy final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.OrderBy) */ {
 public:
  inline OrderBy() : OrderBy(nullptr) {}
  ~OrderBy() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OrderBy* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OrderBy));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OrderBy(::google::protobuf::internal::ConstantInitialized);

  inline OrderBy(const OrderBy& from) : OrderBy(nullptr, from) {}
  inline OrderBy(OrderBy&& from) noexcept
      : OrderBy(nullptr, ::std::move(from)) {}
  inline OrderBy& operator=(const OrderBy& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderBy& operator=(OrderBy&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderBy& default_instance() {
    return *reinterpret_cast<const OrderBy*>(
        &_OrderBy_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 47;
  friend void swap(OrderBy& a, OrderBy& b) { a.Swap(&b); }
  inline void Swap(OrderBy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderBy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderBy* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OrderBy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OrderBy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OrderBy& from) { OrderBy::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OrderBy* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.OrderBy"; }

  explicit OrderBy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  OrderBy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const OrderBy& from);
  OrderBy(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, OrderBy&& from) noexcept
      : OrderBy(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kStartFromFieldNumber = 3,
    kDirectionFieldNumber = 2,
  };
  // string key = 1;
  void clear_key() ;
  const ::std::string& key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_key();
  void set_allocated_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_key();

  public:
  // optional .qdrant.StartFrom start_from = 3;
  bool has_start_from() const;
  void clear_start_from() ;
  const ::qdrant::StartFrom& start_from() const;
  [[nodiscard]] ::qdrant::StartFrom* PROTOBUF_NULLABLE release_start_from();
  ::qdrant::StartFrom* PROTOBUF_NONNULL mutable_start_from();
  void set_allocated_start_from(::qdrant::StartFrom* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_start_from(::qdrant::StartFrom* PROTOBUF_NULLABLE value);
  ::qdrant::StartFrom* PROTOBUF_NULLABLE unsafe_arena_release_start_from();

  private:
  const ::qdrant::StartFrom& _internal_start_from() const;
  ::qdrant::StartFrom* PROTOBUF_NONNULL _internal_mutable_start_from();

  public:
  // optional .qdrant.Direction direction = 2;
  bool has_direction() const;
  void clear_direction() ;
  ::qdrant::Direction direction() const;
  void set_direction(::qdrant::Direction value);

  private:
  ::qdrant::Direction _internal_direction() const;
  void _internal_set_direction(::qdrant::Direction value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.OrderBy)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 26,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const OrderBy& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::qdrant::StartFrom* PROTOBUF_NULLABLE start_from_;
    int direction_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull OrderBy_class_data_;
// -------------------------------------------------------------------

class LookupLocation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.LookupLocation) */ {
 public:
  inline LookupLocation() : LookupLocation(nullptr) {}
  ~LookupLocation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LookupLocation* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LookupLocation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LookupLocation(::google::protobuf::internal::ConstantInitialized);

  inline LookupLocation(const LookupLocation& from) : LookupLocation(nullptr, from) {}
  inline LookupLocation(LookupLocation&& from) noexcept
      : LookupLocation(nullptr, ::std::move(from)) {}
  inline LookupLocation& operator=(const LookupLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupLocation& operator=(LookupLocation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupLocation& default_instance() {
    return *reinterpret_cast<const LookupLocation*>(
        &_LookupLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 49;
  friend void swap(LookupLocation& a, LookupLocation& b) { a.Swap(&b); }
  inline void Swap(LookupLocation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupLocation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupLocation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LookupLocation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LookupLocation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LookupLocation& from) { LookupLocation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LookupLocation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.LookupLocation"; }

  explicit LookupLocation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LookupLocation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LookupLocation& from);
  LookupLocation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LookupLocation&& from) noexcept
      : LookupLocation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kVectorNameFieldNumber = 2,
    kShardKeySelectorFieldNumber = 3,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional string vector_name = 2;
  bool has_vector_name() const;
  void clear_vector_name() ;
  const ::std::string& vector_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_vector_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_vector_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_vector_name();
  void set_allocated_vector_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_vector_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_vector_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_vector_name();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 3;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.LookupLocation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 56,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LookupLocation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::google::protobuf::internal::ArenaStringPtr vector_name_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LookupLocation_class_data_;
// -------------------------------------------------------------------

class InferenceUsage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.InferenceUsage) */ {
 public:
  inline InferenceUsage() : InferenceUsage(nullptr) {}
  ~InferenceUsage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InferenceUsage* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InferenceUsage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InferenceUsage(::google::protobuf::internal::ConstantInitialized);

  inline InferenceUsage(const InferenceUsage& from) : InferenceUsage(nullptr, from) {}
  inline InferenceUsage(InferenceUsage&& from) noexcept
      : InferenceUsage(nullptr, ::std::move(from)) {}
  inline InferenceUsage& operator=(const InferenceUsage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InferenceUsage& operator=(InferenceUsage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InferenceUsage& default_instance() {
    return *reinterpret_cast<const InferenceUsage*>(
        &_InferenceUsage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 155;
  friend void swap(InferenceUsage& a, InferenceUsage& b) { a.Swap(&b); }
  inline void Swap(InferenceUsage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InferenceUsage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InferenceUsage* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InferenceUsage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InferenceUsage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InferenceUsage& from) { InferenceUsage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InferenceUsage* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.InferenceUsage"; }

  explicit InferenceUsage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InferenceUsage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InferenceUsage& from);
  InferenceUsage(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InferenceUsage&& from) noexcept
      : InferenceUsage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kModelsFieldNumber = 1,
  };
  // map<string, .qdrant.ModelUsage> models = 1;
  int models_size() const;
  private:
  int _internal_models_size() const;

  public:
  void clear_models() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::ModelUsage>& models() const;
  ::google::protobuf::Map<::std::string, ::qdrant::ModelUsage>* PROTOBUF_NONNULL mutable_models();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::ModelUsage>& _internal_models() const;
  ::google::protobuf::Map<::std::string, ::qdrant::ModelUsage>* PROTOBUF_NONNULL _internal_mutable_models();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.InferenceUsage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   2, 36,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InferenceUsage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<InferenceUsage_ModelsEntry_DoNotUse, ::std::string, ::qdrant::ModelUsage,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        models_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InferenceUsage_class_data_;
// -------------------------------------------------------------------

class InferenceObject final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.InferenceObject) */ {
 public:
  inline InferenceObject() : InferenceObject(nullptr) {}
  ~InferenceObject() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InferenceObject* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InferenceObject));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InferenceObject(::google::protobuf::internal::ConstantInitialized);

  inline InferenceObject(const InferenceObject& from) : InferenceObject(nullptr, from) {}
  inline InferenceObject(InferenceObject&& from) noexcept
      : InferenceObject(nullptr, ::std::move(from)) {}
  inline InferenceObject& operator=(const InferenceObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline InferenceObject& operator=(InferenceObject&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InferenceObject& default_instance() {
    return *reinterpret_cast<const InferenceObject*>(
        &_InferenceObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(InferenceObject& a, InferenceObject& b) { a.Swap(&b); }
  inline void Swap(InferenceObject* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InferenceObject* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InferenceObject* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InferenceObject>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InferenceObject& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InferenceObject& from) { InferenceObject::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InferenceObject* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.InferenceObject"; }

  explicit InferenceObject(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InferenceObject(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InferenceObject& from);
  InferenceObject(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InferenceObject&& from) noexcept
      : InferenceObject(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kModelFieldNumber = 2,
    kObjectFieldNumber = 1,
    kOptionsFieldNumber = 3,
  };
  // string model = 2;
  void clear_model() ;
  const ::std::string& model() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_model(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_model();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_model();
  void set_allocated_model(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_model() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_model(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_model();

  public:
  // .qdrant.Value object = 1;
  bool has_object() const;
  void clear_object() ;
  const ::qdrant::Value& object() const;
  [[nodiscard]] ::qdrant::Value* PROTOBUF_NULLABLE release_object();
  ::qdrant::Value* PROTOBUF_NONNULL mutable_object();
  void set_allocated_object(::qdrant::Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_object(::qdrant::Value* PROTOBUF_NULLABLE value);
  ::qdrant::Value* PROTOBUF_NULLABLE unsafe_arena_release_object();

  private:
  const ::qdrant::Value& _internal_object() const;
  ::qdrant::Value* PROTOBUF_NONNULL _internal_mutable_object();

  public:
  // map<string, .qdrant.Value> options = 3;
  int options_size() const;
  private:
  int _internal_options_size() const;

  public:
  void clear_options() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& options() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL mutable_options();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& _internal_options() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL _internal_mutable_options();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.InferenceObject)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 3,
                                   3, 43,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InferenceObject& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr model_;
    ::qdrant::Value* PROTOBUF_NULLABLE object_;
    ::google::protobuf::internal::MapField<InferenceObject_OptionsEntry_DoNotUse, ::std::string, ::qdrant::Value,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        options_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InferenceObject_class_data_;
// -------------------------------------------------------------------

class Image final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  ~Image() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Image* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Image));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Image(::google::protobuf::internal::ConstantInitialized);

  inline Image(const Image& from) : Image(nullptr, from) {}
  inline Image(Image&& from) noexcept
      : Image(nullptr, ::std::move(from)) {}
  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Image& default_instance() {
    return *reinterpret_cast<const Image*>(
        &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Image& a, Image& b) { a.Swap(&b); }
  inline void Swap(Image* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Image* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Image>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Image& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Image& from) { Image::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Image* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.Image"; }

  explicit Image(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Image(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Image& from);
  Image(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Image&& from) noexcept
      : Image(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kModelFieldNumber = 2,
    kImageFieldNumber = 1,
    kOptionsFieldNumber = 3,
  };
  // string model = 2;
  void clear_model() ;
  const ::std::string& model() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_model(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_model();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_model();
  void set_allocated_model(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_model() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_model(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_model();

  public:
  // .qdrant.Value image = 1;
  bool has_image() const;
  void clear_image() ;
  const ::qdrant::Value& image() const;
  [[nodiscard]] ::qdrant::Value* PROTOBUF_NULLABLE release_image();
  ::qdrant::Value* PROTOBUF_NONNULL mutable_image();
  void set_allocated_image(::qdrant::Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_image(::qdrant::Value* PROTOBUF_NULLABLE value);
  ::qdrant::Value* PROTOBUF_NULLABLE unsafe_arena_release_image();

  private:
  const ::qdrant::Value& _internal_image() const;
  ::qdrant::Value* PROTOBUF_NONNULL _internal_mutable_image();

  public:
  // map<string, .qdrant.Value> options = 3;
  int options_size() const;
  private:
  int _internal_options_size() const;

  public:
  void clear_options() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& options() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL mutable_options();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& _internal_options() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL _internal_mutable_options();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.Image)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 3,
                                   3, 33,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Image& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr model_;
    ::qdrant::Value* PROTOBUF_NULLABLE image_;
    ::google::protobuf::internal::MapField<Image_OptionsEntry_DoNotUse, ::std::string, ::qdrant::Value,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        options_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Image_class_data_;
// -------------------------------------------------------------------

class GetPoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.GetPoints) */ {
 public:
  inline GetPoints() : GetPoints(nullptr) {}
  ~GetPoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetPoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetPoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetPoints(::google::protobuf::internal::ConstantInitialized);

  inline GetPoints(const GetPoints& from) : GetPoints(nullptr, from) {}
  inline GetPoints(GetPoints&& from) noexcept
      : GetPoints(nullptr, ::std::move(from)) {}
  inline GetPoints& operator=(const GetPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPoints& operator=(GetPoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPoints& default_instance() {
    return *reinterpret_cast<const GetPoints*>(
        &_GetPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(GetPoints& a, GetPoints& b) { a.Swap(&b); }
  inline void Swap(GetPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetPoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetPoints& from) { GetPoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetPoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.GetPoints"; }

  explicit GetPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetPoints& from);
  GetPoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetPoints&& from) noexcept
      : GetPoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdsFieldNumber = 2,
    kCollectionNameFieldNumber = 1,
    kWithPayloadFieldNumber = 4,
    kWithVectorsFieldNumber = 5,
    kReadConsistencyFieldNumber = 6,
    kShardKeySelectorFieldNumber = 7,
    kTimeoutFieldNumber = 8,
  };
  // repeated .qdrant.PointId ids = 2;
  int ids_size() const;
  private:
  int _internal_ids_size() const;

  public:
  void clear_ids() ;
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_ids(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL mutable_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& _internal_ids() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL _internal_mutable_ids();
  public:
  const ::qdrant::PointId& ids(int index) const;
  ::qdrant::PointId* PROTOBUF_NONNULL add_ids();
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& ids() const;
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // .qdrant.WithPayloadSelector with_payload = 4;
  bool has_with_payload() const;
  void clear_with_payload() ;
  const ::qdrant::WithPayloadSelector& with_payload() const;
  [[nodiscard]] ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE release_with_payload();
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL mutable_with_payload();
  void set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_payload();

  private:
  const ::qdrant::WithPayloadSelector& _internal_with_payload() const;
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL _internal_mutable_with_payload();

  public:
  // optional .qdrant.WithVectorsSelector with_vectors = 5;
  bool has_with_vectors() const;
  void clear_with_vectors() ;
  const ::qdrant::WithVectorsSelector& with_vectors() const;
  [[nodiscard]] ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE release_with_vectors();
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL mutable_with_vectors();
  void set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_vectors();

  private:
  const ::qdrant::WithVectorsSelector& _internal_with_vectors() const;
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL _internal_mutable_with_vectors();

  public:
  // optional .qdrant.ReadConsistency read_consistency = 6;
  bool has_read_consistency() const;
  void clear_read_consistency() ;
  const ::qdrant::ReadConsistency& read_consistency() const;
  [[nodiscard]] ::qdrant::ReadConsistency* PROTOBUF_NULLABLE release_read_consistency();
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL mutable_read_consistency();
  void set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  ::qdrant::ReadConsistency* PROTOBUF_NULLABLE unsafe_arena_release_read_consistency();

  private:
  const ::qdrant::ReadConsistency& _internal_read_consistency() const;
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL _internal_mutable_read_consistency();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 7;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional uint64 timeout = 8;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.GetPoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   5, 40,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetPoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::PointId > ids_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE with_payload_;
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE with_vectors_;
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE read_consistency_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::uint64_t timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetPoints_class_data_;
// -------------------------------------------------------------------

class GeoPolygon final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.GeoPolygon) */ {
 public:
  inline GeoPolygon() : GeoPolygon(nullptr) {}
  ~GeoPolygon() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GeoPolygon* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GeoPolygon));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoPolygon(::google::protobuf::internal::ConstantInitialized);

  inline GeoPolygon(const GeoPolygon& from) : GeoPolygon(nullptr, from) {}
  inline GeoPolygon(GeoPolygon&& from) noexcept
      : GeoPolygon(nullptr, ::std::move(from)) {}
  inline GeoPolygon& operator=(const GeoPolygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPolygon& operator=(GeoPolygon&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoPolygon& default_instance() {
    return *reinterpret_cast<const GeoPolygon*>(
        &_GeoPolygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 146;
  friend void swap(GeoPolygon& a, GeoPolygon& b) { a.Swap(&b); }
  inline void Swap(GeoPolygon* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPolygon* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoPolygon* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GeoPolygon>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoPolygon& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoPolygon& from) { GeoPolygon::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GeoPolygon* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.GeoPolygon"; }

  explicit GeoPolygon(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GeoPolygon(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GeoPolygon& from);
  GeoPolygon(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GeoPolygon&& from) noexcept
      : GeoPolygon(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInteriorsFieldNumber = 2,
    kExteriorFieldNumber = 1,
  };
  // repeated .qdrant.GeoLineString interiors = 2;
  int interiors_size() const;
  private:
  int _internal_interiors_size() const;

  public:
  void clear_interiors() ;
  ::qdrant::GeoLineString* PROTOBUF_NONNULL mutable_interiors(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::GeoLineString>* PROTOBUF_NONNULL mutable_interiors();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::GeoLineString>& _internal_interiors() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::GeoLineString>* PROTOBUF_NONNULL _internal_mutable_interiors();
  public:
  const ::qdrant::GeoLineString& interiors(int index) const;
  ::qdrant::GeoLineString* PROTOBUF_NONNULL add_interiors();
  const ::google::protobuf::RepeatedPtrField<::qdrant::GeoLineString>& interiors() const;
  // .qdrant.GeoLineString exterior = 1;
  bool has_exterior() const;
  void clear_exterior() ;
  const ::qdrant::GeoLineString& exterior() const;
  [[nodiscard]] ::qdrant::GeoLineString* PROTOBUF_NULLABLE release_exterior();
  ::qdrant::GeoLineString* PROTOBUF_NONNULL mutable_exterior();
  void set_allocated_exterior(::qdrant::GeoLineString* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_exterior(::qdrant::GeoLineString* PROTOBUF_NULLABLE value);
  ::qdrant::GeoLineString* PROTOBUF_NULLABLE unsafe_arena_release_exterior();

  private:
  const ::qdrant::GeoLineString& _internal_exterior() const;
  ::qdrant::GeoLineString* PROTOBUF_NONNULL _internal_mutable_exterior();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.GeoPolygon)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GeoPolygon& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::GeoLineString > interiors_;
    ::qdrant::GeoLineString* PROTOBUF_NULLABLE exterior_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GeoPolygon_class_data_;
// -------------------------------------------------------------------

class Document final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.Document) */ {
 public:
  inline Document() : Document(nullptr) {}
  ~Document() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Document* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Document));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Document(::google::protobuf::internal::ConstantInitialized);

  inline Document(const Document& from) : Document(nullptr, from) {}
  inline Document(Document&& from) noexcept
      : Document(nullptr, ::std::move(from)) {}
  inline Document& operator=(const Document& from) {
    CopyFrom(from);
    return *this;
  }
  inline Document& operator=(Document&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Document& default_instance() {
    return *reinterpret_cast<const Document*>(
        &_Document_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Document& a, Document& b) { a.Swap(&b); }
  inline void Swap(Document* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Document* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Document* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Document>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Document& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Document& from) { Document::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Document* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.Document"; }

  explicit Document(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Document(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Document& from);
  Document(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Document&& from) noexcept
      : Document(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTextFieldNumber = 1,
    kModelFieldNumber = 3,
    kOptionsFieldNumber = 4,
  };
  // string text = 1;
  void clear_text() ;
  const ::std::string& text() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_text();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_text();
  void set_allocated_text(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_text() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_text(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_text();

  public:
  // string model = 3;
  void clear_model() ;
  const ::std::string& model() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_model(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_model();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_model();
  void set_allocated_model(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_model() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_model(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_model();

  public:
  // map<string, .qdrant.Value> options = 4;
  int options_size() const;
  private:
  int _internal_options_size() const;

  public:
  void clear_options() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& options() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL mutable_options();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& _internal_options() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL _internal_mutable_options();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.Document)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 40,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Document& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::google::protobuf::internal::ArenaStringPtr model_;
    ::google::protobuf::internal::MapField<Document_OptionsEntry_DoNotUse, ::std::string, ::qdrant::Value,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        options_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Document_class_data_;
// -------------------------------------------------------------------

class VectorInput final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.VectorInput) */ {
 public:
  inline VectorInput() : VectorInput(nullptr) {}
  ~VectorInput() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VectorInput* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VectorInput));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VectorInput(::google::protobuf::internal::ConstantInitialized);

  inline VectorInput(const VectorInput& from) : VectorInput(nullptr, from) {}
  inline VectorInput(VectorInput&& from) noexcept
      : VectorInput(nullptr, ::std::move(from)) {}
  inline VectorInput& operator=(const VectorInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorInput& operator=(VectorInput&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorInput& default_instance() {
    return *reinterpret_cast<const VectorInput*>(
        &_VectorInput_default_instance_);
  }
  enum VariantCase {
    kId = 1,
    kDense = 2,
    kSparse = 3,
    kMultiDense = 4,
    kDocument = 5,
    kImage = 6,
    kObject = 7,
    VARIANT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(VectorInput& a, VectorInput& b) { a.Swap(&b); }
  inline void Swap(VectorInput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorInput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorInput* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VectorInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VectorInput& from) { VectorInput::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VectorInput* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.VectorInput"; }

  explicit VectorInput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  VectorInput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const VectorInput& from);
  VectorInput(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, VectorInput&& from) noexcept
      : VectorInput(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kDenseFieldNumber = 2,
    kSparseFieldNumber = 3,
    kMultiDenseFieldNumber = 4,
    kDocumentFieldNumber = 5,
    kImageFieldNumber = 6,
    kObjectFieldNumber = 7,
  };
  // .qdrant.PointId id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;

  public:
  void clear_id() ;
  const ::qdrant::PointId& id() const;
  [[nodiscard]] ::qdrant::PointId* PROTOBUF_NULLABLE release_id();
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_id();
  void set_allocated_id(::qdrant::PointId* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_id(::qdrant::PointId* PROTOBUF_NULLABLE value);
  ::qdrant::PointId* PROTOBUF_NULLABLE unsafe_arena_release_id();

  private:
  const ::qdrant::PointId& _internal_id() const;
  ::qdrant::PointId* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // .qdrant.DenseVector dense = 2;
  bool has_dense() const;
  private:
  bool _internal_has_dense() const;

  public:
  void clear_dense() ;
  const ::qdrant::DenseVector& dense() const;
  [[nodiscard]] ::qdrant::DenseVector* PROTOBUF_NULLABLE release_dense();
  ::qdrant::DenseVector* PROTOBUF_NONNULL mutable_dense();
  void set_allocated_dense(::qdrant::DenseVector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dense(::qdrant::DenseVector* PROTOBUF_NULLABLE value);
  ::qdrant::DenseVector* PROTOBUF_NULLABLE unsafe_arena_release_dense();

  private:
  const ::qdrant::DenseVector& _internal_dense() const;
  ::qdrant::DenseVector* PROTOBUF_NONNULL _internal_mutable_dense();

  public:
  // .qdrant.SparseVector sparse = 3;
  bool has_sparse() const;
  private:
  bool _internal_has_sparse() const;

  public:
  void clear_sparse() ;
  const ::qdrant::SparseVector& sparse() const;
  [[nodiscard]] ::qdrant::SparseVector* PROTOBUF_NULLABLE release_sparse();
  ::qdrant::SparseVector* PROTOBUF_NONNULL mutable_sparse();
  void set_allocated_sparse(::qdrant::SparseVector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sparse(::qdrant::SparseVector* PROTOBUF_NULLABLE value);
  ::qdrant::SparseVector* PROTOBUF_NULLABLE unsafe_arena_release_sparse();

  private:
  const ::qdrant::SparseVector& _internal_sparse() const;
  ::qdrant::SparseVector* PROTOBUF_NONNULL _internal_mutable_sparse();

  public:
  // .qdrant.MultiDenseVector multi_dense = 4;
  bool has_multi_dense() const;
  private:
  bool _internal_has_multi_dense() const;

  public:
  void clear_multi_dense() ;
  const ::qdrant::MultiDenseVector& multi_dense() const;
  [[nodiscard]] ::qdrant::MultiDenseVector* PROTOBUF_NULLABLE release_multi_dense();
  ::qdrant::MultiDenseVector* PROTOBUF_NONNULL mutable_multi_dense();
  void set_allocated_multi_dense(::qdrant::MultiDenseVector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_multi_dense(::qdrant::MultiDenseVector* PROTOBUF_NULLABLE value);
  ::qdrant::MultiDenseVector* PROTOBUF_NULLABLE unsafe_arena_release_multi_dense();

  private:
  const ::qdrant::MultiDenseVector& _internal_multi_dense() const;
  ::qdrant::MultiDenseVector* PROTOBUF_NONNULL _internal_mutable_multi_dense();

  public:
  // .qdrant.Document document = 5;
  bool has_document() const;
  private:
  bool _internal_has_document() const;

  public:
  void clear_document() ;
  const ::qdrant::Document& document() const;
  [[nodiscard]] ::qdrant::Document* PROTOBUF_NULLABLE release_document();
  ::qdrant::Document* PROTOBUF_NONNULL mutable_document();
  void set_allocated_document(::qdrant::Document* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_document(::qdrant::Document* PROTOBUF_NULLABLE value);
  ::qdrant::Document* PROTOBUF_NULLABLE unsafe_arena_release_document();

  private:
  const ::qdrant::Document& _internal_document() const;
  ::qdrant::Document* PROTOBUF_NONNULL _internal_mutable_document();

  public:
  // .qdrant.Image image = 6;
  bool has_image() const;
  private:
  bool _internal_has_image() const;

  public:
  void clear_image() ;
  const ::qdrant::Image& image() const;
  [[nodiscard]] ::qdrant::Image* PROTOBUF_NULLABLE release_image();
  ::qdrant::Image* PROTOBUF_NONNULL mutable_image();
  void set_allocated_image(::qdrant::Image* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_image(::qdrant::Image* PROTOBUF_NULLABLE value);
  ::qdrant::Image* PROTOBUF_NULLABLE unsafe_arena_release_image();

  private:
  const ::qdrant::Image& _internal_image() const;
  ::qdrant::Image* PROTOBUF_NONNULL _internal_mutable_image();

  public:
  // .qdrant.InferenceObject object = 7;
  bool has_object() const;
  private:
  bool _internal_has_object() const;

  public:
  void clear_object() ;
  const ::qdrant::InferenceObject& object() const;
  [[nodiscard]] ::qdrant::InferenceObject* PROTOBUF_NULLABLE release_object();
  ::qdrant::InferenceObject* PROTOBUF_NONNULL mutable_object();
  void set_allocated_object(::qdrant::InferenceObject* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_object(::qdrant::InferenceObject* PROTOBUF_NULLABLE value);
  ::qdrant::InferenceObject* PROTOBUF_NULLABLE unsafe_arena_release_object();

  private:
  const ::qdrant::InferenceObject& _internal_object() const;
  ::qdrant::InferenceObject* PROTOBUF_NONNULL _internal_mutable_object();

  public:
  void clear_variant();
  VariantCase variant_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.VectorInput)
 private:
  class _Internal;
  void set_has_id();
  void set_has_dense();
  void set_has_sparse();
  void set_has_multi_dense();
  void set_has_document();
  void set_has_image();
  void set_has_object();
  inline bool has_variant() const;
  inline void clear_has_variant();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 7,
                                   7, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const VectorInput& from_msg);
    union VariantUnion {
      constexpr VariantUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE id_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE dense_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE sparse_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE multi_dense_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE document_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE image_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE object_;
    } variant_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull VectorInput_class_data_;
// -------------------------------------------------------------------

class Vector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.Vector) */ {
 public:
  inline Vector() : Vector(nullptr) {}
  ~Vector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Vector* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Vector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vector(::google::protobuf::internal::ConstantInitialized);

  inline Vector(const Vector& from) : Vector(nullptr, from) {}
  inline Vector(Vector&& from) noexcept
      : Vector(nullptr, ::std::move(from)) {}
  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector& operator=(Vector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector& default_instance() {
    return *reinterpret_cast<const Vector*>(
        &_Vector_default_instance_);
  }
  enum VectorCase {
    kDense = 101,
    kSparse = 102,
    kMultiDense = 103,
    kDocument = 104,
    kImage = 105,
    kObject = 106,
    VECTOR_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Vector& a, Vector& b) { a.Swap(&b); }
  inline void Swap(Vector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Vector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vector& from) { Vector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Vector* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.Vector"; }

  explicit Vector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Vector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Vector& from);
  Vector(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Vector&& from) noexcept
      : Vector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
    kIndicesFieldNumber = 2,
    kVectorsCountFieldNumber = 3,
    kDenseFieldNumber = 101,
    kSparseFieldNumber = 102,
    kMultiDenseFieldNumber = 103,
    kDocumentFieldNumber = 104,
    kImageFieldNumber = 105,
    kObjectFieldNumber = 106,
  };
  // repeated float data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::google::protobuf::RepeatedField<float>& data() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL mutable_data();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_data() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL _internal_mutable_data();

  public:
  // optional .qdrant.SparseIndices indices = 2;
  bool has_indices() const;
  void clear_indices() ;
  const ::qdrant::SparseIndices& indices() const;
  [[nodiscard]] ::qdrant::SparseIndices* PROTOBUF_NULLABLE release_indices();
  ::qdrant::SparseIndices* PROTOBUF_NONNULL mutable_indices();
  void set_allocated_indices(::qdrant::SparseIndices* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_indices(::qdrant::SparseIndices* PROTOBUF_NULLABLE value);
  ::qdrant::SparseIndices* PROTOBUF_NULLABLE unsafe_arena_release_indices();

  private:
  const ::qdrant::SparseIndices& _internal_indices() const;
  ::qdrant::SparseIndices* PROTOBUF_NONNULL _internal_mutable_indices();

  public:
  // optional uint32 vectors_count = 3;
  bool has_vectors_count() const;
  void clear_vectors_count() ;
  ::uint32_t vectors_count() const;
  void set_vectors_count(::uint32_t value);

  private:
  ::uint32_t _internal_vectors_count() const;
  void _internal_set_vectors_count(::uint32_t value);

  public:
  // .qdrant.DenseVector dense = 101;
  bool has_dense() const;
  private:
  bool _internal_has_dense() const;

  public:
  void clear_dense() ;
  const ::qdrant::DenseVector& dense() const;
  [[nodiscard]] ::qdrant::DenseVector* PROTOBUF_NULLABLE release_dense();
  ::qdrant::DenseVector* PROTOBUF_NONNULL mutable_dense();
  void set_allocated_dense(::qdrant::DenseVector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dense(::qdrant::DenseVector* PROTOBUF_NULLABLE value);
  ::qdrant::DenseVector* PROTOBUF_NULLABLE unsafe_arena_release_dense();

  private:
  const ::qdrant::DenseVector& _internal_dense() const;
  ::qdrant::DenseVector* PROTOBUF_NONNULL _internal_mutable_dense();

  public:
  // .qdrant.SparseVector sparse = 102;
  bool has_sparse() const;
  private:
  bool _internal_has_sparse() const;

  public:
  void clear_sparse() ;
  const ::qdrant::SparseVector& sparse() const;
  [[nodiscard]] ::qdrant::SparseVector* PROTOBUF_NULLABLE release_sparse();
  ::qdrant::SparseVector* PROTOBUF_NONNULL mutable_sparse();
  void set_allocated_sparse(::qdrant::SparseVector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sparse(::qdrant::SparseVector* PROTOBUF_NULLABLE value);
  ::qdrant::SparseVector* PROTOBUF_NULLABLE unsafe_arena_release_sparse();

  private:
  const ::qdrant::SparseVector& _internal_sparse() const;
  ::qdrant::SparseVector* PROTOBUF_NONNULL _internal_mutable_sparse();

  public:
  // .qdrant.MultiDenseVector multi_dense = 103;
  bool has_multi_dense() const;
  private:
  bool _internal_has_multi_dense() const;

  public:
  void clear_multi_dense() ;
  const ::qdrant::MultiDenseVector& multi_dense() const;
  [[nodiscard]] ::qdrant::MultiDenseVector* PROTOBUF_NULLABLE release_multi_dense();
  ::qdrant::MultiDenseVector* PROTOBUF_NONNULL mutable_multi_dense();
  void set_allocated_multi_dense(::qdrant::MultiDenseVector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_multi_dense(::qdrant::MultiDenseVector* PROTOBUF_NULLABLE value);
  ::qdrant::MultiDenseVector* PROTOBUF_NULLABLE unsafe_arena_release_multi_dense();

  private:
  const ::qdrant::MultiDenseVector& _internal_multi_dense() const;
  ::qdrant::MultiDenseVector* PROTOBUF_NONNULL _internal_mutable_multi_dense();

  public:
  // .qdrant.Document document = 104;
  bool has_document() const;
  private:
  bool _internal_has_document() const;

  public:
  void clear_document() ;
  const ::qdrant::Document& document() const;
  [[nodiscard]] ::qdrant::Document* PROTOBUF_NULLABLE release_document();
  ::qdrant::Document* PROTOBUF_NONNULL mutable_document();
  void set_allocated_document(::qdrant::Document* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_document(::qdrant::Document* PROTOBUF_NULLABLE value);
  ::qdrant::Document* PROTOBUF_NULLABLE unsafe_arena_release_document();

  private:
  const ::qdrant::Document& _internal_document() const;
  ::qdrant::Document* PROTOBUF_NONNULL _internal_mutable_document();

  public:
  // .qdrant.Image image = 105;
  bool has_image() const;
  private:
  bool _internal_has_image() const;

  public:
  void clear_image() ;
  const ::qdrant::Image& image() const;
  [[nodiscard]] ::qdrant::Image* PROTOBUF_NULLABLE release_image();
  ::qdrant::Image* PROTOBUF_NONNULL mutable_image();
  void set_allocated_image(::qdrant::Image* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_image(::qdrant::Image* PROTOBUF_NULLABLE value);
  ::qdrant::Image* PROTOBUF_NULLABLE unsafe_arena_release_image();

  private:
  const ::qdrant::Image& _internal_image() const;
  ::qdrant::Image* PROTOBUF_NONNULL _internal_mutable_image();

  public:
  // .qdrant.InferenceObject object = 106;
  bool has_object() const;
  private:
  bool _internal_has_object() const;

  public:
  void clear_object() ;
  const ::qdrant::InferenceObject& object() const;
  [[nodiscard]] ::qdrant::InferenceObject* PROTOBUF_NULLABLE release_object();
  ::qdrant::InferenceObject* PROTOBUF_NONNULL mutable_object();
  void set_allocated_object(::qdrant::InferenceObject* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_object(::qdrant::InferenceObject* PROTOBUF_NULLABLE value);
  ::qdrant::InferenceObject* PROTOBUF_NULLABLE unsafe_arena_release_object();

  private:
  const ::qdrant::InferenceObject& _internal_object() const;
  ::qdrant::InferenceObject* PROTOBUF_NONNULL _internal_mutable_object();

  public:
  void clear_vector();
  VectorCase vector_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.Vector)
 private:
  class _Internal;
  void set_has_dense();
  void set_has_sparse();
  void set_has_multi_dense();
  void set_has_document();
  void set_has_image();
  void set_has_object();
  inline bool has_vector() const;
  inline void clear_has_vector();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 9,
                                   7, 0,
                                   7>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Vector& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> data_;
    ::qdrant::SparseIndices* PROTOBUF_NULLABLE indices_;
    ::uint32_t vectors_count_;
    union VectorUnion {
      constexpr VectorUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE dense_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE sparse_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE multi_dense_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE document_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE image_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE object_;
    } vector_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Vector_class_data_;
// -------------------------------------------------------------------

class Usage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.Usage) */ {
 public:
  inline Usage() : Usage(nullptr) {}
  ~Usage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Usage* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Usage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Usage(::google::protobuf::internal::ConstantInitialized);

  inline Usage(const Usage& from) : Usage(nullptr, from) {}
  inline Usage(Usage&& from) noexcept
      : Usage(nullptr, ::std::move(from)) {}
  inline Usage& operator=(const Usage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Usage& operator=(Usage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Usage& default_instance() {
    return *reinterpret_cast<const Usage*>(
        &_Usage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 153;
  friend void swap(Usage& a, Usage& b) { a.Swap(&b); }
  inline void Swap(Usage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Usage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Usage* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Usage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Usage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Usage& from) { Usage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Usage* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.Usage"; }

  explicit Usage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Usage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Usage& from);
  Usage(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Usage&& from) noexcept
      : Usage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHardwareFieldNumber = 1,
    kInferenceFieldNumber = 2,
  };
  // optional .qdrant.HardwareUsage hardware = 1;
  bool has_hardware() const;
  void clear_hardware() ;
  const ::qdrant::HardwareUsage& hardware() const;
  [[nodiscard]] ::qdrant::HardwareUsage* PROTOBUF_NULLABLE release_hardware();
  ::qdrant::HardwareUsage* PROTOBUF_NONNULL mutable_hardware();
  void set_allocated_hardware(::qdrant::HardwareUsage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_hardware(::qdrant::HardwareUsage* PROTOBUF_NULLABLE value);
  ::qdrant::HardwareUsage* PROTOBUF_NULLABLE unsafe_arena_release_hardware();

  private:
  const ::qdrant::HardwareUsage& _internal_hardware() const;
  ::qdrant::HardwareUsage* PROTOBUF_NONNULL _internal_mutable_hardware();

  public:
  // optional .qdrant.InferenceUsage inference = 2;
  bool has_inference() const;
  void clear_inference() ;
  const ::qdrant::InferenceUsage& inference() const;
  [[nodiscard]] ::qdrant::InferenceUsage* PROTOBUF_NULLABLE release_inference();
  ::qdrant::InferenceUsage* PROTOBUF_NONNULL mutable_inference();
  void set_allocated_inference(::qdrant::InferenceUsage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_inference(::qdrant::InferenceUsage* PROTOBUF_NULLABLE value);
  ::qdrant::InferenceUsage* PROTOBUF_NULLABLE unsafe_arena_release_inference();

  private:
  const ::qdrant::InferenceUsage& _internal_inference() const;
  ::qdrant::InferenceUsage* PROTOBUF_NONNULL _internal_mutable_inference();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.Usage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Usage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::HardwareUsage* PROTOBUF_NULLABLE hardware_;
    ::qdrant::InferenceUsage* PROTOBUF_NULLABLE inference_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Usage_class_data_;
// -------------------------------------------------------------------

class NamedVectorsOutput_VectorsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  NamedVectorsOutput_VectorsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NamedVectorsOutput_VectorsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit NamedVectorsOutput_VectorsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_NamedVectorsOutput_VectorsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_points_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 50,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull NamedVectorsOutput_VectorsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class FieldCondition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.FieldCondition) */ {
 public:
  inline FieldCondition() : FieldCondition(nullptr) {}
  ~FieldCondition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FieldCondition* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FieldCondition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FieldCondition(::google::protobuf::internal::ConstantInitialized);

  inline FieldCondition(const FieldCondition& from) : FieldCondition(nullptr, from) {}
  inline FieldCondition(FieldCondition&& from) noexcept
      : FieldCondition(nullptr, ::std::move(from)) {}
  inline FieldCondition& operator=(const FieldCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldCondition& operator=(FieldCondition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldCondition& default_instance() {
    return *reinterpret_cast<const FieldCondition*>(
        &_FieldCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 137;
  friend void swap(FieldCondition& a, FieldCondition& b) { a.Swap(&b); }
  inline void Swap(FieldCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldCondition* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FieldCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FieldCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FieldCondition& from) { FieldCondition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FieldCondition* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.FieldCondition"; }

  explicit FieldCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FieldCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FieldCondition& from);
  FieldCondition(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FieldCondition&& from) noexcept
      : FieldCondition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kMatchFieldNumber = 2,
    kRangeFieldNumber = 3,
    kGeoBoundingBoxFieldNumber = 4,
    kGeoRadiusFieldNumber = 5,
    kValuesCountFieldNumber = 6,
    kGeoPolygonFieldNumber = 7,
    kDatetimeRangeFieldNumber = 8,
    kIsEmptyFieldNumber = 9,
    kIsNullFieldNumber = 10,
  };
  // string key = 1;
  void clear_key() ;
  const ::std::string& key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_key();
  void set_allocated_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_key();

  public:
  // .qdrant.Match match = 2;
  bool has_match() const;
  void clear_match() ;
  const ::qdrant::Match& match() const;
  [[nodiscard]] ::qdrant::Match* PROTOBUF_NULLABLE release_match();
  ::qdrant::Match* PROTOBUF_NONNULL mutable_match();
  void set_allocated_match(::qdrant::Match* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_match(::qdrant::Match* PROTOBUF_NULLABLE value);
  ::qdrant::Match* PROTOBUF_NULLABLE unsafe_arena_release_match();

  private:
  const ::qdrant::Match& _internal_match() const;
  ::qdrant::Match* PROTOBUF_NONNULL _internal_mutable_match();

  public:
  // .qdrant.Range range = 3;
  bool has_range() const;
  void clear_range() ;
  const ::qdrant::Range& range() const;
  [[nodiscard]] ::qdrant::Range* PROTOBUF_NULLABLE release_range();
  ::qdrant::Range* PROTOBUF_NONNULL mutable_range();
  void set_allocated_range(::qdrant::Range* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_range(::qdrant::Range* PROTOBUF_NULLABLE value);
  ::qdrant::Range* PROTOBUF_NULLABLE unsafe_arena_release_range();

  private:
  const ::qdrant::Range& _internal_range() const;
  ::qdrant::Range* PROTOBUF_NONNULL _internal_mutable_range();

  public:
  // .qdrant.GeoBoundingBox geo_bounding_box = 4;
  bool has_geo_bounding_box() const;
  void clear_geo_bounding_box() ;
  const ::qdrant::GeoBoundingBox& geo_bounding_box() const;
  [[nodiscard]] ::qdrant::GeoBoundingBox* PROTOBUF_NULLABLE release_geo_bounding_box();
  ::qdrant::GeoBoundingBox* PROTOBUF_NONNULL mutable_geo_bounding_box();
  void set_allocated_geo_bounding_box(::qdrant::GeoBoundingBox* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_geo_bounding_box(::qdrant::GeoBoundingBox* PROTOBUF_NULLABLE value);
  ::qdrant::GeoBoundingBox* PROTOBUF_NULLABLE unsafe_arena_release_geo_bounding_box();

  private:
  const ::qdrant::GeoBoundingBox& _internal_geo_bounding_box() const;
  ::qdrant::GeoBoundingBox* PROTOBUF_NONNULL _internal_mutable_geo_bounding_box();

  public:
  // .qdrant.GeoRadius geo_radius = 5;
  bool has_geo_radius() const;
  void clear_geo_radius() ;
  const ::qdrant::GeoRadius& geo_radius() const;
  [[nodiscard]] ::qdrant::GeoRadius* PROTOBUF_NULLABLE release_geo_radius();
  ::qdrant::GeoRadius* PROTOBUF_NONNULL mutable_geo_radius();
  void set_allocated_geo_radius(::qdrant::GeoRadius* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_geo_radius(::qdrant::GeoRadius* PROTOBUF_NULLABLE value);
  ::qdrant::GeoRadius* PROTOBUF_NULLABLE unsafe_arena_release_geo_radius();

  private:
  const ::qdrant::GeoRadius& _internal_geo_radius() const;
  ::qdrant::GeoRadius* PROTOBUF_NONNULL _internal_mutable_geo_radius();

  public:
  // .qdrant.ValuesCount values_count = 6;
  bool has_values_count() const;
  void clear_values_count() ;
  const ::qdrant::ValuesCount& values_count() const;
  [[nodiscard]] ::qdrant::ValuesCount* PROTOBUF_NULLABLE release_values_count();
  ::qdrant::ValuesCount* PROTOBUF_NONNULL mutable_values_count();
  void set_allocated_values_count(::qdrant::ValuesCount* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_values_count(::qdrant::ValuesCount* PROTOBUF_NULLABLE value);
  ::qdrant::ValuesCount* PROTOBUF_NULLABLE unsafe_arena_release_values_count();

  private:
  const ::qdrant::ValuesCount& _internal_values_count() const;
  ::qdrant::ValuesCount* PROTOBUF_NONNULL _internal_mutable_values_count();

  public:
  // .qdrant.GeoPolygon geo_polygon = 7;
  bool has_geo_polygon() const;
  void clear_geo_polygon() ;
  const ::qdrant::GeoPolygon& geo_polygon() const;
  [[nodiscard]] ::qdrant::GeoPolygon* PROTOBUF_NULLABLE release_geo_polygon();
  ::qdrant::GeoPolygon* PROTOBUF_NONNULL mutable_geo_polygon();
  void set_allocated_geo_polygon(::qdrant::GeoPolygon* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_geo_polygon(::qdrant::GeoPolygon* PROTOBUF_NULLABLE value);
  ::qdrant::GeoPolygon* PROTOBUF_NULLABLE unsafe_arena_release_geo_polygon();

  private:
  const ::qdrant::GeoPolygon& _internal_geo_polygon() const;
  ::qdrant::GeoPolygon* PROTOBUF_NONNULL _internal_mutable_geo_polygon();

  public:
  // .qdrant.DatetimeRange datetime_range = 8;
  bool has_datetime_range() const;
  void clear_datetime_range() ;
  const ::qdrant::DatetimeRange& datetime_range() const;
  [[nodiscard]] ::qdrant::DatetimeRange* PROTOBUF_NULLABLE release_datetime_range();
  ::qdrant::DatetimeRange* PROTOBUF_NONNULL mutable_datetime_range();
  void set_allocated_datetime_range(::qdrant::DatetimeRange* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_datetime_range(::qdrant::DatetimeRange* PROTOBUF_NULLABLE value);
  ::qdrant::DatetimeRange* PROTOBUF_NULLABLE unsafe_arena_release_datetime_range();

  private:
  const ::qdrant::DatetimeRange& _internal_datetime_range() const;
  ::qdrant::DatetimeRange* PROTOBUF_NONNULL _internal_mutable_datetime_range();

  public:
  // optional bool is_empty = 9;
  bool has_is_empty() const;
  void clear_is_empty() ;
  bool is_empty() const;
  void set_is_empty(bool value);

  private:
  bool _internal_is_empty() const;
  void _internal_set_is_empty(bool value);

  public:
  // optional bool is_null = 10;
  bool has_is_null() const;
  void clear_is_null() ;
  bool is_null() const;
  void set_is_null(bool value);

  private:
  bool _internal_is_null() const;
  void _internal_set_is_null(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.FieldCondition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 10,
                                   7, 41,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FieldCondition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::qdrant::Match* PROTOBUF_NULLABLE match_;
    ::qdrant::Range* PROTOBUF_NULLABLE range_;
    ::qdrant::GeoBoundingBox* PROTOBUF_NULLABLE geo_bounding_box_;
    ::qdrant::GeoRadius* PROTOBUF_NULLABLE geo_radius_;
    ::qdrant::ValuesCount* PROTOBUF_NULLABLE values_count_;
    ::qdrant::GeoPolygon* PROTOBUF_NULLABLE geo_polygon_;
    ::qdrant::DatetimeRange* PROTOBUF_NULLABLE datetime_range_;
    bool is_empty_;
    bool is_null_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FieldCondition_class_data_;
// -------------------------------------------------------------------

class VectorExample final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.VectorExample) */ {
 public:
  inline VectorExample() : VectorExample(nullptr) {}
  ~VectorExample() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VectorExample* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VectorExample));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VectorExample(::google::protobuf::internal::ConstantInitialized);

  inline VectorExample(const VectorExample& from) : VectorExample(nullptr, from) {}
  inline VectorExample(VectorExample&& from) noexcept
      : VectorExample(nullptr, ::std::move(from)) {}
  inline VectorExample& operator=(const VectorExample& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorExample& operator=(VectorExample&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorExample& default_instance() {
    return *reinterpret_cast<const VectorExample*>(
        &_VectorExample_default_instance_);
  }
  enum ExampleCase {
    kId = 1,
    kVector = 2,
    EXAMPLE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 54;
  friend void swap(VectorExample& a, VectorExample& b) { a.Swap(&b); }
  inline void Swap(VectorExample* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorExample* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorExample* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VectorExample>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorExample& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VectorExample& from) { VectorExample::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VectorExample* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.VectorExample"; }

  explicit VectorExample(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  VectorExample(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const VectorExample& from);
  VectorExample(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, VectorExample&& from) noexcept
      : VectorExample(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kVectorFieldNumber = 2,
  };
  // .qdrant.PointId id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;

  public:
  void clear_id() ;
  const ::qdrant::PointId& id() const;
  [[nodiscard]] ::qdrant::PointId* PROTOBUF_NULLABLE release_id();
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_id();
  void set_allocated_id(::qdrant::PointId* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_id(::qdrant::PointId* PROTOBUF_NULLABLE value);
  ::qdrant::PointId* PROTOBUF_NULLABLE unsafe_arena_release_id();

  private:
  const ::qdrant::PointId& _internal_id() const;
  ::qdrant::PointId* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // .qdrant.Vector vector = 2;
  bool has_vector() const;
  private:
  bool _internal_has_vector() const;

  public:
  void clear_vector() ;
  const ::qdrant::Vector& vector() const;
  [[nodiscard]] ::qdrant::Vector* PROTOBUF_NULLABLE release_vector();
  ::qdrant::Vector* PROTOBUF_NONNULL mutable_vector();
  void set_allocated_vector(::qdrant::Vector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vector(::qdrant::Vector* PROTOBUF_NULLABLE value);
  ::qdrant::Vector* PROTOBUF_NULLABLE unsafe_arena_release_vector();

  private:
  const ::qdrant::Vector& _internal_vector() const;
  ::qdrant::Vector* PROTOBUF_NONNULL _internal_mutable_vector();

  public:
  void clear_example();
  ExampleCase example_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.VectorExample)
 private:
  class _Internal;
  void set_has_id();
  void set_has_vector();
  inline bool has_example() const;
  inline void clear_has_example();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const VectorExample& from_msg);
    union ExampleUnion {
      constexpr ExampleUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::qdrant::PointId* PROTOBUF_NULLABLE id_;
      ::qdrant::Vector* PROTOBUF_NULLABLE vector_;
    } example_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull VectorExample_class_data_;
// -------------------------------------------------------------------

class UpdateBatchResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.UpdateBatchResponse) */ {
 public:
  inline UpdateBatchResponse() : UpdateBatchResponse(nullptr) {}
  ~UpdateBatchResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateBatchResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateBatchResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateBatchResponse(::google::protobuf::internal::ConstantInitialized);

  inline UpdateBatchResponse(const UpdateBatchResponse& from) : UpdateBatchResponse(nullptr, from) {}
  inline UpdateBatchResponse(UpdateBatchResponse&& from) noexcept
      : UpdateBatchResponse(nullptr, ::std::move(from)) {}
  inline UpdateBatchResponse& operator=(const UpdateBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateBatchResponse& operator=(UpdateBatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateBatchResponse& default_instance() {
    return *reinterpret_cast<const UpdateBatchResponse*>(
        &_UpdateBatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 125;
  friend void swap(UpdateBatchResponse& a, UpdateBatchResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateBatchResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateBatchResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateBatchResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateBatchResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateBatchResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateBatchResponse& from) { UpdateBatchResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateBatchResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.UpdateBatchResponse"; }

  explicit UpdateBatchResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateBatchResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateBatchResponse& from);
  UpdateBatchResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateBatchResponse&& from) noexcept
      : UpdateBatchResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // repeated .qdrant.UpdateResult result = 1;
  int result_size() const;
  private:
  int _internal_result_size() const;

  public:
  void clear_result() ;
  ::qdrant::UpdateResult* PROTOBUF_NONNULL mutable_result(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::UpdateResult>* PROTOBUF_NONNULL mutable_result();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::UpdateResult>& _internal_result() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::UpdateResult>* PROTOBUF_NONNULL _internal_mutable_result();
  public:
  const ::qdrant::UpdateResult& result(int index) const;
  ::qdrant::UpdateResult* PROTOBUF_NONNULL add_result();
  const ::google::protobuf::RepeatedPtrField<::qdrant::UpdateResult>& result() const;
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.UpdateBatchResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateBatchResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::UpdateResult > result_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateBatchResponse_class_data_;
// -------------------------------------------------------------------

class SearchMatrixPairsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SearchMatrixPairsResponse) */ {
 public:
  inline SearchMatrixPairsResponse() : SearchMatrixPairsResponse(nullptr) {}
  ~SearchMatrixPairsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SearchMatrixPairsResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SearchMatrixPairsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SearchMatrixPairsResponse(::google::protobuf::internal::ConstantInitialized);

  inline SearchMatrixPairsResponse(const SearchMatrixPairsResponse& from) : SearchMatrixPairsResponse(nullptr, from) {}
  inline SearchMatrixPairsResponse(SearchMatrixPairsResponse&& from) noexcept
      : SearchMatrixPairsResponse(nullptr, ::std::move(from)) {}
  inline SearchMatrixPairsResponse& operator=(const SearchMatrixPairsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchMatrixPairsResponse& operator=(SearchMatrixPairsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchMatrixPairsResponse& default_instance() {
    return *reinterpret_cast<const SearchMatrixPairsResponse*>(
        &_SearchMatrixPairsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 127;
  friend void swap(SearchMatrixPairsResponse& a, SearchMatrixPairsResponse& b) { a.Swap(&b); }
  inline void Swap(SearchMatrixPairsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchMatrixPairsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchMatrixPairsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SearchMatrixPairsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchMatrixPairsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SearchMatrixPairsResponse& from) { SearchMatrixPairsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SearchMatrixPairsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SearchMatrixPairsResponse"; }

  explicit SearchMatrixPairsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SearchMatrixPairsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SearchMatrixPairsResponse& from);
  SearchMatrixPairsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SearchMatrixPairsResponse&& from) noexcept
      : SearchMatrixPairsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // .qdrant.SearchMatrixPairs result = 1;
  bool has_result() const;
  void clear_result() ;
  const ::qdrant::SearchMatrixPairs& result() const;
  [[nodiscard]] ::qdrant::SearchMatrixPairs* PROTOBUF_NULLABLE release_result();
  ::qdrant::SearchMatrixPairs* PROTOBUF_NONNULL mutable_result();
  void set_allocated_result(::qdrant::SearchMatrixPairs* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_result(::qdrant::SearchMatrixPairs* PROTOBUF_NULLABLE value);
  ::qdrant::SearchMatrixPairs* PROTOBUF_NULLABLE unsafe_arena_release_result();

  private:
  const ::qdrant::SearchMatrixPairs& _internal_result() const;
  ::qdrant::SearchMatrixPairs* PROTOBUF_NONNULL _internal_mutable_result();

  public:
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SearchMatrixPairsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SearchMatrixPairsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::SearchMatrixPairs* PROTOBUF_NULLABLE result_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SearchMatrixPairsResponse_class_data_;
// -------------------------------------------------------------------

class SearchMatrixOffsetsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SearchMatrixOffsetsResponse) */ {
 public:
  inline SearchMatrixOffsetsResponse() : SearchMatrixOffsetsResponse(nullptr) {}
  ~SearchMatrixOffsetsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SearchMatrixOffsetsResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SearchMatrixOffsetsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SearchMatrixOffsetsResponse(::google::protobuf::internal::ConstantInitialized);

  inline SearchMatrixOffsetsResponse(const SearchMatrixOffsetsResponse& from) : SearchMatrixOffsetsResponse(nullptr, from) {}
  inline SearchMatrixOffsetsResponse(SearchMatrixOffsetsResponse&& from) noexcept
      : SearchMatrixOffsetsResponse(nullptr, ::std::move(from)) {}
  inline SearchMatrixOffsetsResponse& operator=(const SearchMatrixOffsetsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchMatrixOffsetsResponse& operator=(SearchMatrixOffsetsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchMatrixOffsetsResponse& default_instance() {
    return *reinterpret_cast<const SearchMatrixOffsetsResponse*>(
        &_SearchMatrixOffsetsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 128;
  friend void swap(SearchMatrixOffsetsResponse& a, SearchMatrixOffsetsResponse& b) { a.Swap(&b); }
  inline void Swap(SearchMatrixOffsetsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchMatrixOffsetsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchMatrixOffsetsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SearchMatrixOffsetsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchMatrixOffsetsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SearchMatrixOffsetsResponse& from) { SearchMatrixOffsetsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SearchMatrixOffsetsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SearchMatrixOffsetsResponse"; }

  explicit SearchMatrixOffsetsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SearchMatrixOffsetsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SearchMatrixOffsetsResponse& from);
  SearchMatrixOffsetsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SearchMatrixOffsetsResponse&& from) noexcept
      : SearchMatrixOffsetsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // .qdrant.SearchMatrixOffsets result = 1;
  bool has_result() const;
  void clear_result() ;
  const ::qdrant::SearchMatrixOffsets& result() const;
  [[nodiscard]] ::qdrant::SearchMatrixOffsets* PROTOBUF_NULLABLE release_result();
  ::qdrant::SearchMatrixOffsets* PROTOBUF_NONNULL mutable_result();
  void set_allocated_result(::qdrant::SearchMatrixOffsets* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_result(::qdrant::SearchMatrixOffsets* PROTOBUF_NULLABLE value);
  ::qdrant::SearchMatrixOffsets* PROTOBUF_NULLABLE unsafe_arena_release_result();

  private:
  const ::qdrant::SearchMatrixOffsets& _internal_result() const;
  ::qdrant::SearchMatrixOffsets* PROTOBUF_NONNULL _internal_mutable_result();

  public:
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SearchMatrixOffsetsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SearchMatrixOffsetsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::SearchMatrixOffsets* PROTOBUF_NULLABLE result_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SearchMatrixOffsetsResponse_class_data_;
// -------------------------------------------------------------------

class RecommendInput final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.RecommendInput) */ {
 public:
  inline RecommendInput() : RecommendInput(nullptr) {}
  ~RecommendInput() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RecommendInput* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RecommendInput));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RecommendInput(::google::protobuf::internal::ConstantInitialized);

  inline RecommendInput(const RecommendInput& from) : RecommendInput(nullptr, from) {}
  inline RecommendInput(RecommendInput&& from) noexcept
      : RecommendInput(nullptr, ::std::move(from)) {}
  inline RecommendInput& operator=(const RecommendInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecommendInput& operator=(RecommendInput&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecommendInput& default_instance() {
    return *reinterpret_cast<const RecommendInput*>(
        &_RecommendInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 59;
  friend void swap(RecommendInput& a, RecommendInput& b) { a.Swap(&b); }
  inline void Swap(RecommendInput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecommendInput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecommendInput* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RecommendInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecommendInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RecommendInput& from) { RecommendInput::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RecommendInput* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.RecommendInput"; }

  explicit RecommendInput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RecommendInput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RecommendInput& from);
  RecommendInput(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RecommendInput&& from) noexcept
      : RecommendInput(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositiveFieldNumber = 1,
    kNegativeFieldNumber = 2,
    kStrategyFieldNumber = 3,
  };
  // repeated .qdrant.VectorInput positive = 1;
  int positive_size() const;
  private:
  int _internal_positive_size() const;

  public:
  void clear_positive() ;
  ::qdrant::VectorInput* PROTOBUF_NONNULL mutable_positive(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::VectorInput>* PROTOBUF_NONNULL mutable_positive();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::VectorInput>& _internal_positive() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::VectorInput>* PROTOBUF_NONNULL _internal_mutable_positive();
  public:
  const ::qdrant::VectorInput& positive(int index) const;
  ::qdrant::VectorInput* PROTOBUF_NONNULL add_positive();
  const ::google::protobuf::RepeatedPtrField<::qdrant::VectorInput>& positive() const;
  // repeated .qdrant.VectorInput negative = 2;
  int negative_size() const;
  private:
  int _internal_negative_size() const;

  public:
  void clear_negative() ;
  ::qdrant::VectorInput* PROTOBUF_NONNULL mutable_negative(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::VectorInput>* PROTOBUF_NONNULL mutable_negative();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::VectorInput>& _internal_negative() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::VectorInput>* PROTOBUF_NONNULL _internal_mutable_negative();
  public:
  const ::qdrant::VectorInput& negative(int index) const;
  ::qdrant::VectorInput* PROTOBUF_NONNULL add_negative();
  const ::google::protobuf::RepeatedPtrField<::qdrant::VectorInput>& negative() const;
  // optional .qdrant.RecommendStrategy strategy = 3;
  bool has_strategy() const;
  void clear_strategy() ;
  ::qdrant::RecommendStrategy strategy() const;
  void set_strategy(::qdrant::RecommendStrategy value);

  private:
  ::qdrant::RecommendStrategy _internal_strategy() const;
  void _internal_set_strategy(::qdrant::RecommendStrategy value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.RecommendInput)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RecommendInput& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::VectorInput > positive_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::VectorInput > negative_;
    int strategy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RecommendInput_class_data_;
// -------------------------------------------------------------------

class PointsOperationResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PointsOperationResponse) */ {
 public:
  inline PointsOperationResponse() : PointsOperationResponse(nullptr) {}
  ~PointsOperationResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointsOperationResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointsOperationResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointsOperationResponse(::google::protobuf::internal::ConstantInitialized);

  inline PointsOperationResponse(const PointsOperationResponse& from) : PointsOperationResponse(nullptr, from) {}
  inline PointsOperationResponse(PointsOperationResponse&& from) noexcept
      : PointsOperationResponse(nullptr, ::std::move(from)) {}
  inline PointsOperationResponse& operator=(const PointsOperationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointsOperationResponse& operator=(PointsOperationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointsOperationResponse& default_instance() {
    return *reinterpret_cast<const PointsOperationResponse*>(
        &_PointsOperationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 99;
  friend void swap(PointsOperationResponse& a, PointsOperationResponse& b) { a.Swap(&b); }
  inline void Swap(PointsOperationResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointsOperationResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointsOperationResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointsOperationResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointsOperationResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointsOperationResponse& from) { PointsOperationResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointsOperationResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PointsOperationResponse"; }

  explicit PointsOperationResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointsOperationResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointsOperationResponse& from);
  PointsOperationResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointsOperationResponse&& from) noexcept
      : PointsOperationResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // .qdrant.UpdateResult result = 1;
  bool has_result() const;
  void clear_result() ;
  const ::qdrant::UpdateResult& result() const;
  [[nodiscard]] ::qdrant::UpdateResult* PROTOBUF_NULLABLE release_result();
  ::qdrant::UpdateResult* PROTOBUF_NONNULL mutable_result();
  void set_allocated_result(::qdrant::UpdateResult* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_result(::qdrant::UpdateResult* PROTOBUF_NULLABLE value);
  ::qdrant::UpdateResult* PROTOBUF_NULLABLE unsafe_arena_release_result();

  private:
  const ::qdrant::UpdateResult& _internal_result() const;
  ::qdrant::UpdateResult* PROTOBUF_NONNULL _internal_mutable_result();

  public:
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.PointsOperationResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointsOperationResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::UpdateResult* PROTOBUF_NULLABLE result_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointsOperationResponse_class_data_;
// -------------------------------------------------------------------

class NearestInputWithMmr final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.NearestInputWithMmr) */ {
 public:
  inline NearestInputWithMmr() : NearestInputWithMmr(nullptr) {}
  ~NearestInputWithMmr() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NearestInputWithMmr* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NearestInputWithMmr));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NearestInputWithMmr(::google::protobuf::internal::ConstantInitialized);

  inline NearestInputWithMmr(const NearestInputWithMmr& from) : NearestInputWithMmr(nullptr, from) {}
  inline NearestInputWithMmr(NearestInputWithMmr&& from) noexcept
      : NearestInputWithMmr(nullptr, ::std::move(from)) {}
  inline NearestInputWithMmr& operator=(const NearestInputWithMmr& from) {
    CopyFrom(from);
    return *this;
  }
  inline NearestInputWithMmr& operator=(NearestInputWithMmr&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NearestInputWithMmr& default_instance() {
    return *reinterpret_cast<const NearestInputWithMmr*>(
        &_NearestInputWithMmr_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 72;
  friend void swap(NearestInputWithMmr& a, NearestInputWithMmr& b) { a.Swap(&b); }
  inline void Swap(NearestInputWithMmr* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NearestInputWithMmr* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NearestInputWithMmr* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NearestInputWithMmr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NearestInputWithMmr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NearestInputWithMmr& from) { NearestInputWithMmr::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NearestInputWithMmr* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.NearestInputWithMmr"; }

  explicit NearestInputWithMmr(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NearestInputWithMmr(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NearestInputWithMmr& from);
  NearestInputWithMmr(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NearestInputWithMmr&& from) noexcept
      : NearestInputWithMmr(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNearestFieldNumber = 1,
    kMmrFieldNumber = 2,
  };
  // .qdrant.VectorInput nearest = 1;
  bool has_nearest() const;
  void clear_nearest() ;
  const ::qdrant::VectorInput& nearest() const;
  [[nodiscard]] ::qdrant::VectorInput* PROTOBUF_NULLABLE release_nearest();
  ::qdrant::VectorInput* PROTOBUF_NONNULL mutable_nearest();
  void set_allocated_nearest(::qdrant::VectorInput* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_nearest(::qdrant::VectorInput* PROTOBUF_NULLABLE value);
  ::qdrant::VectorInput* PROTOBUF_NULLABLE unsafe_arena_release_nearest();

  private:
  const ::qdrant::VectorInput& _internal_nearest() const;
  ::qdrant::VectorInput* PROTOBUF_NONNULL _internal_mutable_nearest();

  public:
  // .qdrant.Mmr mmr = 2;
  bool has_mmr() const;
  void clear_mmr() ;
  const ::qdrant::Mmr& mmr() const;
  [[nodiscard]] ::qdrant::Mmr* PROTOBUF_NULLABLE release_mmr();
  ::qdrant::Mmr* PROTOBUF_NONNULL mutable_mmr();
  void set_allocated_mmr(::qdrant::Mmr* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_mmr(::qdrant::Mmr* PROTOBUF_NULLABLE value);
  ::qdrant::Mmr* PROTOBUF_NULLABLE unsafe_arena_release_mmr();

  private:
  const ::qdrant::Mmr& _internal_mmr() const;
  ::qdrant::Mmr* PROTOBUF_NONNULL _internal_mutable_mmr();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.NearestInputWithMmr)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NearestInputWithMmr& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::VectorInput* PROTOBUF_NULLABLE nearest_;
    ::qdrant::Mmr* PROTOBUF_NULLABLE mmr_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NearestInputWithMmr_class_data_;
// -------------------------------------------------------------------

class NamedVectorsOutput final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.NamedVectorsOutput) */ {
 public:
  inline NamedVectorsOutput() : NamedVectorsOutput(nullptr) {}
  ~NamedVectorsOutput() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NamedVectorsOutput* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NamedVectorsOutput));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NamedVectorsOutput(::google::protobuf::internal::ConstantInitialized);

  inline NamedVectorsOutput(const NamedVectorsOutput& from) : NamedVectorsOutput(nullptr, from) {}
  inline NamedVectorsOutput(NamedVectorsOutput&& from) noexcept
      : NamedVectorsOutput(nullptr, ::std::move(from)) {}
  inline NamedVectorsOutput& operator=(const NamedVectorsOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedVectorsOutput& operator=(NamedVectorsOutput&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedVectorsOutput& default_instance() {
    return *reinterpret_cast<const NamedVectorsOutput*>(
        &_NamedVectorsOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(NamedVectorsOutput& a, NamedVectorsOutput& b) { a.Swap(&b); }
  inline void Swap(NamedVectorsOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedVectorsOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedVectorsOutput* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NamedVectorsOutput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NamedVectorsOutput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NamedVectorsOutput& from) { NamedVectorsOutput::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NamedVectorsOutput* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.NamedVectorsOutput"; }

  explicit NamedVectorsOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NamedVectorsOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NamedVectorsOutput& from);
  NamedVectorsOutput(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NamedVectorsOutput&& from) noexcept
      : NamedVectorsOutput(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVectorsFieldNumber = 1,
  };
  // map<string, .qdrant.VectorOutput> vectors = 1;
  int vectors_size() const;
  private:
  int _internal_vectors_size() const;

  public:
  void clear_vectors() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::VectorOutput>& vectors() const;
  ::google::protobuf::Map<::std::string, ::qdrant::VectorOutput>* PROTOBUF_NONNULL mutable_vectors();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::VectorOutput>& _internal_vectors() const;
  ::google::protobuf::Map<::std::string, ::qdrant::VectorOutput>* PROTOBUF_NONNULL _internal_mutable_vectors();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.NamedVectorsOutput)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   2, 41,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NamedVectorsOutput& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<NamedVectorsOutput_VectorsEntry_DoNotUse, ::std::string, ::qdrant::VectorOutput,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        vectors_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NamedVectorsOutput_class_data_;
// -------------------------------------------------------------------

class NamedVectors_VectorsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  NamedVectors_VectorsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NamedVectors_VectorsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit NamedVectors_VectorsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_NamedVectors_VectorsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_points_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 44,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull NamedVectors_VectorsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class FacetResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.FacetResponse) */ {
 public:
  inline FacetResponse() : FacetResponse(nullptr) {}
  ~FacetResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FacetResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FacetResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FacetResponse(::google::protobuf::internal::ConstantInitialized);

  inline FacetResponse(const FacetResponse& from) : FacetResponse(nullptr, from) {}
  inline FacetResponse(FacetResponse&& from) noexcept
      : FacetResponse(nullptr, ::std::move(from)) {}
  inline FacetResponse& operator=(const FacetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FacetResponse& operator=(FacetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FacetResponse& default_instance() {
    return *reinterpret_cast<const FacetResponse*>(
        &_FacetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 126;
  friend void swap(FacetResponse& a, FacetResponse& b) { a.Swap(&b); }
  inline void Swap(FacetResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FacetResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FacetResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FacetResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FacetResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FacetResponse& from) { FacetResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FacetResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.FacetResponse"; }

  explicit FacetResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FacetResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FacetResponse& from);
  FacetResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FacetResponse&& from) noexcept
      : FacetResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHitsFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // repeated .qdrant.FacetHit hits = 1;
  int hits_size() const;
  private:
  int _internal_hits_size() const;

  public:
  void clear_hits() ;
  ::qdrant::FacetHit* PROTOBUF_NONNULL mutable_hits(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::FacetHit>* PROTOBUF_NONNULL mutable_hits();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::FacetHit>& _internal_hits() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::FacetHit>* PROTOBUF_NONNULL _internal_mutable_hits();
  public:
  const ::qdrant::FacetHit& hits(int index) const;
  ::qdrant::FacetHit* PROTOBUF_NONNULL add_hits();
  const ::google::protobuf::RepeatedPtrField<::qdrant::FacetHit>& hits() const;
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.FacetResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FacetResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::FacetHit > hits_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FacetResponse_class_data_;
// -------------------------------------------------------------------

class CreateFieldIndexCollection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CreateFieldIndexCollection) */ {
 public:
  inline CreateFieldIndexCollection() : CreateFieldIndexCollection(nullptr) {}
  ~CreateFieldIndexCollection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateFieldIndexCollection* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateFieldIndexCollection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateFieldIndexCollection(::google::protobuf::internal::ConstantInitialized);

  inline CreateFieldIndexCollection(const CreateFieldIndexCollection& from) : CreateFieldIndexCollection(nullptr, from) {}
  inline CreateFieldIndexCollection(CreateFieldIndexCollection&& from) noexcept
      : CreateFieldIndexCollection(nullptr, ::std::move(from)) {}
  inline CreateFieldIndexCollection& operator=(const CreateFieldIndexCollection& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateFieldIndexCollection& operator=(CreateFieldIndexCollection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateFieldIndexCollection& default_instance() {
    return *reinterpret_cast<const CreateFieldIndexCollection*>(
        &_CreateFieldIndexCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(CreateFieldIndexCollection& a, CreateFieldIndexCollection& b) { a.Swap(&b); }
  inline void Swap(CreateFieldIndexCollection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateFieldIndexCollection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateFieldIndexCollection* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateFieldIndexCollection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateFieldIndexCollection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateFieldIndexCollection& from) { CreateFieldIndexCollection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateFieldIndexCollection* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CreateFieldIndexCollection"; }

  explicit CreateFieldIndexCollection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CreateFieldIndexCollection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CreateFieldIndexCollection& from);
  CreateFieldIndexCollection(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CreateFieldIndexCollection&& from) noexcept
      : CreateFieldIndexCollection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kFieldNameFieldNumber = 3,
    kFieldIndexParamsFieldNumber = 5,
    kOrderingFieldNumber = 6,
    kWaitFieldNumber = 2,
    kFieldTypeFieldNumber = 4,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // string field_name = 3;
  void clear_field_name() ;
  const ::std::string& field_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_field_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_field_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_field_name();
  void set_allocated_field_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_field_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_field_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_field_name();

  public:
  // optional .qdrant.PayloadIndexParams field_index_params = 5;
  bool has_field_index_params() const;
  void clear_field_index_params() ;
  const ::qdrant::PayloadIndexParams& field_index_params() const;
  [[nodiscard]] ::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE release_field_index_params();
  ::qdrant::PayloadIndexParams* PROTOBUF_NONNULL mutable_field_index_params();
  void set_allocated_field_index_params(::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_field_index_params(::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE value);
  ::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE unsafe_arena_release_field_index_params();

  private:
  const ::qdrant::PayloadIndexParams& _internal_field_index_params() const;
  ::qdrant::PayloadIndexParams* PROTOBUF_NONNULL _internal_mutable_field_index_params();

  public:
  // optional .qdrant.WriteOrdering ordering = 6;
  bool has_ordering() const;
  void clear_ordering() ;
  const ::qdrant::WriteOrdering& ordering() const;
  [[nodiscard]] ::qdrant::WriteOrdering* PROTOBUF_NULLABLE release_ordering();
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL mutable_ordering();
  void set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  ::qdrant::WriteOrdering* PROTOBUF_NULLABLE unsafe_arena_release_ordering();

  private:
  const ::qdrant::WriteOrdering& _internal_ordering() const;
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL _internal_mutable_ordering();

  public:
  // optional bool wait = 2;
  bool has_wait() const;
  void clear_wait() ;
  bool wait() const;
  void set_wait(bool value);

  private:
  bool _internal_wait() const;
  void _internal_set_wait(bool value);

  public:
  // optional .qdrant.FieldType field_type = 4;
  bool has_field_type() const;
  void clear_field_type() ;
  ::qdrant::FieldType field_type() const;
  void set_field_type(::qdrant::FieldType value);

  private:
  ::qdrant::FieldType _internal_field_type() const;
  void _internal_set_field_type(::qdrant::FieldType value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CreateFieldIndexCollection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   2, 67,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CreateFieldIndexCollection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::google::protobuf::internal::ArenaStringPtr field_name_;
    ::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE field_index_params_;
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE ordering_;
    bool wait_;
    int field_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CreateFieldIndexCollection_class_data_;
// -------------------------------------------------------------------

class CountResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CountResponse) */ {
 public:
  inline CountResponse() : CountResponse(nullptr) {}
  ~CountResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CountResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CountResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CountResponse(::google::protobuf::internal::ConstantInitialized);

  inline CountResponse(const CountResponse& from) : CountResponse(nullptr, from) {}
  inline CountResponse(CountResponse&& from) noexcept
      : CountResponse(nullptr, ::std::move(from)) {}
  inline CountResponse& operator=(const CountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CountResponse& operator=(CountResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CountResponse& default_instance() {
    return *reinterpret_cast<const CountResponse*>(
        &_CountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 114;
  friend void swap(CountResponse& a, CountResponse& b) { a.Swap(&b); }
  inline void Swap(CountResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CountResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CountResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CountResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CountResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CountResponse& from) { CountResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CountResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CountResponse"; }

  explicit CountResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CountResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CountResponse& from);
  CountResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CountResponse&& from) noexcept
      : CountResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // .qdrant.CountResult result = 1;
  bool has_result() const;
  void clear_result() ;
  const ::qdrant::CountResult& result() const;
  [[nodiscard]] ::qdrant::CountResult* PROTOBUF_NULLABLE release_result();
  ::qdrant::CountResult* PROTOBUF_NONNULL mutable_result();
  void set_allocated_result(::qdrant::CountResult* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_result(::qdrant::CountResult* PROTOBUF_NULLABLE value);
  ::qdrant::CountResult* PROTOBUF_NULLABLE unsafe_arena_release_result();

  private:
  const ::qdrant::CountResult& _internal_result() const;
  ::qdrant::CountResult* PROTOBUF_NONNULL _internal_mutable_result();

  public:
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CountResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CountResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::CountResult* PROTOBUF_NULLABLE result_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CountResponse_class_data_;
// -------------------------------------------------------------------

class ContextInputPair final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ContextInputPair) */ {
 public:
  inline ContextInputPair() : ContextInputPair(nullptr) {}
  ~ContextInputPair() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ContextInputPair* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ContextInputPair));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContextInputPair(::google::protobuf::internal::ConstantInitialized);

  inline ContextInputPair(const ContextInputPair& from) : ContextInputPair(nullptr, from) {}
  inline ContextInputPair(ContextInputPair&& from) noexcept
      : ContextInputPair(nullptr, ::std::move(from)) {}
  inline ContextInputPair& operator=(const ContextInputPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContextInputPair& operator=(ContextInputPair&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContextInputPair& default_instance() {
    return *reinterpret_cast<const ContextInputPair*>(
        &_ContextInputPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 60;
  friend void swap(ContextInputPair& a, ContextInputPair& b) { a.Swap(&b); }
  inline void Swap(ContextInputPair* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContextInputPair* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContextInputPair* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ContextInputPair>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ContextInputPair& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ContextInputPair& from) { ContextInputPair::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ContextInputPair* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ContextInputPair"; }

  explicit ContextInputPair(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ContextInputPair(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ContextInputPair& from);
  ContextInputPair(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ContextInputPair&& from) noexcept
      : ContextInputPair(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositiveFieldNumber = 1,
    kNegativeFieldNumber = 2,
  };
  // .qdrant.VectorInput positive = 1;
  bool has_positive() const;
  void clear_positive() ;
  const ::qdrant::VectorInput& positive() const;
  [[nodiscard]] ::qdrant::VectorInput* PROTOBUF_NULLABLE release_positive();
  ::qdrant::VectorInput* PROTOBUF_NONNULL mutable_positive();
  void set_allocated_positive(::qdrant::VectorInput* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_positive(::qdrant::VectorInput* PROTOBUF_NULLABLE value);
  ::qdrant::VectorInput* PROTOBUF_NULLABLE unsafe_arena_release_positive();

  private:
  const ::qdrant::VectorInput& _internal_positive() const;
  ::qdrant::VectorInput* PROTOBUF_NONNULL _internal_mutable_positive();

  public:
  // .qdrant.VectorInput negative = 2;
  bool has_negative() const;
  void clear_negative() ;
  const ::qdrant::VectorInput& negative() const;
  [[nodiscard]] ::qdrant::VectorInput* PROTOBUF_NULLABLE release_negative();
  ::qdrant::VectorInput* PROTOBUF_NONNULL mutable_negative();
  void set_allocated_negative(::qdrant::VectorInput* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_negative(::qdrant::VectorInput* PROTOBUF_NULLABLE value);
  ::qdrant::VectorInput* PROTOBUF_NULLABLE unsafe_arena_release_negative();

  private:
  const ::qdrant::VectorInput& _internal_negative() const;
  ::qdrant::VectorInput* PROTOBUF_NONNULL _internal_mutable_negative();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.ContextInputPair)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ContextInputPair& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::VectorInput* PROTOBUF_NULLABLE positive_;
    ::qdrant::VectorInput* PROTOBUF_NULLABLE negative_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ContextInputPair_class_data_;
// -------------------------------------------------------------------

class Condition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.Condition) */ {
 public:
  inline Condition() : Condition(nullptr) {}
  ~Condition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Condition* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Condition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Condition(::google::protobuf::internal::ConstantInitialized);

  inline Condition(const Condition& from) : Condition(nullptr, from) {}
  inline Condition(Condition&& from) noexcept
      : Condition(nullptr, ::std::move(from)) {}
  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition& operator=(Condition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Condition& default_instance() {
    return *reinterpret_cast<const Condition*>(
        &_Condition_default_instance_);
  }
  enum ConditionOneOfCase {
    kField = 1,
    kIsEmpty = 2,
    kHasId = 3,
    kFilter = 4,
    kIsNull = 5,
    kNested = 6,
    kHasVector = 7,
    CONDITION_ONE_OF_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 131;
  friend void swap(Condition& a, Condition& b) { a.Swap(&b); }
  inline void Swap(Condition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Condition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Condition* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Condition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Condition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Condition& from) { Condition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Condition* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.Condition"; }

  explicit Condition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Condition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Condition& from);
  Condition(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Condition&& from) noexcept
      : Condition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFieldFieldNumber = 1,
    kIsEmptyFieldNumber = 2,
    kHasIdFieldNumber = 3,
    kFilterFieldNumber = 4,
    kIsNullFieldNumber = 5,
    kNestedFieldNumber = 6,
    kHasVectorFieldNumber = 7,
  };
  // .qdrant.FieldCondition field = 1;
  bool has_field() const;
  private:
  bool _internal_has_field() const;

  public:
  void clear_field() ;
  const ::qdrant::FieldCondition& field() const;
  [[nodiscard]] ::qdrant::FieldCondition* PROTOBUF_NULLABLE release_field();
  ::qdrant::FieldCondition* PROTOBUF_NONNULL mutable_field();
  void set_allocated_field(::qdrant::FieldCondition* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_field(::qdrant::FieldCondition* PROTOBUF_NULLABLE value);
  ::qdrant::FieldCondition* PROTOBUF_NULLABLE unsafe_arena_release_field();

  private:
  const ::qdrant::FieldCondition& _internal_field() const;
  ::qdrant::FieldCondition* PROTOBUF_NONNULL _internal_mutable_field();

  public:
  // .qdrant.IsEmptyCondition is_empty = 2;
  bool has_is_empty() const;
  private:
  bool _internal_has_is_empty() const;

  public:
  void clear_is_empty() ;
  const ::qdrant::IsEmptyCondition& is_empty() const;
  [[nodiscard]] ::qdrant::IsEmptyCondition* PROTOBUF_NULLABLE release_is_empty();
  ::qdrant::IsEmptyCondition* PROTOBUF_NONNULL mutable_is_empty();
  void set_allocated_is_empty(::qdrant::IsEmptyCondition* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_is_empty(::qdrant::IsEmptyCondition* PROTOBUF_NULLABLE value);
  ::qdrant::IsEmptyCondition* PROTOBUF_NULLABLE unsafe_arena_release_is_empty();

  private:
  const ::qdrant::IsEmptyCondition& _internal_is_empty() const;
  ::qdrant::IsEmptyCondition* PROTOBUF_NONNULL _internal_mutable_is_empty();

  public:
  // .qdrant.HasIdCondition has_id = 3;
  bool has_has_id() const;
  private:
  bool _internal_has_has_id() const;

  public:
  void clear_has_id() ;
  const ::qdrant::HasIdCondition& has_id() const;
  [[nodiscard]] ::qdrant::HasIdCondition* PROTOBUF_NULLABLE release_has_id();
  ::qdrant::HasIdCondition* PROTOBUF_NONNULL mutable_has_id();
  void set_allocated_has_id(::qdrant::HasIdCondition* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_has_id(::qdrant::HasIdCondition* PROTOBUF_NULLABLE value);
  ::qdrant::HasIdCondition* PROTOBUF_NULLABLE unsafe_arena_release_has_id();

  private:
  const ::qdrant::HasIdCondition& _internal_has_id() const;
  ::qdrant::HasIdCondition* PROTOBUF_NONNULL _internal_mutable_has_id();

  public:
  // .qdrant.Filter filter = 4;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;

  public:
  void clear_filter() ;
  const ::qdrant::Filter& filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_filter();
  void set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_filter();

  private:
  const ::qdrant::Filter& _internal_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_filter();

  public:
  // .qdrant.IsNullCondition is_null = 5;
  bool has_is_null() const;
  private:
  bool _internal_has_is_null() const;

  public:
  void clear_is_null() ;
  const ::qdrant::IsNullCondition& is_null() const;
  [[nodiscard]] ::qdrant::IsNullCondition* PROTOBUF_NULLABLE release_is_null();
  ::qdrant::IsNullCondition* PROTOBUF_NONNULL mutable_is_null();
  void set_allocated_is_null(::qdrant::IsNullCondition* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_is_null(::qdrant::IsNullCondition* PROTOBUF_NULLABLE value);
  ::qdrant::IsNullCondition* PROTOBUF_NULLABLE unsafe_arena_release_is_null();

  private:
  const ::qdrant::IsNullCondition& _internal_is_null() const;
  ::qdrant::IsNullCondition* PROTOBUF_NONNULL _internal_mutable_is_null();

  public:
  // .qdrant.NestedCondition nested = 6;
  bool has_nested() const;
  private:
  bool _internal_has_nested() const;

  public:
  void clear_nested() ;
  const ::qdrant::NestedCondition& nested() const;
  [[nodiscard]] ::qdrant::NestedCondition* PROTOBUF_NULLABLE release_nested();
  ::qdrant::NestedCondition* PROTOBUF_NONNULL mutable_nested();
  void set_allocated_nested(::qdrant::NestedCondition* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_nested(::qdrant::NestedCondition* PROTOBUF_NULLABLE value);
  ::qdrant::NestedCondition* PROTOBUF_NULLABLE unsafe_arena_release_nested();

  private:
  const ::qdrant::NestedCondition& _internal_nested() const;
  ::qdrant::NestedCondition* PROTOBUF_NONNULL _internal_mutable_nested();

  public:
  // .qdrant.HasVectorCondition has_vector = 7;
  bool has_has_vector() const;
  private:
  bool _internal_has_has_vector() const;

  public:
  void clear_has_vector() ;
  const ::qdrant::HasVectorCondition& has_vector() const;
  [[nodiscard]] ::qdrant::HasVectorCondition* PROTOBUF_NULLABLE release_has_vector();
  ::qdrant::HasVectorCondition* PROTOBUF_NONNULL mutable_has_vector();
  void set_allocated_has_vector(::qdrant::HasVectorCondition* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_has_vector(::qdrant::HasVectorCondition* PROTOBUF_NULLABLE value);
  ::qdrant::HasVectorCondition* PROTOBUF_NULLABLE unsafe_arena_release_has_vector();

  private:
  const ::qdrant::HasVectorCondition& _internal_has_vector() const;
  ::qdrant::HasVectorCondition* PROTOBUF_NONNULL _internal_mutable_has_vector();

  public:
  void clear_condition_one_of();
  ConditionOneOfCase condition_one_of_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.Condition)
 private:
  class _Internal;
  void set_has_field();
  void set_has_is_empty();
  void set_has_has_id();
  void set_has_filter();
  void set_has_is_null();
  void set_has_nested();
  void set_has_has_vector();
  inline bool has_condition_one_of() const;
  inline void clear_has_condition_one_of();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 7,
                                   7, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Condition& from_msg);
    union ConditionOneOfUnion {
      constexpr ConditionOneOfUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE field_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE is_empty_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE has_id_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE filter_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE is_null_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE nested_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE has_vector_;
    } condition_one_of_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Condition_class_data_;
// -------------------------------------------------------------------

class Filter final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.Filter) */ {
 public:
  inline Filter() : Filter(nullptr) {}
  ~Filter() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Filter* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Filter));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Filter(::google::protobuf::internal::ConstantInitialized);

  inline Filter(const Filter& from) : Filter(nullptr, from) {}
  inline Filter(Filter&& from) noexcept
      : Filter(nullptr, ::std::move(from)) {}
  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filter& operator=(Filter&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Filter& default_instance() {
    return *reinterpret_cast<const Filter*>(
        &_Filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 129;
  friend void swap(Filter& a, Filter& b) { a.Swap(&b); }
  inline void Swap(Filter* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filter* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Filter* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Filter>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Filter& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Filter& from) { Filter::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Filter* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.Filter"; }

  explicit Filter(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Filter(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Filter& from);
  Filter(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Filter&& from) noexcept
      : Filter(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kShouldFieldNumber = 1,
    kMustFieldNumber = 2,
    kMustNotFieldNumber = 3,
    kMinShouldFieldNumber = 4,
  };
  // repeated .qdrant.Condition should = 1;
  int should_size() const;
  private:
  int _internal_should_size() const;

  public:
  void clear_should() ;
  ::qdrant::Condition* PROTOBUF_NONNULL mutable_should(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::Condition>* PROTOBUF_NONNULL mutable_should();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::Condition>& _internal_should() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::Condition>* PROTOBUF_NONNULL _internal_mutable_should();
  public:
  const ::qdrant::Condition& should(int index) const;
  ::qdrant::Condition* PROTOBUF_NONNULL add_should();
  const ::google::protobuf::RepeatedPtrField<::qdrant::Condition>& should() const;
  // repeated .qdrant.Condition must = 2;
  int must_size() const;
  private:
  int _internal_must_size() const;

  public:
  void clear_must() ;
  ::qdrant::Condition* PROTOBUF_NONNULL mutable_must(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::Condition>* PROTOBUF_NONNULL mutable_must();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::Condition>& _internal_must() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::Condition>* PROTOBUF_NONNULL _internal_mutable_must();
  public:
  const ::qdrant::Condition& must(int index) const;
  ::qdrant::Condition* PROTOBUF_NONNULL add_must();
  const ::google::protobuf::RepeatedPtrField<::qdrant::Condition>& must() const;
  // repeated .qdrant.Condition must_not = 3;
  int must_not_size() const;
  private:
  int _internal_must_not_size() const;

  public:
  void clear_must_not() ;
  ::qdrant::Condition* PROTOBUF_NONNULL mutable_must_not(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::Condition>* PROTOBUF_NONNULL mutable_must_not();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::Condition>& _internal_must_not() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::Condition>* PROTOBUF_NONNULL _internal_mutable_must_not();
  public:
  const ::qdrant::Condition& must_not(int index) const;
  ::qdrant::Condition* PROTOBUF_NONNULL add_must_not();
  const ::google::protobuf::RepeatedPtrField<::qdrant::Condition>& must_not() const;
  // optional .qdrant.MinShould min_should = 4;
  bool has_min_should() const;
  void clear_min_should() ;
  const ::qdrant::MinShould& min_should() const;
  [[nodiscard]] ::qdrant::MinShould* PROTOBUF_NULLABLE release_min_should();
  ::qdrant::MinShould* PROTOBUF_NONNULL mutable_min_should();
  void set_allocated_min_should(::qdrant::MinShould* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_min_should(::qdrant::MinShould* PROTOBUF_NULLABLE value);
  ::qdrant::MinShould* PROTOBUF_NULLABLE unsafe_arena_release_min_should();

  private:
  const ::qdrant::MinShould& _internal_min_should() const;
  ::qdrant::MinShould* PROTOBUF_NONNULL _internal_mutable_min_should();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.Filter)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Filter& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::Condition > should_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::Condition > must_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::Condition > must_not_;
    ::qdrant::MinShould* PROTOBUF_NULLABLE min_should_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Filter_class_data_;
// -------------------------------------------------------------------

class MinShould final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.MinShould) */ {
 public:
  inline MinShould() : MinShould(nullptr) {}
  ~MinShould() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MinShould* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MinShould));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MinShould(::google::protobuf::internal::ConstantInitialized);

  inline MinShould(const MinShould& from) : MinShould(nullptr, from) {}
  inline MinShould(MinShould&& from) noexcept
      : MinShould(nullptr, ::std::move(from)) {}
  inline MinShould& operator=(const MinShould& from) {
    CopyFrom(from);
    return *this;
  }
  inline MinShould& operator=(MinShould&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MinShould& default_instance() {
    return *reinterpret_cast<const MinShould*>(
        &_MinShould_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 130;
  friend void swap(MinShould& a, MinShould& b) { a.Swap(&b); }
  inline void Swap(MinShould* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MinShould* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MinShould* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MinShould>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MinShould& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MinShould& from) { MinShould::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MinShould* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.MinShould"; }

  explicit MinShould(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MinShould(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MinShould& from);
  MinShould(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MinShould&& from) noexcept
      : MinShould(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConditionsFieldNumber = 1,
    kMinCountFieldNumber = 2,
  };
  // repeated .qdrant.Condition conditions = 1;
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;

  public:
  void clear_conditions() ;
  ::qdrant::Condition* PROTOBUF_NONNULL mutable_conditions(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::Condition>* PROTOBUF_NONNULL mutable_conditions();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::Condition>& _internal_conditions() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::Condition>* PROTOBUF_NONNULL _internal_mutable_conditions();
  public:
  const ::qdrant::Condition& conditions(int index) const;
  ::qdrant::Condition* PROTOBUF_NONNULL add_conditions();
  const ::google::protobuf::RepeatedPtrField<::qdrant::Condition>& conditions() const;
  // uint64 min_count = 2;
  void clear_min_count() ;
  ::uint64_t min_count() const;
  void set_min_count(::uint64_t value);

  private:
  ::uint64_t _internal_min_count() const;
  void _internal_set_min_count(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.MinShould)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MinShould& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::Condition > conditions_;
    ::uint64_t min_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MinShould_class_data_;
// -------------------------------------------------------------------

class NestedCondition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.NestedCondition) */ {
 public:
  inline NestedCondition() : NestedCondition(nullptr) {}
  ~NestedCondition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NestedCondition* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NestedCondition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NestedCondition(::google::protobuf::internal::ConstantInitialized);

  inline NestedCondition(const NestedCondition& from) : NestedCondition(nullptr, from) {}
  inline NestedCondition(NestedCondition&& from) noexcept
      : NestedCondition(nullptr, ::std::move(from)) {}
  inline NestedCondition& operator=(const NestedCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline NestedCondition& operator=(NestedCondition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NestedCondition& default_instance() {
    return *reinterpret_cast<const NestedCondition*>(
        &_NestedCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 136;
  friend void swap(NestedCondition& a, NestedCondition& b) { a.Swap(&b); }
  inline void Swap(NestedCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NestedCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NestedCondition* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NestedCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NestedCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NestedCondition& from) { NestedCondition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NestedCondition* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.NestedCondition"; }

  explicit NestedCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NestedCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NestedCondition& from);
  NestedCondition(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NestedCondition&& from) noexcept
      : NestedCondition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kFilterFieldNumber = 2,
  };
  // string key = 1;
  void clear_key() ;
  const ::std::string& key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_key();
  void set_allocated_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_key();

  public:
  // .qdrant.Filter filter = 2;
  bool has_filter() const;
  void clear_filter() ;
  const ::qdrant::Filter& filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_filter();
  void set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_filter();

  private:
  const ::qdrant::Filter& _internal_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_filter();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.NestedCondition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 34,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NestedCondition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::qdrant::Filter* PROTOBUF_NULLABLE filter_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NestedCondition_class_data_;
// -------------------------------------------------------------------

class VectorsOutput final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.VectorsOutput) */ {
 public:
  inline VectorsOutput() : VectorsOutput(nullptr) {}
  ~VectorsOutput() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VectorsOutput* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VectorsOutput));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VectorsOutput(::google::protobuf::internal::ConstantInitialized);

  inline VectorsOutput(const VectorsOutput& from) : VectorsOutput(nullptr, from) {}
  inline VectorsOutput(VectorsOutput&& from) noexcept
      : VectorsOutput(nullptr, ::std::move(from)) {}
  inline VectorsOutput& operator=(const VectorsOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorsOutput& operator=(VectorsOutput&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorsOutput& default_instance() {
    return *reinterpret_cast<const VectorsOutput*>(
        &_VectorsOutput_default_instance_);
  }
  enum VectorsOptionsCase {
    kVector = 1,
    kVectors = 2,
    VECTORS_OPTIONS_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(VectorsOutput& a, VectorsOutput& b) { a.Swap(&b); }
  inline void Swap(VectorsOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorsOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorsOutput* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VectorsOutput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorsOutput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VectorsOutput& from) { VectorsOutput::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VectorsOutput* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.VectorsOutput"; }

  explicit VectorsOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  VectorsOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const VectorsOutput& from);
  VectorsOutput(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, VectorsOutput&& from) noexcept
      : VectorsOutput(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVectorFieldNumber = 1,
    kVectorsFieldNumber = 2,
  };
  // .qdrant.VectorOutput vector = 1;
  bool has_vector() const;
  private:
  bool _internal_has_vector() const;

  public:
  void clear_vector() ;
  const ::qdrant::VectorOutput& vector() const;
  [[nodiscard]] ::qdrant::VectorOutput* PROTOBUF_NULLABLE release_vector();
  ::qdrant::VectorOutput* PROTOBUF_NONNULL mutable_vector();
  void set_allocated_vector(::qdrant::VectorOutput* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vector(::qdrant::VectorOutput* PROTOBUF_NULLABLE value);
  ::qdrant::VectorOutput* PROTOBUF_NULLABLE unsafe_arena_release_vector();

  private:
  const ::qdrant::VectorOutput& _internal_vector() const;
  ::qdrant::VectorOutput* PROTOBUF_NONNULL _internal_mutable_vector();

  public:
  // .qdrant.NamedVectorsOutput vectors = 2;
  bool has_vectors() const;
  private:
  bool _internal_has_vectors() const;

  public:
  void clear_vectors() ;
  const ::qdrant::NamedVectorsOutput& vectors() const;
  [[nodiscard]] ::qdrant::NamedVectorsOutput* PROTOBUF_NULLABLE release_vectors();
  ::qdrant::NamedVectorsOutput* PROTOBUF_NONNULL mutable_vectors();
  void set_allocated_vectors(::qdrant::NamedVectorsOutput* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vectors(::qdrant::NamedVectorsOutput* PROTOBUF_NULLABLE value);
  ::qdrant::NamedVectorsOutput* PROTOBUF_NULLABLE unsafe_arena_release_vectors();

  private:
  const ::qdrant::NamedVectorsOutput& _internal_vectors() const;
  ::qdrant::NamedVectorsOutput* PROTOBUF_NONNULL _internal_mutable_vectors();

  public:
  void clear_vectors_options();
  VectorsOptionsCase vectors_options_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.VectorsOutput)
 private:
  class _Internal;
  void set_has_vector();
  void set_has_vectors();
  inline bool has_vectors_options() const;
  inline void clear_has_vectors_options();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const VectorsOutput& from_msg);
    union VectorsOptionsUnion {
      constexpr VectorsOptionsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::qdrant::VectorOutput* PROTOBUF_NULLABLE vector_;
      ::qdrant::NamedVectorsOutput* PROTOBUF_NULLABLE vectors_;
    } vectors_options_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull VectorsOutput_class_data_;
// -------------------------------------------------------------------

class TargetVector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.TargetVector) */ {
 public:
  inline TargetVector() : TargetVector(nullptr) {}
  ~TargetVector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TargetVector* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TargetVector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TargetVector(::google::protobuf::internal::ConstantInitialized);

  inline TargetVector(const TargetVector& from) : TargetVector(nullptr, from) {}
  inline TargetVector(TargetVector&& from) noexcept
      : TargetVector(nullptr, ::std::move(from)) {}
  inline TargetVector& operator=(const TargetVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetVector& operator=(TargetVector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetVector& default_instance() {
    return *reinterpret_cast<const TargetVector*>(
        &_TargetVector_default_instance_);
  }
  enum TargetCase {
    kSingle = 1,
    TARGET_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 53;
  friend void swap(TargetVector& a, TargetVector& b) { a.Swap(&b); }
  inline void Swap(TargetVector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetVector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetVector* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TargetVector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TargetVector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TargetVector& from) { TargetVector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TargetVector* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.TargetVector"; }

  explicit TargetVector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TargetVector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TargetVector& from);
  TargetVector(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TargetVector&& from) noexcept
      : TargetVector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSingleFieldNumber = 1,
  };
  // .qdrant.VectorExample single = 1;
  bool has_single() const;
  private:
  bool _internal_has_single() const;

  public:
  void clear_single() ;
  const ::qdrant::VectorExample& single() const;
  [[nodiscard]] ::qdrant::VectorExample* PROTOBUF_NULLABLE release_single();
  ::qdrant::VectorExample* PROTOBUF_NONNULL mutable_single();
  void set_allocated_single(::qdrant::VectorExample* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_single(::qdrant::VectorExample* PROTOBUF_NULLABLE value);
  ::qdrant::VectorExample* PROTOBUF_NULLABLE unsafe_arena_release_single();

  private:
  const ::qdrant::VectorExample& _internal_single() const;
  ::qdrant::VectorExample* PROTOBUF_NONNULL _internal_mutable_single();

  public:
  void clear_target();
  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.TargetVector)
 private:
  class _Internal;
  void set_has_single();
  inline bool has_target() const;
  inline void clear_has_target();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TargetVector& from_msg);
    union TargetUnion {
      constexpr TargetUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::qdrant::VectorExample* PROTOBUF_NULLABLE single_;
    } target_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TargetVector_class_data_;
// -------------------------------------------------------------------

class SearchPoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SearchPoints) */ {
 public:
  inline SearchPoints() : SearchPoints(nullptr) {}
  ~SearchPoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SearchPoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SearchPoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SearchPoints(::google::protobuf::internal::ConstantInitialized);

  inline SearchPoints(const SearchPoints& from) : SearchPoints(nullptr, from) {}
  inline SearchPoints(SearchPoints&& from) noexcept
      : SearchPoints(nullptr, ::std::move(from)) {}
  inline SearchPoints& operator=(const SearchPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchPoints& operator=(SearchPoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchPoints& default_instance() {
    return *reinterpret_cast<const SearchPoints*>(
        &_SearchPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 42;
  friend void swap(SearchPoints& a, SearchPoints& b) { a.Swap(&b); }
  inline void Swap(SearchPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchPoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SearchPoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchPoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SearchPoints& from) { SearchPoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SearchPoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SearchPoints"; }

  explicit SearchPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SearchPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SearchPoints& from);
  SearchPoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SearchPoints&& from) noexcept
      : SearchPoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVectorFieldNumber = 2,
    kCollectionNameFieldNumber = 1,
    kVectorNameFieldNumber = 10,
    kFilterFieldNumber = 3,
    kWithPayloadFieldNumber = 6,
    kParamsFieldNumber = 7,
    kWithVectorsFieldNumber = 11,
    kReadConsistencyFieldNumber = 12,
    kShardKeySelectorFieldNumber = 14,
    kSparseIndicesFieldNumber = 15,
    kLimitFieldNumber = 4,
    kOffsetFieldNumber = 9,
    kTimeoutFieldNumber = 13,
    kScoreThresholdFieldNumber = 8,
  };
  // repeated float vector = 2;
  int vector_size() const;
  private:
  int _internal_vector_size() const;

  public:
  void clear_vector() ;
  float vector(int index) const;
  void set_vector(int index, float value);
  void add_vector(float value);
  const ::google::protobuf::RepeatedField<float>& vector() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL mutable_vector();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_vector() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL _internal_mutable_vector();

  public:
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional string vector_name = 10;
  bool has_vector_name() const;
  void clear_vector_name() ;
  const ::std::string& vector_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_vector_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_vector_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_vector_name();
  void set_allocated_vector_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_vector_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_vector_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_vector_name();

  public:
  // .qdrant.Filter filter = 3;
  bool has_filter() const;
  void clear_filter() ;
  const ::qdrant::Filter& filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_filter();
  void set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_filter();

  private:
  const ::qdrant::Filter& _internal_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_filter();

  public:
  // .qdrant.WithPayloadSelector with_payload = 6;
  bool has_with_payload() const;
  void clear_with_payload() ;
  const ::qdrant::WithPayloadSelector& with_payload() const;
  [[nodiscard]] ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE release_with_payload();
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL mutable_with_payload();
  void set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_payload();

  private:
  const ::qdrant::WithPayloadSelector& _internal_with_payload() const;
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL _internal_mutable_with_payload();

  public:
  // .qdrant.SearchParams params = 7;
  bool has_params() const;
  void clear_params() ;
  const ::qdrant::SearchParams& params() const;
  [[nodiscard]] ::qdrant::SearchParams* PROTOBUF_NULLABLE release_params();
  ::qdrant::SearchParams* PROTOBUF_NONNULL mutable_params();
  void set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value);
  ::qdrant::SearchParams* PROTOBUF_NULLABLE unsafe_arena_release_params();

  private:
  const ::qdrant::SearchParams& _internal_params() const;
  ::qdrant::SearchParams* PROTOBUF_NONNULL _internal_mutable_params();

  public:
  // optional .qdrant.WithVectorsSelector with_vectors = 11;
  bool has_with_vectors() const;
  void clear_with_vectors() ;
  const ::qdrant::WithVectorsSelector& with_vectors() const;
  [[nodiscard]] ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE release_with_vectors();
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL mutable_with_vectors();
  void set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_vectors();

  private:
  const ::qdrant::WithVectorsSelector& _internal_with_vectors() const;
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL _internal_mutable_with_vectors();

  public:
  // optional .qdrant.ReadConsistency read_consistency = 12;
  bool has_read_consistency() const;
  void clear_read_consistency() ;
  const ::qdrant::ReadConsistency& read_consistency() const;
  [[nodiscard]] ::qdrant::ReadConsistency* PROTOBUF_NULLABLE release_read_consistency();
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL mutable_read_consistency();
  void set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  ::qdrant::ReadConsistency* PROTOBUF_NULLABLE unsafe_arena_release_read_consistency();

  private:
  const ::qdrant::ReadConsistency& _internal_read_consistency() const;
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL _internal_mutable_read_consistency();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 14;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional .qdrant.SparseIndices sparse_indices = 15;
  bool has_sparse_indices() const;
  void clear_sparse_indices() ;
  const ::qdrant::SparseIndices& sparse_indices() const;
  [[nodiscard]] ::qdrant::SparseIndices* PROTOBUF_NULLABLE release_sparse_indices();
  ::qdrant::SparseIndices* PROTOBUF_NONNULL mutable_sparse_indices();
  void set_allocated_sparse_indices(::qdrant::SparseIndices* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sparse_indices(::qdrant::SparseIndices* PROTOBUF_NULLABLE value);
  ::qdrant::SparseIndices* PROTOBUF_NULLABLE unsafe_arena_release_sparse_indices();

  private:
  const ::qdrant::SparseIndices& _internal_sparse_indices() const;
  ::qdrant::SparseIndices* PROTOBUF_NONNULL _internal_mutable_sparse_indices();

  public:
  // uint64 limit = 4;
  void clear_limit() ;
  ::uint64_t limit() const;
  void set_limit(::uint64_t value);

  private:
  ::uint64_t _internal_limit() const;
  void _internal_set_limit(::uint64_t value);

  public:
  // optional uint64 offset = 9;
  bool has_offset() const;
  void clear_offset() ;
  ::uint64_t offset() const;
  void set_offset(::uint64_t value);

  private:
  ::uint64_t _internal_offset() const;
  void _internal_set_offset(::uint64_t value);

  public:
  // optional uint64 timeout = 13;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // optional float score_threshold = 8;
  bool has_score_threshold() const;
  void clear_score_threshold() ;
  float score_threshold() const;
  void set_score_threshold(float value);

  private:
  float _internal_score_threshold() const;
  void _internal_set_score_threshold(float value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SearchPoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 14,
                                   7, 62,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SearchPoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> vector_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::google::protobuf::internal::ArenaStringPtr vector_name_;
    ::qdrant::Filter* PROTOBUF_NULLABLE filter_;
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE with_payload_;
    ::qdrant::SearchParams* PROTOBUF_NULLABLE params_;
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE with_vectors_;
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE read_consistency_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::qdrant::SparseIndices* PROTOBUF_NULLABLE sparse_indices_;
    ::uint64_t limit_;
    ::uint64_t offset_;
    ::uint64_t timeout_;
    float score_threshold_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SearchPoints_class_data_;
// -------------------------------------------------------------------

class SearchPointGroups final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SearchPointGroups) */ {
 public:
  inline SearchPointGroups() : SearchPointGroups(nullptr) {}
  ~SearchPointGroups() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SearchPointGroups* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SearchPointGroups));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SearchPointGroups(::google::protobuf::internal::ConstantInitialized);

  inline SearchPointGroups(const SearchPointGroups& from) : SearchPointGroups(nullptr, from) {}
  inline SearchPointGroups(SearchPointGroups&& from) noexcept
      : SearchPointGroups(nullptr, ::std::move(from)) {}
  inline SearchPointGroups& operator=(const SearchPointGroups& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchPointGroups& operator=(SearchPointGroups&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchPointGroups& default_instance() {
    return *reinterpret_cast<const SearchPointGroups*>(
        &_SearchPointGroups_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 45;
  friend void swap(SearchPointGroups& a, SearchPointGroups& b) { a.Swap(&b); }
  inline void Swap(SearchPointGroups* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchPointGroups* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchPointGroups* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SearchPointGroups>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchPointGroups& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SearchPointGroups& from) { SearchPointGroups::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SearchPointGroups* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SearchPointGroups"; }

  explicit SearchPointGroups(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SearchPointGroups(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SearchPointGroups& from);
  SearchPointGroups(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SearchPointGroups&& from) noexcept
      : SearchPointGroups(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVectorFieldNumber = 2,
    kCollectionNameFieldNumber = 1,
    kVectorNameFieldNumber = 8,
    kGroupByFieldNumber = 10,
    kFilterFieldNumber = 3,
    kWithPayloadFieldNumber = 5,
    kParamsFieldNumber = 6,
    kWithVectorsFieldNumber = 9,
    kReadConsistencyFieldNumber = 12,
    kWithLookupFieldNumber = 13,
    kShardKeySelectorFieldNumber = 15,
    kSparseIndicesFieldNumber = 16,
    kLimitFieldNumber = 4,
    kScoreThresholdFieldNumber = 7,
    kTimeoutFieldNumber = 14,
    kGroupSizeFieldNumber = 11,
  };
  // repeated float vector = 2;
  int vector_size() const;
  private:
  int _internal_vector_size() const;

  public:
  void clear_vector() ;
  float vector(int index) const;
  void set_vector(int index, float value);
  void add_vector(float value);
  const ::google::protobuf::RepeatedField<float>& vector() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL mutable_vector();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_vector() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL _internal_mutable_vector();

  public:
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional string vector_name = 8;
  bool has_vector_name() const;
  void clear_vector_name() ;
  const ::std::string& vector_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_vector_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_vector_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_vector_name();
  void set_allocated_vector_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_vector_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_vector_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_vector_name();

  public:
  // string group_by = 10;
  void clear_group_by() ;
  const ::std::string& group_by() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_group_by(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_group_by();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_group_by();
  void set_allocated_group_by(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_group_by() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_group_by(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_group_by();

  public:
  // .qdrant.Filter filter = 3;
  bool has_filter() const;
  void clear_filter() ;
  const ::qdrant::Filter& filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_filter();
  void set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_filter();

  private:
  const ::qdrant::Filter& _internal_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_filter();

  public:
  // .qdrant.WithPayloadSelector with_payload = 5;
  bool has_with_payload() const;
  void clear_with_payload() ;
  const ::qdrant::WithPayloadSelector& with_payload() const;
  [[nodiscard]] ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE release_with_payload();
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL mutable_with_payload();
  void set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_payload();

  private:
  const ::qdrant::WithPayloadSelector& _internal_with_payload() const;
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL _internal_mutable_with_payload();

  public:
  // .qdrant.SearchParams params = 6;
  bool has_params() const;
  void clear_params() ;
  const ::qdrant::SearchParams& params() const;
  [[nodiscard]] ::qdrant::SearchParams* PROTOBUF_NULLABLE release_params();
  ::qdrant::SearchParams* PROTOBUF_NONNULL mutable_params();
  void set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value);
  ::qdrant::SearchParams* PROTOBUF_NULLABLE unsafe_arena_release_params();

  private:
  const ::qdrant::SearchParams& _internal_params() const;
  ::qdrant::SearchParams* PROTOBUF_NONNULL _internal_mutable_params();

  public:
  // optional .qdrant.WithVectorsSelector with_vectors = 9;
  bool has_with_vectors() const;
  void clear_with_vectors() ;
  const ::qdrant::WithVectorsSelector& with_vectors() const;
  [[nodiscard]] ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE release_with_vectors();
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL mutable_with_vectors();
  void set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_vectors();

  private:
  const ::qdrant::WithVectorsSelector& _internal_with_vectors() const;
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL _internal_mutable_with_vectors();

  public:
  // optional .qdrant.ReadConsistency read_consistency = 12;
  bool has_read_consistency() const;
  void clear_read_consistency() ;
  const ::qdrant::ReadConsistency& read_consistency() const;
  [[nodiscard]] ::qdrant::ReadConsistency* PROTOBUF_NULLABLE release_read_consistency();
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL mutable_read_consistency();
  void set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  ::qdrant::ReadConsistency* PROTOBUF_NULLABLE unsafe_arena_release_read_consistency();

  private:
  const ::qdrant::ReadConsistency& _internal_read_consistency() const;
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL _internal_mutable_read_consistency();

  public:
  // optional .qdrant.WithLookup with_lookup = 13;
  bool has_with_lookup() const;
  void clear_with_lookup() ;
  const ::qdrant::WithLookup& with_lookup() const;
  [[nodiscard]] ::qdrant::WithLookup* PROTOBUF_NULLABLE release_with_lookup();
  ::qdrant::WithLookup* PROTOBUF_NONNULL mutable_with_lookup();
  void set_allocated_with_lookup(::qdrant::WithLookup* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_lookup(::qdrant::WithLookup* PROTOBUF_NULLABLE value);
  ::qdrant::WithLookup* PROTOBUF_NULLABLE unsafe_arena_release_with_lookup();

  private:
  const ::qdrant::WithLookup& _internal_with_lookup() const;
  ::qdrant::WithLookup* PROTOBUF_NONNULL _internal_mutable_with_lookup();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 15;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional .qdrant.SparseIndices sparse_indices = 16;
  bool has_sparse_indices() const;
  void clear_sparse_indices() ;
  const ::qdrant::SparseIndices& sparse_indices() const;
  [[nodiscard]] ::qdrant::SparseIndices* PROTOBUF_NULLABLE release_sparse_indices();
  ::qdrant::SparseIndices* PROTOBUF_NONNULL mutable_sparse_indices();
  void set_allocated_sparse_indices(::qdrant::SparseIndices* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sparse_indices(::qdrant::SparseIndices* PROTOBUF_NULLABLE value);
  ::qdrant::SparseIndices* PROTOBUF_NULLABLE unsafe_arena_release_sparse_indices();

  private:
  const ::qdrant::SparseIndices& _internal_sparse_indices() const;
  ::qdrant::SparseIndices* PROTOBUF_NONNULL _internal_mutable_sparse_indices();

  public:
  // uint32 limit = 4;
  void clear_limit() ;
  ::uint32_t limit() const;
  void set_limit(::uint32_t value);

  private:
  ::uint32_t _internal_limit() const;
  void _internal_set_limit(::uint32_t value);

  public:
  // optional float score_threshold = 7;
  bool has_score_threshold() const;
  void clear_score_threshold() ;
  float score_threshold() const;
  void set_score_threshold(float value);

  private:
  float _internal_score_threshold() const;
  void _internal_set_score_threshold(float value);

  public:
  // optional uint64 timeout = 14;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // uint32 group_size = 11;
  void clear_group_size() ;
  ::uint32_t group_size() const;
  void set_group_size(::uint32_t value);

  private:
  ::uint32_t _internal_group_size() const;
  void _internal_set_group_size(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SearchPointGroups)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 16,
                                   8, 83,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SearchPointGroups& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> vector_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::google::protobuf::internal::ArenaStringPtr vector_name_;
    ::google::protobuf::internal::ArenaStringPtr group_by_;
    ::qdrant::Filter* PROTOBUF_NULLABLE filter_;
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE with_payload_;
    ::qdrant::SearchParams* PROTOBUF_NULLABLE params_;
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE with_vectors_;
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE read_consistency_;
    ::qdrant::WithLookup* PROTOBUF_NULLABLE with_lookup_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::qdrant::SparseIndices* PROTOBUF_NULLABLE sparse_indices_;
    ::uint32_t limit_;
    float score_threshold_;
    ::uint64_t timeout_;
    ::uint32_t group_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SearchPointGroups_class_data_;
// -------------------------------------------------------------------

class SearchMatrixPoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SearchMatrixPoints) */ {
 public:
  inline SearchMatrixPoints() : SearchMatrixPoints(nullptr) {}
  ~SearchMatrixPoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SearchMatrixPoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SearchMatrixPoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SearchMatrixPoints(::google::protobuf::internal::ConstantInitialized);

  inline SearchMatrixPoints(const SearchMatrixPoints& from) : SearchMatrixPoints(nullptr, from) {}
  inline SearchMatrixPoints(SearchMatrixPoints&& from) noexcept
      : SearchMatrixPoints(nullptr, ::std::move(from)) {}
  inline SearchMatrixPoints& operator=(const SearchMatrixPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchMatrixPoints& operator=(SearchMatrixPoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchMatrixPoints& default_instance() {
    return *reinterpret_cast<const SearchMatrixPoints*>(
        &_SearchMatrixPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 83;
  friend void swap(SearchMatrixPoints& a, SearchMatrixPoints& b) { a.Swap(&b); }
  inline void Swap(SearchMatrixPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchMatrixPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchMatrixPoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SearchMatrixPoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchMatrixPoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SearchMatrixPoints& from) { SearchMatrixPoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SearchMatrixPoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SearchMatrixPoints"; }

  explicit SearchMatrixPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SearchMatrixPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SearchMatrixPoints& from);
  SearchMatrixPoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SearchMatrixPoints&& from) noexcept
      : SearchMatrixPoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kUsingFieldNumber = 5,
    kFilterFieldNumber = 2,
    kReadConsistencyFieldNumber = 7,
    kShardKeySelectorFieldNumber = 8,
    kSampleFieldNumber = 3,
    kLimitFieldNumber = 4,
    kTimeoutFieldNumber = 6,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional string using = 5;
  bool has_using_() const;
  void clear_using_() ;
  const ::std::string& using_() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_using_(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_using_();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_using_();
  void set_allocated_using_(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_using_() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_using_(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_using_();

  public:
  // optional .qdrant.Filter filter = 2;
  bool has_filter() const;
  void clear_filter() ;
  const ::qdrant::Filter& filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_filter();
  void set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_filter();

  private:
  const ::qdrant::Filter& _internal_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_filter();

  public:
  // optional .qdrant.ReadConsistency read_consistency = 7;
  bool has_read_consistency() const;
  void clear_read_consistency() ;
  const ::qdrant::ReadConsistency& read_consistency() const;
  [[nodiscard]] ::qdrant::ReadConsistency* PROTOBUF_NULLABLE release_read_consistency();
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL mutable_read_consistency();
  void set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  ::qdrant::ReadConsistency* PROTOBUF_NULLABLE unsafe_arena_release_read_consistency();

  private:
  const ::qdrant::ReadConsistency& _internal_read_consistency() const;
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL _internal_mutable_read_consistency();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 8;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional uint64 sample = 3;
  bool has_sample() const;
  void clear_sample() ;
  ::uint64_t sample() const;
  void set_sample(::uint64_t value);

  private:
  ::uint64_t _internal_sample() const;
  void _internal_set_sample(::uint64_t value);

  public:
  // optional uint64 limit = 4;
  bool has_limit() const;
  void clear_limit() ;
  ::uint64_t limit() const;
  void set_limit(::uint64_t value);

  private:
  ::uint64_t _internal_limit() const;
  void _internal_set_limit(::uint64_t value);

  public:
  // optional uint64 timeout = 6;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SearchMatrixPoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   3, 62,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SearchMatrixPoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::google::protobuf::internal::ArenaStringPtr using__;
    ::qdrant::Filter* PROTOBUF_NULLABLE filter_;
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE read_consistency_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::uint64_t sample_;
    ::uint64_t limit_;
    ::uint64_t timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SearchMatrixPoints_class_data_;
// -------------------------------------------------------------------

class ScrollPoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ScrollPoints) */ {
 public:
  inline ScrollPoints() : ScrollPoints(nullptr) {}
  ~ScrollPoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ScrollPoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ScrollPoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ScrollPoints(::google::protobuf::internal::ConstantInitialized);

  inline ScrollPoints(const ScrollPoints& from) : ScrollPoints(nullptr, from) {}
  inline ScrollPoints(ScrollPoints&& from) noexcept
      : ScrollPoints(nullptr, ::std::move(from)) {}
  inline ScrollPoints& operator=(const ScrollPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScrollPoints& operator=(ScrollPoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScrollPoints& default_instance() {
    return *reinterpret_cast<const ScrollPoints*>(
        &_ScrollPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 48;
  friend void swap(ScrollPoints& a, ScrollPoints& b) { a.Swap(&b); }
  inline void Swap(ScrollPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScrollPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScrollPoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ScrollPoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ScrollPoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ScrollPoints& from) { ScrollPoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ScrollPoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ScrollPoints"; }

  explicit ScrollPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ScrollPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ScrollPoints& from);
  ScrollPoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ScrollPoints&& from) noexcept
      : ScrollPoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kFilterFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kWithPayloadFieldNumber = 6,
    kWithVectorsFieldNumber = 7,
    kReadConsistencyFieldNumber = 8,
    kShardKeySelectorFieldNumber = 9,
    kOrderByFieldNumber = 10,
    kTimeoutFieldNumber = 11,
    kLimitFieldNumber = 4,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // .qdrant.Filter filter = 2;
  bool has_filter() const;
  void clear_filter() ;
  const ::qdrant::Filter& filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_filter();
  void set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_filter();

  private:
  const ::qdrant::Filter& _internal_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_filter();

  public:
  // optional .qdrant.PointId offset = 3;
  bool has_offset() const;
  void clear_offset() ;
  const ::qdrant::PointId& offset() const;
  [[nodiscard]] ::qdrant::PointId* PROTOBUF_NULLABLE release_offset();
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_offset();
  void set_allocated_offset(::qdrant::PointId* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_offset(::qdrant::PointId* PROTOBUF_NULLABLE value);
  ::qdrant::PointId* PROTOBUF_NULLABLE unsafe_arena_release_offset();

  private:
  const ::qdrant::PointId& _internal_offset() const;
  ::qdrant::PointId* PROTOBUF_NONNULL _internal_mutable_offset();

  public:
  // .qdrant.WithPayloadSelector with_payload = 6;
  bool has_with_payload() const;
  void clear_with_payload() ;
  const ::qdrant::WithPayloadSelector& with_payload() const;
  [[nodiscard]] ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE release_with_payload();
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL mutable_with_payload();
  void set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_payload();

  private:
  const ::qdrant::WithPayloadSelector& _internal_with_payload() const;
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL _internal_mutable_with_payload();

  public:
  // optional .qdrant.WithVectorsSelector with_vectors = 7;
  bool has_with_vectors() const;
  void clear_with_vectors() ;
  const ::qdrant::WithVectorsSelector& with_vectors() const;
  [[nodiscard]] ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE release_with_vectors();
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL mutable_with_vectors();
  void set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_vectors();

  private:
  const ::qdrant::WithVectorsSelector& _internal_with_vectors() const;
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL _internal_mutable_with_vectors();

  public:
  // optional .qdrant.ReadConsistency read_consistency = 8;
  bool has_read_consistency() const;
  void clear_read_consistency() ;
  const ::qdrant::ReadConsistency& read_consistency() const;
  [[nodiscard]] ::qdrant::ReadConsistency* PROTOBUF_NULLABLE release_read_consistency();
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL mutable_read_consistency();
  void set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  ::qdrant::ReadConsistency* PROTOBUF_NULLABLE unsafe_arena_release_read_consistency();

  private:
  const ::qdrant::ReadConsistency& _internal_read_consistency() const;
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL _internal_mutable_read_consistency();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 9;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional .qdrant.OrderBy order_by = 10;
  bool has_order_by() const;
  void clear_order_by() ;
  const ::qdrant::OrderBy& order_by() const;
  [[nodiscard]] ::qdrant::OrderBy* PROTOBUF_NULLABLE release_order_by();
  ::qdrant::OrderBy* PROTOBUF_NONNULL mutable_order_by();
  void set_allocated_order_by(::qdrant::OrderBy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_order_by(::qdrant::OrderBy* PROTOBUF_NULLABLE value);
  ::qdrant::OrderBy* PROTOBUF_NULLABLE unsafe_arena_release_order_by();

  private:
  const ::qdrant::OrderBy& _internal_order_by() const;
  ::qdrant::OrderBy* PROTOBUF_NONNULL _internal_mutable_order_by();

  public:
  // optional uint64 timeout = 11;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // optional uint32 limit = 4;
  bool has_limit() const;
  void clear_limit() ;
  ::uint32_t limit() const;
  void set_limit(::uint32_t value);

  private:
  ::uint32_t _internal_limit() const;
  void _internal_set_limit(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.ScrollPoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 10,
                                   7, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ScrollPoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::qdrant::Filter* PROTOBUF_NULLABLE filter_;
    ::qdrant::PointId* PROTOBUF_NULLABLE offset_;
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE with_payload_;
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE with_vectors_;
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE read_consistency_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::qdrant::OrderBy* PROTOBUF_NULLABLE order_by_;
    ::uint64_t timeout_;
    ::uint32_t limit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ScrollPoints_class_data_;
// -------------------------------------------------------------------

class RecommendPoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.RecommendPoints) */ {
 public:
  inline RecommendPoints() : RecommendPoints(nullptr) {}
  ~RecommendPoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RecommendPoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RecommendPoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RecommendPoints(::google::protobuf::internal::ConstantInitialized);

  inline RecommendPoints(const RecommendPoints& from) : RecommendPoints(nullptr, from) {}
  inline RecommendPoints(RecommendPoints&& from) noexcept
      : RecommendPoints(nullptr, ::std::move(from)) {}
  inline RecommendPoints& operator=(const RecommendPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecommendPoints& operator=(RecommendPoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecommendPoints& default_instance() {
    return *reinterpret_cast<const RecommendPoints*>(
        &_RecommendPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 50;
  friend void swap(RecommendPoints& a, RecommendPoints& b) { a.Swap(&b); }
  inline void Swap(RecommendPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecommendPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecommendPoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RecommendPoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecommendPoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RecommendPoints& from) { RecommendPoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RecommendPoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.RecommendPoints"; }

  explicit RecommendPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RecommendPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RecommendPoints& from);
  RecommendPoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RecommendPoints&& from) noexcept
      : RecommendPoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositiveFieldNumber = 2,
    kNegativeFieldNumber = 3,
    kPositiveVectorsFieldNumber = 17,
    kNegativeVectorsFieldNumber = 18,
    kCollectionNameFieldNumber = 1,
    kUsingFieldNumber = 11,
    kFilterFieldNumber = 4,
    kWithPayloadFieldNumber = 7,
    kParamsFieldNumber = 8,
    kWithVectorsFieldNumber = 12,
    kLookupFromFieldNumber = 13,
    kReadConsistencyFieldNumber = 14,
    kShardKeySelectorFieldNumber = 20,
    kLimitFieldNumber = 5,
    kOffsetFieldNumber = 10,
    kScoreThresholdFieldNumber = 9,
    kStrategyFieldNumber = 16,
    kTimeoutFieldNumber = 19,
  };
  // repeated .qdrant.PointId positive = 2;
  int positive_size() const;
  private:
  int _internal_positive_size() const;

  public:
  void clear_positive() ;
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_positive(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL mutable_positive();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& _internal_positive() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL _internal_mutable_positive();
  public:
  const ::qdrant::PointId& positive(int index) const;
  ::qdrant::PointId* PROTOBUF_NONNULL add_positive();
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& positive() const;
  // repeated .qdrant.PointId negative = 3;
  int negative_size() const;
  private:
  int _internal_negative_size() const;

  public:
  void clear_negative() ;
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_negative(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL mutable_negative();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& _internal_negative() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL _internal_mutable_negative();
  public:
  const ::qdrant::PointId& negative(int index) const;
  ::qdrant::PointId* PROTOBUF_NONNULL add_negative();
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& negative() const;
  // repeated .qdrant.Vector positive_vectors = 17;
  int positive_vectors_size() const;
  private:
  int _internal_positive_vectors_size() const;

  public:
  void clear_positive_vectors() ;
  ::qdrant::Vector* PROTOBUF_NONNULL mutable_positive_vectors(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::Vector>* PROTOBUF_NONNULL mutable_positive_vectors();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::Vector>& _internal_positive_vectors() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::Vector>* PROTOBUF_NONNULL _internal_mutable_positive_vectors();
  public:
  const ::qdrant::Vector& positive_vectors(int index) const;
  ::qdrant::Vector* PROTOBUF_NONNULL add_positive_vectors();
  const ::google::protobuf::RepeatedPtrField<::qdrant::Vector>& positive_vectors() const;
  // repeated .qdrant.Vector negative_vectors = 18;
  int negative_vectors_size() const;
  private:
  int _internal_negative_vectors_size() const;

  public:
  void clear_negative_vectors() ;
  ::qdrant::Vector* PROTOBUF_NONNULL mutable_negative_vectors(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::Vector>* PROTOBUF_NONNULL mutable_negative_vectors();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::Vector>& _internal_negative_vectors() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::Vector>* PROTOBUF_NONNULL _internal_mutable_negative_vectors();
  public:
  const ::qdrant::Vector& negative_vectors(int index) const;
  ::qdrant::Vector* PROTOBUF_NONNULL add_negative_vectors();
  const ::google::protobuf::RepeatedPtrField<::qdrant::Vector>& negative_vectors() const;
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional string using = 11;
  bool has_using_() const;
  void clear_using_() ;
  const ::std::string& using_() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_using_(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_using_();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_using_();
  void set_allocated_using_(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_using_() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_using_(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_using_();

  public:
  // .qdrant.Filter filter = 4;
  bool has_filter() const;
  void clear_filter() ;
  const ::qdrant::Filter& filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_filter();
  void set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_filter();

  private:
  const ::qdrant::Filter& _internal_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_filter();

  public:
  // .qdrant.WithPayloadSelector with_payload = 7;
  bool has_with_payload() const;
  void clear_with_payload() ;
  const ::qdrant::WithPayloadSelector& with_payload() const;
  [[nodiscard]] ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE release_with_payload();
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL mutable_with_payload();
  void set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_payload();

  private:
  const ::qdrant::WithPayloadSelector& _internal_with_payload() const;
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL _internal_mutable_with_payload();

  public:
  // .qdrant.SearchParams params = 8;
  bool has_params() const;
  void clear_params() ;
  const ::qdrant::SearchParams& params() const;
  [[nodiscard]] ::qdrant::SearchParams* PROTOBUF_NULLABLE release_params();
  ::qdrant::SearchParams* PROTOBUF_NONNULL mutable_params();
  void set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value);
  ::qdrant::SearchParams* PROTOBUF_NULLABLE unsafe_arena_release_params();

  private:
  const ::qdrant::SearchParams& _internal_params() const;
  ::qdrant::SearchParams* PROTOBUF_NONNULL _internal_mutable_params();

  public:
  // optional .qdrant.WithVectorsSelector with_vectors = 12;
  bool has_with_vectors() const;
  void clear_with_vectors() ;
  const ::qdrant::WithVectorsSelector& with_vectors() const;
  [[nodiscard]] ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE release_with_vectors();
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL mutable_with_vectors();
  void set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_vectors();

  private:
  const ::qdrant::WithVectorsSelector& _internal_with_vectors() const;
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL _internal_mutable_with_vectors();

  public:
  // optional .qdrant.LookupLocation lookup_from = 13;
  bool has_lookup_from() const;
  void clear_lookup_from() ;
  const ::qdrant::LookupLocation& lookup_from() const;
  [[nodiscard]] ::qdrant::LookupLocation* PROTOBUF_NULLABLE release_lookup_from();
  ::qdrant::LookupLocation* PROTOBUF_NONNULL mutable_lookup_from();
  void set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value);
  ::qdrant::LookupLocation* PROTOBUF_NULLABLE unsafe_arena_release_lookup_from();

  private:
  const ::qdrant::LookupLocation& _internal_lookup_from() const;
  ::qdrant::LookupLocation* PROTOBUF_NONNULL _internal_mutable_lookup_from();

  public:
  // optional .qdrant.ReadConsistency read_consistency = 14;
  bool has_read_consistency() const;
  void clear_read_consistency() ;
  const ::qdrant::ReadConsistency& read_consistency() const;
  [[nodiscard]] ::qdrant::ReadConsistency* PROTOBUF_NULLABLE release_read_consistency();
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL mutable_read_consistency();
  void set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  ::qdrant::ReadConsistency* PROTOBUF_NULLABLE unsafe_arena_release_read_consistency();

  private:
  const ::qdrant::ReadConsistency& _internal_read_consistency() const;
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL _internal_mutable_read_consistency();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 20;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // uint64 limit = 5;
  void clear_limit() ;
  ::uint64_t limit() const;
  void set_limit(::uint64_t value);

  private:
  ::uint64_t _internal_limit() const;
  void _internal_set_limit(::uint64_t value);

  public:
  // optional uint64 offset = 10;
  bool has_offset() const;
  void clear_offset() ;
  ::uint64_t offset() const;
  void set_offset(::uint64_t value);

  private:
  ::uint64_t _internal_offset() const;
  void _internal_set_offset(::uint64_t value);

  public:
  // optional float score_threshold = 9;
  bool has_score_threshold() const;
  void clear_score_threshold() ;
  float score_threshold() const;
  void set_score_threshold(float value);

  private:
  float _internal_score_threshold() const;
  void _internal_set_score_threshold(float value);

  public:
  // optional .qdrant.RecommendStrategy strategy = 16;
  bool has_strategy() const;
  void clear_strategy() ;
  ::qdrant::RecommendStrategy strategy() const;
  void set_strategy(::qdrant::RecommendStrategy value);

  private:
  ::qdrant::RecommendStrategy _internal_strategy() const;
  void _internal_set_strategy(::qdrant::RecommendStrategy value);

  public:
  // optional uint64 timeout = 19;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.RecommendPoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 18,
                                   11, 67,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RecommendPoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::PointId > positive_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::PointId > negative_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::Vector > positive_vectors_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::Vector > negative_vectors_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::google::protobuf::internal::ArenaStringPtr using__;
    ::qdrant::Filter* PROTOBUF_NULLABLE filter_;
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE with_payload_;
    ::qdrant::SearchParams* PROTOBUF_NULLABLE params_;
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE with_vectors_;
    ::qdrant::LookupLocation* PROTOBUF_NULLABLE lookup_from_;
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE read_consistency_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::uint64_t limit_;
    ::uint64_t offset_;
    float score_threshold_;
    int strategy_;
    ::uint64_t timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RecommendPoints_class_data_;
// -------------------------------------------------------------------

class RecommendPointGroups final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.RecommendPointGroups) */ {
 public:
  inline RecommendPointGroups() : RecommendPointGroups(nullptr) {}
  ~RecommendPointGroups() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RecommendPointGroups* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RecommendPointGroups));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RecommendPointGroups(::google::protobuf::internal::ConstantInitialized);

  inline RecommendPointGroups(const RecommendPointGroups& from) : RecommendPointGroups(nullptr, from) {}
  inline RecommendPointGroups(RecommendPointGroups&& from) noexcept
      : RecommendPointGroups(nullptr, ::std::move(from)) {}
  inline RecommendPointGroups& operator=(const RecommendPointGroups& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecommendPointGroups& operator=(RecommendPointGroups&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecommendPointGroups& default_instance() {
    return *reinterpret_cast<const RecommendPointGroups*>(
        &_RecommendPointGroups_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 52;
  friend void swap(RecommendPointGroups& a, RecommendPointGroups& b) { a.Swap(&b); }
  inline void Swap(RecommendPointGroups* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecommendPointGroups* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecommendPointGroups* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RecommendPointGroups>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecommendPointGroups& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RecommendPointGroups& from) { RecommendPointGroups::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RecommendPointGroups* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.RecommendPointGroups"; }

  explicit RecommendPointGroups(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RecommendPointGroups(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RecommendPointGroups& from);
  RecommendPointGroups(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RecommendPointGroups&& from) noexcept
      : RecommendPointGroups(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositiveFieldNumber = 2,
    kNegativeFieldNumber = 3,
    kPositiveVectorsFieldNumber = 18,
    kNegativeVectorsFieldNumber = 19,
    kCollectionNameFieldNumber = 1,
    kUsingFieldNumber = 9,
    kGroupByFieldNumber = 12,
    kFilterFieldNumber = 4,
    kWithPayloadFieldNumber = 6,
    kParamsFieldNumber = 7,
    kWithVectorsFieldNumber = 10,
    kLookupFromFieldNumber = 11,
    kReadConsistencyFieldNumber = 14,
    kWithLookupFieldNumber = 15,
    kShardKeySelectorFieldNumber = 21,
    kLimitFieldNumber = 5,
    kScoreThresholdFieldNumber = 8,
    kGroupSizeFieldNumber = 13,
    kStrategyFieldNumber = 17,
    kTimeoutFieldNumber = 20,
  };
  // repeated .qdrant.PointId positive = 2;
  int positive_size() const;
  private:
  int _internal_positive_size() const;

  public:
  void clear_positive() ;
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_positive(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL mutable_positive();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& _internal_positive() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL _internal_mutable_positive();
  public:
  const ::qdrant::PointId& positive(int index) const;
  ::qdrant::PointId* PROTOBUF_NONNULL add_positive();
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& positive() const;
  // repeated .qdrant.PointId negative = 3;
  int negative_size() const;
  private:
  int _internal_negative_size() const;

  public:
  void clear_negative() ;
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_negative(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL mutable_negative();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& _internal_negative() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL _internal_mutable_negative();
  public:
  const ::qdrant::PointId& negative(int index) const;
  ::qdrant::PointId* PROTOBUF_NONNULL add_negative();
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& negative() const;
  // repeated .qdrant.Vector positive_vectors = 18;
  int positive_vectors_size() const;
  private:
  int _internal_positive_vectors_size() const;

  public:
  void clear_positive_vectors() ;
  ::qdrant::Vector* PROTOBUF_NONNULL mutable_positive_vectors(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::Vector>* PROTOBUF_NONNULL mutable_positive_vectors();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::Vector>& _internal_positive_vectors() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::Vector>* PROTOBUF_NONNULL _internal_mutable_positive_vectors();
  public:
  const ::qdrant::Vector& positive_vectors(int index) const;
  ::qdrant::Vector* PROTOBUF_NONNULL add_positive_vectors();
  const ::google::protobuf::RepeatedPtrField<::qdrant::Vector>& positive_vectors() const;
  // repeated .qdrant.Vector negative_vectors = 19;
  int negative_vectors_size() const;
  private:
  int _internal_negative_vectors_size() const;

  public:
  void clear_negative_vectors() ;
  ::qdrant::Vector* PROTOBUF_NONNULL mutable_negative_vectors(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::Vector>* PROTOBUF_NONNULL mutable_negative_vectors();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::Vector>& _internal_negative_vectors() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::Vector>* PROTOBUF_NONNULL _internal_mutable_negative_vectors();
  public:
  const ::qdrant::Vector& negative_vectors(int index) const;
  ::qdrant::Vector* PROTOBUF_NONNULL add_negative_vectors();
  const ::google::protobuf::RepeatedPtrField<::qdrant::Vector>& negative_vectors() const;
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional string using = 9;
  bool has_using_() const;
  void clear_using_() ;
  const ::std::string& using_() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_using_(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_using_();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_using_();
  void set_allocated_using_(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_using_() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_using_(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_using_();

  public:
  // string group_by = 12;
  void clear_group_by() ;
  const ::std::string& group_by() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_group_by(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_group_by();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_group_by();
  void set_allocated_group_by(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_group_by() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_group_by(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_group_by();

  public:
  // .qdrant.Filter filter = 4;
  bool has_filter() const;
  void clear_filter() ;
  const ::qdrant::Filter& filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_filter();
  void set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_filter();

  private:
  const ::qdrant::Filter& _internal_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_filter();

  public:
  // .qdrant.WithPayloadSelector with_payload = 6;
  bool has_with_payload() const;
  void clear_with_payload() ;
  const ::qdrant::WithPayloadSelector& with_payload() const;
  [[nodiscard]] ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE release_with_payload();
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL mutable_with_payload();
  void set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_payload();

  private:
  const ::qdrant::WithPayloadSelector& _internal_with_payload() const;
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL _internal_mutable_with_payload();

  public:
  // .qdrant.SearchParams params = 7;
  bool has_params() const;
  void clear_params() ;
  const ::qdrant::SearchParams& params() const;
  [[nodiscard]] ::qdrant::SearchParams* PROTOBUF_NULLABLE release_params();
  ::qdrant::SearchParams* PROTOBUF_NONNULL mutable_params();
  void set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value);
  ::qdrant::SearchParams* PROTOBUF_NULLABLE unsafe_arena_release_params();

  private:
  const ::qdrant::SearchParams& _internal_params() const;
  ::qdrant::SearchParams* PROTOBUF_NONNULL _internal_mutable_params();

  public:
  // optional .qdrant.WithVectorsSelector with_vectors = 10;
  bool has_with_vectors() const;
  void clear_with_vectors() ;
  const ::qdrant::WithVectorsSelector& with_vectors() const;
  [[nodiscard]] ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE release_with_vectors();
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL mutable_with_vectors();
  void set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_vectors();

  private:
  const ::qdrant::WithVectorsSelector& _internal_with_vectors() const;
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL _internal_mutable_with_vectors();

  public:
  // optional .qdrant.LookupLocation lookup_from = 11;
  bool has_lookup_from() const;
  void clear_lookup_from() ;
  const ::qdrant::LookupLocation& lookup_from() const;
  [[nodiscard]] ::qdrant::LookupLocation* PROTOBUF_NULLABLE release_lookup_from();
  ::qdrant::LookupLocation* PROTOBUF_NONNULL mutable_lookup_from();
  void set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value);
  ::qdrant::LookupLocation* PROTOBUF_NULLABLE unsafe_arena_release_lookup_from();

  private:
  const ::qdrant::LookupLocation& _internal_lookup_from() const;
  ::qdrant::LookupLocation* PROTOBUF_NONNULL _internal_mutable_lookup_from();

  public:
  // optional .qdrant.ReadConsistency read_consistency = 14;
  bool has_read_consistency() const;
  void clear_read_consistency() ;
  const ::qdrant::ReadConsistency& read_consistency() const;
  [[nodiscard]] ::qdrant::ReadConsistency* PROTOBUF_NULLABLE release_read_consistency();
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL mutable_read_consistency();
  void set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  ::qdrant::ReadConsistency* PROTOBUF_NULLABLE unsafe_arena_release_read_consistency();

  private:
  const ::qdrant::ReadConsistency& _internal_read_consistency() const;
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL _internal_mutable_read_consistency();

  public:
  // optional .qdrant.WithLookup with_lookup = 15;
  bool has_with_lookup() const;
  void clear_with_lookup() ;
  const ::qdrant::WithLookup& with_lookup() const;
  [[nodiscard]] ::qdrant::WithLookup* PROTOBUF_NULLABLE release_with_lookup();
  ::qdrant::WithLookup* PROTOBUF_NONNULL mutable_with_lookup();
  void set_allocated_with_lookup(::qdrant::WithLookup* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_lookup(::qdrant::WithLookup* PROTOBUF_NULLABLE value);
  ::qdrant::WithLookup* PROTOBUF_NULLABLE unsafe_arena_release_with_lookup();

  private:
  const ::qdrant::WithLookup& _internal_with_lookup() const;
  ::qdrant::WithLookup* PROTOBUF_NONNULL _internal_mutable_with_lookup();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 21;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // uint32 limit = 5;
  void clear_limit() ;
  ::uint32_t limit() const;
  void set_limit(::uint32_t value);

  private:
  ::uint32_t _internal_limit() const;
  void _internal_set_limit(::uint32_t value);

  public:
  // optional float score_threshold = 8;
  bool has_score_threshold() const;
  void clear_score_threshold() ;
  float score_threshold() const;
  void set_score_threshold(float value);

  private:
  float _internal_score_threshold() const;
  void _internal_set_score_threshold(float value);

  public:
  // uint32 group_size = 13;
  void clear_group_size() ;
  ::uint32_t group_size() const;
  void set_group_size(::uint32_t value);

  private:
  ::uint32_t _internal_group_size() const;
  void _internal_set_group_size(::uint32_t value);

  public:
  // optional .qdrant.RecommendStrategy strategy = 17;
  bool has_strategy() const;
  void clear_strategy() ;
  ::qdrant::RecommendStrategy strategy() const;
  void set_strategy(::qdrant::RecommendStrategy value);

  private:
  ::qdrant::RecommendStrategy _internal_strategy() const;
  void _internal_set_strategy(::qdrant::RecommendStrategy value);

  public:
  // optional uint64 timeout = 20;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.RecommendPointGroups)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 20,
                                   12, 80,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RecommendPointGroups& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::PointId > positive_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::PointId > negative_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::Vector > positive_vectors_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::Vector > negative_vectors_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::google::protobuf::internal::ArenaStringPtr using__;
    ::google::protobuf::internal::ArenaStringPtr group_by_;
    ::qdrant::Filter* PROTOBUF_NULLABLE filter_;
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE with_payload_;
    ::qdrant::SearchParams* PROTOBUF_NULLABLE params_;
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE with_vectors_;
    ::qdrant::LookupLocation* PROTOBUF_NULLABLE lookup_from_;
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE read_consistency_;
    ::qdrant::WithLookup* PROTOBUF_NULLABLE with_lookup_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::uint32_t limit_;
    float score_threshold_;
    ::uint32_t group_size_;
    int strategy_;
    ::uint64_t timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RecommendPointGroups_class_data_;
// -------------------------------------------------------------------

class PointsSelector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PointsSelector) */ {
 public:
  inline PointsSelector() : PointsSelector(nullptr) {}
  ~PointsSelector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointsSelector* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointsSelector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointsSelector(::google::protobuf::internal::ConstantInitialized);

  inline PointsSelector(const PointsSelector& from) : PointsSelector(nullptr, from) {}
  inline PointsSelector(PointsSelector&& from) noexcept
      : PointsSelector(nullptr, ::std::move(from)) {}
  inline PointsSelector& operator=(const PointsSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointsSelector& operator=(PointsSelector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointsSelector& default_instance() {
    return *reinterpret_cast<const PointsSelector*>(
        &_PointsSelector_default_instance_);
  }
  enum PointsSelectorOneOfCase {
    kPoints = 1,
    kFilter = 2,
    POINTS_SELECTOR_ONE_OF_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 148;
  friend void swap(PointsSelector& a, PointsSelector& b) { a.Swap(&b); }
  inline void Swap(PointsSelector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointsSelector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointsSelector* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointsSelector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointsSelector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointsSelector& from) { PointsSelector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointsSelector* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PointsSelector"; }

  explicit PointsSelector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointsSelector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointsSelector& from);
  PointsSelector(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointsSelector&& from) noexcept
      : PointsSelector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPointsFieldNumber = 1,
    kFilterFieldNumber = 2,
  };
  // .qdrant.PointsIdsList points = 1;
  bool has_points() const;
  private:
  bool _internal_has_points() const;

  public:
  void clear_points() ;
  const ::qdrant::PointsIdsList& points() const;
  [[nodiscard]] ::qdrant::PointsIdsList* PROTOBUF_NULLABLE release_points();
  ::qdrant::PointsIdsList* PROTOBUF_NONNULL mutable_points();
  void set_allocated_points(::qdrant::PointsIdsList* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_points(::qdrant::PointsIdsList* PROTOBUF_NULLABLE value);
  ::qdrant::PointsIdsList* PROTOBUF_NULLABLE unsafe_arena_release_points();

  private:
  const ::qdrant::PointsIdsList& _internal_points() const;
  ::qdrant::PointsIdsList* PROTOBUF_NONNULL _internal_mutable_points();

  public:
  // .qdrant.Filter filter = 2;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;

  public:
  void clear_filter() ;
  const ::qdrant::Filter& filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_filter();
  void set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_filter();

  private:
  const ::qdrant::Filter& _internal_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_filter();

  public:
  void clear_points_selector_one_of();
  PointsSelectorOneOfCase points_selector_one_of_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.PointsSelector)
 private:
  class _Internal;
  void set_has_points();
  void set_has_filter();
  inline bool has_points_selector_one_of() const;
  inline void clear_has_points_selector_one_of();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointsSelector& from_msg);
    union PointsSelectorOneOfUnion {
      constexpr PointsSelectorOneOfUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::qdrant::PointsIdsList* PROTOBUF_NULLABLE points_;
      ::qdrant::Filter* PROTOBUF_NULLABLE filter_;
    } points_selector_one_of_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointsSelector_class_data_;
// -------------------------------------------------------------------

class NamedVectors final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.NamedVectors) */ {
 public:
  inline NamedVectors() : NamedVectors(nullptr) {}
  ~NamedVectors() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NamedVectors* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NamedVectors));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NamedVectors(::google::protobuf::internal::ConstantInitialized);

  inline NamedVectors(const NamedVectors& from) : NamedVectors(nullptr, from) {}
  inline NamedVectors(NamedVectors&& from) noexcept
      : NamedVectors(nullptr, ::std::move(from)) {}
  inline NamedVectors& operator=(const NamedVectors& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedVectors& operator=(NamedVectors&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedVectors& default_instance() {
    return *reinterpret_cast<const NamedVectors*>(
        &_NamedVectors_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(NamedVectors& a, NamedVectors& b) { a.Swap(&b); }
  inline void Swap(NamedVectors* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedVectors* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedVectors* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NamedVectors>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NamedVectors& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NamedVectors& from) { NamedVectors::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NamedVectors* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.NamedVectors"; }

  explicit NamedVectors(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NamedVectors(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NamedVectors& from);
  NamedVectors(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NamedVectors&& from) noexcept
      : NamedVectors(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVectorsFieldNumber = 1,
  };
  // map<string, .qdrant.Vector> vectors = 1;
  int vectors_size() const;
  private:
  int _internal_vectors_size() const;

  public:
  void clear_vectors() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::Vector>& vectors() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Vector>* PROTOBUF_NONNULL mutable_vectors();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::Vector>& _internal_vectors() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Vector>* PROTOBUF_NONNULL _internal_mutable_vectors();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.NamedVectors)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   2, 35,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NamedVectors& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<NamedVectors_VectorsEntry_DoNotUse, ::std::string, ::qdrant::Vector,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        vectors_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NamedVectors_class_data_;
// -------------------------------------------------------------------

class FacetCounts final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.FacetCounts) */ {
 public:
  inline FacetCounts() : FacetCounts(nullptr) {}
  ~FacetCounts() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FacetCounts* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FacetCounts));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FacetCounts(::google::protobuf::internal::ConstantInitialized);

  inline FacetCounts(const FacetCounts& from) : FacetCounts(nullptr, from) {}
  inline FacetCounts(FacetCounts&& from) noexcept
      : FacetCounts(nullptr, ::std::move(from)) {}
  inline FacetCounts& operator=(const FacetCounts& from) {
    CopyFrom(from);
    return *this;
  }
  inline FacetCounts& operator=(FacetCounts&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FacetCounts& default_instance() {
    return *reinterpret_cast<const FacetCounts*>(
        &_FacetCounts_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 80;
  friend void swap(FacetCounts& a, FacetCounts& b) { a.Swap(&b); }
  inline void Swap(FacetCounts* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FacetCounts* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FacetCounts* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FacetCounts>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FacetCounts& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FacetCounts& from) { FacetCounts::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FacetCounts* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.FacetCounts"; }

  explicit FacetCounts(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FacetCounts(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FacetCounts& from);
  FacetCounts(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FacetCounts&& from) noexcept
      : FacetCounts(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kKeyFieldNumber = 2,
    kFilterFieldNumber = 3,
    kReadConsistencyFieldNumber = 7,
    kShardKeySelectorFieldNumber = 8,
    kLimitFieldNumber = 4,
    kTimeoutFieldNumber = 6,
    kExactFieldNumber = 5,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // string key = 2;
  void clear_key() ;
  const ::std::string& key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_key();
  void set_allocated_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_key();

  public:
  // optional .qdrant.Filter filter = 3;
  bool has_filter() const;
  void clear_filter() ;
  const ::qdrant::Filter& filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_filter();
  void set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_filter();

  private:
  const ::qdrant::Filter& _internal_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_filter();

  public:
  // optional .qdrant.ReadConsistency read_consistency = 7;
  bool has_read_consistency() const;
  void clear_read_consistency() ;
  const ::qdrant::ReadConsistency& read_consistency() const;
  [[nodiscard]] ::qdrant::ReadConsistency* PROTOBUF_NULLABLE release_read_consistency();
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL mutable_read_consistency();
  void set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  ::qdrant::ReadConsistency* PROTOBUF_NULLABLE unsafe_arena_release_read_consistency();

  private:
  const ::qdrant::ReadConsistency& _internal_read_consistency() const;
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL _internal_mutable_read_consistency();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 8;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional uint64 limit = 4;
  bool has_limit() const;
  void clear_limit() ;
  ::uint64_t limit() const;
  void set_limit(::uint64_t value);

  private:
  ::uint64_t _internal_limit() const;
  void _internal_set_limit(::uint64_t value);

  public:
  // optional uint64 timeout = 6;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // optional bool exact = 5;
  bool has_exact() const;
  void clear_exact() ;
  bool exact() const;
  void set_exact(bool value);

  private:
  bool _internal_exact() const;
  void _internal_set_exact(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.FacetCounts)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   3, 53,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FacetCounts& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::qdrant::Filter* PROTOBUF_NULLABLE filter_;
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE read_consistency_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::uint64_t limit_;
    ::uint64_t timeout_;
    bool exact_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FacetCounts_class_data_;
// -------------------------------------------------------------------

class DecayParamsExpression final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DecayParamsExpression) */ {
 public:
  inline DecayParamsExpression() : DecayParamsExpression(nullptr) {}
  ~DecayParamsExpression() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DecayParamsExpression* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DecayParamsExpression));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DecayParamsExpression(::google::protobuf::internal::ConstantInitialized);

  inline DecayParamsExpression(const DecayParamsExpression& from) : DecayParamsExpression(nullptr, from) {}
  inline DecayParamsExpression(DecayParamsExpression&& from) noexcept
      : DecayParamsExpression(nullptr, ::std::move(from)) {}
  inline DecayParamsExpression& operator=(const DecayParamsExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecayParamsExpression& operator=(DecayParamsExpression&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecayParamsExpression& default_instance() {
    return *reinterpret_cast<const DecayParamsExpression*>(
        &_DecayParamsExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 71;
  friend void swap(DecayParamsExpression& a, DecayParamsExpression& b) { a.Swap(&b); }
  inline void Swap(DecayParamsExpression* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecayParamsExpression* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DecayParamsExpression* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DecayParamsExpression>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DecayParamsExpression& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DecayParamsExpression& from) { DecayParamsExpression::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DecayParamsExpression* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DecayParamsExpression"; }

  explicit DecayParamsExpression(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DecayParamsExpression(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DecayParamsExpression& from);
  DecayParamsExpression(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DecayParamsExpression&& from) noexcept
      : DecayParamsExpression(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kTargetFieldNumber = 2,
    kScaleFieldNumber = 3,
    kMidpointFieldNumber = 4,
  };
  // .qdrant.Expression x = 1;
  bool has_x() const;
  void clear_x() ;
  const ::qdrant::Expression& x() const;
  [[nodiscard]] ::qdrant::Expression* PROTOBUF_NULLABLE release_x();
  ::qdrant::Expression* PROTOBUF_NONNULL mutable_x();
  void set_allocated_x(::qdrant::Expression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_x(::qdrant::Expression* PROTOBUF_NULLABLE value);
  ::qdrant::Expression* PROTOBUF_NULLABLE unsafe_arena_release_x();

  private:
  const ::qdrant::Expression& _internal_x() const;
  ::qdrant::Expression* PROTOBUF_NONNULL _internal_mutable_x();

  public:
  // optional .qdrant.Expression target = 2;
  bool has_target() const;
  void clear_target() ;
  const ::qdrant::Expression& target() const;
  [[nodiscard]] ::qdrant::Expression* PROTOBUF_NULLABLE release_target();
  ::qdrant::Expression* PROTOBUF_NONNULL mutable_target();
  void set_allocated_target(::qdrant::Expression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_target(::qdrant::Expression* PROTOBUF_NULLABLE value);
  ::qdrant::Expression* PROTOBUF_NULLABLE unsafe_arena_release_target();

  private:
  const ::qdrant::Expression& _internal_target() const;
  ::qdrant::Expression* PROTOBUF_NONNULL _internal_mutable_target();

  public:
  // optional float scale = 3;
  bool has_scale() const;
  void clear_scale() ;
  float scale() const;
  void set_scale(float value);

  private:
  float _internal_scale() const;
  void _internal_set_scale(float value);

  public:
  // optional float midpoint = 4;
  bool has_midpoint() const;
  void clear_midpoint() ;
  float midpoint() const;
  void set_midpoint(float value);

  private:
  float _internal_midpoint() const;
  void _internal_set_midpoint(float value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DecayParamsExpression)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DecayParamsExpression& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::Expression* PROTOBUF_NULLABLE x_;
    ::qdrant::Expression* PROTOBUF_NULLABLE target_;
    float scale_;
    float midpoint_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DecayParamsExpression_class_data_;
// -------------------------------------------------------------------

class DivExpression final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DivExpression) */ {
 public:
  inline DivExpression() : DivExpression(nullptr) {}
  ~DivExpression() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DivExpression* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DivExpression));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DivExpression(::google::protobuf::internal::ConstantInitialized);

  inline DivExpression(const DivExpression& from) : DivExpression(nullptr, from) {}
  inline DivExpression(DivExpression&& from) noexcept
      : DivExpression(nullptr, ::std::move(from)) {}
  inline DivExpression& operator=(const DivExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline DivExpression& operator=(DivExpression&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DivExpression& default_instance() {
    return *reinterpret_cast<const DivExpression*>(
        &_DivExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 69;
  friend void swap(DivExpression& a, DivExpression& b) { a.Swap(&b); }
  inline void Swap(DivExpression* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DivExpression* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DivExpression* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DivExpression>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DivExpression& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DivExpression& from) { DivExpression::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DivExpression* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DivExpression"; }

  explicit DivExpression(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DivExpression(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DivExpression& from);
  DivExpression(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DivExpression&& from) noexcept
      : DivExpression(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLeftFieldNumber = 1,
    kRightFieldNumber = 2,
    kByZeroDefaultFieldNumber = 3,
  };
  // .qdrant.Expression left = 1;
  bool has_left() const;
  void clear_left() ;
  const ::qdrant::Expression& left() const;
  [[nodiscard]] ::qdrant::Expression* PROTOBUF_NULLABLE release_left();
  ::qdrant::Expression* PROTOBUF_NONNULL mutable_left();
  void set_allocated_left(::qdrant::Expression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_left(::qdrant::Expression* PROTOBUF_NULLABLE value);
  ::qdrant::Expression* PROTOBUF_NULLABLE unsafe_arena_release_left();

  private:
  const ::qdrant::Expression& _internal_left() const;
  ::qdrant::Expression* PROTOBUF_NONNULL _internal_mutable_left();

  public:
  // .qdrant.Expression right = 2;
  bool has_right() const;
  void clear_right() ;
  const ::qdrant::Expression& right() const;
  [[nodiscard]] ::qdrant::Expression* PROTOBUF_NULLABLE release_right();
  ::qdrant::Expression* PROTOBUF_NONNULL mutable_right();
  void set_allocated_right(::qdrant::Expression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_right(::qdrant::Expression* PROTOBUF_NULLABLE value);
  ::qdrant::Expression* PROTOBUF_NULLABLE unsafe_arena_release_right();

  private:
  const ::qdrant::Expression& _internal_right() const;
  ::qdrant::Expression* PROTOBUF_NONNULL _internal_mutable_right();

  public:
  // optional float by_zero_default = 3;
  bool has_by_zero_default() const;
  void clear_by_zero_default() ;
  float by_zero_default() const;
  void set_by_zero_default(float value);

  private:
  float _internal_by_zero_default() const;
  void _internal_set_by_zero_default(float value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DivExpression)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DivExpression& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::Expression* PROTOBUF_NULLABLE left_;
    ::qdrant::Expression* PROTOBUF_NULLABLE right_;
    float by_zero_default_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DivExpression_class_data_;
// -------------------------------------------------------------------

class Expression final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.Expression) */ {
 public:
  inline Expression() : Expression(nullptr) {}
  ~Expression() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression(::google::protobuf::internal::ConstantInitialized);

  inline Expression(const Expression& from) : Expression(nullptr, from) {}
  inline Expression(Expression&& from) noexcept
      : Expression(nullptr, ::std::move(from)) {}
  inline Expression& operator=(const Expression& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression& operator=(Expression&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression& default_instance() {
    return *reinterpret_cast<const Expression*>(
        &_Expression_default_instance_);
  }
  enum VariantCase {
    kConstant = 1,
    kVariable = 2,
    kCondition = 3,
    kGeoDistance = 4,
    kDatetime = 5,
    kDatetimeKey = 6,
    kMult = 7,
    kSum = 8,
    kDiv = 9,
    kNeg = 10,
    kAbs = 11,
    kSqrt = 12,
    kPow = 13,
    kExp = 14,
    kLog10 = 15,
    kLn = 16,
    kExpDecay = 17,
    kGaussDecay = 18,
    kLinDecay = 19,
    VARIANT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 65;
  friend void swap(Expression& a, Expression& b) { a.Swap(&b); }
  inline void Swap(Expression* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression& from) { Expression::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.Expression"; }

  explicit Expression(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Expression(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Expression& from);
  Expression(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Expression&& from) noexcept
      : Expression(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConstantFieldNumber = 1,
    kVariableFieldNumber = 2,
    kConditionFieldNumber = 3,
    kGeoDistanceFieldNumber = 4,
    kDatetimeFieldNumber = 5,
    kDatetimeKeyFieldNumber = 6,
    kMultFieldNumber = 7,
    kSumFieldNumber = 8,
    kDivFieldNumber = 9,
    kNegFieldNumber = 10,
    kAbsFieldNumber = 11,
    kSqrtFieldNumber = 12,
    kPowFieldNumber = 13,
    kExpFieldNumber = 14,
    kLog10FieldNumber = 15,
    kLnFieldNumber = 16,
    kExpDecayFieldNumber = 17,
    kGaussDecayFieldNumber = 18,
    kLinDecayFieldNumber = 19,
  };
  // float constant = 1;
  bool has_constant() const;
  void clear_constant() ;
  float constant() const;
  void set_constant(float value);

  private:
  float _internal_constant() const;
  void _internal_set_constant(float value);

  public:
  // string variable = 2;
  bool has_variable() const;
  void clear_variable() ;
  const ::std::string& variable() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_variable(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_variable();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_variable();
  void set_allocated_variable(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_variable() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_variable(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_variable();

  public:
  // .qdrant.Condition condition = 3;
  bool has_condition() const;
  private:
  bool _internal_has_condition() const;

  public:
  void clear_condition() ;
  const ::qdrant::Condition& condition() const;
  [[nodiscard]] ::qdrant::Condition* PROTOBUF_NULLABLE release_condition();
  ::qdrant::Condition* PROTOBUF_NONNULL mutable_condition();
  void set_allocated_condition(::qdrant::Condition* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_condition(::qdrant::Condition* PROTOBUF_NULLABLE value);
  ::qdrant::Condition* PROTOBUF_NULLABLE unsafe_arena_release_condition();

  private:
  const ::qdrant::Condition& _internal_condition() const;
  ::qdrant::Condition* PROTOBUF_NONNULL _internal_mutable_condition();

  public:
  // .qdrant.GeoDistance geo_distance = 4;
  bool has_geo_distance() const;
  private:
  bool _internal_has_geo_distance() const;

  public:
  void clear_geo_distance() ;
  const ::qdrant::GeoDistance& geo_distance() const;
  [[nodiscard]] ::qdrant::GeoDistance* PROTOBUF_NULLABLE release_geo_distance();
  ::qdrant::GeoDistance* PROTOBUF_NONNULL mutable_geo_distance();
  void set_allocated_geo_distance(::qdrant::GeoDistance* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_geo_distance(::qdrant::GeoDistance* PROTOBUF_NULLABLE value);
  ::qdrant::GeoDistance* PROTOBUF_NULLABLE unsafe_arena_release_geo_distance();

  private:
  const ::qdrant::GeoDistance& _internal_geo_distance() const;
  ::qdrant::GeoDistance* PROTOBUF_NONNULL _internal_mutable_geo_distance();

  public:
  // string datetime = 5;
  bool has_datetime() const;
  void clear_datetime() ;
  const ::std::string& datetime() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_datetime(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_datetime();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_datetime();
  void set_allocated_datetime(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_datetime() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_datetime(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_datetime();

  public:
  // string datetime_key = 6;
  bool has_datetime_key() const;
  void clear_datetime_key() ;
  const ::std::string& datetime_key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_datetime_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_datetime_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_datetime_key();
  void set_allocated_datetime_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_datetime_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_datetime_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_datetime_key();

  public:
  // .qdrant.MultExpression mult = 7;
  bool has_mult() const;
  private:
  bool _internal_has_mult() const;

  public:
  void clear_mult() ;
  const ::qdrant::MultExpression& mult() const;
  [[nodiscard]] ::qdrant::MultExpression* PROTOBUF_NULLABLE release_mult();
  ::qdrant::MultExpression* PROTOBUF_NONNULL mutable_mult();
  void set_allocated_mult(::qdrant::MultExpression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_mult(::qdrant::MultExpression* PROTOBUF_NULLABLE value);
  ::qdrant::MultExpression* PROTOBUF_NULLABLE unsafe_arena_release_mult();

  private:
  const ::qdrant::MultExpression& _internal_mult() const;
  ::qdrant::MultExpression* PROTOBUF_NONNULL _internal_mutable_mult();

  public:
  // .qdrant.SumExpression sum = 8;
  bool has_sum() const;
  private:
  bool _internal_has_sum() const;

  public:
  void clear_sum() ;
  const ::qdrant::SumExpression& sum() const;
  [[nodiscard]] ::qdrant::SumExpression* PROTOBUF_NULLABLE release_sum();
  ::qdrant::SumExpression* PROTOBUF_NONNULL mutable_sum();
  void set_allocated_sum(::qdrant::SumExpression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sum(::qdrant::SumExpression* PROTOBUF_NULLABLE value);
  ::qdrant::SumExpression* PROTOBUF_NULLABLE unsafe_arena_release_sum();

  private:
  const ::qdrant::SumExpression& _internal_sum() const;
  ::qdrant::SumExpression* PROTOBUF_NONNULL _internal_mutable_sum();

  public:
  // .qdrant.DivExpression div = 9;
  bool has_div() const;
  private:
  bool _internal_has_div() const;

  public:
  void clear_div() ;
  const ::qdrant::DivExpression& div() const;
  [[nodiscard]] ::qdrant::DivExpression* PROTOBUF_NULLABLE release_div();
  ::qdrant::DivExpression* PROTOBUF_NONNULL mutable_div();
  void set_allocated_div(::qdrant::DivExpression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_div(::qdrant::DivExpression* PROTOBUF_NULLABLE value);
  ::qdrant::DivExpression* PROTOBUF_NULLABLE unsafe_arena_release_div();

  private:
  const ::qdrant::DivExpression& _internal_div() const;
  ::qdrant::DivExpression* PROTOBUF_NONNULL _internal_mutable_div();

  public:
  // .qdrant.Expression neg = 10;
  bool has_neg() const;
  private:
  bool _internal_has_neg() const;

  public:
  void clear_neg() ;
  const ::qdrant::Expression& neg() const;
  [[nodiscard]] ::qdrant::Expression* PROTOBUF_NULLABLE release_neg();
  ::qdrant::Expression* PROTOBUF_NONNULL mutable_neg();
  void set_allocated_neg(::qdrant::Expression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_neg(::qdrant::Expression* PROTOBUF_NULLABLE value);
  ::qdrant::Expression* PROTOBUF_NULLABLE unsafe_arena_release_neg();

  private:
  const ::qdrant::Expression& _internal_neg() const;
  ::qdrant::Expression* PROTOBUF_NONNULL _internal_mutable_neg();

  public:
  // .qdrant.Expression abs = 11;
  bool has_abs() const;
  private:
  bool _internal_has_abs() const;

  public:
  void clear_abs() ;
  const ::qdrant::Expression& abs() const;
  [[nodiscard]] ::qdrant::Expression* PROTOBUF_NULLABLE release_abs();
  ::qdrant::Expression* PROTOBUF_NONNULL mutable_abs();
  void set_allocated_abs(::qdrant::Expression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_abs(::qdrant::Expression* PROTOBUF_NULLABLE value);
  ::qdrant::Expression* PROTOBUF_NULLABLE unsafe_arena_release_abs();

  private:
  const ::qdrant::Expression& _internal_abs() const;
  ::qdrant::Expression* PROTOBUF_NONNULL _internal_mutable_abs();

  public:
  // .qdrant.Expression sqrt = 12;
  bool has_sqrt() const;
  private:
  bool _internal_has_sqrt() const;

  public:
  void clear_sqrt() ;
  const ::qdrant::Expression& sqrt() const;
  [[nodiscard]] ::qdrant::Expression* PROTOBUF_NULLABLE release_sqrt();
  ::qdrant::Expression* PROTOBUF_NONNULL mutable_sqrt();
  void set_allocated_sqrt(::qdrant::Expression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sqrt(::qdrant::Expression* PROTOBUF_NULLABLE value);
  ::qdrant::Expression* PROTOBUF_NULLABLE unsafe_arena_release_sqrt();

  private:
  const ::qdrant::Expression& _internal_sqrt() const;
  ::qdrant::Expression* PROTOBUF_NONNULL _internal_mutable_sqrt();

  public:
  // .qdrant.PowExpression pow = 13;
  bool has_pow() const;
  private:
  bool _internal_has_pow() const;

  public:
  void clear_pow() ;
  const ::qdrant::PowExpression& pow() const;
  [[nodiscard]] ::qdrant::PowExpression* PROTOBUF_NULLABLE release_pow();
  ::qdrant::PowExpression* PROTOBUF_NONNULL mutable_pow();
  void set_allocated_pow(::qdrant::PowExpression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pow(::qdrant::PowExpression* PROTOBUF_NULLABLE value);
  ::qdrant::PowExpression* PROTOBUF_NULLABLE unsafe_arena_release_pow();

  private:
  const ::qdrant::PowExpression& _internal_pow() const;
  ::qdrant::PowExpression* PROTOBUF_NONNULL _internal_mutable_pow();

  public:
  // .qdrant.Expression exp = 14;
  bool has_exp() const;
  private:
  bool _internal_has_exp() const;

  public:
  void clear_exp() ;
  const ::qdrant::Expression& exp() const;
  [[nodiscard]] ::qdrant::Expression* PROTOBUF_NULLABLE release_exp();
  ::qdrant::Expression* PROTOBUF_NONNULL mutable_exp();
  void set_allocated_exp(::qdrant::Expression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_exp(::qdrant::Expression* PROTOBUF_NULLABLE value);
  ::qdrant::Expression* PROTOBUF_NULLABLE unsafe_arena_release_exp();

  private:
  const ::qdrant::Expression& _internal_exp() const;
  ::qdrant::Expression* PROTOBUF_NONNULL _internal_mutable_exp();

  public:
  // .qdrant.Expression log10 = 15;
  bool has_log10() const;
  private:
  bool _internal_has_log10() const;

  public:
  void clear_log10() ;
  const ::qdrant::Expression& log10() const;
  [[nodiscard]] ::qdrant::Expression* PROTOBUF_NULLABLE release_log10();
  ::qdrant::Expression* PROTOBUF_NONNULL mutable_log10();
  void set_allocated_log10(::qdrant::Expression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_log10(::qdrant::Expression* PROTOBUF_NULLABLE value);
  ::qdrant::Expression* PROTOBUF_NULLABLE unsafe_arena_release_log10();

  private:
  const ::qdrant::Expression& _internal_log10() const;
  ::qdrant::Expression* PROTOBUF_NONNULL _internal_mutable_log10();

  public:
  // .qdrant.Expression ln = 16;
  bool has_ln() const;
  private:
  bool _internal_has_ln() const;

  public:
  void clear_ln() ;
  const ::qdrant::Expression& ln() const;
  [[nodiscard]] ::qdrant::Expression* PROTOBUF_NULLABLE release_ln();
  ::qdrant::Expression* PROTOBUF_NONNULL mutable_ln();
  void set_allocated_ln(::qdrant::Expression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ln(::qdrant::Expression* PROTOBUF_NULLABLE value);
  ::qdrant::Expression* PROTOBUF_NULLABLE unsafe_arena_release_ln();

  private:
  const ::qdrant::Expression& _internal_ln() const;
  ::qdrant::Expression* PROTOBUF_NONNULL _internal_mutable_ln();

  public:
  // .qdrant.DecayParamsExpression exp_decay = 17;
  bool has_exp_decay() const;
  private:
  bool _internal_has_exp_decay() const;

  public:
  void clear_exp_decay() ;
  const ::qdrant::DecayParamsExpression& exp_decay() const;
  [[nodiscard]] ::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE release_exp_decay();
  ::qdrant::DecayParamsExpression* PROTOBUF_NONNULL mutable_exp_decay();
  void set_allocated_exp_decay(::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_exp_decay(::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE value);
  ::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE unsafe_arena_release_exp_decay();

  private:
  const ::qdrant::DecayParamsExpression& _internal_exp_decay() const;
  ::qdrant::DecayParamsExpression* PROTOBUF_NONNULL _internal_mutable_exp_decay();

  public:
  // .qdrant.DecayParamsExpression gauss_decay = 18;
  bool has_gauss_decay() const;
  private:
  bool _internal_has_gauss_decay() const;

  public:
  void clear_gauss_decay() ;
  const ::qdrant::DecayParamsExpression& gauss_decay() const;
  [[nodiscard]] ::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE release_gauss_decay();
  ::qdrant::DecayParamsExpression* PROTOBUF_NONNULL mutable_gauss_decay();
  void set_allocated_gauss_decay(::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gauss_decay(::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE value);
  ::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE unsafe_arena_release_gauss_decay();

  private:
  const ::qdrant::DecayParamsExpression& _internal_gauss_decay() const;
  ::qdrant::DecayParamsExpression* PROTOBUF_NONNULL _internal_mutable_gauss_decay();

  public:
  // .qdrant.DecayParamsExpression lin_decay = 19;
  bool has_lin_decay() const;
  private:
  bool _internal_has_lin_decay() const;

  public:
  void clear_lin_decay() ;
  const ::qdrant::DecayParamsExpression& lin_decay() const;
  [[nodiscard]] ::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE release_lin_decay();
  ::qdrant::DecayParamsExpression* PROTOBUF_NONNULL mutable_lin_decay();
  void set_allocated_lin_decay(::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lin_decay(::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE value);
  ::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE unsafe_arena_release_lin_decay();

  private:
  const ::qdrant::DecayParamsExpression& _internal_lin_decay() const;
  ::qdrant::DecayParamsExpression* PROTOBUF_NONNULL _internal_mutable_lin_decay();

  public:
  void clear_variant();
  VariantCase variant_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.Expression)
 private:
  class _Internal;
  void set_has_constant();
  void set_has_variable();
  void set_has_condition();
  void set_has_geo_distance();
  void set_has_datetime();
  void set_has_datetime_key();
  void set_has_mult();
  void set_has_sum();
  void set_has_div();
  void set_has_neg();
  void set_has_abs();
  void set_has_sqrt();
  void set_has_pow();
  void set_has_exp();
  void set_has_log10();
  void set_has_ln();
  void set_has_exp_decay();
  void set_has_gauss_decay();
  void set_has_lin_decay();
  inline bool has_variant() const;
  inline void clear_has_variant();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 19,
                                   15, 70,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Expression& from_msg);
    union VariantUnion {
      constexpr VariantUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      float constant_;
      ::google::protobuf::internal::ArenaStringPtr variable_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE condition_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE geo_distance_;
      ::google::protobuf::internal::ArenaStringPtr datetime_;
      ::google::protobuf::internal::ArenaStringPtr datetime_key_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE mult_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE sum_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE div_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE neg_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE abs_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE sqrt_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE pow_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE exp_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE log10_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE ln_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE exp_decay_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE gauss_decay_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE lin_decay_;
    } variant_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_class_data_;
// -------------------------------------------------------------------

class MultExpression final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.MultExpression) */ {
 public:
  inline MultExpression() : MultExpression(nullptr) {}
  ~MultExpression() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MultExpression* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MultExpression));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MultExpression(::google::protobuf::internal::ConstantInitialized);

  inline MultExpression(const MultExpression& from) : MultExpression(nullptr, from) {}
  inline MultExpression(MultExpression&& from) noexcept
      : MultExpression(nullptr, ::std::move(from)) {}
  inline MultExpression& operator=(const MultExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultExpression& operator=(MultExpression&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultExpression& default_instance() {
    return *reinterpret_cast<const MultExpression*>(
        &_MultExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 67;
  friend void swap(MultExpression& a, MultExpression& b) { a.Swap(&b); }
  inline void Swap(MultExpression* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultExpression* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultExpression* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MultExpression>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MultExpression& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MultExpression& from) { MultExpression::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MultExpression* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.MultExpression"; }

  explicit MultExpression(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MultExpression(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MultExpression& from);
  MultExpression(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MultExpression&& from) noexcept
      : MultExpression(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMultFieldNumber = 1,
  };
  // repeated .qdrant.Expression mult = 1;
  int mult_size() const;
  private:
  int _internal_mult_size() const;

  public:
  void clear_mult() ;
  ::qdrant::Expression* PROTOBUF_NONNULL mutable_mult(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::Expression>* PROTOBUF_NONNULL mutable_mult();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::Expression>& _internal_mult() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::Expression>* PROTOBUF_NONNULL _internal_mutable_mult();
  public:
  const ::qdrant::Expression& mult(int index) const;
  ::qdrant::Expression* PROTOBUF_NONNULL add_mult();
  const ::google::protobuf::RepeatedPtrField<::qdrant::Expression>& mult() const;
  // @@protoc_insertion_point(class_scope:qdrant.MultExpression)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MultExpression& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::Expression > mult_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MultExpression_class_data_;
// -------------------------------------------------------------------

class PowExpression final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PowExpression) */ {
 public:
  inline PowExpression() : PowExpression(nullptr) {}
  ~PowExpression() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PowExpression* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PowExpression));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PowExpression(::google::protobuf::internal::ConstantInitialized);

  inline PowExpression(const PowExpression& from) : PowExpression(nullptr, from) {}
  inline PowExpression(PowExpression&& from) noexcept
      : PowExpression(nullptr, ::std::move(from)) {}
  inline PowExpression& operator=(const PowExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline PowExpression& operator=(PowExpression&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PowExpression& default_instance() {
    return *reinterpret_cast<const PowExpression*>(
        &_PowExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 70;
  friend void swap(PowExpression& a, PowExpression& b) { a.Swap(&b); }
  inline void Swap(PowExpression* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PowExpression* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PowExpression* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PowExpression>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PowExpression& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PowExpression& from) { PowExpression::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PowExpression* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PowExpression"; }

  explicit PowExpression(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PowExpression(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PowExpression& from);
  PowExpression(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PowExpression&& from) noexcept
      : PowExpression(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBaseFieldNumber = 1,
    kExponentFieldNumber = 2,
  };
  // .qdrant.Expression base = 1;
  bool has_base() const;
  void clear_base() ;
  const ::qdrant::Expression& base() const;
  [[nodiscard]] ::qdrant::Expression* PROTOBUF_NULLABLE release_base();
  ::qdrant::Expression* PROTOBUF_NONNULL mutable_base();
  void set_allocated_base(::qdrant::Expression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_base(::qdrant::Expression* PROTOBUF_NULLABLE value);
  ::qdrant::Expression* PROTOBUF_NULLABLE unsafe_arena_release_base();

  private:
  const ::qdrant::Expression& _internal_base() const;
  ::qdrant::Expression* PROTOBUF_NONNULL _internal_mutable_base();

  public:
  // .qdrant.Expression exponent = 2;
  bool has_exponent() const;
  void clear_exponent() ;
  const ::qdrant::Expression& exponent() const;
  [[nodiscard]] ::qdrant::Expression* PROTOBUF_NULLABLE release_exponent();
  ::qdrant::Expression* PROTOBUF_NONNULL mutable_exponent();
  void set_allocated_exponent(::qdrant::Expression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_exponent(::qdrant::Expression* PROTOBUF_NULLABLE value);
  ::qdrant::Expression* PROTOBUF_NULLABLE unsafe_arena_release_exponent();

  private:
  const ::qdrant::Expression& _internal_exponent() const;
  ::qdrant::Expression* PROTOBUF_NONNULL _internal_mutable_exponent();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.PowExpression)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PowExpression& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::Expression* PROTOBUF_NULLABLE base_;
    ::qdrant::Expression* PROTOBUF_NULLABLE exponent_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PowExpression_class_data_;
// -------------------------------------------------------------------

class SumExpression final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SumExpression) */ {
 public:
  inline SumExpression() : SumExpression(nullptr) {}
  ~SumExpression() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SumExpression* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SumExpression));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SumExpression(::google::protobuf::internal::ConstantInitialized);

  inline SumExpression(const SumExpression& from) : SumExpression(nullptr, from) {}
  inline SumExpression(SumExpression&& from) noexcept
      : SumExpression(nullptr, ::std::move(from)) {}
  inline SumExpression& operator=(const SumExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline SumExpression& operator=(SumExpression&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SumExpression& default_instance() {
    return *reinterpret_cast<const SumExpression*>(
        &_SumExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 68;
  friend void swap(SumExpression& a, SumExpression& b) { a.Swap(&b); }
  inline void Swap(SumExpression* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SumExpression* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SumExpression* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SumExpression>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SumExpression& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SumExpression& from) { SumExpression::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SumExpression* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SumExpression"; }

  explicit SumExpression(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SumExpression(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SumExpression& from);
  SumExpression(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SumExpression&& from) noexcept
      : SumExpression(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSumFieldNumber = 1,
  };
  // repeated .qdrant.Expression sum = 1;
  int sum_size() const;
  private:
  int _internal_sum_size() const;

  public:
  void clear_sum() ;
  ::qdrant::Expression* PROTOBUF_NONNULL mutable_sum(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::Expression>* PROTOBUF_NONNULL mutable_sum();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::Expression>& _internal_sum() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::Expression>* PROTOBUF_NONNULL _internal_mutable_sum();
  public:
  const ::qdrant::Expression& sum(int index) const;
  ::qdrant::Expression* PROTOBUF_NONNULL add_sum();
  const ::google::protobuf::RepeatedPtrField<::qdrant::Expression>& sum() const;
  // @@protoc_insertion_point(class_scope:qdrant.SumExpression)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SumExpression& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::Expression > sum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SumExpression_class_data_;
// -------------------------------------------------------------------

class CountPoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CountPoints) */ {
 public:
  inline CountPoints() : CountPoints(nullptr) {}
  ~CountPoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CountPoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CountPoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CountPoints(::google::protobuf::internal::ConstantInitialized);

  inline CountPoints(const CountPoints& from) : CountPoints(nullptr, from) {}
  inline CountPoints(CountPoints&& from) noexcept
      : CountPoints(nullptr, ::std::move(from)) {}
  inline CountPoints& operator=(const CountPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline CountPoints& operator=(CountPoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CountPoints& default_instance() {
    return *reinterpret_cast<const CountPoints*>(
        &_CountPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 58;
  friend void swap(CountPoints& a, CountPoints& b) { a.Swap(&b); }
  inline void Swap(CountPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CountPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CountPoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CountPoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CountPoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CountPoints& from) { CountPoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CountPoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CountPoints"; }

  explicit CountPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CountPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CountPoints& from);
  CountPoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CountPoints&& from) noexcept
      : CountPoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kFilterFieldNumber = 2,
    kReadConsistencyFieldNumber = 4,
    kShardKeySelectorFieldNumber = 5,
    kTimeoutFieldNumber = 6,
    kExactFieldNumber = 3,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // .qdrant.Filter filter = 2;
  bool has_filter() const;
  void clear_filter() ;
  const ::qdrant::Filter& filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_filter();
  void set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_filter();

  private:
  const ::qdrant::Filter& _internal_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_filter();

  public:
  // optional .qdrant.ReadConsistency read_consistency = 4;
  bool has_read_consistency() const;
  void clear_read_consistency() ;
  const ::qdrant::ReadConsistency& read_consistency() const;
  [[nodiscard]] ::qdrant::ReadConsistency* PROTOBUF_NULLABLE release_read_consistency();
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL mutable_read_consistency();
  void set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  ::qdrant::ReadConsistency* PROTOBUF_NULLABLE unsafe_arena_release_read_consistency();

  private:
  const ::qdrant::ReadConsistency& _internal_read_consistency() const;
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL _internal_mutable_read_consistency();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 5;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional uint64 timeout = 6;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // optional bool exact = 3;
  bool has_exact() const;
  void clear_exact() ;
  bool exact() const;
  void set_exact(bool value);

  private:
  bool _internal_exact() const;
  void _internal_set_exact(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CountPoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   3, 42,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CountPoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::qdrant::Filter* PROTOBUF_NULLABLE filter_;
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE read_consistency_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::uint64_t timeout_;
    bool exact_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CountPoints_class_data_;
// -------------------------------------------------------------------

class ContextInput final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ContextInput) */ {
 public:
  inline ContextInput() : ContextInput(nullptr) {}
  ~ContextInput() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ContextInput* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ContextInput));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContextInput(::google::protobuf::internal::ConstantInitialized);

  inline ContextInput(const ContextInput& from) : ContextInput(nullptr, from) {}
  inline ContextInput(ContextInput&& from) noexcept
      : ContextInput(nullptr, ::std::move(from)) {}
  inline ContextInput& operator=(const ContextInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContextInput& operator=(ContextInput&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContextInput& default_instance() {
    return *reinterpret_cast<const ContextInput*>(
        &_ContextInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 62;
  friend void swap(ContextInput& a, ContextInput& b) { a.Swap(&b); }
  inline void Swap(ContextInput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContextInput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContextInput* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ContextInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ContextInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ContextInput& from) { ContextInput::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ContextInput* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ContextInput"; }

  explicit ContextInput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ContextInput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ContextInput& from);
  ContextInput(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ContextInput&& from) noexcept
      : ContextInput(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPairsFieldNumber = 1,
  };
  // repeated .qdrant.ContextInputPair pairs = 1;
  int pairs_size() const;
  private:
  int _internal_pairs_size() const;

  public:
  void clear_pairs() ;
  ::qdrant::ContextInputPair* PROTOBUF_NONNULL mutable_pairs(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::ContextInputPair>* PROTOBUF_NONNULL mutable_pairs();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::ContextInputPair>& _internal_pairs() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::ContextInputPair>* PROTOBUF_NONNULL _internal_mutable_pairs();
  public:
  const ::qdrant::ContextInputPair& pairs(int index) const;
  ::qdrant::ContextInputPair* PROTOBUF_NONNULL add_pairs();
  const ::google::protobuf::RepeatedPtrField<::qdrant::ContextInputPair>& pairs() const;
  // @@protoc_insertion_point(class_scope:qdrant.ContextInput)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ContextInput& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::ContextInputPair > pairs_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ContextInput_class_data_;
// -------------------------------------------------------------------

class ContextExamplePair final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ContextExamplePair) */ {
 public:
  inline ContextExamplePair() : ContextExamplePair(nullptr) {}
  ~ContextExamplePair() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ContextExamplePair* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ContextExamplePair));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContextExamplePair(::google::protobuf::internal::ConstantInitialized);

  inline ContextExamplePair(const ContextExamplePair& from) : ContextExamplePair(nullptr, from) {}
  inline ContextExamplePair(ContextExamplePair&& from) noexcept
      : ContextExamplePair(nullptr, ::std::move(from)) {}
  inline ContextExamplePair& operator=(const ContextExamplePair& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContextExamplePair& operator=(ContextExamplePair&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContextExamplePair& default_instance() {
    return *reinterpret_cast<const ContextExamplePair*>(
        &_ContextExamplePair_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 55;
  friend void swap(ContextExamplePair& a, ContextExamplePair& b) { a.Swap(&b); }
  inline void Swap(ContextExamplePair* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContextExamplePair* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContextExamplePair* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ContextExamplePair>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ContextExamplePair& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ContextExamplePair& from) { ContextExamplePair::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ContextExamplePair* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ContextExamplePair"; }

  explicit ContextExamplePair(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ContextExamplePair(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ContextExamplePair& from);
  ContextExamplePair(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ContextExamplePair&& from) noexcept
      : ContextExamplePair(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositiveFieldNumber = 1,
    kNegativeFieldNumber = 2,
  };
  // .qdrant.VectorExample positive = 1;
  bool has_positive() const;
  void clear_positive() ;
  const ::qdrant::VectorExample& positive() const;
  [[nodiscard]] ::qdrant::VectorExample* PROTOBUF_NULLABLE release_positive();
  ::qdrant::VectorExample* PROTOBUF_NONNULL mutable_positive();
  void set_allocated_positive(::qdrant::VectorExample* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_positive(::qdrant::VectorExample* PROTOBUF_NULLABLE value);
  ::qdrant::VectorExample* PROTOBUF_NULLABLE unsafe_arena_release_positive();

  private:
  const ::qdrant::VectorExample& _internal_positive() const;
  ::qdrant::VectorExample* PROTOBUF_NONNULL _internal_mutable_positive();

  public:
  // .qdrant.VectorExample negative = 2;
  bool has_negative() const;
  void clear_negative() ;
  const ::qdrant::VectorExample& negative() const;
  [[nodiscard]] ::qdrant::VectorExample* PROTOBUF_NULLABLE release_negative();
  ::qdrant::VectorExample* PROTOBUF_NONNULL mutable_negative();
  void set_allocated_negative(::qdrant::VectorExample* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_negative(::qdrant::VectorExample* PROTOBUF_NULLABLE value);
  ::qdrant::VectorExample* PROTOBUF_NULLABLE unsafe_arena_release_negative();

  private:
  const ::qdrant::VectorExample& _internal_negative() const;
  ::qdrant::VectorExample* PROTOBUF_NONNULL _internal_mutable_negative();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.ContextExamplePair)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ContextExamplePair& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::VectorExample* PROTOBUF_NULLABLE positive_;
    ::qdrant::VectorExample* PROTOBUF_NULLABLE negative_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ContextExamplePair_class_data_;
// -------------------------------------------------------------------

class Vectors final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.Vectors) */ {
 public:
  inline Vectors() : Vectors(nullptr) {}
  ~Vectors() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Vectors* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Vectors));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vectors(::google::protobuf::internal::ConstantInitialized);

  inline Vectors(const Vectors& from) : Vectors(nullptr, from) {}
  inline Vectors(Vectors&& from) noexcept
      : Vectors(nullptr, ::std::move(from)) {}
  inline Vectors& operator=(const Vectors& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vectors& operator=(Vectors&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vectors& default_instance() {
    return *reinterpret_cast<const Vectors*>(
        &_Vectors_default_instance_);
  }
  enum VectorsOptionsCase {
    kVector = 1,
    kVectors = 2,
    VECTORS_OPTIONS_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(Vectors& a, Vectors& b) { a.Swap(&b); }
  inline void Swap(Vectors* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vectors* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vectors* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Vectors>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vectors& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vectors& from) { Vectors::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Vectors* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.Vectors"; }

  explicit Vectors(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Vectors(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Vectors& from);
  Vectors(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Vectors&& from) noexcept
      : Vectors(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVectorFieldNumber = 1,
    kVectorsFieldNumber = 2,
  };
  // .qdrant.Vector vector = 1;
  bool has_vector() const;
  private:
  bool _internal_has_vector() const;

  public:
  void clear_vector() ;
  const ::qdrant::Vector& vector() const;
  [[nodiscard]] ::qdrant::Vector* PROTOBUF_NULLABLE release_vector();
  ::qdrant::Vector* PROTOBUF_NONNULL mutable_vector();
  void set_allocated_vector(::qdrant::Vector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vector(::qdrant::Vector* PROTOBUF_NULLABLE value);
  ::qdrant::Vector* PROTOBUF_NULLABLE unsafe_arena_release_vector();

  private:
  const ::qdrant::Vector& _internal_vector() const;
  ::qdrant::Vector* PROTOBUF_NONNULL _internal_mutable_vector();

  public:
  // .qdrant.NamedVectors vectors = 2;
  bool has_vectors() const;
  private:
  bool _internal_has_vectors() const;

  public:
  void clear_vectors() ;
  const ::qdrant::NamedVectors& vectors() const;
  [[nodiscard]] ::qdrant::NamedVectors* PROTOBUF_NULLABLE release_vectors();
  ::qdrant::NamedVectors* PROTOBUF_NONNULL mutable_vectors();
  void set_allocated_vectors(::qdrant::NamedVectors* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vectors(::qdrant::NamedVectors* PROTOBUF_NULLABLE value);
  ::qdrant::NamedVectors* PROTOBUF_NULLABLE unsafe_arena_release_vectors();

  private:
  const ::qdrant::NamedVectors& _internal_vectors() const;
  ::qdrant::NamedVectors* PROTOBUF_NONNULL _internal_mutable_vectors();

  public:
  void clear_vectors_options();
  VectorsOptionsCase vectors_options_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.Vectors)
 private:
  class _Internal;
  void set_has_vector();
  void set_has_vectors();
  inline bool has_vectors_options() const;
  inline void clear_has_vectors_options();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Vectors& from_msg);
    union VectorsOptionsUnion {
      constexpr VectorsOptionsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::qdrant::Vector* PROTOBUF_NULLABLE vector_;
      ::qdrant::NamedVectors* PROTOBUF_NULLABLE vectors_;
    } vectors_options_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Vectors_class_data_;
// -------------------------------------------------------------------

class SetPayloadPoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SetPayloadPoints) */ {
 public:
  inline SetPayloadPoints() : SetPayloadPoints(nullptr) {}
  ~SetPayloadPoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetPayloadPoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetPayloadPoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetPayloadPoints(::google::protobuf::internal::ConstantInitialized);

  inline SetPayloadPoints(const SetPayloadPoints& from) : SetPayloadPoints(nullptr, from) {}
  inline SetPayloadPoints(SetPayloadPoints&& from) noexcept
      : SetPayloadPoints(nullptr, ::std::move(from)) {}
  inline SetPayloadPoints& operator=(const SetPayloadPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPayloadPoints& operator=(SetPayloadPoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPayloadPoints& default_instance() {
    return *reinterpret_cast<const SetPayloadPoints*>(
        &_SetPayloadPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(SetPayloadPoints& a, SetPayloadPoints& b) { a.Swap(&b); }
  inline void Swap(SetPayloadPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPayloadPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPayloadPoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetPayloadPoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetPayloadPoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetPayloadPoints& from) { SetPayloadPoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetPayloadPoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SetPayloadPoints"; }

  explicit SetPayloadPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SetPayloadPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SetPayloadPoints& from);
  SetPayloadPoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SetPayloadPoints&& from) noexcept
      : SetPayloadPoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kKeyFieldNumber = 8,
    kPointsSelectorFieldNumber = 5,
    kOrderingFieldNumber = 6,
    kShardKeySelectorFieldNumber = 7,
    kWaitFieldNumber = 2,
    kPayloadFieldNumber = 3,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional string key = 8;
  bool has_key() const;
  void clear_key() ;
  const ::std::string& key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_key();
  void set_allocated_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_key();

  public:
  // optional .qdrant.PointsSelector points_selector = 5;
  bool has_points_selector() const;
  void clear_points_selector() ;
  const ::qdrant::PointsSelector& points_selector() const;
  [[nodiscard]] ::qdrant::PointsSelector* PROTOBUF_NULLABLE release_points_selector();
  ::qdrant::PointsSelector* PROTOBUF_NONNULL mutable_points_selector();
  void set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::PointsSelector* PROTOBUF_NULLABLE unsafe_arena_release_points_selector();

  private:
  const ::qdrant::PointsSelector& _internal_points_selector() const;
  ::qdrant::PointsSelector* PROTOBUF_NONNULL _internal_mutable_points_selector();

  public:
  // optional .qdrant.WriteOrdering ordering = 6;
  bool has_ordering() const;
  void clear_ordering() ;
  const ::qdrant::WriteOrdering& ordering() const;
  [[nodiscard]] ::qdrant::WriteOrdering* PROTOBUF_NULLABLE release_ordering();
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL mutable_ordering();
  void set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  ::qdrant::WriteOrdering* PROTOBUF_NULLABLE unsafe_arena_release_ordering();

  private:
  const ::qdrant::WriteOrdering& _internal_ordering() const;
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL _internal_mutable_ordering();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 7;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional bool wait = 2;
  bool has_wait() const;
  void clear_wait() ;
  bool wait() const;
  void set_wait(bool value);

  private:
  bool _internal_wait() const;
  void _internal_set_wait(bool value);

  public:
  // map<string, .qdrant.Value> payload = 3;
  int payload_size() const;
  private:
  int _internal_payload_size() const;

  public:
  void clear_payload() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& payload() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL mutable_payload();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& _internal_payload() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL _internal_mutable_payload();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SetPayloadPoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   5, 57,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SetPayloadPoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE points_selector_;
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE ordering_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    bool wait_;
    ::google::protobuf::internal::MapField<SetPayloadPoints_PayloadEntry_DoNotUse, ::std::string, ::qdrant::Value,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        payload_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SetPayloadPoints_class_data_;
// -------------------------------------------------------------------

class SearchBatchPoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SearchBatchPoints) */ {
 public:
  inline SearchBatchPoints() : SearchBatchPoints(nullptr) {}
  ~SearchBatchPoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SearchBatchPoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SearchBatchPoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SearchBatchPoints(::google::protobuf::internal::ConstantInitialized);

  inline SearchBatchPoints(const SearchBatchPoints& from) : SearchBatchPoints(nullptr, from) {}
  inline SearchBatchPoints(SearchBatchPoints&& from) noexcept
      : SearchBatchPoints(nullptr, ::std::move(from)) {}
  inline SearchBatchPoints& operator=(const SearchBatchPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchBatchPoints& operator=(SearchBatchPoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchBatchPoints& default_instance() {
    return *reinterpret_cast<const SearchBatchPoints*>(
        &_SearchBatchPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 43;
  friend void swap(SearchBatchPoints& a, SearchBatchPoints& b) { a.Swap(&b); }
  inline void Swap(SearchBatchPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchBatchPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchBatchPoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SearchBatchPoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchBatchPoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SearchBatchPoints& from) { SearchBatchPoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SearchBatchPoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SearchBatchPoints"; }

  explicit SearchBatchPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SearchBatchPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SearchBatchPoints& from);
  SearchBatchPoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SearchBatchPoints&& from) noexcept
      : SearchBatchPoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSearchPointsFieldNumber = 2,
    kCollectionNameFieldNumber = 1,
    kReadConsistencyFieldNumber = 3,
    kTimeoutFieldNumber = 4,
  };
  // repeated .qdrant.SearchPoints search_points = 2;
  int search_points_size() const;
  private:
  int _internal_search_points_size() const;

  public:
  void clear_search_points() ;
  ::qdrant::SearchPoints* PROTOBUF_NONNULL mutable_search_points(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::SearchPoints>* PROTOBUF_NONNULL mutable_search_points();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::SearchPoints>& _internal_search_points() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::SearchPoints>* PROTOBUF_NONNULL _internal_mutable_search_points();
  public:
  const ::qdrant::SearchPoints& search_points(int index) const;
  ::qdrant::SearchPoints* PROTOBUF_NONNULL add_search_points();
  const ::google::protobuf::RepeatedPtrField<::qdrant::SearchPoints>& search_points() const;
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional .qdrant.ReadConsistency read_consistency = 3;
  bool has_read_consistency() const;
  void clear_read_consistency() ;
  const ::qdrant::ReadConsistency& read_consistency() const;
  [[nodiscard]] ::qdrant::ReadConsistency* PROTOBUF_NULLABLE release_read_consistency();
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL mutable_read_consistency();
  void set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  ::qdrant::ReadConsistency* PROTOBUF_NULLABLE unsafe_arena_release_read_consistency();

  private:
  const ::qdrant::ReadConsistency& _internal_read_consistency() const;
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL _internal_mutable_read_consistency();

  public:
  // optional uint64 timeout = 4;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SearchBatchPoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   2, 48,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SearchBatchPoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::SearchPoints > search_points_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE read_consistency_;
    ::uint64_t timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SearchBatchPoints_class_data_;
// -------------------------------------------------------------------

class ScoredPoint final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ScoredPoint) */ {
 public:
  inline ScoredPoint() : ScoredPoint(nullptr) {}
  ~ScoredPoint() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ScoredPoint* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ScoredPoint));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ScoredPoint(::google::protobuf::internal::ConstantInitialized);

  inline ScoredPoint(const ScoredPoint& from) : ScoredPoint(nullptr, from) {}
  inline ScoredPoint(ScoredPoint&& from) noexcept
      : ScoredPoint(nullptr, ::std::move(from)) {}
  inline ScoredPoint& operator=(const ScoredPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScoredPoint& operator=(ScoredPoint&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScoredPoint& default_instance() {
    return *reinterpret_cast<const ScoredPoint*>(
        &_ScoredPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 103;
  friend void swap(ScoredPoint& a, ScoredPoint& b) { a.Swap(&b); }
  inline void Swap(ScoredPoint* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScoredPoint* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScoredPoint* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ScoredPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ScoredPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ScoredPoint& from) { ScoredPoint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ScoredPoint* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ScoredPoint"; }

  explicit ScoredPoint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ScoredPoint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ScoredPoint& from);
  ScoredPoint(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ScoredPoint&& from) noexcept
      : ScoredPoint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kVectorsFieldNumber = 6,
    kShardKeyFieldNumber = 7,
    kOrderValueFieldNumber = 8,
    kVersionFieldNumber = 5,
    kScoreFieldNumber = 3,
    kPayloadFieldNumber = 2,
  };
  // .qdrant.PointId id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::qdrant::PointId& id() const;
  [[nodiscard]] ::qdrant::PointId* PROTOBUF_NULLABLE release_id();
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_id();
  void set_allocated_id(::qdrant::PointId* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_id(::qdrant::PointId* PROTOBUF_NULLABLE value);
  ::qdrant::PointId* PROTOBUF_NULLABLE unsafe_arena_release_id();

  private:
  const ::qdrant::PointId& _internal_id() const;
  ::qdrant::PointId* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // optional .qdrant.VectorsOutput vectors = 6;
  bool has_vectors() const;
  void clear_vectors() ;
  const ::qdrant::VectorsOutput& vectors() const;
  [[nodiscard]] ::qdrant::VectorsOutput* PROTOBUF_NULLABLE release_vectors();
  ::qdrant::VectorsOutput* PROTOBUF_NONNULL mutable_vectors();
  void set_allocated_vectors(::qdrant::VectorsOutput* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vectors(::qdrant::VectorsOutput* PROTOBUF_NULLABLE value);
  ::qdrant::VectorsOutput* PROTOBUF_NULLABLE unsafe_arena_release_vectors();

  private:
  const ::qdrant::VectorsOutput& _internal_vectors() const;
  ::qdrant::VectorsOutput* PROTOBUF_NONNULL _internal_mutable_vectors();

  public:
  // optional .qdrant.ShardKey shard_key = 7;
  bool has_shard_key() const;
  void clear_shard_key() ;
  const ::qdrant::ShardKey& shard_key() const;
  [[nodiscard]] ::qdrant::ShardKey* PROTOBUF_NULLABLE release_shard_key();
  ::qdrant::ShardKey* PROTOBUF_NONNULL mutable_shard_key();
  void set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKey* PROTOBUF_NULLABLE unsafe_arena_release_shard_key();

  private:
  const ::qdrant::ShardKey& _internal_shard_key() const;
  ::qdrant::ShardKey* PROTOBUF_NONNULL _internal_mutable_shard_key();

  public:
  // optional .qdrant.OrderValue order_value = 8;
  bool has_order_value() const;
  void clear_order_value() ;
  const ::qdrant::OrderValue& order_value() const;
  [[nodiscard]] ::qdrant::OrderValue* PROTOBUF_NULLABLE release_order_value();
  ::qdrant::OrderValue* PROTOBUF_NONNULL mutable_order_value();
  void set_allocated_order_value(::qdrant::OrderValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_order_value(::qdrant::OrderValue* PROTOBUF_NULLABLE value);
  ::qdrant::OrderValue* PROTOBUF_NULLABLE unsafe_arena_release_order_value();

  private:
  const ::qdrant::OrderValue& _internal_order_value() const;
  ::qdrant::OrderValue* PROTOBUF_NONNULL _internal_mutable_order_value();

  public:
  // uint64 version = 5;
  void clear_version() ;
  ::uint64_t version() const;
  void set_version(::uint64_t value);

  private:
  ::uint64_t _internal_version() const;
  void _internal_set_version(::uint64_t value);

  public:
  // float score = 3;
  void clear_score() ;
  float score() const;
  void set_score(float value);

  private:
  float _internal_score() const;
  void _internal_set_score(float value);

  public:
  // map<string, .qdrant.Value> payload = 2;
  int payload_size() const;
  private:
  int _internal_payload_size() const;

  public:
  void clear_payload() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& payload() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL mutable_payload();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& _internal_payload() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL _internal_mutable_payload();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.ScoredPoint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   6, 34,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ScoredPoint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::PointId* PROTOBUF_NULLABLE id_;
    ::qdrant::VectorsOutput* PROTOBUF_NULLABLE vectors_;
    ::qdrant::ShardKey* PROTOBUF_NULLABLE shard_key_;
    ::qdrant::OrderValue* PROTOBUF_NULLABLE order_value_;
    ::uint64_t version_;
    float score_;
    ::google::protobuf::internal::MapField<ScoredPoint_PayloadEntry_DoNotUse, ::std::string, ::qdrant::Value,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        payload_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ScoredPoint_class_data_;
// -------------------------------------------------------------------

class RetrievedPoint final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.RetrievedPoint) */ {
 public:
  inline RetrievedPoint() : RetrievedPoint(nullptr) {}
  ~RetrievedPoint() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RetrievedPoint* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RetrievedPoint));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RetrievedPoint(::google::protobuf::internal::ConstantInitialized);

  inline RetrievedPoint(const RetrievedPoint& from) : RetrievedPoint(nullptr, from) {}
  inline RetrievedPoint(RetrievedPoint&& from) noexcept
      : RetrievedPoint(nullptr, ::std::move(from)) {}
  inline RetrievedPoint& operator=(const RetrievedPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline RetrievedPoint& operator=(RetrievedPoint&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RetrievedPoint& default_instance() {
    return *reinterpret_cast<const RetrievedPoint*>(
        &_RetrievedPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 118;
  friend void swap(RetrievedPoint& a, RetrievedPoint& b) { a.Swap(&b); }
  inline void Swap(RetrievedPoint* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RetrievedPoint* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RetrievedPoint* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RetrievedPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RetrievedPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RetrievedPoint& from) { RetrievedPoint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RetrievedPoint* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.RetrievedPoint"; }

  explicit RetrievedPoint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RetrievedPoint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RetrievedPoint& from);
  RetrievedPoint(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RetrievedPoint&& from) noexcept
      : RetrievedPoint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kVectorsFieldNumber = 4,
    kShardKeyFieldNumber = 5,
    kOrderValueFieldNumber = 6,
    kPayloadFieldNumber = 2,
  };
  // .qdrant.PointId id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::qdrant::PointId& id() const;
  [[nodiscard]] ::qdrant::PointId* PROTOBUF_NULLABLE release_id();
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_id();
  void set_allocated_id(::qdrant::PointId* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_id(::qdrant::PointId* PROTOBUF_NULLABLE value);
  ::qdrant::PointId* PROTOBUF_NULLABLE unsafe_arena_release_id();

  private:
  const ::qdrant::PointId& _internal_id() const;
  ::qdrant::PointId* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // optional .qdrant.VectorsOutput vectors = 4;
  bool has_vectors() const;
  void clear_vectors() ;
  const ::qdrant::VectorsOutput& vectors() const;
  [[nodiscard]] ::qdrant::VectorsOutput* PROTOBUF_NULLABLE release_vectors();
  ::qdrant::VectorsOutput* PROTOBUF_NONNULL mutable_vectors();
  void set_allocated_vectors(::qdrant::VectorsOutput* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vectors(::qdrant::VectorsOutput* PROTOBUF_NULLABLE value);
  ::qdrant::VectorsOutput* PROTOBUF_NULLABLE unsafe_arena_release_vectors();

  private:
  const ::qdrant::VectorsOutput& _internal_vectors() const;
  ::qdrant::VectorsOutput* PROTOBUF_NONNULL _internal_mutable_vectors();

  public:
  // optional .qdrant.ShardKey shard_key = 5;
  bool has_shard_key() const;
  void clear_shard_key() ;
  const ::qdrant::ShardKey& shard_key() const;
  [[nodiscard]] ::qdrant::ShardKey* PROTOBUF_NULLABLE release_shard_key();
  ::qdrant::ShardKey* PROTOBUF_NONNULL mutable_shard_key();
  void set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKey* PROTOBUF_NULLABLE unsafe_arena_release_shard_key();

  private:
  const ::qdrant::ShardKey& _internal_shard_key() const;
  ::qdrant::ShardKey* PROTOBUF_NONNULL _internal_mutable_shard_key();

  public:
  // optional .qdrant.OrderValue order_value = 6;
  bool has_order_value() const;
  void clear_order_value() ;
  const ::qdrant::OrderValue& order_value() const;
  [[nodiscard]] ::qdrant::OrderValue* PROTOBUF_NULLABLE release_order_value();
  ::qdrant::OrderValue* PROTOBUF_NONNULL mutable_order_value();
  void set_allocated_order_value(::qdrant::OrderValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_order_value(::qdrant::OrderValue* PROTOBUF_NULLABLE value);
  ::qdrant::OrderValue* PROTOBUF_NULLABLE unsafe_arena_release_order_value();

  private:
  const ::qdrant::OrderValue& _internal_order_value() const;
  ::qdrant::OrderValue* PROTOBUF_NONNULL _internal_mutable_order_value();

  public:
  // map<string, .qdrant.Value> payload = 2;
  int payload_size() const;
  private:
  int _internal_payload_size() const;

  public:
  void clear_payload() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& payload() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL mutable_payload();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& _internal_payload() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL _internal_mutable_payload();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.RetrievedPoint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   6, 37,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RetrievedPoint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::PointId* PROTOBUF_NULLABLE id_;
    ::qdrant::VectorsOutput* PROTOBUF_NULLABLE vectors_;
    ::qdrant::ShardKey* PROTOBUF_NULLABLE shard_key_;
    ::qdrant::OrderValue* PROTOBUF_NULLABLE order_value_;
    ::google::protobuf::internal::MapField<RetrievedPoint_PayloadEntry_DoNotUse, ::std::string, ::qdrant::Value,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        payload_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RetrievedPoint_class_data_;
// -------------------------------------------------------------------

class RecommendBatchPoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.RecommendBatchPoints) */ {
 public:
  inline RecommendBatchPoints() : RecommendBatchPoints(nullptr) {}
  ~RecommendBatchPoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RecommendBatchPoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RecommendBatchPoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RecommendBatchPoints(::google::protobuf::internal::ConstantInitialized);

  inline RecommendBatchPoints(const RecommendBatchPoints& from) : RecommendBatchPoints(nullptr, from) {}
  inline RecommendBatchPoints(RecommendBatchPoints&& from) noexcept
      : RecommendBatchPoints(nullptr, ::std::move(from)) {}
  inline RecommendBatchPoints& operator=(const RecommendBatchPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecommendBatchPoints& operator=(RecommendBatchPoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecommendBatchPoints& default_instance() {
    return *reinterpret_cast<const RecommendBatchPoints*>(
        &_RecommendBatchPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 51;
  friend void swap(RecommendBatchPoints& a, RecommendBatchPoints& b) { a.Swap(&b); }
  inline void Swap(RecommendBatchPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecommendBatchPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecommendBatchPoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RecommendBatchPoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecommendBatchPoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RecommendBatchPoints& from) { RecommendBatchPoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RecommendBatchPoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.RecommendBatchPoints"; }

  explicit RecommendBatchPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RecommendBatchPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RecommendBatchPoints& from);
  RecommendBatchPoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RecommendBatchPoints&& from) noexcept
      : RecommendBatchPoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRecommendPointsFieldNumber = 2,
    kCollectionNameFieldNumber = 1,
    kReadConsistencyFieldNumber = 3,
    kTimeoutFieldNumber = 4,
  };
  // repeated .qdrant.RecommendPoints recommend_points = 2;
  int recommend_points_size() const;
  private:
  int _internal_recommend_points_size() const;

  public:
  void clear_recommend_points() ;
  ::qdrant::RecommendPoints* PROTOBUF_NONNULL mutable_recommend_points(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::RecommendPoints>* PROTOBUF_NONNULL mutable_recommend_points();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::RecommendPoints>& _internal_recommend_points() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::RecommendPoints>* PROTOBUF_NONNULL _internal_mutable_recommend_points();
  public:
  const ::qdrant::RecommendPoints& recommend_points(int index) const;
  ::qdrant::RecommendPoints* PROTOBUF_NONNULL add_recommend_points();
  const ::google::protobuf::RepeatedPtrField<::qdrant::RecommendPoints>& recommend_points() const;
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional .qdrant.ReadConsistency read_consistency = 3;
  bool has_read_consistency() const;
  void clear_read_consistency() ;
  const ::qdrant::ReadConsistency& read_consistency() const;
  [[nodiscard]] ::qdrant::ReadConsistency* PROTOBUF_NULLABLE release_read_consistency();
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL mutable_read_consistency();
  void set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  ::qdrant::ReadConsistency* PROTOBUF_NULLABLE unsafe_arena_release_read_consistency();

  private:
  const ::qdrant::ReadConsistency& _internal_read_consistency() const;
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL _internal_mutable_read_consistency();

  public:
  // optional uint64 timeout = 4;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.RecommendBatchPoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   2, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RecommendBatchPoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::RecommendPoints > recommend_points_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE read_consistency_;
    ::uint64_t timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RecommendBatchPoints_class_data_;
// -------------------------------------------------------------------

class PointsUpdateOperation_SetPayload final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PointsUpdateOperation.SetPayload) */ {
 public:
  inline PointsUpdateOperation_SetPayload() : PointsUpdateOperation_SetPayload(nullptr) {}
  ~PointsUpdateOperation_SetPayload() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointsUpdateOperation_SetPayload* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointsUpdateOperation_SetPayload));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointsUpdateOperation_SetPayload(::google::protobuf::internal::ConstantInitialized);

  inline PointsUpdateOperation_SetPayload(const PointsUpdateOperation_SetPayload& from) : PointsUpdateOperation_SetPayload(nullptr, from) {}
  inline PointsUpdateOperation_SetPayload(PointsUpdateOperation_SetPayload&& from) noexcept
      : PointsUpdateOperation_SetPayload(nullptr, ::std::move(from)) {}
  inline PointsUpdateOperation_SetPayload& operator=(const PointsUpdateOperation_SetPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointsUpdateOperation_SetPayload& operator=(PointsUpdateOperation_SetPayload&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointsUpdateOperation_SetPayload& default_instance() {
    return *reinterpret_cast<const PointsUpdateOperation_SetPayload*>(
        &_PointsUpdateOperation_SetPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 89;
  friend void swap(PointsUpdateOperation_SetPayload& a, PointsUpdateOperation_SetPayload& b) { a.Swap(&b); }
  inline void Swap(PointsUpdateOperation_SetPayload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointsUpdateOperation_SetPayload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointsUpdateOperation_SetPayload* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointsUpdateOperation_SetPayload>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointsUpdateOperation_SetPayload& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointsUpdateOperation_SetPayload& from) { PointsUpdateOperation_SetPayload::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointsUpdateOperation_SetPayload* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PointsUpdateOperation.SetPayload"; }

  explicit PointsUpdateOperation_SetPayload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointsUpdateOperation_SetPayload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointsUpdateOperation_SetPayload& from);
  PointsUpdateOperation_SetPayload(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointsUpdateOperation_SetPayload&& from) noexcept
      : PointsUpdateOperation_SetPayload(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 4,
    kPointsSelectorFieldNumber = 2,
    kShardKeySelectorFieldNumber = 3,
    kPayloadFieldNumber = 1,
  };
  // optional string key = 4;
  bool has_key() const;
  void clear_key() ;
  const ::std::string& key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_key();
  void set_allocated_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_key();

  public:
  // optional .qdrant.PointsSelector points_selector = 2;
  bool has_points_selector() const;
  void clear_points_selector() ;
  const ::qdrant::PointsSelector& points_selector() const;
  [[nodiscard]] ::qdrant::PointsSelector* PROTOBUF_NULLABLE release_points_selector();
  ::qdrant::PointsSelector* PROTOBUF_NONNULL mutable_points_selector();
  void set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::PointsSelector* PROTOBUF_NULLABLE unsafe_arena_release_points_selector();

  private:
  const ::qdrant::PointsSelector& _internal_points_selector() const;
  ::qdrant::PointsSelector* PROTOBUF_NONNULL _internal_mutable_points_selector();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 3;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // map<string, .qdrant.Value> payload = 1;
  int payload_size() const;
  private:
  int _internal_payload_size() const;

  public:
  void clear_payload() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& payload() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL mutable_payload();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& _internal_payload() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL _internal_mutable_payload();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.PointsUpdateOperation.SetPayload)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   4, 58,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointsUpdateOperation_SetPayload& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE points_selector_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::google::protobuf::internal::MapField<PointsUpdateOperation_SetPayload_PayloadEntry_DoNotUse, ::std::string, ::qdrant::Value,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        payload_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_SetPayload_class_data_;
// -------------------------------------------------------------------

class PointsUpdateOperation_OverwritePayload final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PointsUpdateOperation.OverwritePayload) */ {
 public:
  inline PointsUpdateOperation_OverwritePayload() : PointsUpdateOperation_OverwritePayload(nullptr) {}
  ~PointsUpdateOperation_OverwritePayload() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointsUpdateOperation_OverwritePayload* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointsUpdateOperation_OverwritePayload));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointsUpdateOperation_OverwritePayload(::google::protobuf::internal::ConstantInitialized);

  inline PointsUpdateOperation_OverwritePayload(const PointsUpdateOperation_OverwritePayload& from) : PointsUpdateOperation_OverwritePayload(nullptr, from) {}
  inline PointsUpdateOperation_OverwritePayload(PointsUpdateOperation_OverwritePayload&& from) noexcept
      : PointsUpdateOperation_OverwritePayload(nullptr, ::std::move(from)) {}
  inline PointsUpdateOperation_OverwritePayload& operator=(const PointsUpdateOperation_OverwritePayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointsUpdateOperation_OverwritePayload& operator=(PointsUpdateOperation_OverwritePayload&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointsUpdateOperation_OverwritePayload& default_instance() {
    return *reinterpret_cast<const PointsUpdateOperation_OverwritePayload*>(
        &_PointsUpdateOperation_OverwritePayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 91;
  friend void swap(PointsUpdateOperation_OverwritePayload& a, PointsUpdateOperation_OverwritePayload& b) { a.Swap(&b); }
  inline void Swap(PointsUpdateOperation_OverwritePayload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointsUpdateOperation_OverwritePayload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointsUpdateOperation_OverwritePayload* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointsUpdateOperation_OverwritePayload>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointsUpdateOperation_OverwritePayload& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointsUpdateOperation_OverwritePayload& from) { PointsUpdateOperation_OverwritePayload::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointsUpdateOperation_OverwritePayload* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PointsUpdateOperation.OverwritePayload"; }

  explicit PointsUpdateOperation_OverwritePayload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointsUpdateOperation_OverwritePayload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointsUpdateOperation_OverwritePayload& from);
  PointsUpdateOperation_OverwritePayload(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointsUpdateOperation_OverwritePayload&& from) noexcept
      : PointsUpdateOperation_OverwritePayload(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 4,
    kPointsSelectorFieldNumber = 2,
    kShardKeySelectorFieldNumber = 3,
    kPayloadFieldNumber = 1,
  };
  // optional string key = 4;
  bool has_key() const;
  void clear_key() ;
  const ::std::string& key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_key();
  void set_allocated_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_key();

  public:
  // optional .qdrant.PointsSelector points_selector = 2;
  bool has_points_selector() const;
  void clear_points_selector() ;
  const ::qdrant::PointsSelector& points_selector() const;
  [[nodiscard]] ::qdrant::PointsSelector* PROTOBUF_NULLABLE release_points_selector();
  ::qdrant::PointsSelector* PROTOBUF_NONNULL mutable_points_selector();
  void set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::PointsSelector* PROTOBUF_NULLABLE unsafe_arena_release_points_selector();

  private:
  const ::qdrant::PointsSelector& _internal_points_selector() const;
  ::qdrant::PointsSelector* PROTOBUF_NONNULL _internal_mutable_points_selector();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 3;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // map<string, .qdrant.Value> payload = 1;
  int payload_size() const;
  private:
  int _internal_payload_size() const;

  public:
  void clear_payload() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& payload() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL mutable_payload();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& _internal_payload() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL _internal_mutable_payload();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.PointsUpdateOperation.OverwritePayload)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   4, 64,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointsUpdateOperation_OverwritePayload& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE points_selector_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::google::protobuf::internal::MapField<PointsUpdateOperation_OverwritePayload_PayloadEntry_DoNotUse, ::std::string, ::qdrant::Value,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        payload_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_OverwritePayload_class_data_;
// -------------------------------------------------------------------

class PointsUpdateOperation_DeleteVectors final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PointsUpdateOperation.DeleteVectors) */ {
 public:
  inline PointsUpdateOperation_DeleteVectors() : PointsUpdateOperation_DeleteVectors(nullptr) {}
  ~PointsUpdateOperation_DeleteVectors() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointsUpdateOperation_DeleteVectors* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointsUpdateOperation_DeleteVectors));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointsUpdateOperation_DeleteVectors(::google::protobuf::internal::ConstantInitialized);

  inline PointsUpdateOperation_DeleteVectors(const PointsUpdateOperation_DeleteVectors& from) : PointsUpdateOperation_DeleteVectors(nullptr, from) {}
  inline PointsUpdateOperation_DeleteVectors(PointsUpdateOperation_DeleteVectors&& from) noexcept
      : PointsUpdateOperation_DeleteVectors(nullptr, ::std::move(from)) {}
  inline PointsUpdateOperation_DeleteVectors& operator=(const PointsUpdateOperation_DeleteVectors& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointsUpdateOperation_DeleteVectors& operator=(PointsUpdateOperation_DeleteVectors&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointsUpdateOperation_DeleteVectors& default_instance() {
    return *reinterpret_cast<const PointsUpdateOperation_DeleteVectors*>(
        &_PointsUpdateOperation_DeleteVectors_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 94;
  friend void swap(PointsUpdateOperation_DeleteVectors& a, PointsUpdateOperation_DeleteVectors& b) { a.Swap(&b); }
  inline void Swap(PointsUpdateOperation_DeleteVectors* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointsUpdateOperation_DeleteVectors* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointsUpdateOperation_DeleteVectors* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointsUpdateOperation_DeleteVectors>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointsUpdateOperation_DeleteVectors& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointsUpdateOperation_DeleteVectors& from) { PointsUpdateOperation_DeleteVectors::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointsUpdateOperation_DeleteVectors* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PointsUpdateOperation.DeleteVectors"; }

  explicit PointsUpdateOperation_DeleteVectors(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointsUpdateOperation_DeleteVectors(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointsUpdateOperation_DeleteVectors& from);
  PointsUpdateOperation_DeleteVectors(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointsUpdateOperation_DeleteVectors&& from) noexcept
      : PointsUpdateOperation_DeleteVectors(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPointsSelectorFieldNumber = 1,
    kVectorsFieldNumber = 2,
    kShardKeySelectorFieldNumber = 3,
  };
  // .qdrant.PointsSelector points_selector = 1;
  bool has_points_selector() const;
  void clear_points_selector() ;
  const ::qdrant::PointsSelector& points_selector() const;
  [[nodiscard]] ::qdrant::PointsSelector* PROTOBUF_NULLABLE release_points_selector();
  ::qdrant::PointsSelector* PROTOBUF_NONNULL mutable_points_selector();
  void set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::PointsSelector* PROTOBUF_NULLABLE unsafe_arena_release_points_selector();

  private:
  const ::qdrant::PointsSelector& _internal_points_selector() const;
  ::qdrant::PointsSelector* PROTOBUF_NONNULL _internal_mutable_points_selector();

  public:
  // .qdrant.VectorsSelector vectors = 2;
  bool has_vectors() const;
  void clear_vectors() ;
  const ::qdrant::VectorsSelector& vectors() const;
  [[nodiscard]] ::qdrant::VectorsSelector* PROTOBUF_NULLABLE release_vectors();
  ::qdrant::VectorsSelector* PROTOBUF_NONNULL mutable_vectors();
  void set_allocated_vectors(::qdrant::VectorsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vectors(::qdrant::VectorsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::VectorsSelector* PROTOBUF_NULLABLE unsafe_arena_release_vectors();

  private:
  const ::qdrant::VectorsSelector& _internal_vectors() const;
  ::qdrant::VectorsSelector* PROTOBUF_NONNULL _internal_mutable_vectors();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 3;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.PointsUpdateOperation.DeleteVectors)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointsUpdateOperation_DeleteVectors& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE points_selector_;
    ::qdrant::VectorsSelector* PROTOBUF_NULLABLE vectors_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_DeleteVectors_class_data_;
// -------------------------------------------------------------------

class PointsUpdateOperation_DeletePoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PointsUpdateOperation.DeletePoints) */ {
 public:
  inline PointsUpdateOperation_DeletePoints() : PointsUpdateOperation_DeletePoints(nullptr) {}
  ~PointsUpdateOperation_DeletePoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointsUpdateOperation_DeletePoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointsUpdateOperation_DeletePoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointsUpdateOperation_DeletePoints(::google::protobuf::internal::ConstantInitialized);

  inline PointsUpdateOperation_DeletePoints(const PointsUpdateOperation_DeletePoints& from) : PointsUpdateOperation_DeletePoints(nullptr, from) {}
  inline PointsUpdateOperation_DeletePoints(PointsUpdateOperation_DeletePoints&& from) noexcept
      : PointsUpdateOperation_DeletePoints(nullptr, ::std::move(from)) {}
  inline PointsUpdateOperation_DeletePoints& operator=(const PointsUpdateOperation_DeletePoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointsUpdateOperation_DeletePoints& operator=(PointsUpdateOperation_DeletePoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointsUpdateOperation_DeletePoints& default_instance() {
    return *reinterpret_cast<const PointsUpdateOperation_DeletePoints*>(
        &_PointsUpdateOperation_DeletePoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 95;
  friend void swap(PointsUpdateOperation_DeletePoints& a, PointsUpdateOperation_DeletePoints& b) { a.Swap(&b); }
  inline void Swap(PointsUpdateOperation_DeletePoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointsUpdateOperation_DeletePoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointsUpdateOperation_DeletePoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointsUpdateOperation_DeletePoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointsUpdateOperation_DeletePoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointsUpdateOperation_DeletePoints& from) { PointsUpdateOperation_DeletePoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointsUpdateOperation_DeletePoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PointsUpdateOperation.DeletePoints"; }

  explicit PointsUpdateOperation_DeletePoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointsUpdateOperation_DeletePoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointsUpdateOperation_DeletePoints& from);
  PointsUpdateOperation_DeletePoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointsUpdateOperation_DeletePoints&& from) noexcept
      : PointsUpdateOperation_DeletePoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPointsFieldNumber = 1,
    kShardKeySelectorFieldNumber = 2,
  };
  // .qdrant.PointsSelector points = 1;
  bool has_points() const;
  void clear_points() ;
  const ::qdrant::PointsSelector& points() const;
  [[nodiscard]] ::qdrant::PointsSelector* PROTOBUF_NULLABLE release_points();
  ::qdrant::PointsSelector* PROTOBUF_NONNULL mutable_points();
  void set_allocated_points(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_points(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::PointsSelector* PROTOBUF_NULLABLE unsafe_arena_release_points();

  private:
  const ::qdrant::PointsSelector& _internal_points() const;
  ::qdrant::PointsSelector* PROTOBUF_NONNULL _internal_mutable_points();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 2;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.PointsUpdateOperation.DeletePoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointsUpdateOperation_DeletePoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE points_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_DeletePoints_class_data_;
// -------------------------------------------------------------------

class PointsUpdateOperation_DeletePayload final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PointsUpdateOperation.DeletePayload) */ {
 public:
  inline PointsUpdateOperation_DeletePayload() : PointsUpdateOperation_DeletePayload(nullptr) {}
  ~PointsUpdateOperation_DeletePayload() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointsUpdateOperation_DeletePayload* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointsUpdateOperation_DeletePayload));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointsUpdateOperation_DeletePayload(::google::protobuf::internal::ConstantInitialized);

  inline PointsUpdateOperation_DeletePayload(const PointsUpdateOperation_DeletePayload& from) : PointsUpdateOperation_DeletePayload(nullptr, from) {}
  inline PointsUpdateOperation_DeletePayload(PointsUpdateOperation_DeletePayload&& from) noexcept
      : PointsUpdateOperation_DeletePayload(nullptr, ::std::move(from)) {}
  inline PointsUpdateOperation_DeletePayload& operator=(const PointsUpdateOperation_DeletePayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointsUpdateOperation_DeletePayload& operator=(PointsUpdateOperation_DeletePayload&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointsUpdateOperation_DeletePayload& default_instance() {
    return *reinterpret_cast<const PointsUpdateOperation_DeletePayload*>(
        &_PointsUpdateOperation_DeletePayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 92;
  friend void swap(PointsUpdateOperation_DeletePayload& a, PointsUpdateOperation_DeletePayload& b) { a.Swap(&b); }
  inline void Swap(PointsUpdateOperation_DeletePayload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointsUpdateOperation_DeletePayload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointsUpdateOperation_DeletePayload* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointsUpdateOperation_DeletePayload>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointsUpdateOperation_DeletePayload& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointsUpdateOperation_DeletePayload& from) { PointsUpdateOperation_DeletePayload::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointsUpdateOperation_DeletePayload* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PointsUpdateOperation.DeletePayload"; }

  explicit PointsUpdateOperation_DeletePayload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointsUpdateOperation_DeletePayload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointsUpdateOperation_DeletePayload& from);
  PointsUpdateOperation_DeletePayload(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointsUpdateOperation_DeletePayload&& from) noexcept
      : PointsUpdateOperation_DeletePayload(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeysFieldNumber = 1,
    kPointsSelectorFieldNumber = 2,
    kShardKeySelectorFieldNumber = 3,
  };
  // repeated string keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;

  public:
  void clear_keys() ;
  const ::std::string& keys(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_keys(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_keys(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_keys();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_keys(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_keys();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_keys() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_keys();

  public:
  // optional .qdrant.PointsSelector points_selector = 2;
  bool has_points_selector() const;
  void clear_points_selector() ;
  const ::qdrant::PointsSelector& points_selector() const;
  [[nodiscard]] ::qdrant::PointsSelector* PROTOBUF_NULLABLE release_points_selector();
  ::qdrant::PointsSelector* PROTOBUF_NONNULL mutable_points_selector();
  void set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::PointsSelector* PROTOBUF_NULLABLE unsafe_arena_release_points_selector();

  private:
  const ::qdrant::PointsSelector& _internal_points_selector() const;
  ::qdrant::PointsSelector* PROTOBUF_NONNULL _internal_mutable_points_selector();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 3;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.PointsUpdateOperation.DeletePayload)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 55,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointsUpdateOperation_DeletePayload& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> keys_;
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE points_selector_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_DeletePayload_class_data_;
// -------------------------------------------------------------------

class PointsUpdateOperation_ClearPayload final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PointsUpdateOperation.ClearPayload) */ {
 public:
  inline PointsUpdateOperation_ClearPayload() : PointsUpdateOperation_ClearPayload(nullptr) {}
  ~PointsUpdateOperation_ClearPayload() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointsUpdateOperation_ClearPayload* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointsUpdateOperation_ClearPayload));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointsUpdateOperation_ClearPayload(::google::protobuf::internal::ConstantInitialized);

  inline PointsUpdateOperation_ClearPayload(const PointsUpdateOperation_ClearPayload& from) : PointsUpdateOperation_ClearPayload(nullptr, from) {}
  inline PointsUpdateOperation_ClearPayload(PointsUpdateOperation_ClearPayload&& from) noexcept
      : PointsUpdateOperation_ClearPayload(nullptr, ::std::move(from)) {}
  inline PointsUpdateOperation_ClearPayload& operator=(const PointsUpdateOperation_ClearPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointsUpdateOperation_ClearPayload& operator=(PointsUpdateOperation_ClearPayload&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointsUpdateOperation_ClearPayload& default_instance() {
    return *reinterpret_cast<const PointsUpdateOperation_ClearPayload*>(
        &_PointsUpdateOperation_ClearPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 96;
  friend void swap(PointsUpdateOperation_ClearPayload& a, PointsUpdateOperation_ClearPayload& b) { a.Swap(&b); }
  inline void Swap(PointsUpdateOperation_ClearPayload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointsUpdateOperation_ClearPayload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointsUpdateOperation_ClearPayload* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointsUpdateOperation_ClearPayload>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointsUpdateOperation_ClearPayload& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointsUpdateOperation_ClearPayload& from) { PointsUpdateOperation_ClearPayload::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointsUpdateOperation_ClearPayload* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PointsUpdateOperation.ClearPayload"; }

  explicit PointsUpdateOperation_ClearPayload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointsUpdateOperation_ClearPayload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointsUpdateOperation_ClearPayload& from);
  PointsUpdateOperation_ClearPayload(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointsUpdateOperation_ClearPayload&& from) noexcept
      : PointsUpdateOperation_ClearPayload(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPointsFieldNumber = 1,
    kShardKeySelectorFieldNumber = 2,
  };
  // .qdrant.PointsSelector points = 1;
  bool has_points() const;
  void clear_points() ;
  const ::qdrant::PointsSelector& points() const;
  [[nodiscard]] ::qdrant::PointsSelector* PROTOBUF_NULLABLE release_points();
  ::qdrant::PointsSelector* PROTOBUF_NONNULL mutable_points();
  void set_allocated_points(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_points(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::PointsSelector* PROTOBUF_NULLABLE unsafe_arena_release_points();

  private:
  const ::qdrant::PointsSelector& _internal_points() const;
  ::qdrant::PointsSelector* PROTOBUF_NONNULL _internal_mutable_points();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 2;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.PointsUpdateOperation.ClearPayload)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointsUpdateOperation_ClearPayload& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE points_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_ClearPayload_class_data_;
// -------------------------------------------------------------------

class Formula final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.Formula) */ {
 public:
  inline Formula() : Formula(nullptr) {}
  ~Formula() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Formula* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Formula));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Formula(::google::protobuf::internal::ConstantInitialized);

  inline Formula(const Formula& from) : Formula(nullptr, from) {}
  inline Formula(Formula&& from) noexcept
      : Formula(nullptr, ::std::move(from)) {}
  inline Formula& operator=(const Formula& from) {
    CopyFrom(from);
    return *this;
  }
  inline Formula& operator=(Formula&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Formula& default_instance() {
    return *reinterpret_cast<const Formula*>(
        &_Formula_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 64;
  friend void swap(Formula& a, Formula& b) { a.Swap(&b); }
  inline void Swap(Formula* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Formula* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Formula* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Formula>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Formula& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Formula& from) { Formula::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Formula* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.Formula"; }

  explicit Formula(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Formula(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Formula& from);
  Formula(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Formula&& from) noexcept
      : Formula(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExpressionFieldNumber = 1,
    kDefaultsFieldNumber = 2,
  };
  // .qdrant.Expression expression = 1;
  bool has_expression() const;
  void clear_expression() ;
  const ::qdrant::Expression& expression() const;
  [[nodiscard]] ::qdrant::Expression* PROTOBUF_NULLABLE release_expression();
  ::qdrant::Expression* PROTOBUF_NONNULL mutable_expression();
  void set_allocated_expression(::qdrant::Expression* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_expression(::qdrant::Expression* PROTOBUF_NULLABLE value);
  ::qdrant::Expression* PROTOBUF_NULLABLE unsafe_arena_release_expression();

  private:
  const ::qdrant::Expression& _internal_expression() const;
  ::qdrant::Expression* PROTOBUF_NONNULL _internal_mutable_expression();

  public:
  // map<string, .qdrant.Value> defaults = 2;
  int defaults_size() const;
  private:
  int _internal_defaults_size() const;

  public:
  void clear_defaults() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& defaults() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL mutable_defaults();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& _internal_defaults() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL _internal_mutable_defaults();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.Formula)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   3, 31,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Formula& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::Expression* PROTOBUF_NULLABLE expression_;
    ::google::protobuf::internal::MapField<Formula_DefaultsEntry_DoNotUse, ::std::string, ::qdrant::Value,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        defaults_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Formula_class_data_;
// -------------------------------------------------------------------

class DiscoverPoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DiscoverPoints) */ {
 public:
  inline DiscoverPoints() : DiscoverPoints(nullptr) {}
  ~DiscoverPoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DiscoverPoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DiscoverPoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DiscoverPoints(::google::protobuf::internal::ConstantInitialized);

  inline DiscoverPoints(const DiscoverPoints& from) : DiscoverPoints(nullptr, from) {}
  inline DiscoverPoints(DiscoverPoints&& from) noexcept
      : DiscoverPoints(nullptr, ::std::move(from)) {}
  inline DiscoverPoints& operator=(const DiscoverPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscoverPoints& operator=(DiscoverPoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiscoverPoints& default_instance() {
    return *reinterpret_cast<const DiscoverPoints*>(
        &_DiscoverPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 56;
  friend void swap(DiscoverPoints& a, DiscoverPoints& b) { a.Swap(&b); }
  inline void Swap(DiscoverPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiscoverPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiscoverPoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DiscoverPoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DiscoverPoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DiscoverPoints& from) { DiscoverPoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DiscoverPoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DiscoverPoints"; }

  explicit DiscoverPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DiscoverPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DiscoverPoints& from);
  DiscoverPoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DiscoverPoints&& from) noexcept
      : DiscoverPoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kContextFieldNumber = 3,
    kCollectionNameFieldNumber = 1,
    kUsingFieldNumber = 9,
    kTargetFieldNumber = 2,
    kFilterFieldNumber = 4,
    kWithPayloadFieldNumber = 6,
    kParamsFieldNumber = 7,
    kWithVectorsFieldNumber = 10,
    kLookupFromFieldNumber = 11,
    kReadConsistencyFieldNumber = 12,
    kShardKeySelectorFieldNumber = 14,
    kLimitFieldNumber = 5,
    kOffsetFieldNumber = 8,
    kTimeoutFieldNumber = 13,
  };
  // repeated .qdrant.ContextExamplePair context = 3;
  int context_size() const;
  private:
  int _internal_context_size() const;

  public:
  void clear_context() ;
  ::qdrant::ContextExamplePair* PROTOBUF_NONNULL mutable_context(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::ContextExamplePair>* PROTOBUF_NONNULL mutable_context();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::ContextExamplePair>& _internal_context() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::ContextExamplePair>* PROTOBUF_NONNULL _internal_mutable_context();
  public:
  const ::qdrant::ContextExamplePair& context(int index) const;
  ::qdrant::ContextExamplePair* PROTOBUF_NONNULL add_context();
  const ::google::protobuf::RepeatedPtrField<::qdrant::ContextExamplePair>& context() const;
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional string using = 9;
  bool has_using_() const;
  void clear_using_() ;
  const ::std::string& using_() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_using_(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_using_();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_using_();
  void set_allocated_using_(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_using_() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_using_(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_using_();

  public:
  // .qdrant.TargetVector target = 2;
  bool has_target() const;
  void clear_target() ;
  const ::qdrant::TargetVector& target() const;
  [[nodiscard]] ::qdrant::TargetVector* PROTOBUF_NULLABLE release_target();
  ::qdrant::TargetVector* PROTOBUF_NONNULL mutable_target();
  void set_allocated_target(::qdrant::TargetVector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_target(::qdrant::TargetVector* PROTOBUF_NULLABLE value);
  ::qdrant::TargetVector* PROTOBUF_NULLABLE unsafe_arena_release_target();

  private:
  const ::qdrant::TargetVector& _internal_target() const;
  ::qdrant::TargetVector* PROTOBUF_NONNULL _internal_mutable_target();

  public:
  // .qdrant.Filter filter = 4;
  bool has_filter() const;
  void clear_filter() ;
  const ::qdrant::Filter& filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_filter();
  void set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_filter();

  private:
  const ::qdrant::Filter& _internal_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_filter();

  public:
  // .qdrant.WithPayloadSelector with_payload = 6;
  bool has_with_payload() const;
  void clear_with_payload() ;
  const ::qdrant::WithPayloadSelector& with_payload() const;
  [[nodiscard]] ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE release_with_payload();
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL mutable_with_payload();
  void set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_payload();

  private:
  const ::qdrant::WithPayloadSelector& _internal_with_payload() const;
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL _internal_mutable_with_payload();

  public:
  // .qdrant.SearchParams params = 7;
  bool has_params() const;
  void clear_params() ;
  const ::qdrant::SearchParams& params() const;
  [[nodiscard]] ::qdrant::SearchParams* PROTOBUF_NULLABLE release_params();
  ::qdrant::SearchParams* PROTOBUF_NONNULL mutable_params();
  void set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value);
  ::qdrant::SearchParams* PROTOBUF_NULLABLE unsafe_arena_release_params();

  private:
  const ::qdrant::SearchParams& _internal_params() const;
  ::qdrant::SearchParams* PROTOBUF_NONNULL _internal_mutable_params();

  public:
  // optional .qdrant.WithVectorsSelector with_vectors = 10;
  bool has_with_vectors() const;
  void clear_with_vectors() ;
  const ::qdrant::WithVectorsSelector& with_vectors() const;
  [[nodiscard]] ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE release_with_vectors();
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL mutable_with_vectors();
  void set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_vectors();

  private:
  const ::qdrant::WithVectorsSelector& _internal_with_vectors() const;
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL _internal_mutable_with_vectors();

  public:
  // optional .qdrant.LookupLocation lookup_from = 11;
  bool has_lookup_from() const;
  void clear_lookup_from() ;
  const ::qdrant::LookupLocation& lookup_from() const;
  [[nodiscard]] ::qdrant::LookupLocation* PROTOBUF_NULLABLE release_lookup_from();
  ::qdrant::LookupLocation* PROTOBUF_NONNULL mutable_lookup_from();
  void set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value);
  ::qdrant::LookupLocation* PROTOBUF_NULLABLE unsafe_arena_release_lookup_from();

  private:
  const ::qdrant::LookupLocation& _internal_lookup_from() const;
  ::qdrant::LookupLocation* PROTOBUF_NONNULL _internal_mutable_lookup_from();

  public:
  // optional .qdrant.ReadConsistency read_consistency = 12;
  bool has_read_consistency() const;
  void clear_read_consistency() ;
  const ::qdrant::ReadConsistency& read_consistency() const;
  [[nodiscard]] ::qdrant::ReadConsistency* PROTOBUF_NULLABLE release_read_consistency();
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL mutable_read_consistency();
  void set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  ::qdrant::ReadConsistency* PROTOBUF_NULLABLE unsafe_arena_release_read_consistency();

  private:
  const ::qdrant::ReadConsistency& _internal_read_consistency() const;
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL _internal_mutable_read_consistency();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 14;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // uint64 limit = 5;
  void clear_limit() ;
  ::uint64_t limit() const;
  void set_limit(::uint64_t value);

  private:
  ::uint64_t _internal_limit() const;
  void _internal_set_limit(::uint64_t value);

  public:
  // optional uint64 offset = 8;
  bool has_offset() const;
  void clear_offset() ;
  ::uint64_t offset() const;
  void set_offset(::uint64_t value);

  private:
  ::uint64_t _internal_offset() const;
  void _internal_set_offset(::uint64_t value);

  public:
  // optional uint64 timeout = 13;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DiscoverPoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 14,
                                   9, 58,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DiscoverPoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::ContextExamplePair > context_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::google::protobuf::internal::ArenaStringPtr using__;
    ::qdrant::TargetVector* PROTOBUF_NULLABLE target_;
    ::qdrant::Filter* PROTOBUF_NULLABLE filter_;
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE with_payload_;
    ::qdrant::SearchParams* PROTOBUF_NULLABLE params_;
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE with_vectors_;
    ::qdrant::LookupLocation* PROTOBUF_NULLABLE lookup_from_;
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE read_consistency_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::uint64_t limit_;
    ::uint64_t offset_;
    ::uint64_t timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DiscoverPoints_class_data_;
// -------------------------------------------------------------------

class DiscoverInput final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DiscoverInput) */ {
 public:
  inline DiscoverInput() : DiscoverInput(nullptr) {}
  ~DiscoverInput() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DiscoverInput* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DiscoverInput));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DiscoverInput(::google::protobuf::internal::ConstantInitialized);

  inline DiscoverInput(const DiscoverInput& from) : DiscoverInput(nullptr, from) {}
  inline DiscoverInput(DiscoverInput&& from) noexcept
      : DiscoverInput(nullptr, ::std::move(from)) {}
  inline DiscoverInput& operator=(const DiscoverInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscoverInput& operator=(DiscoverInput&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiscoverInput& default_instance() {
    return *reinterpret_cast<const DiscoverInput*>(
        &_DiscoverInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 61;
  friend void swap(DiscoverInput& a, DiscoverInput& b) { a.Swap(&b); }
  inline void Swap(DiscoverInput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiscoverInput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiscoverInput* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DiscoverInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DiscoverInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DiscoverInput& from) { DiscoverInput::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DiscoverInput* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DiscoverInput"; }

  explicit DiscoverInput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DiscoverInput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DiscoverInput& from);
  DiscoverInput(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DiscoverInput&& from) noexcept
      : DiscoverInput(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
    kContextFieldNumber = 2,
  };
  // .qdrant.VectorInput target = 1;
  bool has_target() const;
  void clear_target() ;
  const ::qdrant::VectorInput& target() const;
  [[nodiscard]] ::qdrant::VectorInput* PROTOBUF_NULLABLE release_target();
  ::qdrant::VectorInput* PROTOBUF_NONNULL mutable_target();
  void set_allocated_target(::qdrant::VectorInput* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_target(::qdrant::VectorInput* PROTOBUF_NULLABLE value);
  ::qdrant::VectorInput* PROTOBUF_NULLABLE unsafe_arena_release_target();

  private:
  const ::qdrant::VectorInput& _internal_target() const;
  ::qdrant::VectorInput* PROTOBUF_NONNULL _internal_mutable_target();

  public:
  // .qdrant.ContextInput context = 2;
  bool has_context() const;
  void clear_context() ;
  const ::qdrant::ContextInput& context() const;
  [[nodiscard]] ::qdrant::ContextInput* PROTOBUF_NULLABLE release_context();
  ::qdrant::ContextInput* PROTOBUF_NONNULL mutable_context();
  void set_allocated_context(::qdrant::ContextInput* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_context(::qdrant::ContextInput* PROTOBUF_NULLABLE value);
  ::qdrant::ContextInput* PROTOBUF_NULLABLE unsafe_arena_release_context();

  private:
  const ::qdrant::ContextInput& _internal_context() const;
  ::qdrant::ContextInput* PROTOBUF_NONNULL _internal_mutable_context();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DiscoverInput)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DiscoverInput& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::VectorInput* PROTOBUF_NULLABLE target_;
    ::qdrant::ContextInput* PROTOBUF_NULLABLE context_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DiscoverInput_class_data_;
// -------------------------------------------------------------------

class DeletePoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DeletePoints) */ {
 public:
  inline DeletePoints() : DeletePoints(nullptr) {}
  ~DeletePoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeletePoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeletePoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeletePoints(::google::protobuf::internal::ConstantInitialized);

  inline DeletePoints(const DeletePoints& from) : DeletePoints(nullptr, from) {}
  inline DeletePoints(DeletePoints&& from) noexcept
      : DeletePoints(nullptr, ::std::move(from)) {}
  inline DeletePoints& operator=(const DeletePoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePoints& operator=(DeletePoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePoints& default_instance() {
    return *reinterpret_cast<const DeletePoints*>(
        &_DeletePoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(DeletePoints& a, DeletePoints& b) { a.Swap(&b); }
  inline void Swap(DeletePoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeletePoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeletePoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeletePoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeletePoints& from) { DeletePoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeletePoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DeletePoints"; }

  explicit DeletePoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeletePoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeletePoints& from);
  DeletePoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeletePoints&& from) noexcept
      : DeletePoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kPointsFieldNumber = 3,
    kOrderingFieldNumber = 4,
    kShardKeySelectorFieldNumber = 5,
    kWaitFieldNumber = 2,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // .qdrant.PointsSelector points = 3;
  bool has_points() const;
  void clear_points() ;
  const ::qdrant::PointsSelector& points() const;
  [[nodiscard]] ::qdrant::PointsSelector* PROTOBUF_NULLABLE release_points();
  ::qdrant::PointsSelector* PROTOBUF_NONNULL mutable_points();
  void set_allocated_points(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_points(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::PointsSelector* PROTOBUF_NULLABLE unsafe_arena_release_points();

  private:
  const ::qdrant::PointsSelector& _internal_points() const;
  ::qdrant::PointsSelector* PROTOBUF_NONNULL _internal_mutable_points();

  public:
  // optional .qdrant.WriteOrdering ordering = 4;
  bool has_ordering() const;
  void clear_ordering() ;
  const ::qdrant::WriteOrdering& ordering() const;
  [[nodiscard]] ::qdrant::WriteOrdering* PROTOBUF_NULLABLE release_ordering();
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL mutable_ordering();
  void set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  ::qdrant::WriteOrdering* PROTOBUF_NULLABLE unsafe_arena_release_ordering();

  private:
  const ::qdrant::WriteOrdering& _internal_ordering() const;
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL _internal_mutable_ordering();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 5;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional bool wait = 2;
  bool has_wait() const;
  void clear_wait() ;
  bool wait() const;
  void set_wait(bool value);

  private:
  bool _internal_wait() const;
  void _internal_set_wait(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DeletePoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   3, 43,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeletePoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE points_;
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE ordering_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    bool wait_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeletePoints_class_data_;
// -------------------------------------------------------------------

class DeletePointVectors final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DeletePointVectors) */ {
 public:
  inline DeletePointVectors() : DeletePointVectors(nullptr) {}
  ~DeletePointVectors() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeletePointVectors* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeletePointVectors));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeletePointVectors(::google::protobuf::internal::ConstantInitialized);

  inline DeletePointVectors(const DeletePointVectors& from) : DeletePointVectors(nullptr, from) {}
  inline DeletePointVectors(DeletePointVectors&& from) noexcept
      : DeletePointVectors(nullptr, ::std::move(from)) {}
  inline DeletePointVectors& operator=(const DeletePointVectors& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePointVectors& operator=(DeletePointVectors&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePointVectors& default_instance() {
    return *reinterpret_cast<const DeletePointVectors*>(
        &_DeletePointVectors_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(DeletePointVectors& a, DeletePointVectors& b) { a.Swap(&b); }
  inline void Swap(DeletePointVectors* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePointVectors* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeletePointVectors* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeletePointVectors>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeletePointVectors& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeletePointVectors& from) { DeletePointVectors::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeletePointVectors* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DeletePointVectors"; }

  explicit DeletePointVectors(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeletePointVectors(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeletePointVectors& from);
  DeletePointVectors(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeletePointVectors&& from) noexcept
      : DeletePointVectors(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kPointsSelectorFieldNumber = 3,
    kVectorsFieldNumber = 4,
    kOrderingFieldNumber = 5,
    kShardKeySelectorFieldNumber = 6,
    kWaitFieldNumber = 2,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // .qdrant.PointsSelector points_selector = 3;
  bool has_points_selector() const;
  void clear_points_selector() ;
  const ::qdrant::PointsSelector& points_selector() const;
  [[nodiscard]] ::qdrant::PointsSelector* PROTOBUF_NULLABLE release_points_selector();
  ::qdrant::PointsSelector* PROTOBUF_NONNULL mutable_points_selector();
  void set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::PointsSelector* PROTOBUF_NULLABLE unsafe_arena_release_points_selector();

  private:
  const ::qdrant::PointsSelector& _internal_points_selector() const;
  ::qdrant::PointsSelector* PROTOBUF_NONNULL _internal_mutable_points_selector();

  public:
  // .qdrant.VectorsSelector vectors = 4;
  bool has_vectors() const;
  void clear_vectors() ;
  const ::qdrant::VectorsSelector& vectors() const;
  [[nodiscard]] ::qdrant::VectorsSelector* PROTOBUF_NULLABLE release_vectors();
  ::qdrant::VectorsSelector* PROTOBUF_NONNULL mutable_vectors();
  void set_allocated_vectors(::qdrant::VectorsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vectors(::qdrant::VectorsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::VectorsSelector* PROTOBUF_NULLABLE unsafe_arena_release_vectors();

  private:
  const ::qdrant::VectorsSelector& _internal_vectors() const;
  ::qdrant::VectorsSelector* PROTOBUF_NONNULL _internal_mutable_vectors();

  public:
  // optional .qdrant.WriteOrdering ordering = 5;
  bool has_ordering() const;
  void clear_ordering() ;
  const ::qdrant::WriteOrdering& ordering() const;
  [[nodiscard]] ::qdrant::WriteOrdering* PROTOBUF_NULLABLE release_ordering();
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL mutable_ordering();
  void set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  ::qdrant::WriteOrdering* PROTOBUF_NULLABLE unsafe_arena_release_ordering();

  private:
  const ::qdrant::WriteOrdering& _internal_ordering() const;
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL _internal_mutable_ordering();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 6;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional bool wait = 2;
  bool has_wait() const;
  void clear_wait() ;
  bool wait() const;
  void set_wait(bool value);

  private:
  bool _internal_wait() const;
  void _internal_set_wait(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DeletePointVectors)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   4, 49,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeletePointVectors& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE points_selector_;
    ::qdrant::VectorsSelector* PROTOBUF_NULLABLE vectors_;
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE ordering_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    bool wait_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeletePointVectors_class_data_;
// -------------------------------------------------------------------

class DeletePayloadPoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DeletePayloadPoints) */ {
 public:
  inline DeletePayloadPoints() : DeletePayloadPoints(nullptr) {}
  ~DeletePayloadPoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeletePayloadPoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeletePayloadPoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeletePayloadPoints(::google::protobuf::internal::ConstantInitialized);

  inline DeletePayloadPoints(const DeletePayloadPoints& from) : DeletePayloadPoints(nullptr, from) {}
  inline DeletePayloadPoints(DeletePayloadPoints&& from) noexcept
      : DeletePayloadPoints(nullptr, ::std::move(from)) {}
  inline DeletePayloadPoints& operator=(const DeletePayloadPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePayloadPoints& operator=(DeletePayloadPoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePayloadPoints& default_instance() {
    return *reinterpret_cast<const DeletePayloadPoints*>(
        &_DeletePayloadPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(DeletePayloadPoints& a, DeletePayloadPoints& b) { a.Swap(&b); }
  inline void Swap(DeletePayloadPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePayloadPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeletePayloadPoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeletePayloadPoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeletePayloadPoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeletePayloadPoints& from) { DeletePayloadPoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeletePayloadPoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DeletePayloadPoints"; }

  explicit DeletePayloadPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeletePayloadPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeletePayloadPoints& from);
  DeletePayloadPoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeletePayloadPoints&& from) noexcept
      : DeletePayloadPoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeysFieldNumber = 3,
    kCollectionNameFieldNumber = 1,
    kPointsSelectorFieldNumber = 5,
    kOrderingFieldNumber = 6,
    kShardKeySelectorFieldNumber = 7,
    kWaitFieldNumber = 2,
  };
  // repeated string keys = 3;
  int keys_size() const;
  private:
  int _internal_keys_size() const;

  public:
  void clear_keys() ;
  const ::std::string& keys(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_keys(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_keys(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_keys();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_keys(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_keys();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_keys() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_keys();

  public:
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional .qdrant.PointsSelector points_selector = 5;
  bool has_points_selector() const;
  void clear_points_selector() ;
  const ::qdrant::PointsSelector& points_selector() const;
  [[nodiscard]] ::qdrant::PointsSelector* PROTOBUF_NULLABLE release_points_selector();
  ::qdrant::PointsSelector* PROTOBUF_NONNULL mutable_points_selector();
  void set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::PointsSelector* PROTOBUF_NULLABLE unsafe_arena_release_points_selector();

  private:
  const ::qdrant::PointsSelector& _internal_points_selector() const;
  ::qdrant::PointsSelector* PROTOBUF_NONNULL _internal_mutable_points_selector();

  public:
  // optional .qdrant.WriteOrdering ordering = 6;
  bool has_ordering() const;
  void clear_ordering() ;
  const ::qdrant::WriteOrdering& ordering() const;
  [[nodiscard]] ::qdrant::WriteOrdering* PROTOBUF_NULLABLE release_ordering();
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL mutable_ordering();
  void set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  ::qdrant::WriteOrdering* PROTOBUF_NULLABLE unsafe_arena_release_ordering();

  private:
  const ::qdrant::WriteOrdering& _internal_ordering() const;
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL _internal_mutable_ordering();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 7;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional bool wait = 2;
  bool has_wait() const;
  void clear_wait() ;
  bool wait() const;
  void set_wait(bool value);

  private:
  bool _internal_wait() const;
  void _internal_set_wait(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DeletePayloadPoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   3, 54,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeletePayloadPoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> keys_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE points_selector_;
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE ordering_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    bool wait_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeletePayloadPoints_class_data_;
// -------------------------------------------------------------------

class ClearPayloadPoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ClearPayloadPoints) */ {
 public:
  inline ClearPayloadPoints() : ClearPayloadPoints(nullptr) {}
  ~ClearPayloadPoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ClearPayloadPoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ClearPayloadPoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClearPayloadPoints(::google::protobuf::internal::ConstantInitialized);

  inline ClearPayloadPoints(const ClearPayloadPoints& from) : ClearPayloadPoints(nullptr, from) {}
  inline ClearPayloadPoints(ClearPayloadPoints&& from) noexcept
      : ClearPayloadPoints(nullptr, ::std::move(from)) {}
  inline ClearPayloadPoints& operator=(const ClearPayloadPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearPayloadPoints& operator=(ClearPayloadPoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearPayloadPoints& default_instance() {
    return *reinterpret_cast<const ClearPayloadPoints*>(
        &_ClearPayloadPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(ClearPayloadPoints& a, ClearPayloadPoints& b) { a.Swap(&b); }
  inline void Swap(ClearPayloadPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearPayloadPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearPayloadPoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ClearPayloadPoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClearPayloadPoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ClearPayloadPoints& from) { ClearPayloadPoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ClearPayloadPoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ClearPayloadPoints"; }

  explicit ClearPayloadPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ClearPayloadPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ClearPayloadPoints& from);
  ClearPayloadPoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ClearPayloadPoints&& from) noexcept
      : ClearPayloadPoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kPointsFieldNumber = 3,
    kOrderingFieldNumber = 4,
    kShardKeySelectorFieldNumber = 5,
    kWaitFieldNumber = 2,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // .qdrant.PointsSelector points = 3;
  bool has_points() const;
  void clear_points() ;
  const ::qdrant::PointsSelector& points() const;
  [[nodiscard]] ::qdrant::PointsSelector* PROTOBUF_NULLABLE release_points();
  ::qdrant::PointsSelector* PROTOBUF_NONNULL mutable_points();
  void set_allocated_points(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_points(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::PointsSelector* PROTOBUF_NULLABLE unsafe_arena_release_points();

  private:
  const ::qdrant::PointsSelector& _internal_points() const;
  ::qdrant::PointsSelector* PROTOBUF_NONNULL _internal_mutable_points();

  public:
  // optional .qdrant.WriteOrdering ordering = 4;
  bool has_ordering() const;
  void clear_ordering() ;
  const ::qdrant::WriteOrdering& ordering() const;
  [[nodiscard]] ::qdrant::WriteOrdering* PROTOBUF_NULLABLE release_ordering();
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL mutable_ordering();
  void set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  ::qdrant::WriteOrdering* PROTOBUF_NULLABLE unsafe_arena_release_ordering();

  private:
  const ::qdrant::WriteOrdering& _internal_ordering() const;
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL _internal_mutable_ordering();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 5;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional bool wait = 2;
  bool has_wait() const;
  void clear_wait() ;
  bool wait() const;
  void set_wait(bool value);

  private:
  bool _internal_wait() const;
  void _internal_set_wait(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.ClearPayloadPoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   3, 49,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ClearPayloadPoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE points_;
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE ordering_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    bool wait_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ClearPayloadPoints_class_data_;
// -------------------------------------------------------------------

class SearchResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SearchResponse) */ {
 public:
  inline SearchResponse() : SearchResponse(nullptr) {}
  ~SearchResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SearchResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SearchResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SearchResponse(::google::protobuf::internal::ConstantInitialized);

  inline SearchResponse(const SearchResponse& from) : SearchResponse(nullptr, from) {}
  inline SearchResponse(SearchResponse&& from) noexcept
      : SearchResponse(nullptr, ::std::move(from)) {}
  inline SearchResponse& operator=(const SearchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResponse& operator=(SearchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchResponse& default_instance() {
    return *reinterpret_cast<const SearchResponse*>(
        &_SearchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 107;
  friend void swap(SearchResponse& a, SearchResponse& b) { a.Swap(&b); }
  inline void Swap(SearchResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SearchResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SearchResponse& from) { SearchResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SearchResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SearchResponse"; }

  explicit SearchResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SearchResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SearchResponse& from);
  SearchResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SearchResponse&& from) noexcept
      : SearchResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // repeated .qdrant.ScoredPoint result = 1;
  int result_size() const;
  private:
  int _internal_result_size() const;

  public:
  void clear_result() ;
  ::qdrant::ScoredPoint* PROTOBUF_NONNULL mutable_result(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL mutable_result();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& _internal_result() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL _internal_mutable_result();
  public:
  const ::qdrant::ScoredPoint& result(int index) const;
  ::qdrant::ScoredPoint* PROTOBUF_NONNULL add_result();
  const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& result() const;
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SearchResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SearchResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::ScoredPoint > result_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SearchResponse_class_data_;
// -------------------------------------------------------------------

class ScrollResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ScrollResponse) */ {
 public:
  inline ScrollResponse() : ScrollResponse(nullptr) {}
  ~ScrollResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ScrollResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ScrollResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ScrollResponse(::google::protobuf::internal::ConstantInitialized);

  inline ScrollResponse(const ScrollResponse& from) : ScrollResponse(nullptr, from) {}
  inline ScrollResponse(ScrollResponse&& from) noexcept
      : ScrollResponse(nullptr, ::std::move(from)) {}
  inline ScrollResponse& operator=(const ScrollResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScrollResponse& operator=(ScrollResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScrollResponse& default_instance() {
    return *reinterpret_cast<const ScrollResponse*>(
        &_ScrollResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 115;
  friend void swap(ScrollResponse& a, ScrollResponse& b) { a.Swap(&b); }
  inline void Swap(ScrollResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScrollResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScrollResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ScrollResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ScrollResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ScrollResponse& from) { ScrollResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ScrollResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ScrollResponse"; }

  explicit ScrollResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ScrollResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ScrollResponse& from);
  ScrollResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ScrollResponse&& from) noexcept
      : ScrollResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 2,
    kNextPageOffsetFieldNumber = 1,
    kUsageFieldNumber = 4,
    kTimeFieldNumber = 3,
  };
  // repeated .qdrant.RetrievedPoint result = 2;
  int result_size() const;
  private:
  int _internal_result_size() const;

  public:
  void clear_result() ;
  ::qdrant::RetrievedPoint* PROTOBUF_NONNULL mutable_result(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::RetrievedPoint>* PROTOBUF_NONNULL mutable_result();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::RetrievedPoint>& _internal_result() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::RetrievedPoint>* PROTOBUF_NONNULL _internal_mutable_result();
  public:
  const ::qdrant::RetrievedPoint& result(int index) const;
  ::qdrant::RetrievedPoint* PROTOBUF_NONNULL add_result();
  const ::google::protobuf::RepeatedPtrField<::qdrant::RetrievedPoint>& result() const;
  // optional .qdrant.PointId next_page_offset = 1;
  bool has_next_page_offset() const;
  void clear_next_page_offset() ;
  const ::qdrant::PointId& next_page_offset() const;
  [[nodiscard]] ::qdrant::PointId* PROTOBUF_NULLABLE release_next_page_offset();
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_next_page_offset();
  void set_allocated_next_page_offset(::qdrant::PointId* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_next_page_offset(::qdrant::PointId* PROTOBUF_NULLABLE value);
  ::qdrant::PointId* PROTOBUF_NULLABLE unsafe_arena_release_next_page_offset();

  private:
  const ::qdrant::PointId& _internal_next_page_offset() const;
  ::qdrant::PointId* PROTOBUF_NONNULL _internal_mutable_next_page_offset();

  public:
  // optional .qdrant.Usage usage = 4;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 3;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.ScrollResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ScrollResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::RetrievedPoint > result_;
    ::qdrant::PointId* PROTOBUF_NULLABLE next_page_offset_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ScrollResponse_class_data_;
// -------------------------------------------------------------------

class RecommendResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.RecommendResponse) */ {
 public:
  inline RecommendResponse() : RecommendResponse(nullptr) {}
  ~RecommendResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RecommendResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RecommendResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RecommendResponse(::google::protobuf::internal::ConstantInitialized);

  inline RecommendResponse(const RecommendResponse& from) : RecommendResponse(nullptr, from) {}
  inline RecommendResponse(RecommendResponse&& from) noexcept
      : RecommendResponse(nullptr, ::std::move(from)) {}
  inline RecommendResponse& operator=(const RecommendResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecommendResponse& operator=(RecommendResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecommendResponse& default_instance() {
    return *reinterpret_cast<const RecommendResponse*>(
        &_RecommendResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 120;
  friend void swap(RecommendResponse& a, RecommendResponse& b) { a.Swap(&b); }
  inline void Swap(RecommendResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecommendResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecommendResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RecommendResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecommendResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RecommendResponse& from) { RecommendResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RecommendResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.RecommendResponse"; }

  explicit RecommendResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RecommendResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RecommendResponse& from);
  RecommendResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RecommendResponse&& from) noexcept
      : RecommendResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // repeated .qdrant.ScoredPoint result = 1;
  int result_size() const;
  private:
  int _internal_result_size() const;

  public:
  void clear_result() ;
  ::qdrant::ScoredPoint* PROTOBUF_NONNULL mutable_result(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL mutable_result();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& _internal_result() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL _internal_mutable_result();
  public:
  const ::qdrant::ScoredPoint& result(int index) const;
  ::qdrant::ScoredPoint* PROTOBUF_NONNULL add_result();
  const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& result() const;
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.RecommendResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RecommendResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::ScoredPoint > result_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RecommendResponse_class_data_;
// -------------------------------------------------------------------

class QueryResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.QueryResponse) */ {
 public:
  inline QueryResponse() : QueryResponse(nullptr) {}
  ~QueryResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QueryResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QueryResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryResponse(::google::protobuf::internal::ConstantInitialized);

  inline QueryResponse(const QueryResponse& from) : QueryResponse(nullptr, from) {}
  inline QueryResponse(QueryResponse&& from) noexcept
      : QueryResponse(nullptr, ::std::move(from)) {}
  inline QueryResponse& operator=(const QueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryResponse& operator=(QueryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryResponse& default_instance() {
    return *reinterpret_cast<const QueryResponse*>(
        &_QueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 108;
  friend void swap(QueryResponse& a, QueryResponse& b) { a.Swap(&b); }
  inline void Swap(QueryResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QueryResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryResponse& from) { QueryResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QueryResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.QueryResponse"; }

  explicit QueryResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QueryResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QueryResponse& from);
  QueryResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QueryResponse&& from) noexcept
      : QueryResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // repeated .qdrant.ScoredPoint result = 1;
  int result_size() const;
  private:
  int _internal_result_size() const;

  public:
  void clear_result() ;
  ::qdrant::ScoredPoint* PROTOBUF_NONNULL mutable_result(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL mutable_result();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& _internal_result() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL _internal_mutable_result();
  public:
  const ::qdrant::ScoredPoint& result(int index) const;
  ::qdrant::ScoredPoint* PROTOBUF_NONNULL add_result();
  const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& result() const;
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.QueryResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QueryResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::ScoredPoint > result_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QueryResponse_class_data_;
// -------------------------------------------------------------------

class Query final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.Query) */ {
 public:
  inline Query() : Query(nullptr) {}
  ~Query() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Query* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Query));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Query(::google::protobuf::internal::ConstantInitialized);

  inline Query(const Query& from) : Query(nullptr, from) {}
  inline Query(Query&& from) noexcept
      : Query(nullptr, ::std::move(from)) {}
  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }
  inline Query& operator=(Query&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Query& default_instance() {
    return *reinterpret_cast<const Query*>(
        &_Query_default_instance_);
  }
  enum VariantCase {
    kNearest = 1,
    kRecommend = 2,
    kDiscover = 3,
    kContext = 4,
    kOrderBy = 5,
    kFusion = 6,
    kSample = 7,
    kFormula = 8,
    kNearestWithMmr = 9,
    kRrf = 10,
    VARIANT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 75;
  friend void swap(Query& a, Query& b) { a.Swap(&b); }
  inline void Swap(Query* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Query* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Query* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Query>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Query& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Query& from) { Query::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Query* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.Query"; }

  explicit Query(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Query(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Query& from);
  Query(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Query&& from) noexcept
      : Query(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNearestFieldNumber = 1,
    kRecommendFieldNumber = 2,
    kDiscoverFieldNumber = 3,
    kContextFieldNumber = 4,
    kOrderByFieldNumber = 5,
    kFusionFieldNumber = 6,
    kSampleFieldNumber = 7,
    kFormulaFieldNumber = 8,
    kNearestWithMmrFieldNumber = 9,
    kRrfFieldNumber = 10,
  };
  // .qdrant.VectorInput nearest = 1;
  bool has_nearest() const;
  private:
  bool _internal_has_nearest() const;

  public:
  void clear_nearest() ;
  const ::qdrant::VectorInput& nearest() const;
  [[nodiscard]] ::qdrant::VectorInput* PROTOBUF_NULLABLE release_nearest();
  ::qdrant::VectorInput* PROTOBUF_NONNULL mutable_nearest();
  void set_allocated_nearest(::qdrant::VectorInput* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_nearest(::qdrant::VectorInput* PROTOBUF_NULLABLE value);
  ::qdrant::VectorInput* PROTOBUF_NULLABLE unsafe_arena_release_nearest();

  private:
  const ::qdrant::VectorInput& _internal_nearest() const;
  ::qdrant::VectorInput* PROTOBUF_NONNULL _internal_mutable_nearest();

  public:
  // .qdrant.RecommendInput recommend = 2;
  bool has_recommend() const;
  private:
  bool _internal_has_recommend() const;

  public:
  void clear_recommend() ;
  const ::qdrant::RecommendInput& recommend() const;
  [[nodiscard]] ::qdrant::RecommendInput* PROTOBUF_NULLABLE release_recommend();
  ::qdrant::RecommendInput* PROTOBUF_NONNULL mutable_recommend();
  void set_allocated_recommend(::qdrant::RecommendInput* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_recommend(::qdrant::RecommendInput* PROTOBUF_NULLABLE value);
  ::qdrant::RecommendInput* PROTOBUF_NULLABLE unsafe_arena_release_recommend();

  private:
  const ::qdrant::RecommendInput& _internal_recommend() const;
  ::qdrant::RecommendInput* PROTOBUF_NONNULL _internal_mutable_recommend();

  public:
  // .qdrant.DiscoverInput discover = 3;
  bool has_discover() const;
  private:
  bool _internal_has_discover() const;

  public:
  void clear_discover() ;
  const ::qdrant::DiscoverInput& discover() const;
  [[nodiscard]] ::qdrant::DiscoverInput* PROTOBUF_NULLABLE release_discover();
  ::qdrant::DiscoverInput* PROTOBUF_NONNULL mutable_discover();
  void set_allocated_discover(::qdrant::DiscoverInput* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_discover(::qdrant::DiscoverInput* PROTOBUF_NULLABLE value);
  ::qdrant::DiscoverInput* PROTOBUF_NULLABLE unsafe_arena_release_discover();

  private:
  const ::qdrant::DiscoverInput& _internal_discover() const;
  ::qdrant::DiscoverInput* PROTOBUF_NONNULL _internal_mutable_discover();

  public:
  // .qdrant.ContextInput context = 4;
  bool has_context() const;
  private:
  bool _internal_has_context() const;

  public:
  void clear_context() ;
  const ::qdrant::ContextInput& context() const;
  [[nodiscard]] ::qdrant::ContextInput* PROTOBUF_NULLABLE release_context();
  ::qdrant::ContextInput* PROTOBUF_NONNULL mutable_context();
  void set_allocated_context(::qdrant::ContextInput* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_context(::qdrant::ContextInput* PROTOBUF_NULLABLE value);
  ::qdrant::ContextInput* PROTOBUF_NULLABLE unsafe_arena_release_context();

  private:
  const ::qdrant::ContextInput& _internal_context() const;
  ::qdrant::ContextInput* PROTOBUF_NONNULL _internal_mutable_context();

  public:
  // .qdrant.OrderBy order_by = 5;
  bool has_order_by() const;
  private:
  bool _internal_has_order_by() const;

  public:
  void clear_order_by() ;
  const ::qdrant::OrderBy& order_by() const;
  [[nodiscard]] ::qdrant::OrderBy* PROTOBUF_NULLABLE release_order_by();
  ::qdrant::OrderBy* PROTOBUF_NONNULL mutable_order_by();
  void set_allocated_order_by(::qdrant::OrderBy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_order_by(::qdrant::OrderBy* PROTOBUF_NULLABLE value);
  ::qdrant::OrderBy* PROTOBUF_NULLABLE unsafe_arena_release_order_by();

  private:
  const ::qdrant::OrderBy& _internal_order_by() const;
  ::qdrant::OrderBy* PROTOBUF_NONNULL _internal_mutable_order_by();

  public:
  // .qdrant.Fusion fusion = 6;
  bool has_fusion() const;
  void clear_fusion() ;
  ::qdrant::Fusion fusion() const;
  void set_fusion(::qdrant::Fusion value);

  private:
  ::qdrant::Fusion _internal_fusion() const;
  void _internal_set_fusion(::qdrant::Fusion value);

  public:
  // .qdrant.Sample sample = 7;
  bool has_sample() const;
  void clear_sample() ;
  ::qdrant::Sample sample() const;
  void set_sample(::qdrant::Sample value);

  private:
  ::qdrant::Sample _internal_sample() const;
  void _internal_set_sample(::qdrant::Sample value);

  public:
  // .qdrant.Formula formula = 8;
  bool has_formula() const;
  private:
  bool _internal_has_formula() const;

  public:
  void clear_formula() ;
  const ::qdrant::Formula& formula() const;
  [[nodiscard]] ::qdrant::Formula* PROTOBUF_NULLABLE release_formula();
  ::qdrant::Formula* PROTOBUF_NONNULL mutable_formula();
  void set_allocated_formula(::qdrant::Formula* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_formula(::qdrant::Formula* PROTOBUF_NULLABLE value);
  ::qdrant::Formula* PROTOBUF_NULLABLE unsafe_arena_release_formula();

  private:
  const ::qdrant::Formula& _internal_formula() const;
  ::qdrant::Formula* PROTOBUF_NONNULL _internal_mutable_formula();

  public:
  // .qdrant.NearestInputWithMmr nearest_with_mmr = 9;
  bool has_nearest_with_mmr() const;
  private:
  bool _internal_has_nearest_with_mmr() const;

  public:
  void clear_nearest_with_mmr() ;
  const ::qdrant::NearestInputWithMmr& nearest_with_mmr() const;
  [[nodiscard]] ::qdrant::NearestInputWithMmr* PROTOBUF_NULLABLE release_nearest_with_mmr();
  ::qdrant::NearestInputWithMmr* PROTOBUF_NONNULL mutable_nearest_with_mmr();
  void set_allocated_nearest_with_mmr(::qdrant::NearestInputWithMmr* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_nearest_with_mmr(::qdrant::NearestInputWithMmr* PROTOBUF_NULLABLE value);
  ::qdrant::NearestInputWithMmr* PROTOBUF_NULLABLE unsafe_arena_release_nearest_with_mmr();

  private:
  const ::qdrant::NearestInputWithMmr& _internal_nearest_with_mmr() const;
  ::qdrant::NearestInputWithMmr* PROTOBUF_NONNULL _internal_mutable_nearest_with_mmr();

  public:
  // .qdrant.Rrf rrf = 10;
  bool has_rrf() const;
  private:
  bool _internal_has_rrf() const;

  public:
  void clear_rrf() ;
  const ::qdrant::Rrf& rrf() const;
  [[nodiscard]] ::qdrant::Rrf* PROTOBUF_NULLABLE release_rrf();
  ::qdrant::Rrf* PROTOBUF_NONNULL mutable_rrf();
  void set_allocated_rrf(::qdrant::Rrf* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_rrf(::qdrant::Rrf* PROTOBUF_NULLABLE value);
  ::qdrant::Rrf* PROTOBUF_NULLABLE unsafe_arena_release_rrf();

  private:
  const ::qdrant::Rrf& _internal_rrf() const;
  ::qdrant::Rrf* PROTOBUF_NONNULL _internal_mutable_rrf();

  public:
  void clear_variant();
  VariantCase variant_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.Query)
 private:
  class _Internal;
  void set_has_nearest();
  void set_has_recommend();
  void set_has_discover();
  void set_has_context();
  void set_has_order_by();
  void set_has_fusion();
  void set_has_sample();
  void set_has_formula();
  void set_has_nearest_with_mmr();
  void set_has_rrf();
  inline bool has_variant() const;
  inline void clear_has_variant();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 10,
                                   8, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Query& from_msg);
    union VariantUnion {
      constexpr VariantUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE nearest_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE recommend_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE discover_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE context_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE order_by_;
      int fusion_;
      int sample_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE formula_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE nearest_with_mmr_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE rrf_;
    } variant_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Query_class_data_;
// -------------------------------------------------------------------

class PointVectors final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PointVectors) */ {
 public:
  inline PointVectors() : PointVectors(nullptr) {}
  ~PointVectors() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointVectors* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointVectors));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointVectors(::google::protobuf::internal::ConstantInitialized);

  inline PointVectors(const PointVectors& from) : PointVectors(nullptr, from) {}
  inline PointVectors(PointVectors&& from) noexcept
      : PointVectors(nullptr, ::std::move(from)) {}
  inline PointVectors& operator=(const PointVectors& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointVectors& operator=(PointVectors&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointVectors& default_instance() {
    return *reinterpret_cast<const PointVectors*>(
        &_PointVectors_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(PointVectors& a, PointVectors& b) { a.Swap(&b); }
  inline void Swap(PointVectors* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointVectors* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointVectors* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointVectors>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointVectors& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointVectors& from) { PointVectors::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointVectors* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PointVectors"; }

  explicit PointVectors(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointVectors(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointVectors& from);
  PointVectors(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointVectors&& from) noexcept
      : PointVectors(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kVectorsFieldNumber = 2,
  };
  // .qdrant.PointId id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::qdrant::PointId& id() const;
  [[nodiscard]] ::qdrant::PointId* PROTOBUF_NULLABLE release_id();
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_id();
  void set_allocated_id(::qdrant::PointId* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_id(::qdrant::PointId* PROTOBUF_NULLABLE value);
  ::qdrant::PointId* PROTOBUF_NULLABLE unsafe_arena_release_id();

  private:
  const ::qdrant::PointId& _internal_id() const;
  ::qdrant::PointId* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // .qdrant.Vectors vectors = 2;
  bool has_vectors() const;
  void clear_vectors() ;
  const ::qdrant::Vectors& vectors() const;
  [[nodiscard]] ::qdrant::Vectors* PROTOBUF_NULLABLE release_vectors();
  ::qdrant::Vectors* PROTOBUF_NONNULL mutable_vectors();
  void set_allocated_vectors(::qdrant::Vectors* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vectors(::qdrant::Vectors* PROTOBUF_NULLABLE value);
  ::qdrant::Vectors* PROTOBUF_NULLABLE unsafe_arena_release_vectors();

  private:
  const ::qdrant::Vectors& _internal_vectors() const;
  ::qdrant::Vectors* PROTOBUF_NONNULL _internal_mutable_vectors();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.PointVectors)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointVectors& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::PointId* PROTOBUF_NULLABLE id_;
    ::qdrant::Vectors* PROTOBUF_NULLABLE vectors_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointVectors_class_data_;
// -------------------------------------------------------------------

class PointStruct final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PointStruct) */ {
 public:
  inline PointStruct() : PointStruct(nullptr) {}
  ~PointStruct() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointStruct* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointStruct));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointStruct(::google::protobuf::internal::ConstantInitialized);

  inline PointStruct(const PointStruct& from) : PointStruct(nullptr, from) {}
  inline PointStruct(PointStruct&& from) noexcept
      : PointStruct(nullptr, ::std::move(from)) {}
  inline PointStruct& operator=(const PointStruct& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointStruct& operator=(PointStruct&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointStruct& default_instance() {
    return *reinterpret_cast<const PointStruct*>(
        &_PointStruct_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 151;
  friend void swap(PointStruct& a, PointStruct& b) { a.Swap(&b); }
  inline void Swap(PointStruct* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointStruct* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointStruct* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointStruct>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointStruct& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointStruct& from) { PointStruct::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointStruct* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PointStruct"; }

  explicit PointStruct(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointStruct(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointStruct& from);
  PointStruct(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointStruct&& from) noexcept
      : PointStruct(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kVectorsFieldNumber = 4,
    kPayloadFieldNumber = 3,
  };
  // .qdrant.PointId id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::qdrant::PointId& id() const;
  [[nodiscard]] ::qdrant::PointId* PROTOBUF_NULLABLE release_id();
  ::qdrant::PointId* PROTOBUF_NONNULL mutable_id();
  void set_allocated_id(::qdrant::PointId* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_id(::qdrant::PointId* PROTOBUF_NULLABLE value);
  ::qdrant::PointId* PROTOBUF_NULLABLE unsafe_arena_release_id();

  private:
  const ::qdrant::PointId& _internal_id() const;
  ::qdrant::PointId* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // optional .qdrant.Vectors vectors = 4;
  bool has_vectors() const;
  void clear_vectors() ;
  const ::qdrant::Vectors& vectors() const;
  [[nodiscard]] ::qdrant::Vectors* PROTOBUF_NULLABLE release_vectors();
  ::qdrant::Vectors* PROTOBUF_NONNULL mutable_vectors();
  void set_allocated_vectors(::qdrant::Vectors* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vectors(::qdrant::Vectors* PROTOBUF_NULLABLE value);
  ::qdrant::Vectors* PROTOBUF_NULLABLE unsafe_arena_release_vectors();

  private:
  const ::qdrant::Vectors& _internal_vectors() const;
  ::qdrant::Vectors* PROTOBUF_NONNULL _internal_mutable_vectors();

  public:
  // map<string, .qdrant.Value> payload = 3;
  int payload_size() const;
  private:
  int _internal_payload_size() const;

  public:
  void clear_payload() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& payload() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL mutable_payload();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& _internal_payload() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL _internal_mutable_payload();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.PointStruct)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 3,
                                   4, 34,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointStruct& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::PointId* PROTOBUF_NULLABLE id_;
    ::qdrant::Vectors* PROTOBUF_NULLABLE vectors_;
    ::google::protobuf::internal::MapField<PointStruct_PayloadEntry_DoNotUse, ::std::string, ::qdrant::Value,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        payload_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointStruct_class_data_;
// -------------------------------------------------------------------

class PointGroup final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PointGroup) */ {
 public:
  inline PointGroup() : PointGroup(nullptr) {}
  ~PointGroup() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointGroup* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointGroup));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointGroup(::google::protobuf::internal::ConstantInitialized);

  inline PointGroup(const PointGroup& from) : PointGroup(nullptr, from) {}
  inline PointGroup(PointGroup&& from) noexcept
      : PointGroup(nullptr, ::std::move(from)) {}
  inline PointGroup& operator=(const PointGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointGroup& operator=(PointGroup&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointGroup& default_instance() {
    return *reinterpret_cast<const PointGroup*>(
        &_PointGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 105;
  friend void swap(PointGroup& a, PointGroup& b) { a.Swap(&b); }
  inline void Swap(PointGroup* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointGroup* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointGroup* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointGroup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointGroup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointGroup& from) { PointGroup::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointGroup* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PointGroup"; }

  explicit PointGroup(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointGroup(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointGroup& from);
  PointGroup(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointGroup&& from) noexcept
      : PointGroup(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHitsFieldNumber = 2,
    kIdFieldNumber = 1,
    kLookupFieldNumber = 3,
  };
  // repeated .qdrant.ScoredPoint hits = 2;
  int hits_size() const;
  private:
  int _internal_hits_size() const;

  public:
  void clear_hits() ;
  ::qdrant::ScoredPoint* PROTOBUF_NONNULL mutable_hits(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL mutable_hits();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& _internal_hits() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL _internal_mutable_hits();
  public:
  const ::qdrant::ScoredPoint& hits(int index) const;
  ::qdrant::ScoredPoint* PROTOBUF_NONNULL add_hits();
  const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& hits() const;
  // .qdrant.GroupId id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::qdrant::GroupId& id() const;
  [[nodiscard]] ::qdrant::GroupId* PROTOBUF_NULLABLE release_id();
  ::qdrant::GroupId* PROTOBUF_NONNULL mutable_id();
  void set_allocated_id(::qdrant::GroupId* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_id(::qdrant::GroupId* PROTOBUF_NULLABLE value);
  ::qdrant::GroupId* PROTOBUF_NULLABLE unsafe_arena_release_id();

  private:
  const ::qdrant::GroupId& _internal_id() const;
  ::qdrant::GroupId* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // .qdrant.RetrievedPoint lookup = 3;
  bool has_lookup() const;
  void clear_lookup() ;
  const ::qdrant::RetrievedPoint& lookup() const;
  [[nodiscard]] ::qdrant::RetrievedPoint* PROTOBUF_NULLABLE release_lookup();
  ::qdrant::RetrievedPoint* PROTOBUF_NONNULL mutable_lookup();
  void set_allocated_lookup(::qdrant::RetrievedPoint* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lookup(::qdrant::RetrievedPoint* PROTOBUF_NULLABLE value);
  ::qdrant::RetrievedPoint* PROTOBUF_NULLABLE unsafe_arena_release_lookup();

  private:
  const ::qdrant::RetrievedPoint& _internal_lookup() const;
  ::qdrant::RetrievedPoint* PROTOBUF_NONNULL _internal_mutable_lookup();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.PointGroup)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointGroup& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::ScoredPoint > hits_;
    ::qdrant::GroupId* PROTOBUF_NULLABLE id_;
    ::qdrant::RetrievedPoint* PROTOBUF_NULLABLE lookup_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointGroup_class_data_;
// -------------------------------------------------------------------

class GetResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.GetResponse) */ {
 public:
  inline GetResponse() : GetResponse(nullptr) {}
  ~GetResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetResponse(const GetResponse& from) : GetResponse(nullptr, from) {}
  inline GetResponse(GetResponse&& from) noexcept
      : GetResponse(nullptr, ::std::move(from)) {}
  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponse& operator=(GetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponse& default_instance() {
    return *reinterpret_cast<const GetResponse*>(
        &_GetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 119;
  friend void swap(GetResponse& a, GetResponse& b) { a.Swap(&b); }
  inline void Swap(GetResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetResponse& from) { GetResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.GetResponse"; }

  explicit GetResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetResponse& from);
  GetResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetResponse&& from) noexcept
      : GetResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // repeated .qdrant.RetrievedPoint result = 1;
  int result_size() const;
  private:
  int _internal_result_size() const;

  public:
  void clear_result() ;
  ::qdrant::RetrievedPoint* PROTOBUF_NONNULL mutable_result(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::RetrievedPoint>* PROTOBUF_NONNULL mutable_result();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::RetrievedPoint>& _internal_result() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::RetrievedPoint>* PROTOBUF_NONNULL _internal_mutable_result();
  public:
  const ::qdrant::RetrievedPoint& result(int index) const;
  ::qdrant::RetrievedPoint* PROTOBUF_NONNULL add_result();
  const ::google::protobuf::RepeatedPtrField<::qdrant::RetrievedPoint>& result() const;
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.GetResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::RetrievedPoint > result_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetResponse_class_data_;
// -------------------------------------------------------------------

class DiscoverResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DiscoverResponse) */ {
 public:
  inline DiscoverResponse() : DiscoverResponse(nullptr) {}
  ~DiscoverResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DiscoverResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DiscoverResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DiscoverResponse(::google::protobuf::internal::ConstantInitialized);

  inline DiscoverResponse(const DiscoverResponse& from) : DiscoverResponse(nullptr, from) {}
  inline DiscoverResponse(DiscoverResponse&& from) noexcept
      : DiscoverResponse(nullptr, ::std::move(from)) {}
  inline DiscoverResponse& operator=(const DiscoverResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscoverResponse& operator=(DiscoverResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiscoverResponse& default_instance() {
    return *reinterpret_cast<const DiscoverResponse*>(
        &_DiscoverResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 122;
  friend void swap(DiscoverResponse& a, DiscoverResponse& b) { a.Swap(&b); }
  inline void Swap(DiscoverResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiscoverResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiscoverResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DiscoverResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DiscoverResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DiscoverResponse& from) { DiscoverResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DiscoverResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DiscoverResponse"; }

  explicit DiscoverResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DiscoverResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DiscoverResponse& from);
  DiscoverResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DiscoverResponse&& from) noexcept
      : DiscoverResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // repeated .qdrant.ScoredPoint result = 1;
  int result_size() const;
  private:
  int _internal_result_size() const;

  public:
  void clear_result() ;
  ::qdrant::ScoredPoint* PROTOBUF_NONNULL mutable_result(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL mutable_result();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& _internal_result() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL _internal_mutable_result();
  public:
  const ::qdrant::ScoredPoint& result(int index) const;
  ::qdrant::ScoredPoint* PROTOBUF_NONNULL add_result();
  const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& result() const;
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DiscoverResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DiscoverResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::ScoredPoint > result_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DiscoverResponse_class_data_;
// -------------------------------------------------------------------

class DiscoverBatchPoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DiscoverBatchPoints) */ {
 public:
  inline DiscoverBatchPoints() : DiscoverBatchPoints(nullptr) {}
  ~DiscoverBatchPoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DiscoverBatchPoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DiscoverBatchPoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DiscoverBatchPoints(::google::protobuf::internal::ConstantInitialized);

  inline DiscoverBatchPoints(const DiscoverBatchPoints& from) : DiscoverBatchPoints(nullptr, from) {}
  inline DiscoverBatchPoints(DiscoverBatchPoints&& from) noexcept
      : DiscoverBatchPoints(nullptr, ::std::move(from)) {}
  inline DiscoverBatchPoints& operator=(const DiscoverBatchPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscoverBatchPoints& operator=(DiscoverBatchPoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiscoverBatchPoints& default_instance() {
    return *reinterpret_cast<const DiscoverBatchPoints*>(
        &_DiscoverBatchPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 57;
  friend void swap(DiscoverBatchPoints& a, DiscoverBatchPoints& b) { a.Swap(&b); }
  inline void Swap(DiscoverBatchPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiscoverBatchPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiscoverBatchPoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DiscoverBatchPoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DiscoverBatchPoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DiscoverBatchPoints& from) { DiscoverBatchPoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DiscoverBatchPoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DiscoverBatchPoints"; }

  explicit DiscoverBatchPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DiscoverBatchPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DiscoverBatchPoints& from);
  DiscoverBatchPoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DiscoverBatchPoints&& from) noexcept
      : DiscoverBatchPoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDiscoverPointsFieldNumber = 2,
    kCollectionNameFieldNumber = 1,
    kReadConsistencyFieldNumber = 3,
    kTimeoutFieldNumber = 4,
  };
  // repeated .qdrant.DiscoverPoints discover_points = 2;
  int discover_points_size() const;
  private:
  int _internal_discover_points_size() const;

  public:
  void clear_discover_points() ;
  ::qdrant::DiscoverPoints* PROTOBUF_NONNULL mutable_discover_points(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::DiscoverPoints>* PROTOBUF_NONNULL mutable_discover_points();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::DiscoverPoints>& _internal_discover_points() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::DiscoverPoints>* PROTOBUF_NONNULL _internal_mutable_discover_points();
  public:
  const ::qdrant::DiscoverPoints& discover_points(int index) const;
  ::qdrant::DiscoverPoints* PROTOBUF_NONNULL add_discover_points();
  const ::google::protobuf::RepeatedPtrField<::qdrant::DiscoverPoints>& discover_points() const;
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional .qdrant.ReadConsistency read_consistency = 3;
  bool has_read_consistency() const;
  void clear_read_consistency() ;
  const ::qdrant::ReadConsistency& read_consistency() const;
  [[nodiscard]] ::qdrant::ReadConsistency* PROTOBUF_NULLABLE release_read_consistency();
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL mutable_read_consistency();
  void set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  ::qdrant::ReadConsistency* PROTOBUF_NULLABLE unsafe_arena_release_read_consistency();

  private:
  const ::qdrant::ReadConsistency& _internal_read_consistency() const;
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL _internal_mutable_read_consistency();

  public:
  // optional uint64 timeout = 4;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DiscoverBatchPoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   2, 50,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DiscoverBatchPoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::DiscoverPoints > discover_points_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE read_consistency_;
    ::uint64_t timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DiscoverBatchPoints_class_data_;
// -------------------------------------------------------------------

class BatchResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.BatchResult) */ {
 public:
  inline BatchResult() : BatchResult(nullptr) {}
  ~BatchResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BatchResult* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BatchResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BatchResult(::google::protobuf::internal::ConstantInitialized);

  inline BatchResult(const BatchResult& from) : BatchResult(nullptr, from) {}
  inline BatchResult(BatchResult&& from) noexcept
      : BatchResult(nullptr, ::std::move(from)) {}
  inline BatchResult& operator=(const BatchResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchResult& operator=(BatchResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchResult& default_instance() {
    return *reinterpret_cast<const BatchResult*>(
        &_BatchResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 111;
  friend void swap(BatchResult& a, BatchResult& b) { a.Swap(&b); }
  inline void Swap(BatchResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchResult* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BatchResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BatchResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BatchResult& from) { BatchResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BatchResult* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.BatchResult"; }

  explicit BatchResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BatchResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BatchResult& from);
  BatchResult(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BatchResult&& from) noexcept
      : BatchResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
  };
  // repeated .qdrant.ScoredPoint result = 1;
  int result_size() const;
  private:
  int _internal_result_size() const;

  public:
  void clear_result() ;
  ::qdrant::ScoredPoint* PROTOBUF_NONNULL mutable_result(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL mutable_result();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& _internal_result() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL _internal_mutable_result();
  public:
  const ::qdrant::ScoredPoint& result(int index) const;
  ::qdrant::ScoredPoint* PROTOBUF_NONNULL add_result();
  const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& result() const;
  // @@protoc_insertion_point(class_scope:qdrant.BatchResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BatchResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::ScoredPoint > result_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BatchResult_class_data_;
// -------------------------------------------------------------------

class UpsertPoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.UpsertPoints) */ {
 public:
  inline UpsertPoints() : UpsertPoints(nullptr) {}
  ~UpsertPoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpsertPoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpsertPoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpsertPoints(::google::protobuf::internal::ConstantInitialized);

  inline UpsertPoints(const UpsertPoints& from) : UpsertPoints(nullptr, from) {}
  inline UpsertPoints(UpsertPoints&& from) noexcept
      : UpsertPoints(nullptr, ::std::move(from)) {}
  inline UpsertPoints& operator=(const UpsertPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpsertPoints& operator=(UpsertPoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpsertPoints& default_instance() {
    return *reinterpret_cast<const UpsertPoints*>(
        &_UpsertPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(UpsertPoints& a, UpsertPoints& b) { a.Swap(&b); }
  inline void Swap(UpsertPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpsertPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpsertPoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpsertPoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpsertPoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpsertPoints& from) { UpsertPoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpsertPoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.UpsertPoints"; }

  explicit UpsertPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpsertPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpsertPoints& from);
  UpsertPoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpsertPoints&& from) noexcept
      : UpsertPoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPointsFieldNumber = 3,
    kCollectionNameFieldNumber = 1,
    kOrderingFieldNumber = 4,
    kShardKeySelectorFieldNumber = 5,
    kUpdateFilterFieldNumber = 6,
    kWaitFieldNumber = 2,
  };
  // repeated .qdrant.PointStruct points = 3;
  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  void clear_points() ;
  ::qdrant::PointStruct* PROTOBUF_NONNULL mutable_points(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::PointStruct>* PROTOBUF_NONNULL mutable_points();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointStruct>& _internal_points() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::PointStruct>* PROTOBUF_NONNULL _internal_mutable_points();
  public:
  const ::qdrant::PointStruct& points(int index) const;
  ::qdrant::PointStruct* PROTOBUF_NONNULL add_points();
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointStruct>& points() const;
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional .qdrant.WriteOrdering ordering = 4;
  bool has_ordering() const;
  void clear_ordering() ;
  const ::qdrant::WriteOrdering& ordering() const;
  [[nodiscard]] ::qdrant::WriteOrdering* PROTOBUF_NULLABLE release_ordering();
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL mutable_ordering();
  void set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  ::qdrant::WriteOrdering* PROTOBUF_NULLABLE unsafe_arena_release_ordering();

  private:
  const ::qdrant::WriteOrdering& _internal_ordering() const;
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL _internal_mutable_ordering();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 5;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional .qdrant.Filter update_filter = 6;
  bool has_update_filter() const;
  void clear_update_filter() ;
  const ::qdrant::Filter& update_filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_update_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_update_filter();
  void set_allocated_update_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_update_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_update_filter();

  private:
  const ::qdrant::Filter& _internal_update_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_update_filter();

  public:
  // optional bool wait = 2;
  bool has_wait() const;
  void clear_wait() ;
  bool wait() const;
  void set_wait(bool value);

  private:
  bool _internal_wait() const;
  void _internal_set_wait(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.UpsertPoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   4, 43,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpsertPoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::PointStruct > points_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE ordering_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::qdrant::Filter* PROTOBUF_NULLABLE update_filter_;
    bool wait_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpsertPoints_class_data_;
// -------------------------------------------------------------------

class UpdatePointVectors final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.UpdatePointVectors) */ {
 public:
  inline UpdatePointVectors() : UpdatePointVectors(nullptr) {}
  ~UpdatePointVectors() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdatePointVectors* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdatePointVectors));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdatePointVectors(::google::protobuf::internal::ConstantInitialized);

  inline UpdatePointVectors(const UpdatePointVectors& from) : UpdatePointVectors(nullptr, from) {}
  inline UpdatePointVectors(UpdatePointVectors&& from) noexcept
      : UpdatePointVectors(nullptr, ::std::move(from)) {}
  inline UpdatePointVectors& operator=(const UpdatePointVectors& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePointVectors& operator=(UpdatePointVectors&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePointVectors& default_instance() {
    return *reinterpret_cast<const UpdatePointVectors*>(
        &_UpdatePointVectors_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(UpdatePointVectors& a, UpdatePointVectors& b) { a.Swap(&b); }
  inline void Swap(UpdatePointVectors* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePointVectors* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdatePointVectors* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdatePointVectors>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdatePointVectors& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdatePointVectors& from) { UpdatePointVectors::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdatePointVectors* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.UpdatePointVectors"; }

  explicit UpdatePointVectors(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdatePointVectors(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdatePointVectors& from);
  UpdatePointVectors(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdatePointVectors&& from) noexcept
      : UpdatePointVectors(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPointsFieldNumber = 3,
    kCollectionNameFieldNumber = 1,
    kOrderingFieldNumber = 4,
    kShardKeySelectorFieldNumber = 5,
    kUpdateFilterFieldNumber = 6,
    kWaitFieldNumber = 2,
  };
  // repeated .qdrant.PointVectors points = 3;
  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  void clear_points() ;
  ::qdrant::PointVectors* PROTOBUF_NONNULL mutable_points(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::PointVectors>* PROTOBUF_NONNULL mutable_points();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointVectors>& _internal_points() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::PointVectors>* PROTOBUF_NONNULL _internal_mutable_points();
  public:
  const ::qdrant::PointVectors& points(int index) const;
  ::qdrant::PointVectors* PROTOBUF_NONNULL add_points();
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointVectors>& points() const;
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional .qdrant.WriteOrdering ordering = 4;
  bool has_ordering() const;
  void clear_ordering() ;
  const ::qdrant::WriteOrdering& ordering() const;
  [[nodiscard]] ::qdrant::WriteOrdering* PROTOBUF_NULLABLE release_ordering();
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL mutable_ordering();
  void set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  ::qdrant::WriteOrdering* PROTOBUF_NULLABLE unsafe_arena_release_ordering();

  private:
  const ::qdrant::WriteOrdering& _internal_ordering() const;
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL _internal_mutable_ordering();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 5;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional .qdrant.Filter update_filter = 6;
  bool has_update_filter() const;
  void clear_update_filter() ;
  const ::qdrant::Filter& update_filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_update_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_update_filter();
  void set_allocated_update_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_update_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_update_filter();

  private:
  const ::qdrant::Filter& _internal_update_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_update_filter();

  public:
  // optional bool wait = 2;
  bool has_wait() const;
  void clear_wait() ;
  bool wait() const;
  void set_wait(bool value);

  private:
  bool _internal_wait() const;
  void _internal_set_wait(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.UpdatePointVectors)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   4, 49,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdatePointVectors& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::PointVectors > points_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE ordering_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::qdrant::Filter* PROTOBUF_NULLABLE update_filter_;
    bool wait_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdatePointVectors_class_data_;
// -------------------------------------------------------------------

class SearchBatchResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SearchBatchResponse) */ {
 public:
  inline SearchBatchResponse() : SearchBatchResponse(nullptr) {}
  ~SearchBatchResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SearchBatchResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SearchBatchResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SearchBatchResponse(::google::protobuf::internal::ConstantInitialized);

  inline SearchBatchResponse(const SearchBatchResponse& from) : SearchBatchResponse(nullptr, from) {}
  inline SearchBatchResponse(SearchBatchResponse&& from) noexcept
      : SearchBatchResponse(nullptr, ::std::move(from)) {}
  inline SearchBatchResponse& operator=(const SearchBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchBatchResponse& operator=(SearchBatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchBatchResponse& default_instance() {
    return *reinterpret_cast<const SearchBatchResponse*>(
        &_SearchBatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 112;
  friend void swap(SearchBatchResponse& a, SearchBatchResponse& b) { a.Swap(&b); }
  inline void Swap(SearchBatchResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchBatchResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchBatchResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SearchBatchResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchBatchResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SearchBatchResponse& from) { SearchBatchResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SearchBatchResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SearchBatchResponse"; }

  explicit SearchBatchResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SearchBatchResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SearchBatchResponse& from);
  SearchBatchResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SearchBatchResponse&& from) noexcept
      : SearchBatchResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // repeated .qdrant.BatchResult result = 1;
  int result_size() const;
  private:
  int _internal_result_size() const;

  public:
  void clear_result() ;
  ::qdrant::BatchResult* PROTOBUF_NONNULL mutable_result(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>* PROTOBUF_NONNULL mutable_result();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>& _internal_result() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>* PROTOBUF_NONNULL _internal_mutable_result();
  public:
  const ::qdrant::BatchResult& result(int index) const;
  ::qdrant::BatchResult* PROTOBUF_NONNULL add_result();
  const ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>& result() const;
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SearchBatchResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SearchBatchResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::BatchResult > result_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SearchBatchResponse_class_data_;
// -------------------------------------------------------------------

class RecommendBatchResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.RecommendBatchResponse) */ {
 public:
  inline RecommendBatchResponse() : RecommendBatchResponse(nullptr) {}
  ~RecommendBatchResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RecommendBatchResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RecommendBatchResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RecommendBatchResponse(::google::protobuf::internal::ConstantInitialized);

  inline RecommendBatchResponse(const RecommendBatchResponse& from) : RecommendBatchResponse(nullptr, from) {}
  inline RecommendBatchResponse(RecommendBatchResponse&& from) noexcept
      : RecommendBatchResponse(nullptr, ::std::move(from)) {}
  inline RecommendBatchResponse& operator=(const RecommendBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecommendBatchResponse& operator=(RecommendBatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecommendBatchResponse& default_instance() {
    return *reinterpret_cast<const RecommendBatchResponse*>(
        &_RecommendBatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 121;
  friend void swap(RecommendBatchResponse& a, RecommendBatchResponse& b) { a.Swap(&b); }
  inline void Swap(RecommendBatchResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecommendBatchResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecommendBatchResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RecommendBatchResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecommendBatchResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RecommendBatchResponse& from) { RecommendBatchResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RecommendBatchResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.RecommendBatchResponse"; }

  explicit RecommendBatchResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RecommendBatchResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RecommendBatchResponse& from);
  RecommendBatchResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RecommendBatchResponse&& from) noexcept
      : RecommendBatchResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // repeated .qdrant.BatchResult result = 1;
  int result_size() const;
  private:
  int _internal_result_size() const;

  public:
  void clear_result() ;
  ::qdrant::BatchResult* PROTOBUF_NONNULL mutable_result(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>* PROTOBUF_NONNULL mutable_result();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>& _internal_result() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>* PROTOBUF_NONNULL _internal_mutable_result();
  public:
  const ::qdrant::BatchResult& result(int index) const;
  ::qdrant::BatchResult* PROTOBUF_NONNULL add_result();
  const ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>& result() const;
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.RecommendBatchResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RecommendBatchResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::BatchResult > result_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RecommendBatchResponse_class_data_;
// -------------------------------------------------------------------

class QueryBatchResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.QueryBatchResponse) */ {
 public:
  inline QueryBatchResponse() : QueryBatchResponse(nullptr) {}
  ~QueryBatchResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QueryBatchResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QueryBatchResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryBatchResponse(::google::protobuf::internal::ConstantInitialized);

  inline QueryBatchResponse(const QueryBatchResponse& from) : QueryBatchResponse(nullptr, from) {}
  inline QueryBatchResponse(QueryBatchResponse&& from) noexcept
      : QueryBatchResponse(nullptr, ::std::move(from)) {}
  inline QueryBatchResponse& operator=(const QueryBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryBatchResponse& operator=(QueryBatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryBatchResponse& default_instance() {
    return *reinterpret_cast<const QueryBatchResponse*>(
        &_QueryBatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 109;
  friend void swap(QueryBatchResponse& a, QueryBatchResponse& b) { a.Swap(&b); }
  inline void Swap(QueryBatchResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryBatchResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryBatchResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QueryBatchResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryBatchResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryBatchResponse& from) { QueryBatchResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QueryBatchResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.QueryBatchResponse"; }

  explicit QueryBatchResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QueryBatchResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QueryBatchResponse& from);
  QueryBatchResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QueryBatchResponse&& from) noexcept
      : QueryBatchResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // repeated .qdrant.BatchResult result = 1;
  int result_size() const;
  private:
  int _internal_result_size() const;

  public:
  void clear_result() ;
  ::qdrant::BatchResult* PROTOBUF_NONNULL mutable_result(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>* PROTOBUF_NONNULL mutable_result();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>& _internal_result() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>* PROTOBUF_NONNULL _internal_mutable_result();
  public:
  const ::qdrant::BatchResult& result(int index) const;
  ::qdrant::BatchResult* PROTOBUF_NONNULL add_result();
  const ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>& result() const;
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.QueryBatchResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QueryBatchResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::BatchResult > result_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QueryBatchResponse_class_data_;
// -------------------------------------------------------------------

class PrefetchQuery final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PrefetchQuery) */ {
 public:
  inline PrefetchQuery() : PrefetchQuery(nullptr) {}
  ~PrefetchQuery() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PrefetchQuery* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PrefetchQuery));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PrefetchQuery(::google::protobuf::internal::ConstantInitialized);

  inline PrefetchQuery(const PrefetchQuery& from) : PrefetchQuery(nullptr, from) {}
  inline PrefetchQuery(PrefetchQuery&& from) noexcept
      : PrefetchQuery(nullptr, ::std::move(from)) {}
  inline PrefetchQuery& operator=(const PrefetchQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrefetchQuery& operator=(PrefetchQuery&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrefetchQuery& default_instance() {
    return *reinterpret_cast<const PrefetchQuery*>(
        &_PrefetchQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 76;
  friend void swap(PrefetchQuery& a, PrefetchQuery& b) { a.Swap(&b); }
  inline void Swap(PrefetchQuery* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrefetchQuery* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrefetchQuery* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PrefetchQuery>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PrefetchQuery& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PrefetchQuery& from) { PrefetchQuery::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PrefetchQuery* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PrefetchQuery"; }

  explicit PrefetchQuery(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PrefetchQuery(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PrefetchQuery& from);
  PrefetchQuery(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PrefetchQuery&& from) noexcept
      : PrefetchQuery(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPrefetchFieldNumber = 1,
    kUsingFieldNumber = 3,
    kQueryFieldNumber = 2,
    kFilterFieldNumber = 4,
    kParamsFieldNumber = 5,
    kLookupFromFieldNumber = 8,
    kLimitFieldNumber = 7,
    kScoreThresholdFieldNumber = 6,
  };
  // repeated .qdrant.PrefetchQuery prefetch = 1;
  int prefetch_size() const;
  private:
  int _internal_prefetch_size() const;

  public:
  void clear_prefetch() ;
  ::qdrant::PrefetchQuery* PROTOBUF_NONNULL mutable_prefetch(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>* PROTOBUF_NONNULL mutable_prefetch();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>& _internal_prefetch() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>* PROTOBUF_NONNULL _internal_mutable_prefetch();
  public:
  const ::qdrant::PrefetchQuery& prefetch(int index) const;
  ::qdrant::PrefetchQuery* PROTOBUF_NONNULL add_prefetch();
  const ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>& prefetch() const;
  // optional string using = 3;
  bool has_using_() const;
  void clear_using_() ;
  const ::std::string& using_() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_using_(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_using_();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_using_();
  void set_allocated_using_(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_using_() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_using_(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_using_();

  public:
  // optional .qdrant.Query query = 2;
  bool has_query() const;
  void clear_query() ;
  const ::qdrant::Query& query() const;
  [[nodiscard]] ::qdrant::Query* PROTOBUF_NULLABLE release_query();
  ::qdrant::Query* PROTOBUF_NONNULL mutable_query();
  void set_allocated_query(::qdrant::Query* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_query(::qdrant::Query* PROTOBUF_NULLABLE value);
  ::qdrant::Query* PROTOBUF_NULLABLE unsafe_arena_release_query();

  private:
  const ::qdrant::Query& _internal_query() const;
  ::qdrant::Query* PROTOBUF_NONNULL _internal_mutable_query();

  public:
  // optional .qdrant.Filter filter = 4;
  bool has_filter() const;
  void clear_filter() ;
  const ::qdrant::Filter& filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_filter();
  void set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_filter();

  private:
  const ::qdrant::Filter& _internal_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_filter();

  public:
  // optional .qdrant.SearchParams params = 5;
  bool has_params() const;
  void clear_params() ;
  const ::qdrant::SearchParams& params() const;
  [[nodiscard]] ::qdrant::SearchParams* PROTOBUF_NULLABLE release_params();
  ::qdrant::SearchParams* PROTOBUF_NONNULL mutable_params();
  void set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value);
  ::qdrant::SearchParams* PROTOBUF_NULLABLE unsafe_arena_release_params();

  private:
  const ::qdrant::SearchParams& _internal_params() const;
  ::qdrant::SearchParams* PROTOBUF_NONNULL _internal_mutable_params();

  public:
  // optional .qdrant.LookupLocation lookup_from = 8;
  bool has_lookup_from() const;
  void clear_lookup_from() ;
  const ::qdrant::LookupLocation& lookup_from() const;
  [[nodiscard]] ::qdrant::LookupLocation* PROTOBUF_NULLABLE release_lookup_from();
  ::qdrant::LookupLocation* PROTOBUF_NONNULL mutable_lookup_from();
  void set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value);
  ::qdrant::LookupLocation* PROTOBUF_NULLABLE unsafe_arena_release_lookup_from();

  private:
  const ::qdrant::LookupLocation& _internal_lookup_from() const;
  ::qdrant::LookupLocation* PROTOBUF_NONNULL _internal_mutable_lookup_from();

  public:
  // optional uint64 limit = 7;
  bool has_limit() const;
  void clear_limit() ;
  ::uint64_t limit() const;
  void set_limit(::uint64_t value);

  private:
  ::uint64_t _internal_limit() const;
  void _internal_set_limit(::uint64_t value);

  public:
  // optional float score_threshold = 6;
  bool has_score_threshold() const;
  void clear_score_threshold() ;
  float score_threshold() const;
  void set_score_threshold(float value);

  private:
  float _internal_score_threshold() const;
  void _internal_set_score_threshold(float value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.PrefetchQuery)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   5, 42,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PrefetchQuery& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::PrefetchQuery > prefetch_;
    ::google::protobuf::internal::ArenaStringPtr using__;
    ::qdrant::Query* PROTOBUF_NULLABLE query_;
    ::qdrant::Filter* PROTOBUF_NULLABLE filter_;
    ::qdrant::SearchParams* PROTOBUF_NULLABLE params_;
    ::qdrant::LookupLocation* PROTOBUF_NULLABLE lookup_from_;
    ::uint64_t limit_;
    float score_threshold_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PrefetchQuery_class_data_;
// -------------------------------------------------------------------

class PointsUpdateOperation_UpdateVectors final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PointsUpdateOperation.UpdateVectors) */ {
 public:
  inline PointsUpdateOperation_UpdateVectors() : PointsUpdateOperation_UpdateVectors(nullptr) {}
  ~PointsUpdateOperation_UpdateVectors() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointsUpdateOperation_UpdateVectors* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointsUpdateOperation_UpdateVectors));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointsUpdateOperation_UpdateVectors(::google::protobuf::internal::ConstantInitialized);

  inline PointsUpdateOperation_UpdateVectors(const PointsUpdateOperation_UpdateVectors& from) : PointsUpdateOperation_UpdateVectors(nullptr, from) {}
  inline PointsUpdateOperation_UpdateVectors(PointsUpdateOperation_UpdateVectors&& from) noexcept
      : PointsUpdateOperation_UpdateVectors(nullptr, ::std::move(from)) {}
  inline PointsUpdateOperation_UpdateVectors& operator=(const PointsUpdateOperation_UpdateVectors& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointsUpdateOperation_UpdateVectors& operator=(PointsUpdateOperation_UpdateVectors&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointsUpdateOperation_UpdateVectors& default_instance() {
    return *reinterpret_cast<const PointsUpdateOperation_UpdateVectors*>(
        &_PointsUpdateOperation_UpdateVectors_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 93;
  friend void swap(PointsUpdateOperation_UpdateVectors& a, PointsUpdateOperation_UpdateVectors& b) { a.Swap(&b); }
  inline void Swap(PointsUpdateOperation_UpdateVectors* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointsUpdateOperation_UpdateVectors* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointsUpdateOperation_UpdateVectors* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointsUpdateOperation_UpdateVectors>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointsUpdateOperation_UpdateVectors& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointsUpdateOperation_UpdateVectors& from) { PointsUpdateOperation_UpdateVectors::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointsUpdateOperation_UpdateVectors* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PointsUpdateOperation.UpdateVectors"; }

  explicit PointsUpdateOperation_UpdateVectors(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointsUpdateOperation_UpdateVectors(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointsUpdateOperation_UpdateVectors& from);
  PointsUpdateOperation_UpdateVectors(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointsUpdateOperation_UpdateVectors&& from) noexcept
      : PointsUpdateOperation_UpdateVectors(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPointsFieldNumber = 1,
    kShardKeySelectorFieldNumber = 2,
    kUpdateFilterFieldNumber = 3,
  };
  // repeated .qdrant.PointVectors points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  void clear_points() ;
  ::qdrant::PointVectors* PROTOBUF_NONNULL mutable_points(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::PointVectors>* PROTOBUF_NONNULL mutable_points();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointVectors>& _internal_points() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::PointVectors>* PROTOBUF_NONNULL _internal_mutable_points();
  public:
  const ::qdrant::PointVectors& points(int index) const;
  ::qdrant::PointVectors* PROTOBUF_NONNULL add_points();
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointVectors>& points() const;
  // optional .qdrant.ShardKeySelector shard_key_selector = 2;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional .qdrant.Filter update_filter = 3;
  bool has_update_filter() const;
  void clear_update_filter() ;
  const ::qdrant::Filter& update_filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_update_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_update_filter();
  void set_allocated_update_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_update_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_update_filter();

  private:
  const ::qdrant::Filter& _internal_update_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_update_filter();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.PointsUpdateOperation.UpdateVectors)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointsUpdateOperation_UpdateVectors& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::PointVectors > points_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::qdrant::Filter* PROTOBUF_NULLABLE update_filter_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_UpdateVectors_class_data_;
// -------------------------------------------------------------------

class PointsUpdateOperation_PointStructList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PointsUpdateOperation.PointStructList) */ {
 public:
  inline PointsUpdateOperation_PointStructList() : PointsUpdateOperation_PointStructList(nullptr) {}
  ~PointsUpdateOperation_PointStructList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointsUpdateOperation_PointStructList* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointsUpdateOperation_PointStructList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointsUpdateOperation_PointStructList(::google::protobuf::internal::ConstantInitialized);

  inline PointsUpdateOperation_PointStructList(const PointsUpdateOperation_PointStructList& from) : PointsUpdateOperation_PointStructList(nullptr, from) {}
  inline PointsUpdateOperation_PointStructList(PointsUpdateOperation_PointStructList&& from) noexcept
      : PointsUpdateOperation_PointStructList(nullptr, ::std::move(from)) {}
  inline PointsUpdateOperation_PointStructList& operator=(const PointsUpdateOperation_PointStructList& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointsUpdateOperation_PointStructList& operator=(PointsUpdateOperation_PointStructList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointsUpdateOperation_PointStructList& default_instance() {
    return *reinterpret_cast<const PointsUpdateOperation_PointStructList*>(
        &_PointsUpdateOperation_PointStructList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 87;
  friend void swap(PointsUpdateOperation_PointStructList& a, PointsUpdateOperation_PointStructList& b) { a.Swap(&b); }
  inline void Swap(PointsUpdateOperation_PointStructList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointsUpdateOperation_PointStructList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointsUpdateOperation_PointStructList* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointsUpdateOperation_PointStructList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointsUpdateOperation_PointStructList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointsUpdateOperation_PointStructList& from) { PointsUpdateOperation_PointStructList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointsUpdateOperation_PointStructList* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PointsUpdateOperation.PointStructList"; }

  explicit PointsUpdateOperation_PointStructList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointsUpdateOperation_PointStructList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointsUpdateOperation_PointStructList& from);
  PointsUpdateOperation_PointStructList(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointsUpdateOperation_PointStructList&& from) noexcept
      : PointsUpdateOperation_PointStructList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPointsFieldNumber = 1,
    kShardKeySelectorFieldNumber = 2,
    kUpdateFilterFieldNumber = 3,
  };
  // repeated .qdrant.PointStruct points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  void clear_points() ;
  ::qdrant::PointStruct* PROTOBUF_NONNULL mutable_points(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::PointStruct>* PROTOBUF_NONNULL mutable_points();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointStruct>& _internal_points() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::PointStruct>* PROTOBUF_NONNULL _internal_mutable_points();
  public:
  const ::qdrant::PointStruct& points(int index) const;
  ::qdrant::PointStruct* PROTOBUF_NONNULL add_points();
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointStruct>& points() const;
  // optional .qdrant.ShardKeySelector shard_key_selector = 2;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional .qdrant.Filter update_filter = 3;
  bool has_update_filter() const;
  void clear_update_filter() ;
  const ::qdrant::Filter& update_filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_update_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_update_filter();
  void set_allocated_update_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_update_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_update_filter();

  private:
  const ::qdrant::Filter& _internal_update_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_update_filter();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.PointsUpdateOperation.PointStructList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointsUpdateOperation_PointStructList& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::PointStruct > points_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::qdrant::Filter* PROTOBUF_NULLABLE update_filter_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_PointStructList_class_data_;
// -------------------------------------------------------------------

class GroupsResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.GroupsResult) */ {
 public:
  inline GroupsResult() : GroupsResult(nullptr) {}
  ~GroupsResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GroupsResult* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GroupsResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GroupsResult(::google::protobuf::internal::ConstantInitialized);

  inline GroupsResult(const GroupsResult& from) : GroupsResult(nullptr, from) {}
  inline GroupsResult(GroupsResult&& from) noexcept
      : GroupsResult(nullptr, ::std::move(from)) {}
  inline GroupsResult& operator=(const GroupsResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupsResult& operator=(GroupsResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupsResult& default_instance() {
    return *reinterpret_cast<const GroupsResult*>(
        &_GroupsResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 106;
  friend void swap(GroupsResult& a, GroupsResult& b) { a.Swap(&b); }
  inline void Swap(GroupsResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupsResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupsResult* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GroupsResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GroupsResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GroupsResult& from) { GroupsResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GroupsResult* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.GroupsResult"; }

  explicit GroupsResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GroupsResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GroupsResult& from);
  GroupsResult(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GroupsResult&& from) noexcept
      : GroupsResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGroupsFieldNumber = 1,
  };
  // repeated .qdrant.PointGroup groups = 1;
  int groups_size() const;
  private:
  int _internal_groups_size() const;

  public:
  void clear_groups() ;
  ::qdrant::PointGroup* PROTOBUF_NONNULL mutable_groups(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::PointGroup>* PROTOBUF_NONNULL mutable_groups();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointGroup>& _internal_groups() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::PointGroup>* PROTOBUF_NONNULL _internal_mutable_groups();
  public:
  const ::qdrant::PointGroup& groups(int index) const;
  ::qdrant::PointGroup* PROTOBUF_NONNULL add_groups();
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointGroup>& groups() const;
  // @@protoc_insertion_point(class_scope:qdrant.GroupsResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GroupsResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::PointGroup > groups_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GroupsResult_class_data_;
// -------------------------------------------------------------------

class DiscoverBatchResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DiscoverBatchResponse) */ {
 public:
  inline DiscoverBatchResponse() : DiscoverBatchResponse(nullptr) {}
  ~DiscoverBatchResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DiscoverBatchResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DiscoverBatchResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DiscoverBatchResponse(::google::protobuf::internal::ConstantInitialized);

  inline DiscoverBatchResponse(const DiscoverBatchResponse& from) : DiscoverBatchResponse(nullptr, from) {}
  inline DiscoverBatchResponse(DiscoverBatchResponse&& from) noexcept
      : DiscoverBatchResponse(nullptr, ::std::move(from)) {}
  inline DiscoverBatchResponse& operator=(const DiscoverBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscoverBatchResponse& operator=(DiscoverBatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiscoverBatchResponse& default_instance() {
    return *reinterpret_cast<const DiscoverBatchResponse*>(
        &_DiscoverBatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 123;
  friend void swap(DiscoverBatchResponse& a, DiscoverBatchResponse& b) { a.Swap(&b); }
  inline void Swap(DiscoverBatchResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiscoverBatchResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiscoverBatchResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DiscoverBatchResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DiscoverBatchResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DiscoverBatchResponse& from) { DiscoverBatchResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DiscoverBatchResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DiscoverBatchResponse"; }

  explicit DiscoverBatchResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DiscoverBatchResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DiscoverBatchResponse& from);
  DiscoverBatchResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DiscoverBatchResponse&& from) noexcept
      : DiscoverBatchResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // repeated .qdrant.BatchResult result = 1;
  int result_size() const;
  private:
  int _internal_result_size() const;

  public:
  void clear_result() ;
  ::qdrant::BatchResult* PROTOBUF_NONNULL mutable_result(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>* PROTOBUF_NONNULL mutable_result();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>& _internal_result() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>* PROTOBUF_NONNULL _internal_mutable_result();
  public:
  const ::qdrant::BatchResult& result(int index) const;
  ::qdrant::BatchResult* PROTOBUF_NONNULL add_result();
  const ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>& result() const;
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DiscoverBatchResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DiscoverBatchResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::BatchResult > result_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DiscoverBatchResponse_class_data_;
// -------------------------------------------------------------------

class SearchGroupsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SearchGroupsResponse) */ {
 public:
  inline SearchGroupsResponse() : SearchGroupsResponse(nullptr) {}
  ~SearchGroupsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SearchGroupsResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SearchGroupsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SearchGroupsResponse(::google::protobuf::internal::ConstantInitialized);

  inline SearchGroupsResponse(const SearchGroupsResponse& from) : SearchGroupsResponse(nullptr, from) {}
  inline SearchGroupsResponse(SearchGroupsResponse&& from) noexcept
      : SearchGroupsResponse(nullptr, ::std::move(from)) {}
  inline SearchGroupsResponse& operator=(const SearchGroupsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchGroupsResponse& operator=(SearchGroupsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchGroupsResponse& default_instance() {
    return *reinterpret_cast<const SearchGroupsResponse*>(
        &_SearchGroupsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 113;
  friend void swap(SearchGroupsResponse& a, SearchGroupsResponse& b) { a.Swap(&b); }
  inline void Swap(SearchGroupsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchGroupsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchGroupsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SearchGroupsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchGroupsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SearchGroupsResponse& from) { SearchGroupsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SearchGroupsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SearchGroupsResponse"; }

  explicit SearchGroupsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SearchGroupsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SearchGroupsResponse& from);
  SearchGroupsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SearchGroupsResponse&& from) noexcept
      : SearchGroupsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // .qdrant.GroupsResult result = 1;
  bool has_result() const;
  void clear_result() ;
  const ::qdrant::GroupsResult& result() const;
  [[nodiscard]] ::qdrant::GroupsResult* PROTOBUF_NULLABLE release_result();
  ::qdrant::GroupsResult* PROTOBUF_NONNULL mutable_result();
  void set_allocated_result(::qdrant::GroupsResult* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_result(::qdrant::GroupsResult* PROTOBUF_NULLABLE value);
  ::qdrant::GroupsResult* PROTOBUF_NULLABLE unsafe_arena_release_result();

  private:
  const ::qdrant::GroupsResult& _internal_result() const;
  ::qdrant::GroupsResult* PROTOBUF_NONNULL _internal_mutable_result();

  public:
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SearchGroupsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SearchGroupsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::GroupsResult* PROTOBUF_NULLABLE result_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SearchGroupsResponse_class_data_;
// -------------------------------------------------------------------

class RecommendGroupsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.RecommendGroupsResponse) */ {
 public:
  inline RecommendGroupsResponse() : RecommendGroupsResponse(nullptr) {}
  ~RecommendGroupsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RecommendGroupsResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RecommendGroupsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RecommendGroupsResponse(::google::protobuf::internal::ConstantInitialized);

  inline RecommendGroupsResponse(const RecommendGroupsResponse& from) : RecommendGroupsResponse(nullptr, from) {}
  inline RecommendGroupsResponse(RecommendGroupsResponse&& from) noexcept
      : RecommendGroupsResponse(nullptr, ::std::move(from)) {}
  inline RecommendGroupsResponse& operator=(const RecommendGroupsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecommendGroupsResponse& operator=(RecommendGroupsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecommendGroupsResponse& default_instance() {
    return *reinterpret_cast<const RecommendGroupsResponse*>(
        &_RecommendGroupsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 124;
  friend void swap(RecommendGroupsResponse& a, RecommendGroupsResponse& b) { a.Swap(&b); }
  inline void Swap(RecommendGroupsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecommendGroupsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecommendGroupsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RecommendGroupsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecommendGroupsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RecommendGroupsResponse& from) { RecommendGroupsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RecommendGroupsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.RecommendGroupsResponse"; }

  explicit RecommendGroupsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RecommendGroupsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RecommendGroupsResponse& from);
  RecommendGroupsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RecommendGroupsResponse&& from) noexcept
      : RecommendGroupsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // .qdrant.GroupsResult result = 1;
  bool has_result() const;
  void clear_result() ;
  const ::qdrant::GroupsResult& result() const;
  [[nodiscard]] ::qdrant::GroupsResult* PROTOBUF_NULLABLE release_result();
  ::qdrant::GroupsResult* PROTOBUF_NONNULL mutable_result();
  void set_allocated_result(::qdrant::GroupsResult* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_result(::qdrant::GroupsResult* PROTOBUF_NULLABLE value);
  ::qdrant::GroupsResult* PROTOBUF_NULLABLE unsafe_arena_release_result();

  private:
  const ::qdrant::GroupsResult& _internal_result() const;
  ::qdrant::GroupsResult* PROTOBUF_NONNULL _internal_mutable_result();

  public:
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.RecommendGroupsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RecommendGroupsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::GroupsResult* PROTOBUF_NULLABLE result_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RecommendGroupsResponse_class_data_;
// -------------------------------------------------------------------

class QueryPoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.QueryPoints) */ {
 public:
  inline QueryPoints() : QueryPoints(nullptr) {}
  ~QueryPoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QueryPoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QueryPoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryPoints(::google::protobuf::internal::ConstantInitialized);

  inline QueryPoints(const QueryPoints& from) : QueryPoints(nullptr, from) {}
  inline QueryPoints(QueryPoints&& from) noexcept
      : QueryPoints(nullptr, ::std::move(from)) {}
  inline QueryPoints& operator=(const QueryPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryPoints& operator=(QueryPoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryPoints& default_instance() {
    return *reinterpret_cast<const QueryPoints*>(
        &_QueryPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 77;
  friend void swap(QueryPoints& a, QueryPoints& b) { a.Swap(&b); }
  inline void Swap(QueryPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryPoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QueryPoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryPoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryPoints& from) { QueryPoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QueryPoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.QueryPoints"; }

  explicit QueryPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QueryPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QueryPoints& from);
  QueryPoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QueryPoints&& from) noexcept
      : QueryPoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPrefetchFieldNumber = 2,
    kCollectionNameFieldNumber = 1,
    kUsingFieldNumber = 4,
    kQueryFieldNumber = 3,
    kFilterFieldNumber = 5,
    kParamsFieldNumber = 6,
    kWithVectorsFieldNumber = 10,
    kWithPayloadFieldNumber = 11,
    kReadConsistencyFieldNumber = 12,
    kShardKeySelectorFieldNumber = 13,
    kLookupFromFieldNumber = 14,
    kLimitFieldNumber = 8,
    kOffsetFieldNumber = 9,
    kTimeoutFieldNumber = 15,
    kScoreThresholdFieldNumber = 7,
  };
  // repeated .qdrant.PrefetchQuery prefetch = 2;
  int prefetch_size() const;
  private:
  int _internal_prefetch_size() const;

  public:
  void clear_prefetch() ;
  ::qdrant::PrefetchQuery* PROTOBUF_NONNULL mutable_prefetch(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>* PROTOBUF_NONNULL mutable_prefetch();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>& _internal_prefetch() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>* PROTOBUF_NONNULL _internal_mutable_prefetch();
  public:
  const ::qdrant::PrefetchQuery& prefetch(int index) const;
  ::qdrant::PrefetchQuery* PROTOBUF_NONNULL add_prefetch();
  const ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>& prefetch() const;
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional string using = 4;
  bool has_using_() const;
  void clear_using_() ;
  const ::std::string& using_() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_using_(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_using_();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_using_();
  void set_allocated_using_(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_using_() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_using_(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_using_();

  public:
  // optional .qdrant.Query query = 3;
  bool has_query() const;
  void clear_query() ;
  const ::qdrant::Query& query() const;
  [[nodiscard]] ::qdrant::Query* PROTOBUF_NULLABLE release_query();
  ::qdrant::Query* PROTOBUF_NONNULL mutable_query();
  void set_allocated_query(::qdrant::Query* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_query(::qdrant::Query* PROTOBUF_NULLABLE value);
  ::qdrant::Query* PROTOBUF_NULLABLE unsafe_arena_release_query();

  private:
  const ::qdrant::Query& _internal_query() const;
  ::qdrant::Query* PROTOBUF_NONNULL _internal_mutable_query();

  public:
  // optional .qdrant.Filter filter = 5;
  bool has_filter() const;
  void clear_filter() ;
  const ::qdrant::Filter& filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_filter();
  void set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_filter();

  private:
  const ::qdrant::Filter& _internal_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_filter();

  public:
  // optional .qdrant.SearchParams params = 6;
  bool has_params() const;
  void clear_params() ;
  const ::qdrant::SearchParams& params() const;
  [[nodiscard]] ::qdrant::SearchParams* PROTOBUF_NULLABLE release_params();
  ::qdrant::SearchParams* PROTOBUF_NONNULL mutable_params();
  void set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value);
  ::qdrant::SearchParams* PROTOBUF_NULLABLE unsafe_arena_release_params();

  private:
  const ::qdrant::SearchParams& _internal_params() const;
  ::qdrant::SearchParams* PROTOBUF_NONNULL _internal_mutable_params();

  public:
  // optional .qdrant.WithVectorsSelector with_vectors = 10;
  bool has_with_vectors() const;
  void clear_with_vectors() ;
  const ::qdrant::WithVectorsSelector& with_vectors() const;
  [[nodiscard]] ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE release_with_vectors();
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL mutable_with_vectors();
  void set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_vectors();

  private:
  const ::qdrant::WithVectorsSelector& _internal_with_vectors() const;
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL _internal_mutable_with_vectors();

  public:
  // optional .qdrant.WithPayloadSelector with_payload = 11;
  bool has_with_payload() const;
  void clear_with_payload() ;
  const ::qdrant::WithPayloadSelector& with_payload() const;
  [[nodiscard]] ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE release_with_payload();
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL mutable_with_payload();
  void set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_payload();

  private:
  const ::qdrant::WithPayloadSelector& _internal_with_payload() const;
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL _internal_mutable_with_payload();

  public:
  // optional .qdrant.ReadConsistency read_consistency = 12;
  bool has_read_consistency() const;
  void clear_read_consistency() ;
  const ::qdrant::ReadConsistency& read_consistency() const;
  [[nodiscard]] ::qdrant::ReadConsistency* PROTOBUF_NULLABLE release_read_consistency();
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL mutable_read_consistency();
  void set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  ::qdrant::ReadConsistency* PROTOBUF_NULLABLE unsafe_arena_release_read_consistency();

  private:
  const ::qdrant::ReadConsistency& _internal_read_consistency() const;
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL _internal_mutable_read_consistency();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 13;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional .qdrant.LookupLocation lookup_from = 14;
  bool has_lookup_from() const;
  void clear_lookup_from() ;
  const ::qdrant::LookupLocation& lookup_from() const;
  [[nodiscard]] ::qdrant::LookupLocation* PROTOBUF_NULLABLE release_lookup_from();
  ::qdrant::LookupLocation* PROTOBUF_NONNULL mutable_lookup_from();
  void set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value);
  ::qdrant::LookupLocation* PROTOBUF_NULLABLE unsafe_arena_release_lookup_from();

  private:
  const ::qdrant::LookupLocation& _internal_lookup_from() const;
  ::qdrant::LookupLocation* PROTOBUF_NONNULL _internal_mutable_lookup_from();

  public:
  // optional uint64 limit = 8;
  bool has_limit() const;
  void clear_limit() ;
  ::uint64_t limit() const;
  void set_limit(::uint64_t value);

  private:
  ::uint64_t _internal_limit() const;
  void _internal_set_limit(::uint64_t value);

  public:
  // optional uint64 offset = 9;
  bool has_offset() const;
  void clear_offset() ;
  ::uint64_t offset() const;
  void set_offset(::uint64_t value);

  private:
  ::uint64_t _internal_offset() const;
  void _internal_set_offset(::uint64_t value);

  public:
  // optional uint64 timeout = 15;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // optional float score_threshold = 7;
  bool has_score_threshold() const;
  void clear_score_threshold() ;
  float score_threshold() const;
  void set_score_threshold(float value);

  private:
  float _internal_score_threshold() const;
  void _internal_set_score_threshold(float value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.QueryPoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 15,
                                   9, 55,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QueryPoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::PrefetchQuery > prefetch_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::google::protobuf::internal::ArenaStringPtr using__;
    ::qdrant::Query* PROTOBUF_NULLABLE query_;
    ::qdrant::Filter* PROTOBUF_NULLABLE filter_;
    ::qdrant::SearchParams* PROTOBUF_NULLABLE params_;
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE with_vectors_;
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE with_payload_;
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE read_consistency_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::qdrant::LookupLocation* PROTOBUF_NULLABLE lookup_from_;
    ::uint64_t limit_;
    ::uint64_t offset_;
    ::uint64_t timeout_;
    float score_threshold_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QueryPoints_class_data_;
// -------------------------------------------------------------------

class QueryPointGroups final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.QueryPointGroups) */ {
 public:
  inline QueryPointGroups() : QueryPointGroups(nullptr) {}
  ~QueryPointGroups() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QueryPointGroups* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QueryPointGroups));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryPointGroups(::google::protobuf::internal::ConstantInitialized);

  inline QueryPointGroups(const QueryPointGroups& from) : QueryPointGroups(nullptr, from) {}
  inline QueryPointGroups(QueryPointGroups&& from) noexcept
      : QueryPointGroups(nullptr, ::std::move(from)) {}
  inline QueryPointGroups& operator=(const QueryPointGroups& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryPointGroups& operator=(QueryPointGroups&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryPointGroups& default_instance() {
    return *reinterpret_cast<const QueryPointGroups*>(
        &_QueryPointGroups_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 79;
  friend void swap(QueryPointGroups& a, QueryPointGroups& b) { a.Swap(&b); }
  inline void Swap(QueryPointGroups* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryPointGroups* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryPointGroups* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QueryPointGroups>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryPointGroups& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryPointGroups& from) { QueryPointGroups::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QueryPointGroups* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.QueryPointGroups"; }

  explicit QueryPointGroups(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QueryPointGroups(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QueryPointGroups& from);
  QueryPointGroups(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QueryPointGroups&& from) noexcept
      : QueryPointGroups(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPrefetchFieldNumber = 2,
    kCollectionNameFieldNumber = 1,
    kUsingFieldNumber = 4,
    kGroupByFieldNumber = 13,
    kQueryFieldNumber = 3,
    kFilterFieldNumber = 5,
    kParamsFieldNumber = 6,
    kWithPayloadFieldNumber = 8,
    kWithVectorsFieldNumber = 9,
    kLookupFromFieldNumber = 10,
    kReadConsistencyFieldNumber = 14,
    kWithLookupFieldNumber = 15,
    kShardKeySelectorFieldNumber = 17,
    kLimitFieldNumber = 11,
    kGroupSizeFieldNumber = 12,
    kTimeoutFieldNumber = 16,
    kScoreThresholdFieldNumber = 7,
  };
  // repeated .qdrant.PrefetchQuery prefetch = 2;
  int prefetch_size() const;
  private:
  int _internal_prefetch_size() const;

  public:
  void clear_prefetch() ;
  ::qdrant::PrefetchQuery* PROTOBUF_NONNULL mutable_prefetch(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>* PROTOBUF_NONNULL mutable_prefetch();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>& _internal_prefetch() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>* PROTOBUF_NONNULL _internal_mutable_prefetch();
  public:
  const ::qdrant::PrefetchQuery& prefetch(int index) const;
  ::qdrant::PrefetchQuery* PROTOBUF_NONNULL add_prefetch();
  const ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>& prefetch() const;
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional string using = 4;
  bool has_using_() const;
  void clear_using_() ;
  const ::std::string& using_() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_using_(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_using_();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_using_();
  void set_allocated_using_(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_using_() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_using_(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_using_();

  public:
  // string group_by = 13;
  void clear_group_by() ;
  const ::std::string& group_by() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_group_by(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_group_by();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_group_by();
  void set_allocated_group_by(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_group_by() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_group_by(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_group_by();

  public:
  // optional .qdrant.Query query = 3;
  bool has_query() const;
  void clear_query() ;
  const ::qdrant::Query& query() const;
  [[nodiscard]] ::qdrant::Query* PROTOBUF_NULLABLE release_query();
  ::qdrant::Query* PROTOBUF_NONNULL mutable_query();
  void set_allocated_query(::qdrant::Query* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_query(::qdrant::Query* PROTOBUF_NULLABLE value);
  ::qdrant::Query* PROTOBUF_NULLABLE unsafe_arena_release_query();

  private:
  const ::qdrant::Query& _internal_query() const;
  ::qdrant::Query* PROTOBUF_NONNULL _internal_mutable_query();

  public:
  // optional .qdrant.Filter filter = 5;
  bool has_filter() const;
  void clear_filter() ;
  const ::qdrant::Filter& filter() const;
  [[nodiscard]] ::qdrant::Filter* PROTOBUF_NULLABLE release_filter();
  ::qdrant::Filter* PROTOBUF_NONNULL mutable_filter();
  void set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value);
  ::qdrant::Filter* PROTOBUF_NULLABLE unsafe_arena_release_filter();

  private:
  const ::qdrant::Filter& _internal_filter() const;
  ::qdrant::Filter* PROTOBUF_NONNULL _internal_mutable_filter();

  public:
  // optional .qdrant.SearchParams params = 6;
  bool has_params() const;
  void clear_params() ;
  const ::qdrant::SearchParams& params() const;
  [[nodiscard]] ::qdrant::SearchParams* PROTOBUF_NULLABLE release_params();
  ::qdrant::SearchParams* PROTOBUF_NONNULL mutable_params();
  void set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value);
  ::qdrant::SearchParams* PROTOBUF_NULLABLE unsafe_arena_release_params();

  private:
  const ::qdrant::SearchParams& _internal_params() const;
  ::qdrant::SearchParams* PROTOBUF_NONNULL _internal_mutable_params();

  public:
  // .qdrant.WithPayloadSelector with_payload = 8;
  bool has_with_payload() const;
  void clear_with_payload() ;
  const ::qdrant::WithPayloadSelector& with_payload() const;
  [[nodiscard]] ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE release_with_payload();
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL mutable_with_payload();
  void set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_payload();

  private:
  const ::qdrant::WithPayloadSelector& _internal_with_payload() const;
  ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL _internal_mutable_with_payload();

  public:
  // optional .qdrant.WithVectorsSelector with_vectors = 9;
  bool has_with_vectors() const;
  void clear_with_vectors() ;
  const ::qdrant::WithVectorsSelector& with_vectors() const;
  [[nodiscard]] ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE release_with_vectors();
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL mutable_with_vectors();
  void set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value);
  ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE unsafe_arena_release_with_vectors();

  private:
  const ::qdrant::WithVectorsSelector& _internal_with_vectors() const;
  ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL _internal_mutable_with_vectors();

  public:
  // optional .qdrant.LookupLocation lookup_from = 10;
  bool has_lookup_from() const;
  void clear_lookup_from() ;
  const ::qdrant::LookupLocation& lookup_from() const;
  [[nodiscard]] ::qdrant::LookupLocation* PROTOBUF_NULLABLE release_lookup_from();
  ::qdrant::LookupLocation* PROTOBUF_NONNULL mutable_lookup_from();
  void set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value);
  ::qdrant::LookupLocation* PROTOBUF_NULLABLE unsafe_arena_release_lookup_from();

  private:
  const ::qdrant::LookupLocation& _internal_lookup_from() const;
  ::qdrant::LookupLocation* PROTOBUF_NONNULL _internal_mutable_lookup_from();

  public:
  // optional .qdrant.ReadConsistency read_consistency = 14;
  bool has_read_consistency() const;
  void clear_read_consistency() ;
  const ::qdrant::ReadConsistency& read_consistency() const;
  [[nodiscard]] ::qdrant::ReadConsistency* PROTOBUF_NULLABLE release_read_consistency();
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL mutable_read_consistency();
  void set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  ::qdrant::ReadConsistency* PROTOBUF_NULLABLE unsafe_arena_release_read_consistency();

  private:
  const ::qdrant::ReadConsistency& _internal_read_consistency() const;
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL _internal_mutable_read_consistency();

  public:
  // optional .qdrant.WithLookup with_lookup = 15;
  bool has_with_lookup() const;
  void clear_with_lookup() ;
  const ::qdrant::WithLookup& with_lookup() const;
  [[nodiscard]] ::qdrant::WithLookup* PROTOBUF_NULLABLE release_with_lookup();
  ::qdrant::WithLookup* PROTOBUF_NONNULL mutable_with_lookup();
  void set_allocated_with_lookup(::qdrant::WithLookup* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_with_lookup(::qdrant::WithLookup* PROTOBUF_NULLABLE value);
  ::qdrant::WithLookup* PROTOBUF_NULLABLE unsafe_arena_release_with_lookup();

  private:
  const ::qdrant::WithLookup& _internal_with_lookup() const;
  ::qdrant::WithLookup* PROTOBUF_NONNULL _internal_mutable_with_lookup();

  public:
  // optional .qdrant.ShardKeySelector shard_key_selector = 17;
  bool has_shard_key_selector() const;
  void clear_shard_key_selector() ;
  const ::qdrant::ShardKeySelector& shard_key_selector() const;
  [[nodiscard]] ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE release_shard_key_selector();
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL mutable_shard_key_selector();
  void set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE unsafe_arena_release_shard_key_selector();

  private:
  const ::qdrant::ShardKeySelector& _internal_shard_key_selector() const;
  ::qdrant::ShardKeySelector* PROTOBUF_NONNULL _internal_mutable_shard_key_selector();

  public:
  // optional uint64 limit = 11;
  bool has_limit() const;
  void clear_limit() ;
  ::uint64_t limit() const;
  void set_limit(::uint64_t value);

  private:
  ::uint64_t _internal_limit() const;
  void _internal_set_limit(::uint64_t value);

  public:
  // optional uint64 group_size = 12;
  bool has_group_size() const;
  void clear_group_size() ;
  ::uint64_t group_size() const;
  void set_group_size(::uint64_t value);

  private:
  ::uint64_t _internal_group_size() const;
  void _internal_set_group_size(::uint64_t value);

  public:
  // optional uint64 timeout = 16;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // optional float score_threshold = 7;
  bool has_score_threshold() const;
  void clear_score_threshold() ;
  float score_threshold() const;
  void set_score_threshold(float value);

  private:
  float _internal_score_threshold() const;
  void _internal_set_score_threshold(float value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.QueryPointGroups)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 17,
                                   10, 76,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QueryPointGroups& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::PrefetchQuery > prefetch_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::google::protobuf::internal::ArenaStringPtr using__;
    ::google::protobuf::internal::ArenaStringPtr group_by_;
    ::qdrant::Query* PROTOBUF_NULLABLE query_;
    ::qdrant::Filter* PROTOBUF_NULLABLE filter_;
    ::qdrant::SearchParams* PROTOBUF_NULLABLE params_;
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE with_payload_;
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE with_vectors_;
    ::qdrant::LookupLocation* PROTOBUF_NULLABLE lookup_from_;
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE read_consistency_;
    ::qdrant::WithLookup* PROTOBUF_NULLABLE with_lookup_;
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE shard_key_selector_;
    ::uint64_t limit_;
    ::uint64_t group_size_;
    ::uint64_t timeout_;
    float score_threshold_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QueryPointGroups_class_data_;
// -------------------------------------------------------------------

class QueryGroupsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.QueryGroupsResponse) */ {
 public:
  inline QueryGroupsResponse() : QueryGroupsResponse(nullptr) {}
  ~QueryGroupsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QueryGroupsResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QueryGroupsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryGroupsResponse(::google::protobuf::internal::ConstantInitialized);

  inline QueryGroupsResponse(const QueryGroupsResponse& from) : QueryGroupsResponse(nullptr, from) {}
  inline QueryGroupsResponse(QueryGroupsResponse&& from) noexcept
      : QueryGroupsResponse(nullptr, ::std::move(from)) {}
  inline QueryGroupsResponse& operator=(const QueryGroupsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryGroupsResponse& operator=(QueryGroupsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryGroupsResponse& default_instance() {
    return *reinterpret_cast<const QueryGroupsResponse*>(
        &_QueryGroupsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 110;
  friend void swap(QueryGroupsResponse& a, QueryGroupsResponse& b) { a.Swap(&b); }
  inline void Swap(QueryGroupsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryGroupsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryGroupsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QueryGroupsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryGroupsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryGroupsResponse& from) { QueryGroupsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QueryGroupsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.QueryGroupsResponse"; }

  explicit QueryGroupsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QueryGroupsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QueryGroupsResponse& from);
  QueryGroupsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QueryGroupsResponse&& from) noexcept
      : QueryGroupsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kUsageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // .qdrant.GroupsResult result = 1;
  bool has_result() const;
  void clear_result() ;
  const ::qdrant::GroupsResult& result() const;
  [[nodiscard]] ::qdrant::GroupsResult* PROTOBUF_NULLABLE release_result();
  ::qdrant::GroupsResult* PROTOBUF_NONNULL mutable_result();
  void set_allocated_result(::qdrant::GroupsResult* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_result(::qdrant::GroupsResult* PROTOBUF_NULLABLE value);
  ::qdrant::GroupsResult* PROTOBUF_NULLABLE unsafe_arena_release_result();

  private:
  const ::qdrant::GroupsResult& _internal_result() const;
  ::qdrant::GroupsResult* PROTOBUF_NONNULL _internal_mutable_result();

  public:
  // optional .qdrant.Usage usage = 3;
  bool has_usage() const;
  void clear_usage() ;
  const ::qdrant::Usage& usage() const;
  [[nodiscard]] ::qdrant::Usage* PROTOBUF_NULLABLE release_usage();
  ::qdrant::Usage* PROTOBUF_NONNULL mutable_usage();
  void set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value);
  ::qdrant::Usage* PROTOBUF_NULLABLE unsafe_arena_release_usage();

  private:
  const ::qdrant::Usage& _internal_usage() const;
  ::qdrant::Usage* PROTOBUF_NONNULL _internal_mutable_usage();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.QueryGroupsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QueryGroupsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::GroupsResult* PROTOBUF_NULLABLE result_;
    ::qdrant::Usage* PROTOBUF_NULLABLE usage_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QueryGroupsResponse_class_data_;
// -------------------------------------------------------------------

class PointsUpdateOperation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PointsUpdateOperation) */ {
 public:
  inline PointsUpdateOperation() : PointsUpdateOperation(nullptr) {}
  ~PointsUpdateOperation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointsUpdateOperation* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointsUpdateOperation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointsUpdateOperation(::google::protobuf::internal::ConstantInitialized);

  inline PointsUpdateOperation(const PointsUpdateOperation& from) : PointsUpdateOperation(nullptr, from) {}
  inline PointsUpdateOperation(PointsUpdateOperation&& from) noexcept
      : PointsUpdateOperation(nullptr, ::std::move(from)) {}
  inline PointsUpdateOperation& operator=(const PointsUpdateOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointsUpdateOperation& operator=(PointsUpdateOperation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointsUpdateOperation& default_instance() {
    return *reinterpret_cast<const PointsUpdateOperation*>(
        &_PointsUpdateOperation_default_instance_);
  }
  enum OperationCase {
    kUpsert = 1,
    kDeleteDeprecated = 2,
    kSetPayload = 3,
    kOverwritePayload = 4,
    kDeletePayload = 5,
    kClearPayloadDeprecated = 6,
    kUpdateVectors = 7,
    kDeleteVectors = 8,
    kDeletePoints = 9,
    kClearPayload = 10,
    OPERATION_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 97;
  friend void swap(PointsUpdateOperation& a, PointsUpdateOperation& b) { a.Swap(&b); }
  inline void Swap(PointsUpdateOperation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointsUpdateOperation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointsUpdateOperation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointsUpdateOperation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointsUpdateOperation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointsUpdateOperation& from) { PointsUpdateOperation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointsUpdateOperation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PointsUpdateOperation"; }

  explicit PointsUpdateOperation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointsUpdateOperation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointsUpdateOperation& from);
  PointsUpdateOperation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointsUpdateOperation&& from) noexcept
      : PointsUpdateOperation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using PointStructList = PointsUpdateOperation_PointStructList;
  using SetPayload = PointsUpdateOperation_SetPayload;
  using OverwritePayload = PointsUpdateOperation_OverwritePayload;
  using DeletePayload = PointsUpdateOperation_DeletePayload;
  using UpdateVectors = PointsUpdateOperation_UpdateVectors;
  using DeleteVectors = PointsUpdateOperation_DeleteVectors;
  using DeletePoints = PointsUpdateOperation_DeletePoints;
  using ClearPayload = PointsUpdateOperation_ClearPayload;

  // accessors -------------------------------------------------------
  enum : int {
    kUpsertFieldNumber = 1,
    kDeleteDeprecatedFieldNumber = 2,
    kSetPayloadFieldNumber = 3,
    kOverwritePayloadFieldNumber = 4,
    kDeletePayloadFieldNumber = 5,
    kClearPayloadDeprecatedFieldNumber = 6,
    kUpdateVectorsFieldNumber = 7,
    kDeleteVectorsFieldNumber = 8,
    kDeletePointsFieldNumber = 9,
    kClearPayloadFieldNumber = 10,
  };
  // .qdrant.PointsUpdateOperation.PointStructList upsert = 1;
  bool has_upsert() const;
  private:
  bool _internal_has_upsert() const;

  public:
  void clear_upsert() ;
  const ::qdrant::PointsUpdateOperation_PointStructList& upsert() const;
  [[nodiscard]] ::qdrant::PointsUpdateOperation_PointStructList* PROTOBUF_NULLABLE release_upsert();
  ::qdrant::PointsUpdateOperation_PointStructList* PROTOBUF_NONNULL mutable_upsert();
  void set_allocated_upsert(::qdrant::PointsUpdateOperation_PointStructList* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_upsert(::qdrant::PointsUpdateOperation_PointStructList* PROTOBUF_NULLABLE value);
  ::qdrant::PointsUpdateOperation_PointStructList* PROTOBUF_NULLABLE unsafe_arena_release_upsert();

  private:
  const ::qdrant::PointsUpdateOperation_PointStructList& _internal_upsert() const;
  ::qdrant::PointsUpdateOperation_PointStructList* PROTOBUF_NONNULL _internal_mutable_upsert();

  public:
  // .qdrant.PointsSelector delete_deprecated = 2 [deprecated = true];
  [[deprecated]]  bool has_delete_deprecated() const;
  private:
  bool _internal_has_delete_deprecated() const;

  public:
  [[deprecated]]  void clear_delete_deprecated() ;
  [[deprecated]] const ::qdrant::PointsSelector& delete_deprecated() const;
  [[deprecated]] [[nodiscard]] ::qdrant::PointsSelector* PROTOBUF_NULLABLE release_delete_deprecated();
  [[deprecated]] ::qdrant::PointsSelector* PROTOBUF_NONNULL mutable_delete_deprecated();
  [[deprecated]] void set_allocated_delete_deprecated(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  [[deprecated]] void unsafe_arena_set_allocated_delete_deprecated(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  [[deprecated]] ::qdrant::PointsSelector* PROTOBUF_NULLABLE unsafe_arena_release_delete_deprecated();

  private:
  const ::qdrant::PointsSelector& _internal_delete_deprecated() const;
  ::qdrant::PointsSelector* PROTOBUF_NONNULL _internal_mutable_delete_deprecated();

  public:
  // .qdrant.PointsUpdateOperation.SetPayload set_payload = 3;
  bool has_set_payload() const;
  private:
  bool _internal_has_set_payload() const;

  public:
  void clear_set_payload() ;
  const ::qdrant::PointsUpdateOperation_SetPayload& set_payload() const;
  [[nodiscard]] ::qdrant::PointsUpdateOperation_SetPayload* PROTOBUF_NULLABLE release_set_payload();
  ::qdrant::PointsUpdateOperation_SetPayload* PROTOBUF_NONNULL mutable_set_payload();
  void set_allocated_set_payload(::qdrant::PointsUpdateOperation_SetPayload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_set_payload(::qdrant::PointsUpdateOperation_SetPayload* PROTOBUF_NULLABLE value);
  ::qdrant::PointsUpdateOperation_SetPayload* PROTOBUF_NULLABLE unsafe_arena_release_set_payload();

  private:
  const ::qdrant::PointsUpdateOperation_SetPayload& _internal_set_payload() const;
  ::qdrant::PointsUpdateOperation_SetPayload* PROTOBUF_NONNULL _internal_mutable_set_payload();

  public:
  // .qdrant.PointsUpdateOperation.OverwritePayload overwrite_payload = 4;
  bool has_overwrite_payload() const;
  private:
  bool _internal_has_overwrite_payload() const;

  public:
  void clear_overwrite_payload() ;
  const ::qdrant::PointsUpdateOperation_OverwritePayload& overwrite_payload() const;
  [[nodiscard]] ::qdrant::PointsUpdateOperation_OverwritePayload* PROTOBUF_NULLABLE release_overwrite_payload();
  ::qdrant::PointsUpdateOperation_OverwritePayload* PROTOBUF_NONNULL mutable_overwrite_payload();
  void set_allocated_overwrite_payload(::qdrant::PointsUpdateOperation_OverwritePayload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_overwrite_payload(::qdrant::PointsUpdateOperation_OverwritePayload* PROTOBUF_NULLABLE value);
  ::qdrant::PointsUpdateOperation_OverwritePayload* PROTOBUF_NULLABLE unsafe_arena_release_overwrite_payload();

  private:
  const ::qdrant::PointsUpdateOperation_OverwritePayload& _internal_overwrite_payload() const;
  ::qdrant::PointsUpdateOperation_OverwritePayload* PROTOBUF_NONNULL _internal_mutable_overwrite_payload();

  public:
  // .qdrant.PointsUpdateOperation.DeletePayload delete_payload = 5;
  bool has_delete_payload() const;
  private:
  bool _internal_has_delete_payload() const;

  public:
  void clear_delete_payload() ;
  const ::qdrant::PointsUpdateOperation_DeletePayload& delete_payload() const;
  [[nodiscard]] ::qdrant::PointsUpdateOperation_DeletePayload* PROTOBUF_NULLABLE release_delete_payload();
  ::qdrant::PointsUpdateOperation_DeletePayload* PROTOBUF_NONNULL mutable_delete_payload();
  void set_allocated_delete_payload(::qdrant::PointsUpdateOperation_DeletePayload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_delete_payload(::qdrant::PointsUpdateOperation_DeletePayload* PROTOBUF_NULLABLE value);
  ::qdrant::PointsUpdateOperation_DeletePayload* PROTOBUF_NULLABLE unsafe_arena_release_delete_payload();

  private:
  const ::qdrant::PointsUpdateOperation_DeletePayload& _internal_delete_payload() const;
  ::qdrant::PointsUpdateOperation_DeletePayload* PROTOBUF_NONNULL _internal_mutable_delete_payload();

  public:
  // .qdrant.PointsSelector clear_payload_deprecated = 6 [deprecated = true];
  [[deprecated]]  bool has_clear_payload_deprecated() const;
  private:
  bool _internal_has_clear_payload_deprecated() const;

  public:
  [[deprecated]]  void clear_clear_payload_deprecated() ;
  [[deprecated]] const ::qdrant::PointsSelector& clear_payload_deprecated() const;
  [[deprecated]] [[nodiscard]] ::qdrant::PointsSelector* PROTOBUF_NULLABLE release_clear_payload_deprecated();
  [[deprecated]] ::qdrant::PointsSelector* PROTOBUF_NONNULL mutable_clear_payload_deprecated();
  [[deprecated]] void set_allocated_clear_payload_deprecated(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  [[deprecated]] void unsafe_arena_set_allocated_clear_payload_deprecated(::qdrant::PointsSelector* PROTOBUF_NULLABLE value);
  [[deprecated]] ::qdrant::PointsSelector* PROTOBUF_NULLABLE unsafe_arena_release_clear_payload_deprecated();

  private:
  const ::qdrant::PointsSelector& _internal_clear_payload_deprecated() const;
  ::qdrant::PointsSelector* PROTOBUF_NONNULL _internal_mutable_clear_payload_deprecated();

  public:
  // .qdrant.PointsUpdateOperation.UpdateVectors update_vectors = 7;
  bool has_update_vectors() const;
  private:
  bool _internal_has_update_vectors() const;

  public:
  void clear_update_vectors() ;
  const ::qdrant::PointsUpdateOperation_UpdateVectors& update_vectors() const;
  [[nodiscard]] ::qdrant::PointsUpdateOperation_UpdateVectors* PROTOBUF_NULLABLE release_update_vectors();
  ::qdrant::PointsUpdateOperation_UpdateVectors* PROTOBUF_NONNULL mutable_update_vectors();
  void set_allocated_update_vectors(::qdrant::PointsUpdateOperation_UpdateVectors* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_update_vectors(::qdrant::PointsUpdateOperation_UpdateVectors* PROTOBUF_NULLABLE value);
  ::qdrant::PointsUpdateOperation_UpdateVectors* PROTOBUF_NULLABLE unsafe_arena_release_update_vectors();

  private:
  const ::qdrant::PointsUpdateOperation_UpdateVectors& _internal_update_vectors() const;
  ::qdrant::PointsUpdateOperation_UpdateVectors* PROTOBUF_NONNULL _internal_mutable_update_vectors();

  public:
  // .qdrant.PointsUpdateOperation.DeleteVectors delete_vectors = 8;
  bool has_delete_vectors() const;
  private:
  bool _internal_has_delete_vectors() const;

  public:
  void clear_delete_vectors() ;
  const ::qdrant::PointsUpdateOperation_DeleteVectors& delete_vectors() const;
  [[nodiscard]] ::qdrant::PointsUpdateOperation_DeleteVectors* PROTOBUF_NULLABLE release_delete_vectors();
  ::qdrant::PointsUpdateOperation_DeleteVectors* PROTOBUF_NONNULL mutable_delete_vectors();
  void set_allocated_delete_vectors(::qdrant::PointsUpdateOperation_DeleteVectors* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_delete_vectors(::qdrant::PointsUpdateOperation_DeleteVectors* PROTOBUF_NULLABLE value);
  ::qdrant::PointsUpdateOperation_DeleteVectors* PROTOBUF_NULLABLE unsafe_arena_release_delete_vectors();

  private:
  const ::qdrant::PointsUpdateOperation_DeleteVectors& _internal_delete_vectors() const;
  ::qdrant::PointsUpdateOperation_DeleteVectors* PROTOBUF_NONNULL _internal_mutable_delete_vectors();

  public:
  // .qdrant.PointsUpdateOperation.DeletePoints delete_points = 9;
  bool has_delete_points() const;
  private:
  bool _internal_has_delete_points() const;

  public:
  void clear_delete_points() ;
  const ::qdrant::PointsUpdateOperation_DeletePoints& delete_points() const;
  [[nodiscard]] ::qdrant::PointsUpdateOperation_DeletePoints* PROTOBUF_NULLABLE release_delete_points();
  ::qdrant::PointsUpdateOperation_DeletePoints* PROTOBUF_NONNULL mutable_delete_points();
  void set_allocated_delete_points(::qdrant::PointsUpdateOperation_DeletePoints* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_delete_points(::qdrant::PointsUpdateOperation_DeletePoints* PROTOBUF_NULLABLE value);
  ::qdrant::PointsUpdateOperation_DeletePoints* PROTOBUF_NULLABLE unsafe_arena_release_delete_points();

  private:
  const ::qdrant::PointsUpdateOperation_DeletePoints& _internal_delete_points() const;
  ::qdrant::PointsUpdateOperation_DeletePoints* PROTOBUF_NONNULL _internal_mutable_delete_points();

  public:
  // .qdrant.PointsUpdateOperation.ClearPayload clear_payload = 10;
  bool has_clear_payload() const;
  private:
  bool _internal_has_clear_payload() const;

  public:
  void clear_clear_payload() ;
  const ::qdrant::PointsUpdateOperation_ClearPayload& clear_payload() const;
  [[nodiscard]] ::qdrant::PointsUpdateOperation_ClearPayload* PROTOBUF_NULLABLE release_clear_payload();
  ::qdrant::PointsUpdateOperation_ClearPayload* PROTOBUF_NONNULL mutable_clear_payload();
  void set_allocated_clear_payload(::qdrant::PointsUpdateOperation_ClearPayload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_clear_payload(::qdrant::PointsUpdateOperation_ClearPayload* PROTOBUF_NULLABLE value);
  ::qdrant::PointsUpdateOperation_ClearPayload* PROTOBUF_NULLABLE unsafe_arena_release_clear_payload();

  private:
  const ::qdrant::PointsUpdateOperation_ClearPayload& _internal_clear_payload() const;
  ::qdrant::PointsUpdateOperation_ClearPayload* PROTOBUF_NONNULL _internal_mutable_clear_payload();

  public:
  void clear_operation();
  OperationCase operation_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.PointsUpdateOperation)
 private:
  class _Internal;
  void set_has_upsert();
  void set_has_delete_deprecated();
  void set_has_set_payload();
  void set_has_overwrite_payload();
  void set_has_delete_payload();
  void set_has_clear_payload_deprecated();
  void set_has_update_vectors();
  void set_has_delete_vectors();
  void set_has_delete_points();
  void set_has_clear_payload();
  inline bool has_operation() const;
  inline void clear_has_operation();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 10,
                                   10, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointsUpdateOperation& from_msg);
    union OperationUnion {
      constexpr OperationUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE upsert_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE delete_deprecated_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE set_payload_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE overwrite_payload_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE delete_payload_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE clear_payload_deprecated_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE update_vectors_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE delete_vectors_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE delete_points_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE clear_payload_;
    } operation_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointsUpdateOperation_class_data_;
// -------------------------------------------------------------------

class UpdateBatchPoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.UpdateBatchPoints) */ {
 public:
  inline UpdateBatchPoints() : UpdateBatchPoints(nullptr) {}
  ~UpdateBatchPoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateBatchPoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateBatchPoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateBatchPoints(::google::protobuf::internal::ConstantInitialized);

  inline UpdateBatchPoints(const UpdateBatchPoints& from) : UpdateBatchPoints(nullptr, from) {}
  inline UpdateBatchPoints(UpdateBatchPoints&& from) noexcept
      : UpdateBatchPoints(nullptr, ::std::move(from)) {}
  inline UpdateBatchPoints& operator=(const UpdateBatchPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateBatchPoints& operator=(UpdateBatchPoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateBatchPoints& default_instance() {
    return *reinterpret_cast<const UpdateBatchPoints*>(
        &_UpdateBatchPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 98;
  friend void swap(UpdateBatchPoints& a, UpdateBatchPoints& b) { a.Swap(&b); }
  inline void Swap(UpdateBatchPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateBatchPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateBatchPoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateBatchPoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateBatchPoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateBatchPoints& from) { UpdateBatchPoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateBatchPoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.UpdateBatchPoints"; }

  explicit UpdateBatchPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateBatchPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateBatchPoints& from);
  UpdateBatchPoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateBatchPoints&& from) noexcept
      : UpdateBatchPoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOperationsFieldNumber = 3,
    kCollectionNameFieldNumber = 1,
    kOrderingFieldNumber = 4,
    kWaitFieldNumber = 2,
  };
  // repeated .qdrant.PointsUpdateOperation operations = 3;
  int operations_size() const;
  private:
  int _internal_operations_size() const;

  public:
  void clear_operations() ;
  ::qdrant::PointsUpdateOperation* PROTOBUF_NONNULL mutable_operations(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::PointsUpdateOperation>* PROTOBUF_NONNULL mutable_operations();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointsUpdateOperation>& _internal_operations() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::PointsUpdateOperation>* PROTOBUF_NONNULL _internal_mutable_operations();
  public:
  const ::qdrant::PointsUpdateOperation& operations(int index) const;
  ::qdrant::PointsUpdateOperation* PROTOBUF_NONNULL add_operations();
  const ::google::protobuf::RepeatedPtrField<::qdrant::PointsUpdateOperation>& operations() const;
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional .qdrant.WriteOrdering ordering = 4;
  bool has_ordering() const;
  void clear_ordering() ;
  const ::qdrant::WriteOrdering& ordering() const;
  [[nodiscard]] ::qdrant::WriteOrdering* PROTOBUF_NULLABLE release_ordering();
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL mutable_ordering();
  void set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value);
  ::qdrant::WriteOrdering* PROTOBUF_NULLABLE unsafe_arena_release_ordering();

  private:
  const ::qdrant::WriteOrdering& _internal_ordering() const;
  ::qdrant::WriteOrdering* PROTOBUF_NONNULL _internal_mutable_ordering();

  public:
  // optional bool wait = 2;
  bool has_wait() const;
  void clear_wait() ;
  bool wait() const;
  void set_wait(bool value);

  private:
  bool _internal_wait() const;
  void _internal_set_wait(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.UpdateBatchPoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   2, 48,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateBatchPoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::PointsUpdateOperation > operations_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE ordering_;
    bool wait_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateBatchPoints_class_data_;
// -------------------------------------------------------------------

class QueryBatchPoints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.QueryBatchPoints) */ {
 public:
  inline QueryBatchPoints() : QueryBatchPoints(nullptr) {}
  ~QueryBatchPoints() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QueryBatchPoints* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QueryBatchPoints));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryBatchPoints(::google::protobuf::internal::ConstantInitialized);

  inline QueryBatchPoints(const QueryBatchPoints& from) : QueryBatchPoints(nullptr, from) {}
  inline QueryBatchPoints(QueryBatchPoints&& from) noexcept
      : QueryBatchPoints(nullptr, ::std::move(from)) {}
  inline QueryBatchPoints& operator=(const QueryBatchPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryBatchPoints& operator=(QueryBatchPoints&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryBatchPoints& default_instance() {
    return *reinterpret_cast<const QueryBatchPoints*>(
        &_QueryBatchPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 78;
  friend void swap(QueryBatchPoints& a, QueryBatchPoints& b) { a.Swap(&b); }
  inline void Swap(QueryBatchPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryBatchPoints* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryBatchPoints* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QueryBatchPoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryBatchPoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryBatchPoints& from) { QueryBatchPoints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QueryBatchPoints* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.QueryBatchPoints"; }

  explicit QueryBatchPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QueryBatchPoints(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QueryBatchPoints& from);
  QueryBatchPoints(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QueryBatchPoints&& from) noexcept
      : QueryBatchPoints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQueryPointsFieldNumber = 2,
    kCollectionNameFieldNumber = 1,
    kReadConsistencyFieldNumber = 3,
    kTimeoutFieldNumber = 4,
  };
  // repeated .qdrant.QueryPoints query_points = 2;
  int query_points_size() const;
  private:
  int _internal_query_points_size() const;

  public:
  void clear_query_points() ;
  ::qdrant::QueryPoints* PROTOBUF_NONNULL mutable_query_points(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::QueryPoints>* PROTOBUF_NONNULL mutable_query_points();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::QueryPoints>& _internal_query_points() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::QueryPoints>* PROTOBUF_NONNULL _internal_mutable_query_points();
  public:
  const ::qdrant::QueryPoints& query_points(int index) const;
  ::qdrant::QueryPoints* PROTOBUF_NONNULL add_query_points();
  const ::google::protobuf::RepeatedPtrField<::qdrant::QueryPoints>& query_points() const;
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional .qdrant.ReadConsistency read_consistency = 3;
  bool has_read_consistency() const;
  void clear_read_consistency() ;
  const ::qdrant::ReadConsistency& read_consistency() const;
  [[nodiscard]] ::qdrant::ReadConsistency* PROTOBUF_NULLABLE release_read_consistency();
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL mutable_read_consistency();
  void set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value);
  ::qdrant::ReadConsistency* PROTOBUF_NULLABLE unsafe_arena_release_read_consistency();

  private:
  const ::qdrant::ReadConsistency& _internal_read_consistency() const;
  ::qdrant::ReadConsistency* PROTOBUF_NONNULL _internal_mutable_read_consistency();

  public:
  // optional uint64 timeout = 4;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.QueryBatchPoints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   2, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QueryBatchPoints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::QueryPoints > query_points_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE read_consistency_;
    ::uint64_t timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_points_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QueryBatchPoints_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// WriteOrdering

// .qdrant.WriteOrderingType type = 1;
inline void WriteOrdering::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::WriteOrderingType WriteOrdering::type() const {
  // @@protoc_insertion_point(field_get:qdrant.WriteOrdering.type)
  return _internal_type();
}
inline void WriteOrdering::set_type(::qdrant::WriteOrderingType value) {
  _internal_set_type(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.WriteOrdering.type)
}
inline ::qdrant::WriteOrderingType WriteOrdering::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::WriteOrderingType>(_impl_.type_);
}
inline void WriteOrdering::_internal_set_type(::qdrant::WriteOrderingType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// ReadConsistency

// .qdrant.ReadConsistencyType type = 1;
inline bool ReadConsistency::has_type() const {
  return value_case() == kType;
}
inline void ReadConsistency::set_has_type() {
  _impl_._oneof_case_[0] = kType;
}
inline void ReadConsistency::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kType) {
    _impl_.value_.type_ = 0;
    clear_has_value();
  }
}
inline ::qdrant::ReadConsistencyType ReadConsistency::type() const {
  // @@protoc_insertion_point(field_get:qdrant.ReadConsistency.type)
  return _internal_type();
}
inline void ReadConsistency::set_type(::qdrant::ReadConsistencyType value) {
  if (value_case() != kType) {
    clear_value();
    set_has_type();
  }
  _impl_.value_.type_ = value;
  // @@protoc_insertion_point(field_set:qdrant.ReadConsistency.type)
}
inline ::qdrant::ReadConsistencyType ReadConsistency::_internal_type() const {
  if (value_case() == kType) {
    return static_cast<::qdrant::ReadConsistencyType>(_impl_.value_.type_);
  }
  return static_cast<::qdrant::ReadConsistencyType>(0);
}

// uint64 factor = 2;
inline bool ReadConsistency::has_factor() const {
  return value_case() == kFactor;
}
inline void ReadConsistency::set_has_factor() {
  _impl_._oneof_case_[0] = kFactor;
}
inline void ReadConsistency::clear_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kFactor) {
    _impl_.value_.factor_ = ::uint64_t{0u};
    clear_has_value();
  }
}
inline ::uint64_t ReadConsistency::factor() const {
  // @@protoc_insertion_point(field_get:qdrant.ReadConsistency.factor)
  return _internal_factor();
}
inline void ReadConsistency::set_factor(::uint64_t value) {
  if (value_case() != kFactor) {
    clear_value();
    set_has_factor();
  }
  _impl_.value_.factor_ = value;
  // @@protoc_insertion_point(field_set:qdrant.ReadConsistency.factor)
}
inline ::uint64_t ReadConsistency::_internal_factor() const {
  if (value_case() == kFactor) {
    return _impl_.value_.factor_;
  }
  return ::uint64_t{0u};
}

inline bool ReadConsistency::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void ReadConsistency::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline ReadConsistency::ValueCase ReadConsistency::value_case() const {
  return ReadConsistency::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PointId

// uint64 num = 1;
inline bool PointId::has_num() const {
  return point_id_options_case() == kNum;
}
inline void PointId::set_has_num() {
  _impl_._oneof_case_[0] = kNum;
}
inline void PointId::clear_num() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (point_id_options_case() == kNum) {
    _impl_.point_id_options_.num_ = ::uint64_t{0u};
    clear_has_point_id_options();
  }
}
inline ::uint64_t PointId::num() const {
  // @@protoc_insertion_point(field_get:qdrant.PointId.num)
  return _internal_num();
}
inline void PointId::set_num(::uint64_t value) {
  if (point_id_options_case() != kNum) {
    clear_point_id_options();
    set_has_num();
  }
  _impl_.point_id_options_.num_ = value;
  // @@protoc_insertion_point(field_set:qdrant.PointId.num)
}
inline ::uint64_t PointId::_internal_num() const {
  if (point_id_options_case() == kNum) {
    return _impl_.point_id_options_.num_;
  }
  return ::uint64_t{0u};
}

// string uuid = 2;
inline bool PointId::has_uuid() const {
  return point_id_options_case() == kUuid;
}
inline void PointId::set_has_uuid() {
  _impl_._oneof_case_[0] = kUuid;
}
inline void PointId::clear_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (point_id_options_case() == kUuid) {
    _impl_.point_id_options_.uuid_.Destroy();
    clear_has_point_id_options();
  }
}
inline const ::std::string& PointId::uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointId.uuid)
  return _internal_uuid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PointId::set_uuid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (point_id_options_case() != kUuid) {
    clear_point_id_options();

    set_has_uuid();
    _impl_.point_id_options_.uuid_.InitDefault();
  }
  _impl_.point_id_options_.uuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.PointId.uuid)
}
inline ::std::string* PROTOBUF_NONNULL PointId::mutable_uuid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  if (point_id_options_case() != kUuid) {
    clear_point_id_options();

    set_has_uuid();
    _impl_.point_id_options_.uuid_.InitDefault();
  }
  ::std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:qdrant.PointId.uuid)
  return _s;
}
inline const ::std::string& PointId::_internal_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (point_id_options_case() != kUuid) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.point_id_options_.uuid_.Get();
}
inline void PointId::_internal_set_uuid(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.point_id_options_.uuid_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PointId::_internal_mutable_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.point_id_options_.uuid_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PointId::release_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointId.uuid)
  if (point_id_options_case() != kUuid) {
    return nullptr;
  }
  clear_has_point_id_options();
  return _impl_.point_id_options_.uuid_.Release();
}
inline void PointId::set_allocated_uuid(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_point_id_options()) {
    clear_point_id_options();
  }
  if (value != nullptr) {
    set_has_uuid();
    _impl_.point_id_options_.uuid_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointId.uuid)
}

inline bool PointId::has_point_id_options() const {
  return point_id_options_case() != POINT_ID_OPTIONS_NOT_SET;
}
inline void PointId::clear_has_point_id_options() {
  _impl_._oneof_case_[0] = POINT_ID_OPTIONS_NOT_SET;
}
inline PointId::PointIdOptionsCase PointId::point_id_options_case() const {
  return PointId::PointIdOptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SparseIndices

// repeated uint32 data = 1;
inline int SparseIndices::_internal_data_size() const {
  return _internal_data().size();
}
inline int SparseIndices::data_size() const {
  return _internal_data_size();
}
inline void SparseIndices::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint32_t SparseIndices::data(int index) const {
  // @@protoc_insertion_point(field_get:qdrant.SparseIndices.data)
  return _internal_data().Get(index);
}
inline void SparseIndices::set_data(int index, ::uint32_t value) {
  _internal_mutable_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:qdrant.SparseIndices.data)
}
inline void SparseIndices::add_data(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_data()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.SparseIndices.data)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& SparseIndices::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.SparseIndices.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL SparseIndices::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.SparseIndices.data)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
SparseIndices::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
SparseIndices::_internal_mutable_data() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Document

// string text = 1;
inline void Document::clear_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& Document::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Document.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Document::set_text(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.Document.text)
}
inline ::std::string* PROTOBUF_NONNULL Document::mutable_text()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:qdrant.Document.text)
  return _s;
}
inline const ::std::string& Document::_internal_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.text_.Get();
}
inline void Document::_internal_set_text(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Document::_internal_mutable_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.text_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Document::release_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.Document.text)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.text_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.text_.Set("", GetArena());
  }
  return released;
}
inline void Document::set_allocated_text(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.text_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.Document.text)
}

// string model = 3;
inline void Document::clear_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& Document::model() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Document.model)
  return _internal_model();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Document::set_model(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.model_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.Document.model)
}
inline ::std::string* PROTOBUF_NONNULL Document::mutable_model()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:qdrant.Document.model)
  return _s;
}
inline const ::std::string& Document::_internal_model() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_.Get();
}
inline void Document::_internal_set_model(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Document::_internal_mutable_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Document::release_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.Document.model)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.model_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.model_.Set("", GetArena());
  }
  return released;
}
inline void Document::set_allocated_model(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.model_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.Document.model)
}

// map<string, .qdrant.Value> options = 4;
inline int Document::_internal_options_size() const {
  return _internal_options().size();
}
inline int Document::options_size() const {
  return _internal_options_size();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& Document::_internal_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.options_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& Document::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.Document.options)
  return _internal_options();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL Document::_internal_mutable_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.options_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL Document::mutable_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.Document.options)
  return _internal_mutable_options();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Image

// .qdrant.Value image = 1;
inline bool Image::has_image() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.image_ != nullptr);
  return value;
}
inline const ::qdrant::Value& Image::_internal_image() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Value* p = _impl_.image_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Value&>(::qdrant::_Value_default_instance_);
}
inline const ::qdrant::Value& Image::image() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Image.image)
  return _internal_image();
}
inline void Image::unsafe_arena_set_allocated_image(
    ::qdrant::Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.image_);
  }
  _impl_.image_ = reinterpret_cast<::qdrant::Value*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Image.image)
}
inline ::qdrant::Value* PROTOBUF_NULLABLE Image::release_image() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Value* released = _impl_.image_;
  _impl_.image_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Value* PROTOBUF_NULLABLE Image::unsafe_arena_release_image() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.Image.image)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Value* temp = _impl_.image_;
  _impl_.image_ = nullptr;
  return temp;
}
inline ::qdrant::Value* PROTOBUF_NONNULL Image::_internal_mutable_image() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.image_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Value>(GetArena());
    _impl_.image_ = reinterpret_cast<::qdrant::Value*>(p);
  }
  return _impl_.image_;
}
inline ::qdrant::Value* PROTOBUF_NONNULL Image::mutable_image()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Value* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:qdrant.Image.image)
  return _msg;
}
inline void Image::set_allocated_image(::qdrant::Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.image_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.image_ = reinterpret_cast<::qdrant::Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.Image.image)
}

// string model = 2;
inline void Image::clear_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& Image::model() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Image.model)
  return _internal_model();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Image::set_model(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.model_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.Image.model)
}
inline ::std::string* PROTOBUF_NONNULL Image::mutable_model()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:qdrant.Image.model)
  return _s;
}
inline const ::std::string& Image::_internal_model() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_.Get();
}
inline void Image::_internal_set_model(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Image::_internal_mutable_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Image::release_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.Image.model)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.model_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.model_.Set("", GetArena());
  }
  return released;
}
inline void Image::set_allocated_model(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.model_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.Image.model)
}

// map<string, .qdrant.Value> options = 3;
inline int Image::_internal_options_size() const {
  return _internal_options().size();
}
inline int Image::options_size() const {
  return _internal_options_size();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& Image::_internal_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.options_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& Image::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.Image.options)
  return _internal_options();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL Image::_internal_mutable_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.options_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL Image::mutable_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.Image.options)
  return _internal_mutable_options();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InferenceObject

// .qdrant.Value object = 1;
inline bool InferenceObject::has_object() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.object_ != nullptr);
  return value;
}
inline const ::qdrant::Value& InferenceObject::_internal_object() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Value* p = _impl_.object_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Value&>(::qdrant::_Value_default_instance_);
}
inline const ::qdrant::Value& InferenceObject::object() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.InferenceObject.object)
  return _internal_object();
}
inline void InferenceObject::unsafe_arena_set_allocated_object(
    ::qdrant::Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_);
  }
  _impl_.object_ = reinterpret_cast<::qdrant::Value*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.InferenceObject.object)
}
inline ::qdrant::Value* PROTOBUF_NULLABLE InferenceObject::release_object() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Value* released = _impl_.object_;
  _impl_.object_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Value* PROTOBUF_NULLABLE InferenceObject::unsafe_arena_release_object() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.InferenceObject.object)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Value* temp = _impl_.object_;
  _impl_.object_ = nullptr;
  return temp;
}
inline ::qdrant::Value* PROTOBUF_NONNULL InferenceObject::_internal_mutable_object() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.object_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Value>(GetArena());
    _impl_.object_ = reinterpret_cast<::qdrant::Value*>(p);
  }
  return _impl_.object_;
}
inline ::qdrant::Value* PROTOBUF_NONNULL InferenceObject::mutable_object()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Value* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:qdrant.InferenceObject.object)
  return _msg;
}
inline void InferenceObject::set_allocated_object(::qdrant::Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.object_ = reinterpret_cast<::qdrant::Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.InferenceObject.object)
}

// string model = 2;
inline void InferenceObject::clear_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& InferenceObject::model() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.InferenceObject.model)
  return _internal_model();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InferenceObject::set_model(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.model_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.InferenceObject.model)
}
inline ::std::string* PROTOBUF_NONNULL InferenceObject::mutable_model()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:qdrant.InferenceObject.model)
  return _s;
}
inline const ::std::string& InferenceObject::_internal_model() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_.Get();
}
inline void InferenceObject::_internal_set_model(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InferenceObject::_internal_mutable_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InferenceObject::release_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.InferenceObject.model)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.model_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.model_.Set("", GetArena());
  }
  return released;
}
inline void InferenceObject::set_allocated_model(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.model_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.InferenceObject.model)
}

// map<string, .qdrant.Value> options = 3;
inline int InferenceObject::_internal_options_size() const {
  return _internal_options().size();
}
inline int InferenceObject::options_size() const {
  return _internal_options_size();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& InferenceObject::_internal_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.options_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& InferenceObject::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.InferenceObject.options)
  return _internal_options();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL InferenceObject::_internal_mutable_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.options_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL InferenceObject::mutable_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.InferenceObject.options)
  return _internal_mutable_options();
}

// -------------------------------------------------------------------

// Vector

// repeated float data = 1;
inline int Vector::_internal_data_size() const {
  return _internal_data().size();
}
inline int Vector::data_size() const {
  return _internal_data_size();
}
inline void Vector::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline float Vector::data(int index) const {
  // @@protoc_insertion_point(field_get:qdrant.Vector.data)
  return _internal_data().Get(index);
}
inline void Vector::set_data(int index, float value) {
  _internal_mutable_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:qdrant.Vector.data)
}
inline void Vector::add_data(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_data()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.Vector.data)
}
inline const ::google::protobuf::RepeatedField<float>& Vector::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.Vector.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL Vector::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.Vector.data)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedField<float>&
Vector::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL
Vector::_internal_mutable_data() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.data_;
}

// optional .qdrant.SparseIndices indices = 2;
inline bool Vector::has_indices() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.indices_ != nullptr);
  return value;
}
inline void Vector::clear_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.indices_ != nullptr) _impl_.indices_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::SparseIndices& Vector::_internal_indices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SparseIndices* p = _impl_.indices_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SparseIndices&>(::qdrant::_SparseIndices_default_instance_);
}
inline const ::qdrant::SparseIndices& Vector::indices() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Vector.indices)
  return _internal_indices();
}
inline void Vector::unsafe_arena_set_allocated_indices(
    ::qdrant::SparseIndices* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.indices_);
  }
  _impl_.indices_ = reinterpret_cast<::qdrant::SparseIndices*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Vector.indices)
}
inline ::qdrant::SparseIndices* PROTOBUF_NULLABLE Vector::release_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::SparseIndices* released = _impl_.indices_;
  _impl_.indices_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SparseIndices* PROTOBUF_NULLABLE Vector::unsafe_arena_release_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.Vector.indices)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::SparseIndices* temp = _impl_.indices_;
  _impl_.indices_ = nullptr;
  return temp;
}
inline ::qdrant::SparseIndices* PROTOBUF_NONNULL Vector::_internal_mutable_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.indices_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SparseIndices>(GetArena());
    _impl_.indices_ = reinterpret_cast<::qdrant::SparseIndices*>(p);
  }
  return _impl_.indices_;
}
inline ::qdrant::SparseIndices* PROTOBUF_NONNULL Vector::mutable_indices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::SparseIndices* _msg = _internal_mutable_indices();
  // @@protoc_insertion_point(field_mutable:qdrant.Vector.indices)
  return _msg;
}
inline void Vector::set_allocated_indices(::qdrant::SparseIndices* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.indices_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.indices_ = reinterpret_cast<::qdrant::SparseIndices*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.Vector.indices)
}

// optional uint32 vectors_count = 3;
inline bool Vector::has_vectors_count() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void Vector::clear_vectors_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vectors_count_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint32_t Vector::vectors_count() const {
  // @@protoc_insertion_point(field_get:qdrant.Vector.vectors_count)
  return _internal_vectors_count();
}
inline void Vector::set_vectors_count(::uint32_t value) {
  _internal_set_vectors_count(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.Vector.vectors_count)
}
inline ::uint32_t Vector::_internal_vectors_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vectors_count_;
}
inline void Vector::_internal_set_vectors_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vectors_count_ = value;
}

// .qdrant.DenseVector dense = 101;
inline bool Vector::has_dense() const {
  return vector_case() == kDense;
}
inline bool Vector::_internal_has_dense() const {
  return vector_case() == kDense;
}
inline void Vector::set_has_dense() {
  _impl_._oneof_case_[0] = kDense;
}
inline void Vector::clear_dense() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (vector_case() == kDense) {
    if (GetArena() == nullptr) {
      delete _impl_.vector_.dense_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.vector_.dense_);
    }
    clear_has_vector();
  }
}
inline ::qdrant::DenseVector* PROTOBUF_NULLABLE Vector::release_dense() {
  // @@protoc_insertion_point(field_release:qdrant.Vector.dense)
  if (vector_case() == kDense) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::DenseVector*>(_impl_.vector_.dense_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vector_.dense_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::DenseVector& Vector::_internal_dense() const {
  return vector_case() == kDense ? static_cast<const ::qdrant::DenseVector&>(*reinterpret_cast<::qdrant::DenseVector*>(_impl_.vector_.dense_))
                     : reinterpret_cast<const ::qdrant::DenseVector&>(::qdrant::_DenseVector_default_instance_);
}
inline const ::qdrant::DenseVector& Vector::dense() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Vector.dense)
  return _internal_dense();
}
inline ::qdrant::DenseVector* PROTOBUF_NULLABLE Vector::unsafe_arena_release_dense() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Vector.dense)
  if (vector_case() == kDense) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::DenseVector*>(_impl_.vector_.dense_);
    _impl_.vector_.dense_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Vector::unsafe_arena_set_allocated_dense(
    ::qdrant::DenseVector* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_vector();
  if (value) {
    set_has_dense();
    _impl_.vector_.dense_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Vector.dense)
}
inline ::qdrant::DenseVector* PROTOBUF_NONNULL Vector::_internal_mutable_dense() {
  if (vector_case() != kDense) {
    clear_vector();
    set_has_dense();
    _impl_.vector_.dense_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::DenseVector>(GetArena()));
  }
  return reinterpret_cast<::qdrant::DenseVector*>(_impl_.vector_.dense_);
}
inline ::qdrant::DenseVector* PROTOBUF_NONNULL Vector::mutable_dense()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::DenseVector* _msg = _internal_mutable_dense();
  // @@protoc_insertion_point(field_mutable:qdrant.Vector.dense)
  return _msg;
}

// .qdrant.SparseVector sparse = 102;
inline bool Vector::has_sparse() const {
  return vector_case() == kSparse;
}
inline bool Vector::_internal_has_sparse() const {
  return vector_case() == kSparse;
}
inline void Vector::set_has_sparse() {
  _impl_._oneof_case_[0] = kSparse;
}
inline void Vector::clear_sparse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (vector_case() == kSparse) {
    if (GetArena() == nullptr) {
      delete _impl_.vector_.sparse_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.vector_.sparse_);
    }
    clear_has_vector();
  }
}
inline ::qdrant::SparseVector* PROTOBUF_NULLABLE Vector::release_sparse() {
  // @@protoc_insertion_point(field_release:qdrant.Vector.sparse)
  if (vector_case() == kSparse) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::SparseVector*>(_impl_.vector_.sparse_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vector_.sparse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::SparseVector& Vector::_internal_sparse() const {
  return vector_case() == kSparse ? static_cast<const ::qdrant::SparseVector&>(*reinterpret_cast<::qdrant::SparseVector*>(_impl_.vector_.sparse_))
                     : reinterpret_cast<const ::qdrant::SparseVector&>(::qdrant::_SparseVector_default_instance_);
}
inline const ::qdrant::SparseVector& Vector::sparse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Vector.sparse)
  return _internal_sparse();
}
inline ::qdrant::SparseVector* PROTOBUF_NULLABLE Vector::unsafe_arena_release_sparse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Vector.sparse)
  if (vector_case() == kSparse) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::SparseVector*>(_impl_.vector_.sparse_);
    _impl_.vector_.sparse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Vector::unsafe_arena_set_allocated_sparse(
    ::qdrant::SparseVector* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_vector();
  if (value) {
    set_has_sparse();
    _impl_.vector_.sparse_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Vector.sparse)
}
inline ::qdrant::SparseVector* PROTOBUF_NONNULL Vector::_internal_mutable_sparse() {
  if (vector_case() != kSparse) {
    clear_vector();
    set_has_sparse();
    _impl_.vector_.sparse_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::SparseVector>(GetArena()));
  }
  return reinterpret_cast<::qdrant::SparseVector*>(_impl_.vector_.sparse_);
}
inline ::qdrant::SparseVector* PROTOBUF_NONNULL Vector::mutable_sparse()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::SparseVector* _msg = _internal_mutable_sparse();
  // @@protoc_insertion_point(field_mutable:qdrant.Vector.sparse)
  return _msg;
}

// .qdrant.MultiDenseVector multi_dense = 103;
inline bool Vector::has_multi_dense() const {
  return vector_case() == kMultiDense;
}
inline bool Vector::_internal_has_multi_dense() const {
  return vector_case() == kMultiDense;
}
inline void Vector::set_has_multi_dense() {
  _impl_._oneof_case_[0] = kMultiDense;
}
inline void Vector::clear_multi_dense() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (vector_case() == kMultiDense) {
    if (GetArena() == nullptr) {
      delete _impl_.vector_.multi_dense_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.vector_.multi_dense_);
    }
    clear_has_vector();
  }
}
inline ::qdrant::MultiDenseVector* PROTOBUF_NULLABLE Vector::release_multi_dense() {
  // @@protoc_insertion_point(field_release:qdrant.Vector.multi_dense)
  if (vector_case() == kMultiDense) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::MultiDenseVector*>(_impl_.vector_.multi_dense_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vector_.multi_dense_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::MultiDenseVector& Vector::_internal_multi_dense() const {
  return vector_case() == kMultiDense ? static_cast<const ::qdrant::MultiDenseVector&>(*reinterpret_cast<::qdrant::MultiDenseVector*>(_impl_.vector_.multi_dense_))
                     : reinterpret_cast<const ::qdrant::MultiDenseVector&>(::qdrant::_MultiDenseVector_default_instance_);
}
inline const ::qdrant::MultiDenseVector& Vector::multi_dense() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Vector.multi_dense)
  return _internal_multi_dense();
}
inline ::qdrant::MultiDenseVector* PROTOBUF_NULLABLE Vector::unsafe_arena_release_multi_dense() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Vector.multi_dense)
  if (vector_case() == kMultiDense) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::MultiDenseVector*>(_impl_.vector_.multi_dense_);
    _impl_.vector_.multi_dense_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Vector::unsafe_arena_set_allocated_multi_dense(
    ::qdrant::MultiDenseVector* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_vector();
  if (value) {
    set_has_multi_dense();
    _impl_.vector_.multi_dense_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Vector.multi_dense)
}
inline ::qdrant::MultiDenseVector* PROTOBUF_NONNULL Vector::_internal_mutable_multi_dense() {
  if (vector_case() != kMultiDense) {
    clear_vector();
    set_has_multi_dense();
    _impl_.vector_.multi_dense_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::MultiDenseVector>(GetArena()));
  }
  return reinterpret_cast<::qdrant::MultiDenseVector*>(_impl_.vector_.multi_dense_);
}
inline ::qdrant::MultiDenseVector* PROTOBUF_NONNULL Vector::mutable_multi_dense()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::MultiDenseVector* _msg = _internal_mutable_multi_dense();
  // @@protoc_insertion_point(field_mutable:qdrant.Vector.multi_dense)
  return _msg;
}

// .qdrant.Document document = 104;
inline bool Vector::has_document() const {
  return vector_case() == kDocument;
}
inline bool Vector::_internal_has_document() const {
  return vector_case() == kDocument;
}
inline void Vector::set_has_document() {
  _impl_._oneof_case_[0] = kDocument;
}
inline void Vector::clear_document() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (vector_case() == kDocument) {
    if (GetArena() == nullptr) {
      delete _impl_.vector_.document_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.vector_.document_);
    }
    clear_has_vector();
  }
}
inline ::qdrant::Document* PROTOBUF_NULLABLE Vector::release_document() {
  // @@protoc_insertion_point(field_release:qdrant.Vector.document)
  if (vector_case() == kDocument) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::Document*>(_impl_.vector_.document_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vector_.document_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Document& Vector::_internal_document() const {
  return vector_case() == kDocument ? static_cast<const ::qdrant::Document&>(*reinterpret_cast<::qdrant::Document*>(_impl_.vector_.document_))
                     : reinterpret_cast<const ::qdrant::Document&>(::qdrant::_Document_default_instance_);
}
inline const ::qdrant::Document& Vector::document() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Vector.document)
  return _internal_document();
}
inline ::qdrant::Document* PROTOBUF_NULLABLE Vector::unsafe_arena_release_document() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Vector.document)
  if (vector_case() == kDocument) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::Document*>(_impl_.vector_.document_);
    _impl_.vector_.document_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Vector::unsafe_arena_set_allocated_document(
    ::qdrant::Document* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_vector();
  if (value) {
    set_has_document();
    _impl_.vector_.document_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Vector.document)
}
inline ::qdrant::Document* PROTOBUF_NONNULL Vector::_internal_mutable_document() {
  if (vector_case() != kDocument) {
    clear_vector();
    set_has_document();
    _impl_.vector_.document_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Document>(GetArena()));
  }
  return reinterpret_cast<::qdrant::Document*>(_impl_.vector_.document_);
}
inline ::qdrant::Document* PROTOBUF_NONNULL Vector::mutable_document()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Document* _msg = _internal_mutable_document();
  // @@protoc_insertion_point(field_mutable:qdrant.Vector.document)
  return _msg;
}

// .qdrant.Image image = 105;
inline bool Vector::has_image() const {
  return vector_case() == kImage;
}
inline bool Vector::_internal_has_image() const {
  return vector_case() == kImage;
}
inline void Vector::set_has_image() {
  _impl_._oneof_case_[0] = kImage;
}
inline void Vector::clear_image() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (vector_case() == kImage) {
    if (GetArena() == nullptr) {
      delete _impl_.vector_.image_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.vector_.image_);
    }
    clear_has_vector();
  }
}
inline ::qdrant::Image* PROTOBUF_NULLABLE Vector::release_image() {
  // @@protoc_insertion_point(field_release:qdrant.Vector.image)
  if (vector_case() == kImage) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::Image*>(_impl_.vector_.image_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vector_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Image& Vector::_internal_image() const {
  return vector_case() == kImage ? static_cast<const ::qdrant::Image&>(*reinterpret_cast<::qdrant::Image*>(_impl_.vector_.image_))
                     : reinterpret_cast<const ::qdrant::Image&>(::qdrant::_Image_default_instance_);
}
inline const ::qdrant::Image& Vector::image() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Vector.image)
  return _internal_image();
}
inline ::qdrant::Image* PROTOBUF_NULLABLE Vector::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Vector.image)
  if (vector_case() == kImage) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::Image*>(_impl_.vector_.image_);
    _impl_.vector_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Vector::unsafe_arena_set_allocated_image(
    ::qdrant::Image* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_vector();
  if (value) {
    set_has_image();
    _impl_.vector_.image_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Vector.image)
}
inline ::qdrant::Image* PROTOBUF_NONNULL Vector::_internal_mutable_image() {
  if (vector_case() != kImage) {
    clear_vector();
    set_has_image();
    _impl_.vector_.image_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Image>(GetArena()));
  }
  return reinterpret_cast<::qdrant::Image*>(_impl_.vector_.image_);
}
inline ::qdrant::Image* PROTOBUF_NONNULL Vector::mutable_image()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:qdrant.Vector.image)
  return _msg;
}

// .qdrant.InferenceObject object = 106;
inline bool Vector::has_object() const {
  return vector_case() == kObject;
}
inline bool Vector::_internal_has_object() const {
  return vector_case() == kObject;
}
inline void Vector::set_has_object() {
  _impl_._oneof_case_[0] = kObject;
}
inline void Vector::clear_object() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (vector_case() == kObject) {
    if (GetArena() == nullptr) {
      delete _impl_.vector_.object_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.vector_.object_);
    }
    clear_has_vector();
  }
}
inline ::qdrant::InferenceObject* PROTOBUF_NULLABLE Vector::release_object() {
  // @@protoc_insertion_point(field_release:qdrant.Vector.object)
  if (vector_case() == kObject) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::InferenceObject*>(_impl_.vector_.object_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vector_.object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::InferenceObject& Vector::_internal_object() const {
  return vector_case() == kObject ? static_cast<const ::qdrant::InferenceObject&>(*reinterpret_cast<::qdrant::InferenceObject*>(_impl_.vector_.object_))
                     : reinterpret_cast<const ::qdrant::InferenceObject&>(::qdrant::_InferenceObject_default_instance_);
}
inline const ::qdrant::InferenceObject& Vector::object() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Vector.object)
  return _internal_object();
}
inline ::qdrant::InferenceObject* PROTOBUF_NULLABLE Vector::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Vector.object)
  if (vector_case() == kObject) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::InferenceObject*>(_impl_.vector_.object_);
    _impl_.vector_.object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Vector::unsafe_arena_set_allocated_object(
    ::qdrant::InferenceObject* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_vector();
  if (value) {
    set_has_object();
    _impl_.vector_.object_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Vector.object)
}
inline ::qdrant::InferenceObject* PROTOBUF_NONNULL Vector::_internal_mutable_object() {
  if (vector_case() != kObject) {
    clear_vector();
    set_has_object();
    _impl_.vector_.object_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::InferenceObject>(GetArena()));
  }
  return reinterpret_cast<::qdrant::InferenceObject*>(_impl_.vector_.object_);
}
inline ::qdrant::InferenceObject* PROTOBUF_NONNULL Vector::mutable_object()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::InferenceObject* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:qdrant.Vector.object)
  return _msg;
}

inline bool Vector::has_vector() const {
  return vector_case() != VECTOR_NOT_SET;
}
inline void Vector::clear_has_vector() {
  _impl_._oneof_case_[0] = VECTOR_NOT_SET;
}
inline Vector::VectorCase Vector::vector_case() const {
  return Vector::VectorCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VectorOutput

// repeated float data = 1;
inline int VectorOutput::_internal_data_size() const {
  return _internal_data().size();
}
inline int VectorOutput::data_size() const {
  return _internal_data_size();
}
inline void VectorOutput::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline float VectorOutput::data(int index) const {
  // @@protoc_insertion_point(field_get:qdrant.VectorOutput.data)
  return _internal_data().Get(index);
}
inline void VectorOutput::set_data(int index, float value) {
  _internal_mutable_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:qdrant.VectorOutput.data)
}
inline void VectorOutput::add_data(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_data()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.VectorOutput.data)
}
inline const ::google::protobuf::RepeatedField<float>& VectorOutput::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.VectorOutput.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL VectorOutput::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.VectorOutput.data)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedField<float>&
VectorOutput::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL
VectorOutput::_internal_mutable_data() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.data_;
}

// optional .qdrant.SparseIndices indices = 2;
inline bool VectorOutput::has_indices() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.indices_ != nullptr);
  return value;
}
inline void VectorOutput::clear_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.indices_ != nullptr) _impl_.indices_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::SparseIndices& VectorOutput::_internal_indices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SparseIndices* p = _impl_.indices_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SparseIndices&>(::qdrant::_SparseIndices_default_instance_);
}
inline const ::qdrant::SparseIndices& VectorOutput::indices() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorOutput.indices)
  return _internal_indices();
}
inline void VectorOutput::unsafe_arena_set_allocated_indices(
    ::qdrant::SparseIndices* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.indices_);
  }
  _impl_.indices_ = reinterpret_cast<::qdrant::SparseIndices*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorOutput.indices)
}
inline ::qdrant::SparseIndices* PROTOBUF_NULLABLE VectorOutput::release_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::SparseIndices* released = _impl_.indices_;
  _impl_.indices_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SparseIndices* PROTOBUF_NULLABLE VectorOutput::unsafe_arena_release_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.VectorOutput.indices)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::SparseIndices* temp = _impl_.indices_;
  _impl_.indices_ = nullptr;
  return temp;
}
inline ::qdrant::SparseIndices* PROTOBUF_NONNULL VectorOutput::_internal_mutable_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.indices_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SparseIndices>(GetArena());
    _impl_.indices_ = reinterpret_cast<::qdrant::SparseIndices*>(p);
  }
  return _impl_.indices_;
}
inline ::qdrant::SparseIndices* PROTOBUF_NONNULL VectorOutput::mutable_indices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::SparseIndices* _msg = _internal_mutable_indices();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorOutput.indices)
  return _msg;
}
inline void VectorOutput::set_allocated_indices(::qdrant::SparseIndices* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.indices_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.indices_ = reinterpret_cast<::qdrant::SparseIndices*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.VectorOutput.indices)
}

// optional uint32 vectors_count = 3;
inline bool VectorOutput::has_vectors_count() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void VectorOutput::clear_vectors_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vectors_count_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint32_t VectorOutput::vectors_count() const {
  // @@protoc_insertion_point(field_get:qdrant.VectorOutput.vectors_count)
  return _internal_vectors_count();
}
inline void VectorOutput::set_vectors_count(::uint32_t value) {
  _internal_set_vectors_count(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.VectorOutput.vectors_count)
}
inline ::uint32_t VectorOutput::_internal_vectors_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vectors_count_;
}
inline void VectorOutput::_internal_set_vectors_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vectors_count_ = value;
}

// .qdrant.DenseVector dense = 101;
inline bool VectorOutput::has_dense() const {
  return vector_case() == kDense;
}
inline bool VectorOutput::_internal_has_dense() const {
  return vector_case() == kDense;
}
inline void VectorOutput::set_has_dense() {
  _impl_._oneof_case_[0] = kDense;
}
inline void VectorOutput::clear_dense() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (vector_case() == kDense) {
    if (GetArena() == nullptr) {
      delete _impl_.vector_.dense_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.vector_.dense_);
    }
    clear_has_vector();
  }
}
inline ::qdrant::DenseVector* PROTOBUF_NULLABLE VectorOutput::release_dense() {
  // @@protoc_insertion_point(field_release:qdrant.VectorOutput.dense)
  if (vector_case() == kDense) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::DenseVector*>(_impl_.vector_.dense_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vector_.dense_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::DenseVector& VectorOutput::_internal_dense() const {
  return vector_case() == kDense ? static_cast<const ::qdrant::DenseVector&>(*reinterpret_cast<::qdrant::DenseVector*>(_impl_.vector_.dense_))
                     : reinterpret_cast<const ::qdrant::DenseVector&>(::qdrant::_DenseVector_default_instance_);
}
inline const ::qdrant::DenseVector& VectorOutput::dense() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorOutput.dense)
  return _internal_dense();
}
inline ::qdrant::DenseVector* PROTOBUF_NULLABLE VectorOutput::unsafe_arena_release_dense() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorOutput.dense)
  if (vector_case() == kDense) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::DenseVector*>(_impl_.vector_.dense_);
    _impl_.vector_.dense_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorOutput::unsafe_arena_set_allocated_dense(
    ::qdrant::DenseVector* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_vector();
  if (value) {
    set_has_dense();
    _impl_.vector_.dense_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorOutput.dense)
}
inline ::qdrant::DenseVector* PROTOBUF_NONNULL VectorOutput::_internal_mutable_dense() {
  if (vector_case() != kDense) {
    clear_vector();
    set_has_dense();
    _impl_.vector_.dense_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::DenseVector>(GetArena()));
  }
  return reinterpret_cast<::qdrant::DenseVector*>(_impl_.vector_.dense_);
}
inline ::qdrant::DenseVector* PROTOBUF_NONNULL VectorOutput::mutable_dense()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::DenseVector* _msg = _internal_mutable_dense();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorOutput.dense)
  return _msg;
}

// .qdrant.SparseVector sparse = 102;
inline bool VectorOutput::has_sparse() const {
  return vector_case() == kSparse;
}
inline bool VectorOutput::_internal_has_sparse() const {
  return vector_case() == kSparse;
}
inline void VectorOutput::set_has_sparse() {
  _impl_._oneof_case_[0] = kSparse;
}
inline void VectorOutput::clear_sparse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (vector_case() == kSparse) {
    if (GetArena() == nullptr) {
      delete _impl_.vector_.sparse_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.vector_.sparse_);
    }
    clear_has_vector();
  }
}
inline ::qdrant::SparseVector* PROTOBUF_NULLABLE VectorOutput::release_sparse() {
  // @@protoc_insertion_point(field_release:qdrant.VectorOutput.sparse)
  if (vector_case() == kSparse) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::SparseVector*>(_impl_.vector_.sparse_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vector_.sparse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::SparseVector& VectorOutput::_internal_sparse() const {
  return vector_case() == kSparse ? static_cast<const ::qdrant::SparseVector&>(*reinterpret_cast<::qdrant::SparseVector*>(_impl_.vector_.sparse_))
                     : reinterpret_cast<const ::qdrant::SparseVector&>(::qdrant::_SparseVector_default_instance_);
}
inline const ::qdrant::SparseVector& VectorOutput::sparse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorOutput.sparse)
  return _internal_sparse();
}
inline ::qdrant::SparseVector* PROTOBUF_NULLABLE VectorOutput::unsafe_arena_release_sparse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorOutput.sparse)
  if (vector_case() == kSparse) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::SparseVector*>(_impl_.vector_.sparse_);
    _impl_.vector_.sparse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorOutput::unsafe_arena_set_allocated_sparse(
    ::qdrant::SparseVector* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_vector();
  if (value) {
    set_has_sparse();
    _impl_.vector_.sparse_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorOutput.sparse)
}
inline ::qdrant::SparseVector* PROTOBUF_NONNULL VectorOutput::_internal_mutable_sparse() {
  if (vector_case() != kSparse) {
    clear_vector();
    set_has_sparse();
    _impl_.vector_.sparse_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::SparseVector>(GetArena()));
  }
  return reinterpret_cast<::qdrant::SparseVector*>(_impl_.vector_.sparse_);
}
inline ::qdrant::SparseVector* PROTOBUF_NONNULL VectorOutput::mutable_sparse()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::SparseVector* _msg = _internal_mutable_sparse();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorOutput.sparse)
  return _msg;
}

// .qdrant.MultiDenseVector multi_dense = 103;
inline bool VectorOutput::has_multi_dense() const {
  return vector_case() == kMultiDense;
}
inline bool VectorOutput::_internal_has_multi_dense() const {
  return vector_case() == kMultiDense;
}
inline void VectorOutput::set_has_multi_dense() {
  _impl_._oneof_case_[0] = kMultiDense;
}
inline void VectorOutput::clear_multi_dense() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (vector_case() == kMultiDense) {
    if (GetArena() == nullptr) {
      delete _impl_.vector_.multi_dense_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.vector_.multi_dense_);
    }
    clear_has_vector();
  }
}
inline ::qdrant::MultiDenseVector* PROTOBUF_NULLABLE VectorOutput::release_multi_dense() {
  // @@protoc_insertion_point(field_release:qdrant.VectorOutput.multi_dense)
  if (vector_case() == kMultiDense) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::MultiDenseVector*>(_impl_.vector_.multi_dense_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vector_.multi_dense_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::MultiDenseVector& VectorOutput::_internal_multi_dense() const {
  return vector_case() == kMultiDense ? static_cast<const ::qdrant::MultiDenseVector&>(*reinterpret_cast<::qdrant::MultiDenseVector*>(_impl_.vector_.multi_dense_))
                     : reinterpret_cast<const ::qdrant::MultiDenseVector&>(::qdrant::_MultiDenseVector_default_instance_);
}
inline const ::qdrant::MultiDenseVector& VectorOutput::multi_dense() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorOutput.multi_dense)
  return _internal_multi_dense();
}
inline ::qdrant::MultiDenseVector* PROTOBUF_NULLABLE VectorOutput::unsafe_arena_release_multi_dense() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorOutput.multi_dense)
  if (vector_case() == kMultiDense) {
    clear_has_vector();
    auto* temp = reinterpret_cast<::qdrant::MultiDenseVector*>(_impl_.vector_.multi_dense_);
    _impl_.vector_.multi_dense_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorOutput::unsafe_arena_set_allocated_multi_dense(
    ::qdrant::MultiDenseVector* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_vector();
  if (value) {
    set_has_multi_dense();
    _impl_.vector_.multi_dense_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorOutput.multi_dense)
}
inline ::qdrant::MultiDenseVector* PROTOBUF_NONNULL VectorOutput::_internal_mutable_multi_dense() {
  if (vector_case() != kMultiDense) {
    clear_vector();
    set_has_multi_dense();
    _impl_.vector_.multi_dense_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::MultiDenseVector>(GetArena()));
  }
  return reinterpret_cast<::qdrant::MultiDenseVector*>(_impl_.vector_.multi_dense_);
}
inline ::qdrant::MultiDenseVector* PROTOBUF_NONNULL VectorOutput::mutable_multi_dense()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::MultiDenseVector* _msg = _internal_mutable_multi_dense();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorOutput.multi_dense)
  return _msg;
}

inline bool VectorOutput::has_vector() const {
  return vector_case() != VECTOR_NOT_SET;
}
inline void VectorOutput::clear_has_vector() {
  _impl_._oneof_case_[0] = VECTOR_NOT_SET;
}
inline VectorOutput::VectorCase VectorOutput::vector_case() const {
  return VectorOutput::VectorCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DenseVector

// repeated float data = 1;
inline int DenseVector::_internal_data_size() const {
  return _internal_data().size();
}
inline int DenseVector::data_size() const {
  return _internal_data_size();
}
inline void DenseVector::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline float DenseVector::data(int index) const {
  // @@protoc_insertion_point(field_get:qdrant.DenseVector.data)
  return _internal_data().Get(index);
}
inline void DenseVector::set_data(int index, float value) {
  _internal_mutable_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:qdrant.DenseVector.data)
}
inline void DenseVector::add_data(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_data()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.DenseVector.data)
}
inline const ::google::protobuf::RepeatedField<float>& DenseVector::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.DenseVector.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL DenseVector::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.DenseVector.data)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedField<float>&
DenseVector::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL
DenseVector::_internal_mutable_data() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// SparseVector

// repeated float values = 1;
inline int SparseVector::_internal_values_size() const {
  return _internal_values().size();
}
inline int SparseVector::values_size() const {
  return _internal_values_size();
}
inline void SparseVector::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline float SparseVector::values(int index) const {
  // @@protoc_insertion_point(field_get:qdrant.SparseVector.values)
  return _internal_values().Get(index);
}
inline void SparseVector::set_values(int index, float value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:qdrant.SparseVector.values)
}
inline void SparseVector::add_values(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_values()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.SparseVector.values)
}
inline const ::google::protobuf::RepeatedField<float>& SparseVector::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.SparseVector.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL SparseVector::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.SparseVector.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<float>&
SparseVector::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL
SparseVector::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// repeated uint32 indices = 2;
inline int SparseVector::_internal_indices_size() const {
  return _internal_indices().size();
}
inline int SparseVector::indices_size() const {
  return _internal_indices_size();
}
inline void SparseVector::clear_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.indices_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint32_t SparseVector::indices(int index) const {
  // @@protoc_insertion_point(field_get:qdrant.SparseVector.indices)
  return _internal_indices().Get(index);
}
inline void SparseVector::set_indices(int index, ::uint32_t value) {
  _internal_mutable_indices()->Set(index, value);
  // @@protoc_insertion_point(field_set:qdrant.SparseVector.indices)
}
inline void SparseVector::add_indices(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_indices()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:qdrant.SparseVector.indices)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& SparseVector::indices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.SparseVector.indices)
  return _internal_indices();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL SparseVector::mutable_indices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.SparseVector.indices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_indices();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
SparseVector::_internal_indices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.indices_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
SparseVector::_internal_mutable_indices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.indices_;
}

// -------------------------------------------------------------------

// MultiDenseVector

// repeated .qdrant.DenseVector vectors = 1;
inline int MultiDenseVector::_internal_vectors_size() const {
  return _internal_vectors().size();
}
inline int MultiDenseVector::vectors_size() const {
  return _internal_vectors_size();
}
inline void MultiDenseVector::clear_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vectors_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::DenseVector* PROTOBUF_NONNULL MultiDenseVector::mutable_vectors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.MultiDenseVector.vectors)
  return _internal_mutable_vectors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::DenseVector>* PROTOBUF_NONNULL MultiDenseVector::mutable_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.MultiDenseVector.vectors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_vectors();
}
inline const ::qdrant::DenseVector& MultiDenseVector::vectors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.MultiDenseVector.vectors)
  return _internal_vectors().Get(index);
}
inline ::qdrant::DenseVector* PROTOBUF_NONNULL MultiDenseVector::add_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::DenseVector* _add =
      _internal_mutable_vectors()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.MultiDenseVector.vectors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::DenseVector>& MultiDenseVector::vectors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.MultiDenseVector.vectors)
  return _internal_vectors();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::DenseVector>&
MultiDenseVector::_internal_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vectors_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::DenseVector>* PROTOBUF_NONNULL
MultiDenseVector::_internal_mutable_vectors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.vectors_;
}

// -------------------------------------------------------------------

// VectorInput

// .qdrant.PointId id = 1;
inline bool VectorInput::has_id() const {
  return variant_case() == kId;
}
inline bool VectorInput::_internal_has_id() const {
  return variant_case() == kId;
}
inline void VectorInput::set_has_id() {
  _impl_._oneof_case_[0] = kId;
}
inline void VectorInput::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kId) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.id_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.id_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE VectorInput::release_id() {
  // @@protoc_insertion_point(field_release:qdrant.VectorInput.id)
  if (variant_case() == kId) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::PointId*>(_impl_.variant_.id_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::PointId& VectorInput::_internal_id() const {
  return variant_case() == kId ? static_cast<const ::qdrant::PointId&>(*reinterpret_cast<::qdrant::PointId*>(_impl_.variant_.id_))
                     : reinterpret_cast<const ::qdrant::PointId&>(::qdrant::_PointId_default_instance_);
}
inline const ::qdrant::PointId& VectorInput::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorInput.id)
  return _internal_id();
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE VectorInput::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorInput.id)
  if (variant_case() == kId) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::PointId*>(_impl_.variant_.id_);
    _impl_.variant_.id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorInput::unsafe_arena_set_allocated_id(
    ::qdrant::PointId* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_id();
    _impl_.variant_.id_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorInput.id)
}
inline ::qdrant::PointId* PROTOBUF_NONNULL VectorInput::_internal_mutable_id() {
  if (variant_case() != kId) {
    clear_variant();
    set_has_id();
    _impl_.variant_.id_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::PointId>(GetArena()));
  }
  return reinterpret_cast<::qdrant::PointId*>(_impl_.variant_.id_);
}
inline ::qdrant::PointId* PROTOBUF_NONNULL VectorInput::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::PointId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorInput.id)
  return _msg;
}

// .qdrant.DenseVector dense = 2;
inline bool VectorInput::has_dense() const {
  return variant_case() == kDense;
}
inline bool VectorInput::_internal_has_dense() const {
  return variant_case() == kDense;
}
inline void VectorInput::set_has_dense() {
  _impl_._oneof_case_[0] = kDense;
}
inline void VectorInput::clear_dense() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kDense) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.dense_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.dense_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::DenseVector* PROTOBUF_NULLABLE VectorInput::release_dense() {
  // @@protoc_insertion_point(field_release:qdrant.VectorInput.dense)
  if (variant_case() == kDense) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::DenseVector*>(_impl_.variant_.dense_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.dense_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::DenseVector& VectorInput::_internal_dense() const {
  return variant_case() == kDense ? static_cast<const ::qdrant::DenseVector&>(*reinterpret_cast<::qdrant::DenseVector*>(_impl_.variant_.dense_))
                     : reinterpret_cast<const ::qdrant::DenseVector&>(::qdrant::_DenseVector_default_instance_);
}
inline const ::qdrant::DenseVector& VectorInput::dense() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorInput.dense)
  return _internal_dense();
}
inline ::qdrant::DenseVector* PROTOBUF_NULLABLE VectorInput::unsafe_arena_release_dense() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorInput.dense)
  if (variant_case() == kDense) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::DenseVector*>(_impl_.variant_.dense_);
    _impl_.variant_.dense_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorInput::unsafe_arena_set_allocated_dense(
    ::qdrant::DenseVector* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_dense();
    _impl_.variant_.dense_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorInput.dense)
}
inline ::qdrant::DenseVector* PROTOBUF_NONNULL VectorInput::_internal_mutable_dense() {
  if (variant_case() != kDense) {
    clear_variant();
    set_has_dense();
    _impl_.variant_.dense_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::DenseVector>(GetArena()));
  }
  return reinterpret_cast<::qdrant::DenseVector*>(_impl_.variant_.dense_);
}
inline ::qdrant::DenseVector* PROTOBUF_NONNULL VectorInput::mutable_dense()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::DenseVector* _msg = _internal_mutable_dense();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorInput.dense)
  return _msg;
}

// .qdrant.SparseVector sparse = 3;
inline bool VectorInput::has_sparse() const {
  return variant_case() == kSparse;
}
inline bool VectorInput::_internal_has_sparse() const {
  return variant_case() == kSparse;
}
inline void VectorInput::set_has_sparse() {
  _impl_._oneof_case_[0] = kSparse;
}
inline void VectorInput::clear_sparse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kSparse) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.sparse_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.sparse_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::SparseVector* PROTOBUF_NULLABLE VectorInput::release_sparse() {
  // @@protoc_insertion_point(field_release:qdrant.VectorInput.sparse)
  if (variant_case() == kSparse) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::SparseVector*>(_impl_.variant_.sparse_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.sparse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::SparseVector& VectorInput::_internal_sparse() const {
  return variant_case() == kSparse ? static_cast<const ::qdrant::SparseVector&>(*reinterpret_cast<::qdrant::SparseVector*>(_impl_.variant_.sparse_))
                     : reinterpret_cast<const ::qdrant::SparseVector&>(::qdrant::_SparseVector_default_instance_);
}
inline const ::qdrant::SparseVector& VectorInput::sparse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorInput.sparse)
  return _internal_sparse();
}
inline ::qdrant::SparseVector* PROTOBUF_NULLABLE VectorInput::unsafe_arena_release_sparse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorInput.sparse)
  if (variant_case() == kSparse) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::SparseVector*>(_impl_.variant_.sparse_);
    _impl_.variant_.sparse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorInput::unsafe_arena_set_allocated_sparse(
    ::qdrant::SparseVector* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_sparse();
    _impl_.variant_.sparse_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorInput.sparse)
}
inline ::qdrant::SparseVector* PROTOBUF_NONNULL VectorInput::_internal_mutable_sparse() {
  if (variant_case() != kSparse) {
    clear_variant();
    set_has_sparse();
    _impl_.variant_.sparse_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::SparseVector>(GetArena()));
  }
  return reinterpret_cast<::qdrant::SparseVector*>(_impl_.variant_.sparse_);
}
inline ::qdrant::SparseVector* PROTOBUF_NONNULL VectorInput::mutable_sparse()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::SparseVector* _msg = _internal_mutable_sparse();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorInput.sparse)
  return _msg;
}

// .qdrant.MultiDenseVector multi_dense = 4;
inline bool VectorInput::has_multi_dense() const {
  return variant_case() == kMultiDense;
}
inline bool VectorInput::_internal_has_multi_dense() const {
  return variant_case() == kMultiDense;
}
inline void VectorInput::set_has_multi_dense() {
  _impl_._oneof_case_[0] = kMultiDense;
}
inline void VectorInput::clear_multi_dense() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kMultiDense) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.multi_dense_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.multi_dense_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::MultiDenseVector* PROTOBUF_NULLABLE VectorInput::release_multi_dense() {
  // @@protoc_insertion_point(field_release:qdrant.VectorInput.multi_dense)
  if (variant_case() == kMultiDense) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::MultiDenseVector*>(_impl_.variant_.multi_dense_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.multi_dense_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::MultiDenseVector& VectorInput::_internal_multi_dense() const {
  return variant_case() == kMultiDense ? static_cast<const ::qdrant::MultiDenseVector&>(*reinterpret_cast<::qdrant::MultiDenseVector*>(_impl_.variant_.multi_dense_))
                     : reinterpret_cast<const ::qdrant::MultiDenseVector&>(::qdrant::_MultiDenseVector_default_instance_);
}
inline const ::qdrant::MultiDenseVector& VectorInput::multi_dense() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorInput.multi_dense)
  return _internal_multi_dense();
}
inline ::qdrant::MultiDenseVector* PROTOBUF_NULLABLE VectorInput::unsafe_arena_release_multi_dense() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorInput.multi_dense)
  if (variant_case() == kMultiDense) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::MultiDenseVector*>(_impl_.variant_.multi_dense_);
    _impl_.variant_.multi_dense_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorInput::unsafe_arena_set_allocated_multi_dense(
    ::qdrant::MultiDenseVector* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_multi_dense();
    _impl_.variant_.multi_dense_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorInput.multi_dense)
}
inline ::qdrant::MultiDenseVector* PROTOBUF_NONNULL VectorInput::_internal_mutable_multi_dense() {
  if (variant_case() != kMultiDense) {
    clear_variant();
    set_has_multi_dense();
    _impl_.variant_.multi_dense_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::MultiDenseVector>(GetArena()));
  }
  return reinterpret_cast<::qdrant::MultiDenseVector*>(_impl_.variant_.multi_dense_);
}
inline ::qdrant::MultiDenseVector* PROTOBUF_NONNULL VectorInput::mutable_multi_dense()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::MultiDenseVector* _msg = _internal_mutable_multi_dense();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorInput.multi_dense)
  return _msg;
}

// .qdrant.Document document = 5;
inline bool VectorInput::has_document() const {
  return variant_case() == kDocument;
}
inline bool VectorInput::_internal_has_document() const {
  return variant_case() == kDocument;
}
inline void VectorInput::set_has_document() {
  _impl_._oneof_case_[0] = kDocument;
}
inline void VectorInput::clear_document() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kDocument) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.document_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.document_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::Document* PROTOBUF_NULLABLE VectorInput::release_document() {
  // @@protoc_insertion_point(field_release:qdrant.VectorInput.document)
  if (variant_case() == kDocument) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Document*>(_impl_.variant_.document_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.document_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Document& VectorInput::_internal_document() const {
  return variant_case() == kDocument ? static_cast<const ::qdrant::Document&>(*reinterpret_cast<::qdrant::Document*>(_impl_.variant_.document_))
                     : reinterpret_cast<const ::qdrant::Document&>(::qdrant::_Document_default_instance_);
}
inline const ::qdrant::Document& VectorInput::document() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorInput.document)
  return _internal_document();
}
inline ::qdrant::Document* PROTOBUF_NULLABLE VectorInput::unsafe_arena_release_document() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorInput.document)
  if (variant_case() == kDocument) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Document*>(_impl_.variant_.document_);
    _impl_.variant_.document_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorInput::unsafe_arena_set_allocated_document(
    ::qdrant::Document* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_document();
    _impl_.variant_.document_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorInput.document)
}
inline ::qdrant::Document* PROTOBUF_NONNULL VectorInput::_internal_mutable_document() {
  if (variant_case() != kDocument) {
    clear_variant();
    set_has_document();
    _impl_.variant_.document_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Document>(GetArena()));
  }
  return reinterpret_cast<::qdrant::Document*>(_impl_.variant_.document_);
}
inline ::qdrant::Document* PROTOBUF_NONNULL VectorInput::mutable_document()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Document* _msg = _internal_mutable_document();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorInput.document)
  return _msg;
}

// .qdrant.Image image = 6;
inline bool VectorInput::has_image() const {
  return variant_case() == kImage;
}
inline bool VectorInput::_internal_has_image() const {
  return variant_case() == kImage;
}
inline void VectorInput::set_has_image() {
  _impl_._oneof_case_[0] = kImage;
}
inline void VectorInput::clear_image() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kImage) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.image_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.image_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::Image* PROTOBUF_NULLABLE VectorInput::release_image() {
  // @@protoc_insertion_point(field_release:qdrant.VectorInput.image)
  if (variant_case() == kImage) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Image*>(_impl_.variant_.image_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Image& VectorInput::_internal_image() const {
  return variant_case() == kImage ? static_cast<const ::qdrant::Image&>(*reinterpret_cast<::qdrant::Image*>(_impl_.variant_.image_))
                     : reinterpret_cast<const ::qdrant::Image&>(::qdrant::_Image_default_instance_);
}
inline const ::qdrant::Image& VectorInput::image() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorInput.image)
  return _internal_image();
}
inline ::qdrant::Image* PROTOBUF_NULLABLE VectorInput::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorInput.image)
  if (variant_case() == kImage) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Image*>(_impl_.variant_.image_);
    _impl_.variant_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorInput::unsafe_arena_set_allocated_image(
    ::qdrant::Image* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_image();
    _impl_.variant_.image_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorInput.image)
}
inline ::qdrant::Image* PROTOBUF_NONNULL VectorInput::_internal_mutable_image() {
  if (variant_case() != kImage) {
    clear_variant();
    set_has_image();
    _impl_.variant_.image_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Image>(GetArena()));
  }
  return reinterpret_cast<::qdrant::Image*>(_impl_.variant_.image_);
}
inline ::qdrant::Image* PROTOBUF_NONNULL VectorInput::mutable_image()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorInput.image)
  return _msg;
}

// .qdrant.InferenceObject object = 7;
inline bool VectorInput::has_object() const {
  return variant_case() == kObject;
}
inline bool VectorInput::_internal_has_object() const {
  return variant_case() == kObject;
}
inline void VectorInput::set_has_object() {
  _impl_._oneof_case_[0] = kObject;
}
inline void VectorInput::clear_object() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kObject) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.object_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.object_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::InferenceObject* PROTOBUF_NULLABLE VectorInput::release_object() {
  // @@protoc_insertion_point(field_release:qdrant.VectorInput.object)
  if (variant_case() == kObject) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::InferenceObject*>(_impl_.variant_.object_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::InferenceObject& VectorInput::_internal_object() const {
  return variant_case() == kObject ? static_cast<const ::qdrant::InferenceObject&>(*reinterpret_cast<::qdrant::InferenceObject*>(_impl_.variant_.object_))
                     : reinterpret_cast<const ::qdrant::InferenceObject&>(::qdrant::_InferenceObject_default_instance_);
}
inline const ::qdrant::InferenceObject& VectorInput::object() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorInput.object)
  return _internal_object();
}
inline ::qdrant::InferenceObject* PROTOBUF_NULLABLE VectorInput::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorInput.object)
  if (variant_case() == kObject) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::InferenceObject*>(_impl_.variant_.object_);
    _impl_.variant_.object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorInput::unsafe_arena_set_allocated_object(
    ::qdrant::InferenceObject* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_object();
    _impl_.variant_.object_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorInput.object)
}
inline ::qdrant::InferenceObject* PROTOBUF_NONNULL VectorInput::_internal_mutable_object() {
  if (variant_case() != kObject) {
    clear_variant();
    set_has_object();
    _impl_.variant_.object_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::InferenceObject>(GetArena()));
  }
  return reinterpret_cast<::qdrant::InferenceObject*>(_impl_.variant_.object_);
}
inline ::qdrant::InferenceObject* PROTOBUF_NONNULL VectorInput::mutable_object()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::InferenceObject* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorInput.object)
  return _msg;
}

inline bool VectorInput::has_variant() const {
  return variant_case() != VARIANT_NOT_SET;
}
inline void VectorInput::clear_has_variant() {
  _impl_._oneof_case_[0] = VARIANT_NOT_SET;
}
inline VectorInput::VariantCase VectorInput::variant_case() const {
  return VectorInput::VariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ShardKeySelector

// repeated .qdrant.ShardKey shard_keys = 1;
inline int ShardKeySelector::_internal_shard_keys_size() const {
  return _internal_shard_keys().size();
}
inline int ShardKeySelector::shard_keys_size() const {
  return _internal_shard_keys_size();
}
inline ::qdrant::ShardKey* PROTOBUF_NONNULL ShardKeySelector::mutable_shard_keys(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.ShardKeySelector.shard_keys)
  return _internal_mutable_shard_keys()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ShardKey>* PROTOBUF_NONNULL ShardKeySelector::mutable_shard_keys()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.ShardKeySelector.shard_keys)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_shard_keys();
}
inline const ::qdrant::ShardKey& ShardKeySelector::shard_keys(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ShardKeySelector.shard_keys)
  return _internal_shard_keys().Get(index);
}
inline ::qdrant::ShardKey* PROTOBUF_NONNULL ShardKeySelector::add_shard_keys()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::ShardKey* _add =
      _internal_mutable_shard_keys()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.ShardKeySelector.shard_keys)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ShardKey>& ShardKeySelector::shard_keys() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.ShardKeySelector.shard_keys)
  return _internal_shard_keys();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ShardKey>&
ShardKeySelector::_internal_shard_keys() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shard_keys_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ShardKey>* PROTOBUF_NONNULL
ShardKeySelector::_internal_mutable_shard_keys() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.shard_keys_;
}

// -------------------------------------------------------------------

// UpsertPoints

// string collection_name = 1;
inline void UpsertPoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& UpsertPoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpsertPoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpsertPoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.UpsertPoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL UpsertPoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.UpsertPoints.collection_name)
  return _s;
}
inline const ::std::string& UpsertPoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void UpsertPoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UpsertPoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UpsertPoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpsertPoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void UpsertPoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpsertPoints.collection_name)
}

// optional bool wait = 2;
inline bool UpsertPoints::has_wait() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void UpsertPoints::clear_wait() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool UpsertPoints::wait() const {
  // @@protoc_insertion_point(field_get:qdrant.UpsertPoints.wait)
  return _internal_wait();
}
inline void UpsertPoints::set_wait(bool value) {
  _internal_set_wait(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.UpsertPoints.wait)
}
inline bool UpsertPoints::_internal_wait() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wait_;
}
inline void UpsertPoints::_internal_set_wait(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = value;
}

// repeated .qdrant.PointStruct points = 3;
inline int UpsertPoints::_internal_points_size() const {
  return _internal_points().size();
}
inline int UpsertPoints::points_size() const {
  return _internal_points_size();
}
inline void UpsertPoints::clear_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.points_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::PointStruct* PROTOBUF_NONNULL UpsertPoints::mutable_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.UpsertPoints.points)
  return _internal_mutable_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointStruct>* PROTOBUF_NONNULL UpsertPoints::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.UpsertPoints.points)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_points();
}
inline const ::qdrant::PointStruct& UpsertPoints::points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpsertPoints.points)
  return _internal_points().Get(index);
}
inline ::qdrant::PointStruct* PROTOBUF_NONNULL UpsertPoints::add_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::PointStruct* _add =
      _internal_mutable_points()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.UpsertPoints.points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointStruct>& UpsertPoints::points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.UpsertPoints.points)
  return _internal_points();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointStruct>&
UpsertPoints::_internal_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.points_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointStruct>* PROTOBUF_NONNULL
UpsertPoints::_internal_mutable_points() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.points_;
}

// optional .qdrant.WriteOrdering ordering = 4;
inline bool UpsertPoints::has_ordering() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.ordering_ != nullptr);
  return value;
}
inline void UpsertPoints::clear_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ != nullptr) _impl_.ordering_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::WriteOrdering& UpsertPoints::_internal_ordering() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WriteOrdering* p = _impl_.ordering_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WriteOrdering&>(::qdrant::_WriteOrdering_default_instance_);
}
inline const ::qdrant::WriteOrdering& UpsertPoints::ordering() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpsertPoints.ordering)
  return _internal_ordering();
}
inline void UpsertPoints::unsafe_arena_set_allocated_ordering(
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }
  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpsertPoints.ordering)
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE UpsertPoints::release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* released = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE UpsertPoints::unsafe_arena_release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpsertPoints.ordering)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* temp = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  return temp;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL UpsertPoints::_internal_mutable_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WriteOrdering>(GetArena());
    _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(p);
  }
  return _impl_.ordering_;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL UpsertPoints::mutable_ordering()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* _msg = _internal_mutable_ordering();
  // @@protoc_insertion_point(field_mutable:qdrant.UpsertPoints.ordering)
  return _msg;
}
inline void UpsertPoints::set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpsertPoints.ordering)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 5;
inline bool UpsertPoints::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void UpsertPoints::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::ShardKeySelector& UpsertPoints::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& UpsertPoints::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpsertPoints.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void UpsertPoints::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpsertPoints.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE UpsertPoints::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE UpsertPoints::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpsertPoints.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL UpsertPoints::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL UpsertPoints::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.UpsertPoints.shard_key_selector)
  return _msg;
}
inline void UpsertPoints::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpsertPoints.shard_key_selector)
}

// optional .qdrant.Filter update_filter = 6;
inline bool UpsertPoints::has_update_filter() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.update_filter_ != nullptr);
  return value;
}
inline void UpsertPoints::clear_update_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.update_filter_ != nullptr) _impl_.update_filter_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::Filter& UpsertPoints::_internal_update_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Filter* p = _impl_.update_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& UpsertPoints::update_filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpsertPoints.update_filter)
  return _internal_update_filter();
}
inline void UpsertPoints::unsafe_arena_set_allocated_update_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_filter_);
  }
  _impl_.update_filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpsertPoints.update_filter)
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE UpsertPoints::release_update_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Filter* released = _impl_.update_filter_;
  _impl_.update_filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE UpsertPoints::unsafe_arena_release_update_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpsertPoints.update_filter)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Filter* temp = _impl_.update_filter_;
  _impl_.update_filter_ = nullptr;
  return temp;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL UpsertPoints::_internal_mutable_update_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.update_filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
    _impl_.update_filter_ = reinterpret_cast<::qdrant::Filter*>(p);
  }
  return _impl_.update_filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL UpsertPoints::mutable_update_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Filter* _msg = _internal_mutable_update_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.UpsertPoints.update_filter)
  return _msg;
}
inline void UpsertPoints::set_allocated_update_filter(::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.update_filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpsertPoints.update_filter)
}

// -------------------------------------------------------------------

// DeletePoints

// string collection_name = 1;
inline void DeletePoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& DeletePoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeletePoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DeletePoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.DeletePoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL DeletePoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.DeletePoints.collection_name)
  return _s;
}
inline const ::std::string& DeletePoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void DeletePoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DeletePoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DeletePoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeletePoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void DeletePoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeletePoints.collection_name)
}

// optional bool wait = 2;
inline bool DeletePoints::has_wait() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void DeletePoints::clear_wait() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool DeletePoints::wait() const {
  // @@protoc_insertion_point(field_get:qdrant.DeletePoints.wait)
  return _internal_wait();
}
inline void DeletePoints::set_wait(bool value) {
  _internal_set_wait(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.DeletePoints.wait)
}
inline bool DeletePoints::_internal_wait() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wait_;
}
inline void DeletePoints::_internal_set_wait(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = value;
}

// .qdrant.PointsSelector points = 3;
inline bool DeletePoints::has_points() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.points_ != nullptr);
  return value;
}
inline void DeletePoints::clear_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_ != nullptr) _impl_.points_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::PointsSelector& DeletePoints::_internal_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointsSelector* p = _impl_.points_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointsSelector&>(::qdrant::_PointsSelector_default_instance_);
}
inline const ::qdrant::PointsSelector& DeletePoints::points() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeletePoints.points)
  return _internal_points();
}
inline void DeletePoints::unsafe_arena_set_allocated_points(
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_);
  }
  _impl_.points_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DeletePoints.points)
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE DeletePoints::release_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* released = _impl_.points_;
  _impl_.points_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE DeletePoints::unsafe_arena_release_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeletePoints.points)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* temp = _impl_.points_;
  _impl_.points_ = nullptr;
  return temp;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL DeletePoints::_internal_mutable_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsSelector>(GetArena());
    _impl_.points_ = reinterpret_cast<::qdrant::PointsSelector*>(p);
  }
  return _impl_.points_;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL DeletePoints::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* _msg = _internal_mutable_points();
  // @@protoc_insertion_point(field_mutable:qdrant.DeletePoints.points)
  return _msg;
}
inline void DeletePoints::set_allocated_points(::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.points_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeletePoints.points)
}

// optional .qdrant.WriteOrdering ordering = 4;
inline bool DeletePoints::has_ordering() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.ordering_ != nullptr);
  return value;
}
inline void DeletePoints::clear_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ != nullptr) _impl_.ordering_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::WriteOrdering& DeletePoints::_internal_ordering() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WriteOrdering* p = _impl_.ordering_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WriteOrdering&>(::qdrant::_WriteOrdering_default_instance_);
}
inline const ::qdrant::WriteOrdering& DeletePoints::ordering() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeletePoints.ordering)
  return _internal_ordering();
}
inline void DeletePoints::unsafe_arena_set_allocated_ordering(
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }
  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DeletePoints.ordering)
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE DeletePoints::release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* released = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE DeletePoints::unsafe_arena_release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeletePoints.ordering)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* temp = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  return temp;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL DeletePoints::_internal_mutable_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WriteOrdering>(GetArena());
    _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(p);
  }
  return _impl_.ordering_;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL DeletePoints::mutable_ordering()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* _msg = _internal_mutable_ordering();
  // @@protoc_insertion_point(field_mutable:qdrant.DeletePoints.ordering)
  return _msg;
}
inline void DeletePoints::set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeletePoints.ordering)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 5;
inline bool DeletePoints::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void DeletePoints::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::ShardKeySelector& DeletePoints::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& DeletePoints::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeletePoints.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void DeletePoints::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DeletePoints.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE DeletePoints::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE DeletePoints::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeletePoints.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL DeletePoints::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL DeletePoints::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.DeletePoints.shard_key_selector)
  return _msg;
}
inline void DeletePoints::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeletePoints.shard_key_selector)
}

// -------------------------------------------------------------------

// GetPoints

// string collection_name = 1;
inline void GetPoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& GetPoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GetPoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetPoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.GetPoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL GetPoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.GetPoints.collection_name)
  return _s;
}
inline const ::std::string& GetPoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void GetPoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetPoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetPoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.GetPoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void GetPoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.GetPoints.collection_name)
}

// repeated .qdrant.PointId ids = 2;
inline int GetPoints::_internal_ids_size() const {
  return _internal_ids().size();
}
inline int GetPoints::ids_size() const {
  return _internal_ids_size();
}
inline void GetPoints::clear_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ids_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::PointId* PROTOBUF_NONNULL GetPoints::mutable_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.GetPoints.ids)
  return _internal_mutable_ids()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL GetPoints::mutable_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.GetPoints.ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ids();
}
inline const ::qdrant::PointId& GetPoints::ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GetPoints.ids)
  return _internal_ids().Get(index);
}
inline ::qdrant::PointId* PROTOBUF_NONNULL GetPoints::add_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::PointId* _add =
      _internal_mutable_ids()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.GetPoints.ids)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& GetPoints::ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.GetPoints.ids)
  return _internal_ids();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>&
GetPoints::_internal_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ids_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL
GetPoints::_internal_mutable_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ids_;
}

// .qdrant.WithPayloadSelector with_payload = 4;
inline bool GetPoints::has_with_payload() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.with_payload_ != nullptr);
  return value;
}
inline void GetPoints::clear_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ != nullptr) _impl_.with_payload_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::WithPayloadSelector& GetPoints::_internal_with_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithPayloadSelector* p = _impl_.with_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithPayloadSelector&>(::qdrant::_WithPayloadSelector_default_instance_);
}
inline const ::qdrant::WithPayloadSelector& GetPoints::with_payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GetPoints.with_payload)
  return _internal_with_payload();
}
inline void GetPoints::unsafe_arena_set_allocated_with_payload(
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }
  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.GetPoints.with_payload)
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE GetPoints::release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WithPayloadSelector* released = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE GetPoints::unsafe_arena_release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.GetPoints.with_payload)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WithPayloadSelector* temp = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  return temp;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL GetPoints::_internal_mutable_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithPayloadSelector>(GetArena());
    _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(p);
  }
  return _impl_.with_payload_;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL GetPoints::mutable_with_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WithPayloadSelector* _msg = _internal_mutable_with_payload();
  // @@protoc_insertion_point(field_mutable:qdrant.GetPoints.with_payload)
  return _msg;
}
inline void GetPoints::set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.GetPoints.with_payload)
}

// optional .qdrant.WithVectorsSelector with_vectors = 5;
inline bool GetPoints::has_with_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.with_vectors_ != nullptr);
  return value;
}
inline void GetPoints::clear_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ != nullptr) _impl_.with_vectors_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::WithVectorsSelector& GetPoints::_internal_with_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithVectorsSelector* p = _impl_.with_vectors_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithVectorsSelector&>(::qdrant::_WithVectorsSelector_default_instance_);
}
inline const ::qdrant::WithVectorsSelector& GetPoints::with_vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GetPoints.with_vectors)
  return _internal_with_vectors();
}
inline void GetPoints::unsafe_arena_set_allocated_with_vectors(
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }
  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.GetPoints.with_vectors)
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE GetPoints::release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WithVectorsSelector* released = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE GetPoints::unsafe_arena_release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.GetPoints.with_vectors)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WithVectorsSelector* temp = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  return temp;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL GetPoints::_internal_mutable_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithVectorsSelector>(GetArena());
    _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(p);
  }
  return _impl_.with_vectors_;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL GetPoints::mutable_with_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WithVectorsSelector* _msg = _internal_mutable_with_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.GetPoints.with_vectors)
  return _msg;
}
inline void GetPoints::set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.GetPoints.with_vectors)
}

// optional .qdrant.ReadConsistency read_consistency = 6;
inline bool GetPoints::has_read_consistency() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.read_consistency_ != nullptr);
  return value;
}
inline void GetPoints::clear_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ != nullptr) _impl_.read_consistency_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::ReadConsistency& GetPoints::_internal_read_consistency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ReadConsistency* p = _impl_.read_consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ReadConsistency&>(::qdrant::_ReadConsistency_default_instance_);
}
inline const ::qdrant::ReadConsistency& GetPoints::read_consistency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GetPoints.read_consistency)
  return _internal_read_consistency();
}
inline void GetPoints::unsafe_arena_set_allocated_read_consistency(
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }
  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.GetPoints.read_consistency)
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE GetPoints::release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ReadConsistency* released = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE GetPoints::unsafe_arena_release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.GetPoints.read_consistency)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ReadConsistency* temp = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  return temp;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL GetPoints::_internal_mutable_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ReadConsistency>(GetArena());
    _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(p);
  }
  return _impl_.read_consistency_;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL GetPoints::mutable_read_consistency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ReadConsistency* _msg = _internal_mutable_read_consistency();
  // @@protoc_insertion_point(field_mutable:qdrant.GetPoints.read_consistency)
  return _msg;
}
inline void GetPoints::set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.GetPoints.read_consistency)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 7;
inline bool GetPoints::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void GetPoints::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::qdrant::ShardKeySelector& GetPoints::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& GetPoints::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GetPoints.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void GetPoints::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.GetPoints.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE GetPoints::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE GetPoints::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.GetPoints.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL GetPoints::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL GetPoints::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.GetPoints.shard_key_selector)
  return _msg;
}
inline void GetPoints::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.GetPoints.shard_key_selector)
}

// optional uint64 timeout = 8;
inline bool GetPoints::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  return value;
}
inline void GetPoints::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline ::uint64_t GetPoints::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.GetPoints.timeout)
  return _internal_timeout();
}
inline void GetPoints::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:qdrant.GetPoints.timeout)
}
inline ::uint64_t GetPoints::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void GetPoints::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// -------------------------------------------------------------------

// UpdatePointVectors

// string collection_name = 1;
inline void UpdatePointVectors::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& UpdatePointVectors::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdatePointVectors.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdatePointVectors::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.UpdatePointVectors.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL UpdatePointVectors::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdatePointVectors.collection_name)
  return _s;
}
inline const ::std::string& UpdatePointVectors::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void UpdatePointVectors::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UpdatePointVectors::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UpdatePointVectors::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpdatePointVectors.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void UpdatePointVectors::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpdatePointVectors.collection_name)
}

// optional bool wait = 2;
inline bool UpdatePointVectors::has_wait() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void UpdatePointVectors::clear_wait() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool UpdatePointVectors::wait() const {
  // @@protoc_insertion_point(field_get:qdrant.UpdatePointVectors.wait)
  return _internal_wait();
}
inline void UpdatePointVectors::set_wait(bool value) {
  _internal_set_wait(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.UpdatePointVectors.wait)
}
inline bool UpdatePointVectors::_internal_wait() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wait_;
}
inline void UpdatePointVectors::_internal_set_wait(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = value;
}

// repeated .qdrant.PointVectors points = 3;
inline int UpdatePointVectors::_internal_points_size() const {
  return _internal_points().size();
}
inline int UpdatePointVectors::points_size() const {
  return _internal_points_size();
}
inline void UpdatePointVectors::clear_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.points_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::PointVectors* PROTOBUF_NONNULL UpdatePointVectors::mutable_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.UpdatePointVectors.points)
  return _internal_mutable_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointVectors>* PROTOBUF_NONNULL UpdatePointVectors::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.UpdatePointVectors.points)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_points();
}
inline const ::qdrant::PointVectors& UpdatePointVectors::points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdatePointVectors.points)
  return _internal_points().Get(index);
}
inline ::qdrant::PointVectors* PROTOBUF_NONNULL UpdatePointVectors::add_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::PointVectors* _add =
      _internal_mutable_points()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.UpdatePointVectors.points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointVectors>& UpdatePointVectors::points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.UpdatePointVectors.points)
  return _internal_points();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointVectors>&
UpdatePointVectors::_internal_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.points_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointVectors>* PROTOBUF_NONNULL
UpdatePointVectors::_internal_mutable_points() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.points_;
}

// optional .qdrant.WriteOrdering ordering = 4;
inline bool UpdatePointVectors::has_ordering() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.ordering_ != nullptr);
  return value;
}
inline void UpdatePointVectors::clear_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ != nullptr) _impl_.ordering_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::WriteOrdering& UpdatePointVectors::_internal_ordering() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WriteOrdering* p = _impl_.ordering_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WriteOrdering&>(::qdrant::_WriteOrdering_default_instance_);
}
inline const ::qdrant::WriteOrdering& UpdatePointVectors::ordering() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdatePointVectors.ordering)
  return _internal_ordering();
}
inline void UpdatePointVectors::unsafe_arena_set_allocated_ordering(
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }
  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdatePointVectors.ordering)
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE UpdatePointVectors::release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* released = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE UpdatePointVectors::unsafe_arena_release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpdatePointVectors.ordering)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* temp = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  return temp;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL UpdatePointVectors::_internal_mutable_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WriteOrdering>(GetArena());
    _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(p);
  }
  return _impl_.ordering_;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL UpdatePointVectors::mutable_ordering()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* _msg = _internal_mutable_ordering();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdatePointVectors.ordering)
  return _msg;
}
inline void UpdatePointVectors::set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpdatePointVectors.ordering)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 5;
inline bool UpdatePointVectors::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void UpdatePointVectors::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::ShardKeySelector& UpdatePointVectors::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& UpdatePointVectors::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdatePointVectors.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void UpdatePointVectors::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdatePointVectors.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE UpdatePointVectors::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE UpdatePointVectors::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpdatePointVectors.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL UpdatePointVectors::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL UpdatePointVectors::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdatePointVectors.shard_key_selector)
  return _msg;
}
inline void UpdatePointVectors::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpdatePointVectors.shard_key_selector)
}

// optional .qdrant.Filter update_filter = 6;
inline bool UpdatePointVectors::has_update_filter() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.update_filter_ != nullptr);
  return value;
}
inline void UpdatePointVectors::clear_update_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.update_filter_ != nullptr) _impl_.update_filter_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::Filter& UpdatePointVectors::_internal_update_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Filter* p = _impl_.update_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& UpdatePointVectors::update_filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdatePointVectors.update_filter)
  return _internal_update_filter();
}
inline void UpdatePointVectors::unsafe_arena_set_allocated_update_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_filter_);
  }
  _impl_.update_filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdatePointVectors.update_filter)
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE UpdatePointVectors::release_update_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Filter* released = _impl_.update_filter_;
  _impl_.update_filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE UpdatePointVectors::unsafe_arena_release_update_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpdatePointVectors.update_filter)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Filter* temp = _impl_.update_filter_;
  _impl_.update_filter_ = nullptr;
  return temp;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL UpdatePointVectors::_internal_mutable_update_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.update_filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
    _impl_.update_filter_ = reinterpret_cast<::qdrant::Filter*>(p);
  }
  return _impl_.update_filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL UpdatePointVectors::mutable_update_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Filter* _msg = _internal_mutable_update_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdatePointVectors.update_filter)
  return _msg;
}
inline void UpdatePointVectors::set_allocated_update_filter(::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.update_filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpdatePointVectors.update_filter)
}

// -------------------------------------------------------------------

// PointVectors

// .qdrant.PointId id = 1;
inline bool PointVectors::has_id() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline void PointVectors::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::PointId& PointVectors::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointId&>(::qdrant::_PointId_default_instance_);
}
inline const ::qdrant::PointId& PointVectors::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointVectors.id)
  return _internal_id();
}
inline void PointVectors::unsafe_arena_set_allocated_id(
    ::qdrant::PointId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::qdrant::PointId*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointVectors.id)
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE PointVectors::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointId* released = _impl_.id_;
  _impl_.id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE PointVectors::unsafe_arena_release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointVectors.id)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::qdrant::PointId* PROTOBUF_NONNULL PointVectors::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointId>(GetArena());
    _impl_.id_ = reinterpret_cast<::qdrant::PointId*>(p);
  }
  return _impl_.id_;
}
inline ::qdrant::PointId* PROTOBUF_NONNULL PointVectors::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:qdrant.PointVectors.id)
  return _msg;
}
inline void PointVectors::set_allocated_id(::qdrant::PointId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.id_ = reinterpret_cast<::qdrant::PointId*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointVectors.id)
}

// .qdrant.Vectors vectors = 2;
inline bool PointVectors::has_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.vectors_ != nullptr);
  return value;
}
inline void PointVectors::clear_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_ != nullptr) _impl_.vectors_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Vectors& PointVectors::_internal_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Vectors* p = _impl_.vectors_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Vectors&>(::qdrant::_Vectors_default_instance_);
}
inline const ::qdrant::Vectors& PointVectors::vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointVectors.vectors)
  return _internal_vectors();
}
inline void PointVectors::unsafe_arena_set_allocated_vectors(
    ::qdrant::Vectors* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_);
  }
  _impl_.vectors_ = reinterpret_cast<::qdrant::Vectors*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointVectors.vectors)
}
inline ::qdrant::Vectors* PROTOBUF_NULLABLE PointVectors::release_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Vectors* released = _impl_.vectors_;
  _impl_.vectors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Vectors* PROTOBUF_NULLABLE PointVectors::unsafe_arena_release_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointVectors.vectors)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Vectors* temp = _impl_.vectors_;
  _impl_.vectors_ = nullptr;
  return temp;
}
inline ::qdrant::Vectors* PROTOBUF_NONNULL PointVectors::_internal_mutable_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Vectors>(GetArena());
    _impl_.vectors_ = reinterpret_cast<::qdrant::Vectors*>(p);
  }
  return _impl_.vectors_;
}
inline ::qdrant::Vectors* PROTOBUF_NONNULL PointVectors::mutable_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Vectors* _msg = _internal_mutable_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.PointVectors.vectors)
  return _msg;
}
inline void PointVectors::set_allocated_vectors(::qdrant::Vectors* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.vectors_ = reinterpret_cast<::qdrant::Vectors*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointVectors.vectors)
}

// -------------------------------------------------------------------

// DeletePointVectors

// string collection_name = 1;
inline void DeletePointVectors::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& DeletePointVectors::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeletePointVectors.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DeletePointVectors::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.DeletePointVectors.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL DeletePointVectors::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.DeletePointVectors.collection_name)
  return _s;
}
inline const ::std::string& DeletePointVectors::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void DeletePointVectors::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DeletePointVectors::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DeletePointVectors::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeletePointVectors.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void DeletePointVectors::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeletePointVectors.collection_name)
}

// optional bool wait = 2;
inline bool DeletePointVectors::has_wait() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void DeletePointVectors::clear_wait() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool DeletePointVectors::wait() const {
  // @@protoc_insertion_point(field_get:qdrant.DeletePointVectors.wait)
  return _internal_wait();
}
inline void DeletePointVectors::set_wait(bool value) {
  _internal_set_wait(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.DeletePointVectors.wait)
}
inline bool DeletePointVectors::_internal_wait() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wait_;
}
inline void DeletePointVectors::_internal_set_wait(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = value;
}

// .qdrant.PointsSelector points_selector = 3;
inline bool DeletePointVectors::has_points_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.points_selector_ != nullptr);
  return value;
}
inline void DeletePointVectors::clear_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_selector_ != nullptr) _impl_.points_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::PointsSelector& DeletePointVectors::_internal_points_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointsSelector* p = _impl_.points_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointsSelector&>(::qdrant::_PointsSelector_default_instance_);
}
inline const ::qdrant::PointsSelector& DeletePointVectors::points_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeletePointVectors.points_selector)
  return _internal_points_selector();
}
inline void DeletePointVectors::unsafe_arena_set_allocated_points_selector(
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_selector_);
  }
  _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DeletePointVectors.points_selector)
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE DeletePointVectors::release_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* released = _impl_.points_selector_;
  _impl_.points_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE DeletePointVectors::unsafe_arena_release_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeletePointVectors.points_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* temp = _impl_.points_selector_;
  _impl_.points_selector_ = nullptr;
  return temp;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL DeletePointVectors::_internal_mutable_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsSelector>(GetArena());
    _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(p);
  }
  return _impl_.points_selector_;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL DeletePointVectors::mutable_points_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* _msg = _internal_mutable_points_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.DeletePointVectors.points_selector)
  return _msg;
}
inline void DeletePointVectors::set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeletePointVectors.points_selector)
}

// .qdrant.VectorsSelector vectors = 4;
inline bool DeletePointVectors::has_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.vectors_ != nullptr);
  return value;
}
inline void DeletePointVectors::clear_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_ != nullptr) _impl_.vectors_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::VectorsSelector& DeletePointVectors::_internal_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::VectorsSelector* p = _impl_.vectors_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::VectorsSelector&>(::qdrant::_VectorsSelector_default_instance_);
}
inline const ::qdrant::VectorsSelector& DeletePointVectors::vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeletePointVectors.vectors)
  return _internal_vectors();
}
inline void DeletePointVectors::unsafe_arena_set_allocated_vectors(
    ::qdrant::VectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_);
  }
  _impl_.vectors_ = reinterpret_cast<::qdrant::VectorsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DeletePointVectors.vectors)
}
inline ::qdrant::VectorsSelector* PROTOBUF_NULLABLE DeletePointVectors::release_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::VectorsSelector* released = _impl_.vectors_;
  _impl_.vectors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::VectorsSelector* PROTOBUF_NULLABLE DeletePointVectors::unsafe_arena_release_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeletePointVectors.vectors)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::VectorsSelector* temp = _impl_.vectors_;
  _impl_.vectors_ = nullptr;
  return temp;
}
inline ::qdrant::VectorsSelector* PROTOBUF_NONNULL DeletePointVectors::_internal_mutable_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorsSelector>(GetArena());
    _impl_.vectors_ = reinterpret_cast<::qdrant::VectorsSelector*>(p);
  }
  return _impl_.vectors_;
}
inline ::qdrant::VectorsSelector* PROTOBUF_NONNULL DeletePointVectors::mutable_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::VectorsSelector* _msg = _internal_mutable_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.DeletePointVectors.vectors)
  return _msg;
}
inline void DeletePointVectors::set_allocated_vectors(::qdrant::VectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.vectors_ = reinterpret_cast<::qdrant::VectorsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeletePointVectors.vectors)
}

// optional .qdrant.WriteOrdering ordering = 5;
inline bool DeletePointVectors::has_ordering() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.ordering_ != nullptr);
  return value;
}
inline void DeletePointVectors::clear_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ != nullptr) _impl_.ordering_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::WriteOrdering& DeletePointVectors::_internal_ordering() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WriteOrdering* p = _impl_.ordering_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WriteOrdering&>(::qdrant::_WriteOrdering_default_instance_);
}
inline const ::qdrant::WriteOrdering& DeletePointVectors::ordering() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeletePointVectors.ordering)
  return _internal_ordering();
}
inline void DeletePointVectors::unsafe_arena_set_allocated_ordering(
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }
  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DeletePointVectors.ordering)
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE DeletePointVectors::release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WriteOrdering* released = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE DeletePointVectors::unsafe_arena_release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeletePointVectors.ordering)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WriteOrdering* temp = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  return temp;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL DeletePointVectors::_internal_mutable_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WriteOrdering>(GetArena());
    _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(p);
  }
  return _impl_.ordering_;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL DeletePointVectors::mutable_ordering()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WriteOrdering* _msg = _internal_mutable_ordering();
  // @@protoc_insertion_point(field_mutable:qdrant.DeletePointVectors.ordering)
  return _msg;
}
inline void DeletePointVectors::set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeletePointVectors.ordering)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 6;
inline bool DeletePointVectors::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void DeletePointVectors::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::ShardKeySelector& DeletePointVectors::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& DeletePointVectors::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeletePointVectors.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void DeletePointVectors::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DeletePointVectors.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE DeletePointVectors::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE DeletePointVectors::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeletePointVectors.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL DeletePointVectors::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL DeletePointVectors::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.DeletePointVectors.shard_key_selector)
  return _msg;
}
inline void DeletePointVectors::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeletePointVectors.shard_key_selector)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SetPayloadPoints

// string collection_name = 1;
inline void SetPayloadPoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& SetPayloadPoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SetPayloadPoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SetPayloadPoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.SetPayloadPoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL SetPayloadPoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.SetPayloadPoints.collection_name)
  return _s;
}
inline const ::std::string& SetPayloadPoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void SetPayloadPoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SetPayloadPoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SetPayloadPoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SetPayloadPoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void SetPayloadPoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.SetPayloadPoints.collection_name)
}

// optional bool wait = 2;
inline bool SetPayloadPoints::has_wait() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void SetPayloadPoints::clear_wait() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool SetPayloadPoints::wait() const {
  // @@protoc_insertion_point(field_get:qdrant.SetPayloadPoints.wait)
  return _internal_wait();
}
inline void SetPayloadPoints::set_wait(bool value) {
  _internal_set_wait(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.SetPayloadPoints.wait)
}
inline bool SetPayloadPoints::_internal_wait() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wait_;
}
inline void SetPayloadPoints::_internal_set_wait(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = value;
}

// map<string, .qdrant.Value> payload = 3;
inline int SetPayloadPoints::_internal_payload_size() const {
  return _internal_payload().size();
}
inline int SetPayloadPoints::payload_size() const {
  return _internal_payload_size();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& SetPayloadPoints::_internal_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& SetPayloadPoints::payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.SetPayloadPoints.payload)
  return _internal_payload();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL SetPayloadPoints::_internal_mutable_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.payload_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL SetPayloadPoints::mutable_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.SetPayloadPoints.payload)
  return _internal_mutable_payload();
}

// optional .qdrant.PointsSelector points_selector = 5;
inline bool SetPayloadPoints::has_points_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.points_selector_ != nullptr);
  return value;
}
inline void SetPayloadPoints::clear_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_selector_ != nullptr) _impl_.points_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::PointsSelector& SetPayloadPoints::_internal_points_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointsSelector* p = _impl_.points_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointsSelector&>(::qdrant::_PointsSelector_default_instance_);
}
inline const ::qdrant::PointsSelector& SetPayloadPoints::points_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SetPayloadPoints.points_selector)
  return _internal_points_selector();
}
inline void SetPayloadPoints::unsafe_arena_set_allocated_points_selector(
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_selector_);
  }
  _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SetPayloadPoints.points_selector)
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE SetPayloadPoints::release_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::PointsSelector* released = _impl_.points_selector_;
  _impl_.points_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE SetPayloadPoints::unsafe_arena_release_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SetPayloadPoints.points_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::PointsSelector* temp = _impl_.points_selector_;
  _impl_.points_selector_ = nullptr;
  return temp;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL SetPayloadPoints::_internal_mutable_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsSelector>(GetArena());
    _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(p);
  }
  return _impl_.points_selector_;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL SetPayloadPoints::mutable_points_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::PointsSelector* _msg = _internal_mutable_points_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.SetPayloadPoints.points_selector)
  return _msg;
}
inline void SetPayloadPoints::set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SetPayloadPoints.points_selector)
}

// optional .qdrant.WriteOrdering ordering = 6;
inline bool SetPayloadPoints::has_ordering() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.ordering_ != nullptr);
  return value;
}
inline void SetPayloadPoints::clear_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ != nullptr) _impl_.ordering_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::WriteOrdering& SetPayloadPoints::_internal_ordering() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WriteOrdering* p = _impl_.ordering_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WriteOrdering&>(::qdrant::_WriteOrdering_default_instance_);
}
inline const ::qdrant::WriteOrdering& SetPayloadPoints::ordering() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SetPayloadPoints.ordering)
  return _internal_ordering();
}
inline void SetPayloadPoints::unsafe_arena_set_allocated_ordering(
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }
  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SetPayloadPoints.ordering)
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE SetPayloadPoints::release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WriteOrdering* released = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE SetPayloadPoints::unsafe_arena_release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SetPayloadPoints.ordering)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WriteOrdering* temp = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  return temp;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL SetPayloadPoints::_internal_mutable_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WriteOrdering>(GetArena());
    _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(p);
  }
  return _impl_.ordering_;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL SetPayloadPoints::mutable_ordering()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WriteOrdering* _msg = _internal_mutable_ordering();
  // @@protoc_insertion_point(field_mutable:qdrant.SetPayloadPoints.ordering)
  return _msg;
}
inline void SetPayloadPoints::set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SetPayloadPoints.ordering)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 7;
inline bool SetPayloadPoints::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void SetPayloadPoints::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::ShardKeySelector& SetPayloadPoints::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& SetPayloadPoints::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SetPayloadPoints.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void SetPayloadPoints::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SetPayloadPoints.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE SetPayloadPoints::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE SetPayloadPoints::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SetPayloadPoints.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL SetPayloadPoints::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL SetPayloadPoints::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.SetPayloadPoints.shard_key_selector)
  return _msg;
}
inline void SetPayloadPoints::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SetPayloadPoints.shard_key_selector)
}

// optional string key = 8;
inline bool SetPayloadPoints::has_key() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void SetPayloadPoints::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& SetPayloadPoints::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SetPayloadPoints.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SetPayloadPoints::set_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.SetPayloadPoints.key)
}
inline ::std::string* PROTOBUF_NONNULL SetPayloadPoints::mutable_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:qdrant.SetPayloadPoints.key)
  return _s;
}
inline const ::std::string& SetPayloadPoints::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void SetPayloadPoints::_internal_set_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SetPayloadPoints::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SetPayloadPoints::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SetPayloadPoints.key)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.key_.Set("", GetArena());
  }
  return released;
}
inline void SetPayloadPoints::set_allocated_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.SetPayloadPoints.key)
}

// -------------------------------------------------------------------

// DeletePayloadPoints

// string collection_name = 1;
inline void DeletePayloadPoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& DeletePayloadPoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeletePayloadPoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DeletePayloadPoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.DeletePayloadPoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL DeletePayloadPoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.DeletePayloadPoints.collection_name)
  return _s;
}
inline const ::std::string& DeletePayloadPoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void DeletePayloadPoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DeletePayloadPoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DeletePayloadPoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeletePayloadPoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void DeletePayloadPoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeletePayloadPoints.collection_name)
}

// optional bool wait = 2;
inline bool DeletePayloadPoints::has_wait() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void DeletePayloadPoints::clear_wait() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool DeletePayloadPoints::wait() const {
  // @@protoc_insertion_point(field_get:qdrant.DeletePayloadPoints.wait)
  return _internal_wait();
}
inline void DeletePayloadPoints::set_wait(bool value) {
  _internal_set_wait(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.DeletePayloadPoints.wait)
}
inline bool DeletePayloadPoints::_internal_wait() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wait_;
}
inline void DeletePayloadPoints::_internal_set_wait(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = value;
}

// repeated string keys = 3;
inline int DeletePayloadPoints::_internal_keys_size() const {
  return _internal_keys().size();
}
inline int DeletePayloadPoints::keys_size() const {
  return _internal_keys_size();
}
inline void DeletePayloadPoints::clear_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.keys_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL DeletePayloadPoints::add_keys()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_keys()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:qdrant.DeletePayloadPoints.keys)
  return _s;
}
inline const ::std::string& DeletePayloadPoints::keys(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeletePayloadPoints.keys)
  return _internal_keys().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL DeletePayloadPoints::mutable_keys(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.DeletePayloadPoints.keys)
  return _internal_mutable_keys()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void DeletePayloadPoints::set_keys(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_keys()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:qdrant.DeletePayloadPoints.keys)
}
template <typename Arg_, typename... Args_>
inline void DeletePayloadPoints::add_keys(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_keys(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.DeletePayloadPoints.keys)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& DeletePayloadPoints::keys()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.DeletePayloadPoints.keys)
  return _internal_keys();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
DeletePayloadPoints::mutable_keys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.DeletePayloadPoints.keys)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_keys();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
DeletePayloadPoints::_internal_keys() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.keys_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
DeletePayloadPoints::_internal_mutable_keys() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.keys_;
}

// optional .qdrant.PointsSelector points_selector = 5;
inline bool DeletePayloadPoints::has_points_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.points_selector_ != nullptr);
  return value;
}
inline void DeletePayloadPoints::clear_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_selector_ != nullptr) _impl_.points_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::PointsSelector& DeletePayloadPoints::_internal_points_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointsSelector* p = _impl_.points_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointsSelector&>(::qdrant::_PointsSelector_default_instance_);
}
inline const ::qdrant::PointsSelector& DeletePayloadPoints::points_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeletePayloadPoints.points_selector)
  return _internal_points_selector();
}
inline void DeletePayloadPoints::unsafe_arena_set_allocated_points_selector(
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_selector_);
  }
  _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DeletePayloadPoints.points_selector)
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE DeletePayloadPoints::release_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::PointsSelector* released = _impl_.points_selector_;
  _impl_.points_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE DeletePayloadPoints::unsafe_arena_release_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeletePayloadPoints.points_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::PointsSelector* temp = _impl_.points_selector_;
  _impl_.points_selector_ = nullptr;
  return temp;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL DeletePayloadPoints::_internal_mutable_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsSelector>(GetArena());
    _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(p);
  }
  return _impl_.points_selector_;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL DeletePayloadPoints::mutable_points_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::PointsSelector* _msg = _internal_mutable_points_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.DeletePayloadPoints.points_selector)
  return _msg;
}
inline void DeletePayloadPoints::set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeletePayloadPoints.points_selector)
}

// optional .qdrant.WriteOrdering ordering = 6;
inline bool DeletePayloadPoints::has_ordering() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.ordering_ != nullptr);
  return value;
}
inline void DeletePayloadPoints::clear_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ != nullptr) _impl_.ordering_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::WriteOrdering& DeletePayloadPoints::_internal_ordering() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WriteOrdering* p = _impl_.ordering_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WriteOrdering&>(::qdrant::_WriteOrdering_default_instance_);
}
inline const ::qdrant::WriteOrdering& DeletePayloadPoints::ordering() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeletePayloadPoints.ordering)
  return _internal_ordering();
}
inline void DeletePayloadPoints::unsafe_arena_set_allocated_ordering(
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }
  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DeletePayloadPoints.ordering)
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE DeletePayloadPoints::release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WriteOrdering* released = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE DeletePayloadPoints::unsafe_arena_release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeletePayloadPoints.ordering)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WriteOrdering* temp = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  return temp;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL DeletePayloadPoints::_internal_mutable_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WriteOrdering>(GetArena());
    _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(p);
  }
  return _impl_.ordering_;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL DeletePayloadPoints::mutable_ordering()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WriteOrdering* _msg = _internal_mutable_ordering();
  // @@protoc_insertion_point(field_mutable:qdrant.DeletePayloadPoints.ordering)
  return _msg;
}
inline void DeletePayloadPoints::set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeletePayloadPoints.ordering)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 7;
inline bool DeletePayloadPoints::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void DeletePayloadPoints::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::ShardKeySelector& DeletePayloadPoints::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& DeletePayloadPoints::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeletePayloadPoints.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void DeletePayloadPoints::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DeletePayloadPoints.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE DeletePayloadPoints::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE DeletePayloadPoints::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeletePayloadPoints.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL DeletePayloadPoints::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL DeletePayloadPoints::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.DeletePayloadPoints.shard_key_selector)
  return _msg;
}
inline void DeletePayloadPoints::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeletePayloadPoints.shard_key_selector)
}

// -------------------------------------------------------------------

// ClearPayloadPoints

// string collection_name = 1;
inline void ClearPayloadPoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ClearPayloadPoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ClearPayloadPoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ClearPayloadPoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.ClearPayloadPoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL ClearPayloadPoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.ClearPayloadPoints.collection_name)
  return _s;
}
inline const ::std::string& ClearPayloadPoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void ClearPayloadPoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ClearPayloadPoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ClearPayloadPoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ClearPayloadPoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void ClearPayloadPoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.ClearPayloadPoints.collection_name)
}

// optional bool wait = 2;
inline bool ClearPayloadPoints::has_wait() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void ClearPayloadPoints::clear_wait() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool ClearPayloadPoints::wait() const {
  // @@protoc_insertion_point(field_get:qdrant.ClearPayloadPoints.wait)
  return _internal_wait();
}
inline void ClearPayloadPoints::set_wait(bool value) {
  _internal_set_wait(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.ClearPayloadPoints.wait)
}
inline bool ClearPayloadPoints::_internal_wait() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wait_;
}
inline void ClearPayloadPoints::_internal_set_wait(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = value;
}

// .qdrant.PointsSelector points = 3;
inline bool ClearPayloadPoints::has_points() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.points_ != nullptr);
  return value;
}
inline void ClearPayloadPoints::clear_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_ != nullptr) _impl_.points_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::PointsSelector& ClearPayloadPoints::_internal_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointsSelector* p = _impl_.points_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointsSelector&>(::qdrant::_PointsSelector_default_instance_);
}
inline const ::qdrant::PointsSelector& ClearPayloadPoints::points() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ClearPayloadPoints.points)
  return _internal_points();
}
inline void ClearPayloadPoints::unsafe_arena_set_allocated_points(
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_);
  }
  _impl_.points_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ClearPayloadPoints.points)
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE ClearPayloadPoints::release_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* released = _impl_.points_;
  _impl_.points_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE ClearPayloadPoints::unsafe_arena_release_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ClearPayloadPoints.points)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* temp = _impl_.points_;
  _impl_.points_ = nullptr;
  return temp;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL ClearPayloadPoints::_internal_mutable_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsSelector>(GetArena());
    _impl_.points_ = reinterpret_cast<::qdrant::PointsSelector*>(p);
  }
  return _impl_.points_;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL ClearPayloadPoints::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* _msg = _internal_mutable_points();
  // @@protoc_insertion_point(field_mutable:qdrant.ClearPayloadPoints.points)
  return _msg;
}
inline void ClearPayloadPoints::set_allocated_points(::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.points_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ClearPayloadPoints.points)
}

// optional .qdrant.WriteOrdering ordering = 4;
inline bool ClearPayloadPoints::has_ordering() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.ordering_ != nullptr);
  return value;
}
inline void ClearPayloadPoints::clear_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ != nullptr) _impl_.ordering_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::WriteOrdering& ClearPayloadPoints::_internal_ordering() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WriteOrdering* p = _impl_.ordering_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WriteOrdering&>(::qdrant::_WriteOrdering_default_instance_);
}
inline const ::qdrant::WriteOrdering& ClearPayloadPoints::ordering() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ClearPayloadPoints.ordering)
  return _internal_ordering();
}
inline void ClearPayloadPoints::unsafe_arena_set_allocated_ordering(
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }
  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ClearPayloadPoints.ordering)
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE ClearPayloadPoints::release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* released = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE ClearPayloadPoints::unsafe_arena_release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ClearPayloadPoints.ordering)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* temp = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  return temp;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL ClearPayloadPoints::_internal_mutable_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WriteOrdering>(GetArena());
    _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(p);
  }
  return _impl_.ordering_;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL ClearPayloadPoints::mutable_ordering()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* _msg = _internal_mutable_ordering();
  // @@protoc_insertion_point(field_mutable:qdrant.ClearPayloadPoints.ordering)
  return _msg;
}
inline void ClearPayloadPoints::set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ClearPayloadPoints.ordering)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 5;
inline bool ClearPayloadPoints::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void ClearPayloadPoints::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::ShardKeySelector& ClearPayloadPoints::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& ClearPayloadPoints::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ClearPayloadPoints.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void ClearPayloadPoints::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ClearPayloadPoints.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE ClearPayloadPoints::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE ClearPayloadPoints::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ClearPayloadPoints.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL ClearPayloadPoints::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL ClearPayloadPoints::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.ClearPayloadPoints.shard_key_selector)
  return _msg;
}
inline void ClearPayloadPoints::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ClearPayloadPoints.shard_key_selector)
}

// -------------------------------------------------------------------

// CreateFieldIndexCollection

// string collection_name = 1;
inline void CreateFieldIndexCollection::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& CreateFieldIndexCollection::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateFieldIndexCollection.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CreateFieldIndexCollection::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.CreateFieldIndexCollection.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL CreateFieldIndexCollection::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateFieldIndexCollection.collection_name)
  return _s;
}
inline const ::std::string& CreateFieldIndexCollection::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void CreateFieldIndexCollection::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CreateFieldIndexCollection::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CreateFieldIndexCollection::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateFieldIndexCollection.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void CreateFieldIndexCollection::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateFieldIndexCollection.collection_name)
}

// optional bool wait = 2;
inline bool CreateFieldIndexCollection::has_wait() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void CreateFieldIndexCollection::clear_wait() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool CreateFieldIndexCollection::wait() const {
  // @@protoc_insertion_point(field_get:qdrant.CreateFieldIndexCollection.wait)
  return _internal_wait();
}
inline void CreateFieldIndexCollection::set_wait(bool value) {
  _internal_set_wait(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.CreateFieldIndexCollection.wait)
}
inline bool CreateFieldIndexCollection::_internal_wait() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wait_;
}
inline void CreateFieldIndexCollection::_internal_set_wait(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = value;
}

// string field_name = 3;
inline void CreateFieldIndexCollection::clear_field_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& CreateFieldIndexCollection::field_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateFieldIndexCollection.field_name)
  return _internal_field_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CreateFieldIndexCollection::set_field_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.field_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.CreateFieldIndexCollection.field_name)
}
inline ::std::string* PROTOBUF_NONNULL CreateFieldIndexCollection::mutable_field_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_field_name();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateFieldIndexCollection.field_name)
  return _s;
}
inline const ::std::string& CreateFieldIndexCollection::_internal_field_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.field_name_.Get();
}
inline void CreateFieldIndexCollection::_internal_set_field_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CreateFieldIndexCollection::_internal_mutable_field_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.field_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CreateFieldIndexCollection::release_field_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateFieldIndexCollection.field_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.field_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.field_name_.Set("", GetArena());
  }
  return released;
}
inline void CreateFieldIndexCollection::set_allocated_field_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.field_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.field_name_.IsDefault()) {
    _impl_.field_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateFieldIndexCollection.field_name)
}

// optional .qdrant.FieldType field_type = 4;
inline bool CreateFieldIndexCollection::has_field_type() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void CreateFieldIndexCollection::clear_field_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_type_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::qdrant::FieldType CreateFieldIndexCollection::field_type() const {
  // @@protoc_insertion_point(field_get:qdrant.CreateFieldIndexCollection.field_type)
  return _internal_field_type();
}
inline void CreateFieldIndexCollection::set_field_type(::qdrant::FieldType value) {
  _internal_set_field_type(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.CreateFieldIndexCollection.field_type)
}
inline ::qdrant::FieldType CreateFieldIndexCollection::_internal_field_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::FieldType>(_impl_.field_type_);
}
inline void CreateFieldIndexCollection::_internal_set_field_type(::qdrant::FieldType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_type_ = value;
}

// optional .qdrant.PayloadIndexParams field_index_params = 5;
inline bool CreateFieldIndexCollection::has_field_index_params() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.field_index_params_ != nullptr);
  return value;
}
inline const ::qdrant::PayloadIndexParams& CreateFieldIndexCollection::_internal_field_index_params() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PayloadIndexParams* p = _impl_.field_index_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PayloadIndexParams&>(::qdrant::_PayloadIndexParams_default_instance_);
}
inline const ::qdrant::PayloadIndexParams& CreateFieldIndexCollection::field_index_params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateFieldIndexCollection.field_index_params)
  return _internal_field_index_params();
}
inline void CreateFieldIndexCollection::unsafe_arena_set_allocated_field_index_params(
    ::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.field_index_params_);
  }
  _impl_.field_index_params_ = reinterpret_cast<::qdrant::PayloadIndexParams*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CreateFieldIndexCollection.field_index_params)
}
inline ::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE CreateFieldIndexCollection::release_field_index_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::PayloadIndexParams* released = _impl_.field_index_params_;
  _impl_.field_index_params_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE CreateFieldIndexCollection::unsafe_arena_release_field_index_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateFieldIndexCollection.field_index_params)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::PayloadIndexParams* temp = _impl_.field_index_params_;
  _impl_.field_index_params_ = nullptr;
  return temp;
}
inline ::qdrant::PayloadIndexParams* PROTOBUF_NONNULL CreateFieldIndexCollection::_internal_mutable_field_index_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.field_index_params_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PayloadIndexParams>(GetArena());
    _impl_.field_index_params_ = reinterpret_cast<::qdrant::PayloadIndexParams*>(p);
  }
  return _impl_.field_index_params_;
}
inline ::qdrant::PayloadIndexParams* PROTOBUF_NONNULL CreateFieldIndexCollection::mutable_field_index_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::PayloadIndexParams* _msg = _internal_mutable_field_index_params();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateFieldIndexCollection.field_index_params)
  return _msg;
}
inline void CreateFieldIndexCollection::set_allocated_field_index_params(::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.field_index_params_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.field_index_params_ = reinterpret_cast<::qdrant::PayloadIndexParams*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateFieldIndexCollection.field_index_params)
}

// optional .qdrant.WriteOrdering ordering = 6;
inline bool CreateFieldIndexCollection::has_ordering() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.ordering_ != nullptr);
  return value;
}
inline void CreateFieldIndexCollection::clear_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ != nullptr) _impl_.ordering_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::WriteOrdering& CreateFieldIndexCollection::_internal_ordering() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WriteOrdering* p = _impl_.ordering_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WriteOrdering&>(::qdrant::_WriteOrdering_default_instance_);
}
inline const ::qdrant::WriteOrdering& CreateFieldIndexCollection::ordering() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateFieldIndexCollection.ordering)
  return _internal_ordering();
}
inline void CreateFieldIndexCollection::unsafe_arena_set_allocated_ordering(
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }
  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CreateFieldIndexCollection.ordering)
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE CreateFieldIndexCollection::release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WriteOrdering* released = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE CreateFieldIndexCollection::unsafe_arena_release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateFieldIndexCollection.ordering)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WriteOrdering* temp = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  return temp;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL CreateFieldIndexCollection::_internal_mutable_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WriteOrdering>(GetArena());
    _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(p);
  }
  return _impl_.ordering_;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL CreateFieldIndexCollection::mutable_ordering()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WriteOrdering* _msg = _internal_mutable_ordering();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateFieldIndexCollection.ordering)
  return _msg;
}
inline void CreateFieldIndexCollection::set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateFieldIndexCollection.ordering)
}

// -------------------------------------------------------------------

// DeleteFieldIndexCollection

// string collection_name = 1;
inline void DeleteFieldIndexCollection::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& DeleteFieldIndexCollection::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeleteFieldIndexCollection.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DeleteFieldIndexCollection::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.DeleteFieldIndexCollection.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL DeleteFieldIndexCollection::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.DeleteFieldIndexCollection.collection_name)
  return _s;
}
inline const ::std::string& DeleteFieldIndexCollection::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void DeleteFieldIndexCollection::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DeleteFieldIndexCollection::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DeleteFieldIndexCollection::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeleteFieldIndexCollection.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void DeleteFieldIndexCollection::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeleteFieldIndexCollection.collection_name)
}

// optional bool wait = 2;
inline bool DeleteFieldIndexCollection::has_wait() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void DeleteFieldIndexCollection::clear_wait() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool DeleteFieldIndexCollection::wait() const {
  // @@protoc_insertion_point(field_get:qdrant.DeleteFieldIndexCollection.wait)
  return _internal_wait();
}
inline void DeleteFieldIndexCollection::set_wait(bool value) {
  _internal_set_wait(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.DeleteFieldIndexCollection.wait)
}
inline bool DeleteFieldIndexCollection::_internal_wait() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wait_;
}
inline void DeleteFieldIndexCollection::_internal_set_wait(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = value;
}

// string field_name = 3;
inline void DeleteFieldIndexCollection::clear_field_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& DeleteFieldIndexCollection::field_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeleteFieldIndexCollection.field_name)
  return _internal_field_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DeleteFieldIndexCollection::set_field_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.field_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.DeleteFieldIndexCollection.field_name)
}
inline ::std::string* PROTOBUF_NONNULL DeleteFieldIndexCollection::mutable_field_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_field_name();
  // @@protoc_insertion_point(field_mutable:qdrant.DeleteFieldIndexCollection.field_name)
  return _s;
}
inline const ::std::string& DeleteFieldIndexCollection::_internal_field_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.field_name_.Get();
}
inline void DeleteFieldIndexCollection::_internal_set_field_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DeleteFieldIndexCollection::_internal_mutable_field_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.field_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DeleteFieldIndexCollection::release_field_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeleteFieldIndexCollection.field_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.field_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.field_name_.Set("", GetArena());
  }
  return released;
}
inline void DeleteFieldIndexCollection::set_allocated_field_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.field_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.field_name_.IsDefault()) {
    _impl_.field_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeleteFieldIndexCollection.field_name)
}

// optional .qdrant.WriteOrdering ordering = 4;
inline bool DeleteFieldIndexCollection::has_ordering() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.ordering_ != nullptr);
  return value;
}
inline void DeleteFieldIndexCollection::clear_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ != nullptr) _impl_.ordering_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::WriteOrdering& DeleteFieldIndexCollection::_internal_ordering() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WriteOrdering* p = _impl_.ordering_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WriteOrdering&>(::qdrant::_WriteOrdering_default_instance_);
}
inline const ::qdrant::WriteOrdering& DeleteFieldIndexCollection::ordering() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeleteFieldIndexCollection.ordering)
  return _internal_ordering();
}
inline void DeleteFieldIndexCollection::unsafe_arena_set_allocated_ordering(
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }
  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DeleteFieldIndexCollection.ordering)
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE DeleteFieldIndexCollection::release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* released = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE DeleteFieldIndexCollection::unsafe_arena_release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeleteFieldIndexCollection.ordering)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* temp = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  return temp;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL DeleteFieldIndexCollection::_internal_mutable_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WriteOrdering>(GetArena());
    _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(p);
  }
  return _impl_.ordering_;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL DeleteFieldIndexCollection::mutable_ordering()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* _msg = _internal_mutable_ordering();
  // @@protoc_insertion_point(field_mutable:qdrant.DeleteFieldIndexCollection.ordering)
  return _msg;
}
inline void DeleteFieldIndexCollection::set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeleteFieldIndexCollection.ordering)
}

// -------------------------------------------------------------------

// PayloadIncludeSelector

// repeated string fields = 1;
inline int PayloadIncludeSelector::_internal_fields_size() const {
  return _internal_fields().size();
}
inline int PayloadIncludeSelector::fields_size() const {
  return _internal_fields_size();
}
inline void PayloadIncludeSelector::clear_fields() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fields_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL PayloadIncludeSelector::add_fields()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_fields()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:qdrant.PayloadIncludeSelector.fields)
  return _s;
}
inline const ::std::string& PayloadIncludeSelector::fields(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PayloadIncludeSelector.fields)
  return _internal_fields().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL PayloadIncludeSelector::mutable_fields(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.PayloadIncludeSelector.fields)
  return _internal_mutable_fields()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void PayloadIncludeSelector::set_fields(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_fields()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:qdrant.PayloadIncludeSelector.fields)
}
template <typename Arg_, typename... Args_>
inline void PayloadIncludeSelector::add_fields(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_fields(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.PayloadIncludeSelector.fields)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& PayloadIncludeSelector::fields()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.PayloadIncludeSelector.fields)
  return _internal_fields();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
PayloadIncludeSelector::mutable_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.PayloadIncludeSelector.fields)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_fields();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
PayloadIncludeSelector::_internal_fields() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fields_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
PayloadIncludeSelector::_internal_mutable_fields() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.fields_;
}

// -------------------------------------------------------------------

// PayloadExcludeSelector

// repeated string fields = 1;
inline int PayloadExcludeSelector::_internal_fields_size() const {
  return _internal_fields().size();
}
inline int PayloadExcludeSelector::fields_size() const {
  return _internal_fields_size();
}
inline void PayloadExcludeSelector::clear_fields() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fields_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL PayloadExcludeSelector::add_fields()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_fields()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:qdrant.PayloadExcludeSelector.fields)
  return _s;
}
inline const ::std::string& PayloadExcludeSelector::fields(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PayloadExcludeSelector.fields)
  return _internal_fields().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL PayloadExcludeSelector::mutable_fields(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.PayloadExcludeSelector.fields)
  return _internal_mutable_fields()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void PayloadExcludeSelector::set_fields(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_fields()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:qdrant.PayloadExcludeSelector.fields)
}
template <typename Arg_, typename... Args_>
inline void PayloadExcludeSelector::add_fields(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_fields(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.PayloadExcludeSelector.fields)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& PayloadExcludeSelector::fields()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.PayloadExcludeSelector.fields)
  return _internal_fields();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
PayloadExcludeSelector::mutable_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.PayloadExcludeSelector.fields)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_fields();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
PayloadExcludeSelector::_internal_fields() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fields_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
PayloadExcludeSelector::_internal_mutable_fields() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.fields_;
}

// -------------------------------------------------------------------

// WithPayloadSelector

// bool enable = 1;
inline bool WithPayloadSelector::has_enable() const {
  return selector_options_case() == kEnable;
}
inline void WithPayloadSelector::set_has_enable() {
  _impl_._oneof_case_[0] = kEnable;
}
inline void WithPayloadSelector::clear_enable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selector_options_case() == kEnable) {
    _impl_.selector_options_.enable_ = false;
    clear_has_selector_options();
  }
}
inline bool WithPayloadSelector::enable() const {
  // @@protoc_insertion_point(field_get:qdrant.WithPayloadSelector.enable)
  return _internal_enable();
}
inline void WithPayloadSelector::set_enable(bool value) {
  if (selector_options_case() != kEnable) {
    clear_selector_options();
    set_has_enable();
  }
  _impl_.selector_options_.enable_ = value;
  // @@protoc_insertion_point(field_set:qdrant.WithPayloadSelector.enable)
}
inline bool WithPayloadSelector::_internal_enable() const {
  if (selector_options_case() == kEnable) {
    return _impl_.selector_options_.enable_;
  }
  return false;
}

// .qdrant.PayloadIncludeSelector include = 2;
inline bool WithPayloadSelector::has_include() const {
  return selector_options_case() == kInclude;
}
inline bool WithPayloadSelector::_internal_has_include() const {
  return selector_options_case() == kInclude;
}
inline void WithPayloadSelector::set_has_include() {
  _impl_._oneof_case_[0] = kInclude;
}
inline void WithPayloadSelector::clear_include() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selector_options_case() == kInclude) {
    if (GetArena() == nullptr) {
      delete _impl_.selector_options_.include_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selector_options_.include_);
    }
    clear_has_selector_options();
  }
}
inline ::qdrant::PayloadIncludeSelector* PROTOBUF_NULLABLE WithPayloadSelector::release_include() {
  // @@protoc_insertion_point(field_release:qdrant.WithPayloadSelector.include)
  if (selector_options_case() == kInclude) {
    clear_has_selector_options();
    auto* temp = _impl_.selector_options_.include_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selector_options_.include_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::PayloadIncludeSelector& WithPayloadSelector::_internal_include() const {
  return selector_options_case() == kInclude ? static_cast<const ::qdrant::PayloadIncludeSelector&>(*_impl_.selector_options_.include_)
                     : reinterpret_cast<const ::qdrant::PayloadIncludeSelector&>(::qdrant::_PayloadIncludeSelector_default_instance_);
}
inline const ::qdrant::PayloadIncludeSelector& WithPayloadSelector::include() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.WithPayloadSelector.include)
  return _internal_include();
}
inline ::qdrant::PayloadIncludeSelector* PROTOBUF_NULLABLE WithPayloadSelector::unsafe_arena_release_include() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.WithPayloadSelector.include)
  if (selector_options_case() == kInclude) {
    clear_has_selector_options();
    auto* temp = _impl_.selector_options_.include_;
    _impl_.selector_options_.include_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WithPayloadSelector::unsafe_arena_set_allocated_include(
    ::qdrant::PayloadIncludeSelector* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selector_options();
  if (value) {
    set_has_include();
    _impl_.selector_options_.include_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.WithPayloadSelector.include)
}
inline ::qdrant::PayloadIncludeSelector* PROTOBUF_NONNULL WithPayloadSelector::_internal_mutable_include() {
  if (selector_options_case() != kInclude) {
    clear_selector_options();
    set_has_include();
    _impl_.selector_options_.include_ = 
        ::google::protobuf::Message::DefaultConstruct<::qdrant::PayloadIncludeSelector>(GetArena());
  }
  return _impl_.selector_options_.include_;
}
inline ::qdrant::PayloadIncludeSelector* PROTOBUF_NONNULL WithPayloadSelector::mutable_include()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::PayloadIncludeSelector* _msg = _internal_mutable_include();
  // @@protoc_insertion_point(field_mutable:qdrant.WithPayloadSelector.include)
  return _msg;
}

// .qdrant.PayloadExcludeSelector exclude = 3;
inline bool WithPayloadSelector::has_exclude() const {
  return selector_options_case() == kExclude;
}
inline bool WithPayloadSelector::_internal_has_exclude() const {
  return selector_options_case() == kExclude;
}
inline void WithPayloadSelector::set_has_exclude() {
  _impl_._oneof_case_[0] = kExclude;
}
inline void WithPayloadSelector::clear_exclude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selector_options_case() == kExclude) {
    if (GetArena() == nullptr) {
      delete _impl_.selector_options_.exclude_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selector_options_.exclude_);
    }
    clear_has_selector_options();
  }
}
inline ::qdrant::PayloadExcludeSelector* PROTOBUF_NULLABLE WithPayloadSelector::release_exclude() {
  // @@protoc_insertion_point(field_release:qdrant.WithPayloadSelector.exclude)
  if (selector_options_case() == kExclude) {
    clear_has_selector_options();
    auto* temp = _impl_.selector_options_.exclude_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selector_options_.exclude_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::PayloadExcludeSelector& WithPayloadSelector::_internal_exclude() const {
  return selector_options_case() == kExclude ? static_cast<const ::qdrant::PayloadExcludeSelector&>(*_impl_.selector_options_.exclude_)
                     : reinterpret_cast<const ::qdrant::PayloadExcludeSelector&>(::qdrant::_PayloadExcludeSelector_default_instance_);
}
inline const ::qdrant::PayloadExcludeSelector& WithPayloadSelector::exclude() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.WithPayloadSelector.exclude)
  return _internal_exclude();
}
inline ::qdrant::PayloadExcludeSelector* PROTOBUF_NULLABLE WithPayloadSelector::unsafe_arena_release_exclude() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.WithPayloadSelector.exclude)
  if (selector_options_case() == kExclude) {
    clear_has_selector_options();
    auto* temp = _impl_.selector_options_.exclude_;
    _impl_.selector_options_.exclude_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WithPayloadSelector::unsafe_arena_set_allocated_exclude(
    ::qdrant::PayloadExcludeSelector* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selector_options();
  if (value) {
    set_has_exclude();
    _impl_.selector_options_.exclude_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.WithPayloadSelector.exclude)
}
inline ::qdrant::PayloadExcludeSelector* PROTOBUF_NONNULL WithPayloadSelector::_internal_mutable_exclude() {
  if (selector_options_case() != kExclude) {
    clear_selector_options();
    set_has_exclude();
    _impl_.selector_options_.exclude_ = 
        ::google::protobuf::Message::DefaultConstruct<::qdrant::PayloadExcludeSelector>(GetArena());
  }
  return _impl_.selector_options_.exclude_;
}
inline ::qdrant::PayloadExcludeSelector* PROTOBUF_NONNULL WithPayloadSelector::mutable_exclude()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::PayloadExcludeSelector* _msg = _internal_mutable_exclude();
  // @@protoc_insertion_point(field_mutable:qdrant.WithPayloadSelector.exclude)
  return _msg;
}

inline bool WithPayloadSelector::has_selector_options() const {
  return selector_options_case() != SELECTOR_OPTIONS_NOT_SET;
}
inline void WithPayloadSelector::clear_has_selector_options() {
  _impl_._oneof_case_[0] = SELECTOR_OPTIONS_NOT_SET;
}
inline WithPayloadSelector::SelectorOptionsCase WithPayloadSelector::selector_options_case() const {
  return WithPayloadSelector::SelectorOptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NamedVectors

// map<string, .qdrant.Vector> vectors = 1;
inline int NamedVectors::_internal_vectors_size() const {
  return _internal_vectors().size();
}
inline int NamedVectors::vectors_size() const {
  return _internal_vectors_size();
}
inline void NamedVectors::clear_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vectors_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Vector>& NamedVectors::_internal_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vectors_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Vector>& NamedVectors::vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.NamedVectors.vectors)
  return _internal_vectors();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Vector>* PROTOBUF_NONNULL NamedVectors::_internal_mutable_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.vectors_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Vector>* PROTOBUF_NONNULL NamedVectors::mutable_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.NamedVectors.vectors)
  return _internal_mutable_vectors();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NamedVectorsOutput

// map<string, .qdrant.VectorOutput> vectors = 1;
inline int NamedVectorsOutput::_internal_vectors_size() const {
  return _internal_vectors().size();
}
inline int NamedVectorsOutput::vectors_size() const {
  return _internal_vectors_size();
}
inline void NamedVectorsOutput::clear_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vectors_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::VectorOutput>& NamedVectorsOutput::_internal_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vectors_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::VectorOutput>& NamedVectorsOutput::vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.NamedVectorsOutput.vectors)
  return _internal_vectors();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::VectorOutput>* PROTOBUF_NONNULL NamedVectorsOutput::_internal_mutable_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.vectors_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::VectorOutput>* PROTOBUF_NONNULL NamedVectorsOutput::mutable_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.NamedVectorsOutput.vectors)
  return _internal_mutable_vectors();
}

// -------------------------------------------------------------------

// Vectors

// .qdrant.Vector vector = 1;
inline bool Vectors::has_vector() const {
  return vectors_options_case() == kVector;
}
inline bool Vectors::_internal_has_vector() const {
  return vectors_options_case() == kVector;
}
inline void Vectors::set_has_vector() {
  _impl_._oneof_case_[0] = kVector;
}
inline void Vectors::clear_vector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (vectors_options_case() == kVector) {
    if (GetArena() == nullptr) {
      delete _impl_.vectors_options_.vector_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.vectors_options_.vector_);
    }
    clear_has_vectors_options();
  }
}
inline ::qdrant::Vector* PROTOBUF_NULLABLE Vectors::release_vector() {
  // @@protoc_insertion_point(field_release:qdrant.Vectors.vector)
  if (vectors_options_case() == kVector) {
    clear_has_vectors_options();
    auto* temp = _impl_.vectors_options_.vector_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vectors_options_.vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Vector& Vectors::_internal_vector() const {
  return vectors_options_case() == kVector ? static_cast<const ::qdrant::Vector&>(*_impl_.vectors_options_.vector_)
                     : reinterpret_cast<const ::qdrant::Vector&>(::qdrant::_Vector_default_instance_);
}
inline const ::qdrant::Vector& Vectors::vector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Vectors.vector)
  return _internal_vector();
}
inline ::qdrant::Vector* PROTOBUF_NULLABLE Vectors::unsafe_arena_release_vector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Vectors.vector)
  if (vectors_options_case() == kVector) {
    clear_has_vectors_options();
    auto* temp = _impl_.vectors_options_.vector_;
    _impl_.vectors_options_.vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Vectors::unsafe_arena_set_allocated_vector(
    ::qdrant::Vector* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_vectors_options();
  if (value) {
    set_has_vector();
    _impl_.vectors_options_.vector_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Vectors.vector)
}
inline ::qdrant::Vector* PROTOBUF_NONNULL Vectors::_internal_mutable_vector() {
  if (vectors_options_case() != kVector) {
    clear_vectors_options();
    set_has_vector();
    _impl_.vectors_options_.vector_ = 
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Vector>(GetArena());
  }
  return _impl_.vectors_options_.vector_;
}
inline ::qdrant::Vector* PROTOBUF_NONNULL Vectors::mutable_vector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Vector* _msg = _internal_mutable_vector();
  // @@protoc_insertion_point(field_mutable:qdrant.Vectors.vector)
  return _msg;
}

// .qdrant.NamedVectors vectors = 2;
inline bool Vectors::has_vectors() const {
  return vectors_options_case() == kVectors;
}
inline bool Vectors::_internal_has_vectors() const {
  return vectors_options_case() == kVectors;
}
inline void Vectors::set_has_vectors() {
  _impl_._oneof_case_[0] = kVectors;
}
inline void Vectors::clear_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (vectors_options_case() == kVectors) {
    if (GetArena() == nullptr) {
      delete _impl_.vectors_options_.vectors_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.vectors_options_.vectors_);
    }
    clear_has_vectors_options();
  }
}
inline ::qdrant::NamedVectors* PROTOBUF_NULLABLE Vectors::release_vectors() {
  // @@protoc_insertion_point(field_release:qdrant.Vectors.vectors)
  if (vectors_options_case() == kVectors) {
    clear_has_vectors_options();
    auto* temp = _impl_.vectors_options_.vectors_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vectors_options_.vectors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::NamedVectors& Vectors::_internal_vectors() const {
  return vectors_options_case() == kVectors ? static_cast<const ::qdrant::NamedVectors&>(*_impl_.vectors_options_.vectors_)
                     : reinterpret_cast<const ::qdrant::NamedVectors&>(::qdrant::_NamedVectors_default_instance_);
}
inline const ::qdrant::NamedVectors& Vectors::vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Vectors.vectors)
  return _internal_vectors();
}
inline ::qdrant::NamedVectors* PROTOBUF_NULLABLE Vectors::unsafe_arena_release_vectors() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Vectors.vectors)
  if (vectors_options_case() == kVectors) {
    clear_has_vectors_options();
    auto* temp = _impl_.vectors_options_.vectors_;
    _impl_.vectors_options_.vectors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Vectors::unsafe_arena_set_allocated_vectors(
    ::qdrant::NamedVectors* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_vectors_options();
  if (value) {
    set_has_vectors();
    _impl_.vectors_options_.vectors_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Vectors.vectors)
}
inline ::qdrant::NamedVectors* PROTOBUF_NONNULL Vectors::_internal_mutable_vectors() {
  if (vectors_options_case() != kVectors) {
    clear_vectors_options();
    set_has_vectors();
    _impl_.vectors_options_.vectors_ = 
        ::google::protobuf::Message::DefaultConstruct<::qdrant::NamedVectors>(GetArena());
  }
  return _impl_.vectors_options_.vectors_;
}
inline ::qdrant::NamedVectors* PROTOBUF_NONNULL Vectors::mutable_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::NamedVectors* _msg = _internal_mutable_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.Vectors.vectors)
  return _msg;
}

inline bool Vectors::has_vectors_options() const {
  return vectors_options_case() != VECTORS_OPTIONS_NOT_SET;
}
inline void Vectors::clear_has_vectors_options() {
  _impl_._oneof_case_[0] = VECTORS_OPTIONS_NOT_SET;
}
inline Vectors::VectorsOptionsCase Vectors::vectors_options_case() const {
  return Vectors::VectorsOptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VectorsOutput

// .qdrant.VectorOutput vector = 1;
inline bool VectorsOutput::has_vector() const {
  return vectors_options_case() == kVector;
}
inline bool VectorsOutput::_internal_has_vector() const {
  return vectors_options_case() == kVector;
}
inline void VectorsOutput::set_has_vector() {
  _impl_._oneof_case_[0] = kVector;
}
inline void VectorsOutput::clear_vector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (vectors_options_case() == kVector) {
    if (GetArena() == nullptr) {
      delete _impl_.vectors_options_.vector_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.vectors_options_.vector_);
    }
    clear_has_vectors_options();
  }
}
inline ::qdrant::VectorOutput* PROTOBUF_NULLABLE VectorsOutput::release_vector() {
  // @@protoc_insertion_point(field_release:qdrant.VectorsOutput.vector)
  if (vectors_options_case() == kVector) {
    clear_has_vectors_options();
    auto* temp = _impl_.vectors_options_.vector_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vectors_options_.vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::VectorOutput& VectorsOutput::_internal_vector() const {
  return vectors_options_case() == kVector ? static_cast<const ::qdrant::VectorOutput&>(*_impl_.vectors_options_.vector_)
                     : reinterpret_cast<const ::qdrant::VectorOutput&>(::qdrant::_VectorOutput_default_instance_);
}
inline const ::qdrant::VectorOutput& VectorsOutput::vector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorsOutput.vector)
  return _internal_vector();
}
inline ::qdrant::VectorOutput* PROTOBUF_NULLABLE VectorsOutput::unsafe_arena_release_vector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorsOutput.vector)
  if (vectors_options_case() == kVector) {
    clear_has_vectors_options();
    auto* temp = _impl_.vectors_options_.vector_;
    _impl_.vectors_options_.vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorsOutput::unsafe_arena_set_allocated_vector(
    ::qdrant::VectorOutput* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_vectors_options();
  if (value) {
    set_has_vector();
    _impl_.vectors_options_.vector_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorsOutput.vector)
}
inline ::qdrant::VectorOutput* PROTOBUF_NONNULL VectorsOutput::_internal_mutable_vector() {
  if (vectors_options_case() != kVector) {
    clear_vectors_options();
    set_has_vector();
    _impl_.vectors_options_.vector_ = 
        ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorOutput>(GetArena());
  }
  return _impl_.vectors_options_.vector_;
}
inline ::qdrant::VectorOutput* PROTOBUF_NONNULL VectorsOutput::mutable_vector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::VectorOutput* _msg = _internal_mutable_vector();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorsOutput.vector)
  return _msg;
}

// .qdrant.NamedVectorsOutput vectors = 2;
inline bool VectorsOutput::has_vectors() const {
  return vectors_options_case() == kVectors;
}
inline bool VectorsOutput::_internal_has_vectors() const {
  return vectors_options_case() == kVectors;
}
inline void VectorsOutput::set_has_vectors() {
  _impl_._oneof_case_[0] = kVectors;
}
inline void VectorsOutput::clear_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (vectors_options_case() == kVectors) {
    if (GetArena() == nullptr) {
      delete _impl_.vectors_options_.vectors_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.vectors_options_.vectors_);
    }
    clear_has_vectors_options();
  }
}
inline ::qdrant::NamedVectorsOutput* PROTOBUF_NULLABLE VectorsOutput::release_vectors() {
  // @@protoc_insertion_point(field_release:qdrant.VectorsOutput.vectors)
  if (vectors_options_case() == kVectors) {
    clear_has_vectors_options();
    auto* temp = _impl_.vectors_options_.vectors_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vectors_options_.vectors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::NamedVectorsOutput& VectorsOutput::_internal_vectors() const {
  return vectors_options_case() == kVectors ? static_cast<const ::qdrant::NamedVectorsOutput&>(*_impl_.vectors_options_.vectors_)
                     : reinterpret_cast<const ::qdrant::NamedVectorsOutput&>(::qdrant::_NamedVectorsOutput_default_instance_);
}
inline const ::qdrant::NamedVectorsOutput& VectorsOutput::vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorsOutput.vectors)
  return _internal_vectors();
}
inline ::qdrant::NamedVectorsOutput* PROTOBUF_NULLABLE VectorsOutput::unsafe_arena_release_vectors() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorsOutput.vectors)
  if (vectors_options_case() == kVectors) {
    clear_has_vectors_options();
    auto* temp = _impl_.vectors_options_.vectors_;
    _impl_.vectors_options_.vectors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorsOutput::unsafe_arena_set_allocated_vectors(
    ::qdrant::NamedVectorsOutput* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_vectors_options();
  if (value) {
    set_has_vectors();
    _impl_.vectors_options_.vectors_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorsOutput.vectors)
}
inline ::qdrant::NamedVectorsOutput* PROTOBUF_NONNULL VectorsOutput::_internal_mutable_vectors() {
  if (vectors_options_case() != kVectors) {
    clear_vectors_options();
    set_has_vectors();
    _impl_.vectors_options_.vectors_ = 
        ::google::protobuf::Message::DefaultConstruct<::qdrant::NamedVectorsOutput>(GetArena());
  }
  return _impl_.vectors_options_.vectors_;
}
inline ::qdrant::NamedVectorsOutput* PROTOBUF_NONNULL VectorsOutput::mutable_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::NamedVectorsOutput* _msg = _internal_mutable_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorsOutput.vectors)
  return _msg;
}

inline bool VectorsOutput::has_vectors_options() const {
  return vectors_options_case() != VECTORS_OPTIONS_NOT_SET;
}
inline void VectorsOutput::clear_has_vectors_options() {
  _impl_._oneof_case_[0] = VECTORS_OPTIONS_NOT_SET;
}
inline VectorsOutput::VectorsOptionsCase VectorsOutput::vectors_options_case() const {
  return VectorsOutput::VectorsOptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VectorsSelector

// repeated string names = 1;
inline int VectorsSelector::_internal_names_size() const {
  return _internal_names().size();
}
inline int VectorsSelector::names_size() const {
  return _internal_names_size();
}
inline void VectorsSelector::clear_names() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.names_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL VectorsSelector::add_names()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_names()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:qdrant.VectorsSelector.names)
  return _s;
}
inline const ::std::string& VectorsSelector::names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorsSelector.names)
  return _internal_names().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL VectorsSelector::mutable_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.VectorsSelector.names)
  return _internal_mutable_names()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void VectorsSelector::set_names(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_names()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:qdrant.VectorsSelector.names)
}
template <typename Arg_, typename... Args_>
inline void VectorsSelector::add_names(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_names(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.VectorsSelector.names)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& VectorsSelector::names()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.VectorsSelector.names)
  return _internal_names();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
VectorsSelector::mutable_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.VectorsSelector.names)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_names();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
VectorsSelector::_internal_names() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.names_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
VectorsSelector::_internal_mutable_names() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.names_;
}

// -------------------------------------------------------------------

// WithVectorsSelector

// bool enable = 1;
inline bool WithVectorsSelector::has_enable() const {
  return selector_options_case() == kEnable;
}
inline void WithVectorsSelector::set_has_enable() {
  _impl_._oneof_case_[0] = kEnable;
}
inline void WithVectorsSelector::clear_enable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selector_options_case() == kEnable) {
    _impl_.selector_options_.enable_ = false;
    clear_has_selector_options();
  }
}
inline bool WithVectorsSelector::enable() const {
  // @@protoc_insertion_point(field_get:qdrant.WithVectorsSelector.enable)
  return _internal_enable();
}
inline void WithVectorsSelector::set_enable(bool value) {
  if (selector_options_case() != kEnable) {
    clear_selector_options();
    set_has_enable();
  }
  _impl_.selector_options_.enable_ = value;
  // @@protoc_insertion_point(field_set:qdrant.WithVectorsSelector.enable)
}
inline bool WithVectorsSelector::_internal_enable() const {
  if (selector_options_case() == kEnable) {
    return _impl_.selector_options_.enable_;
  }
  return false;
}

// .qdrant.VectorsSelector include = 2;
inline bool WithVectorsSelector::has_include() const {
  return selector_options_case() == kInclude;
}
inline bool WithVectorsSelector::_internal_has_include() const {
  return selector_options_case() == kInclude;
}
inline void WithVectorsSelector::set_has_include() {
  _impl_._oneof_case_[0] = kInclude;
}
inline void WithVectorsSelector::clear_include() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selector_options_case() == kInclude) {
    if (GetArena() == nullptr) {
      delete _impl_.selector_options_.include_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selector_options_.include_);
    }
    clear_has_selector_options();
  }
}
inline ::qdrant::VectorsSelector* PROTOBUF_NULLABLE WithVectorsSelector::release_include() {
  // @@protoc_insertion_point(field_release:qdrant.WithVectorsSelector.include)
  if (selector_options_case() == kInclude) {
    clear_has_selector_options();
    auto* temp = _impl_.selector_options_.include_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selector_options_.include_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::VectorsSelector& WithVectorsSelector::_internal_include() const {
  return selector_options_case() == kInclude ? static_cast<const ::qdrant::VectorsSelector&>(*_impl_.selector_options_.include_)
                     : reinterpret_cast<const ::qdrant::VectorsSelector&>(::qdrant::_VectorsSelector_default_instance_);
}
inline const ::qdrant::VectorsSelector& WithVectorsSelector::include() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.WithVectorsSelector.include)
  return _internal_include();
}
inline ::qdrant::VectorsSelector* PROTOBUF_NULLABLE WithVectorsSelector::unsafe_arena_release_include() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.WithVectorsSelector.include)
  if (selector_options_case() == kInclude) {
    clear_has_selector_options();
    auto* temp = _impl_.selector_options_.include_;
    _impl_.selector_options_.include_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WithVectorsSelector::unsafe_arena_set_allocated_include(
    ::qdrant::VectorsSelector* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selector_options();
  if (value) {
    set_has_include();
    _impl_.selector_options_.include_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.WithVectorsSelector.include)
}
inline ::qdrant::VectorsSelector* PROTOBUF_NONNULL WithVectorsSelector::_internal_mutable_include() {
  if (selector_options_case() != kInclude) {
    clear_selector_options();
    set_has_include();
    _impl_.selector_options_.include_ = 
        ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorsSelector>(GetArena());
  }
  return _impl_.selector_options_.include_;
}
inline ::qdrant::VectorsSelector* PROTOBUF_NONNULL WithVectorsSelector::mutable_include()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::VectorsSelector* _msg = _internal_mutable_include();
  // @@protoc_insertion_point(field_mutable:qdrant.WithVectorsSelector.include)
  return _msg;
}

inline bool WithVectorsSelector::has_selector_options() const {
  return selector_options_case() != SELECTOR_OPTIONS_NOT_SET;
}
inline void WithVectorsSelector::clear_has_selector_options() {
  _impl_._oneof_case_[0] = SELECTOR_OPTIONS_NOT_SET;
}
inline WithVectorsSelector::SelectorOptionsCase WithVectorsSelector::selector_options_case() const {
  return WithVectorsSelector::SelectorOptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// QuantizationSearchParams

// optional bool ignore = 1;
inline bool QuantizationSearchParams::has_ignore() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void QuantizationSearchParams::clear_ignore() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool QuantizationSearchParams::ignore() const {
  // @@protoc_insertion_point(field_get:qdrant.QuantizationSearchParams.ignore)
  return _internal_ignore();
}
inline void QuantizationSearchParams::set_ignore(bool value) {
  _internal_set_ignore(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.QuantizationSearchParams.ignore)
}
inline bool QuantizationSearchParams::_internal_ignore() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_;
}
inline void QuantizationSearchParams::_internal_set_ignore(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_ = value;
}

// optional bool rescore = 2;
inline bool QuantizationSearchParams::has_rescore() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void QuantizationSearchParams::clear_rescore() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rescore_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline bool QuantizationSearchParams::rescore() const {
  // @@protoc_insertion_point(field_get:qdrant.QuantizationSearchParams.rescore)
  return _internal_rescore();
}
inline void QuantizationSearchParams::set_rescore(bool value) {
  _internal_set_rescore(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.QuantizationSearchParams.rescore)
}
inline bool QuantizationSearchParams::_internal_rescore() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rescore_;
}
inline void QuantizationSearchParams::_internal_set_rescore(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rescore_ = value;
}

// optional double oversampling = 3;
inline bool QuantizationSearchParams::has_oversampling() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void QuantizationSearchParams::clear_oversampling() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.oversampling_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline double QuantizationSearchParams::oversampling() const {
  // @@protoc_insertion_point(field_get:qdrant.QuantizationSearchParams.oversampling)
  return _internal_oversampling();
}
inline void QuantizationSearchParams::set_oversampling(double value) {
  _internal_set_oversampling(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.QuantizationSearchParams.oversampling)
}
inline double QuantizationSearchParams::_internal_oversampling() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.oversampling_;
}
inline void QuantizationSearchParams::_internal_set_oversampling(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.oversampling_ = value;
}

// -------------------------------------------------------------------

// SearchParams

// optional uint64 hnsw_ef = 1;
inline bool SearchParams::has_hnsw_ef() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void SearchParams::clear_hnsw_ef() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hnsw_ef_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint64_t SearchParams::hnsw_ef() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchParams.hnsw_ef)
  return _internal_hnsw_ef();
}
inline void SearchParams::set_hnsw_ef(::uint64_t value) {
  _internal_set_hnsw_ef(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.SearchParams.hnsw_ef)
}
inline ::uint64_t SearchParams::_internal_hnsw_ef() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hnsw_ef_;
}
inline void SearchParams::_internal_set_hnsw_ef(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hnsw_ef_ = value;
}

// optional bool exact = 2;
inline bool SearchParams::has_exact() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void SearchParams::clear_exact() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exact_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline bool SearchParams::exact() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchParams.exact)
  return _internal_exact();
}
inline void SearchParams::set_exact(bool value) {
  _internal_set_exact(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.SearchParams.exact)
}
inline bool SearchParams::_internal_exact() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exact_;
}
inline void SearchParams::_internal_set_exact(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exact_ = value;
}

// optional .qdrant.QuantizationSearchParams quantization = 3;
inline bool SearchParams::has_quantization() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.quantization_ != nullptr);
  return value;
}
inline void SearchParams::clear_quantization() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.quantization_ != nullptr) _impl_.quantization_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::QuantizationSearchParams& SearchParams::_internal_quantization() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::QuantizationSearchParams* p = _impl_.quantization_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::QuantizationSearchParams&>(::qdrant::_QuantizationSearchParams_default_instance_);
}
inline const ::qdrant::QuantizationSearchParams& SearchParams::quantization() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchParams.quantization)
  return _internal_quantization();
}
inline void SearchParams::unsafe_arena_set_allocated_quantization(
    ::qdrant::QuantizationSearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quantization_);
  }
  _impl_.quantization_ = reinterpret_cast<::qdrant::QuantizationSearchParams*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchParams.quantization)
}
inline ::qdrant::QuantizationSearchParams* PROTOBUF_NULLABLE SearchParams::release_quantization() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::QuantizationSearchParams* released = _impl_.quantization_;
  _impl_.quantization_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::QuantizationSearchParams* PROTOBUF_NULLABLE SearchParams::unsafe_arena_release_quantization() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchParams.quantization)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::QuantizationSearchParams* temp = _impl_.quantization_;
  _impl_.quantization_ = nullptr;
  return temp;
}
inline ::qdrant::QuantizationSearchParams* PROTOBUF_NONNULL SearchParams::_internal_mutable_quantization() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.quantization_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::QuantizationSearchParams>(GetArena());
    _impl_.quantization_ = reinterpret_cast<::qdrant::QuantizationSearchParams*>(p);
  }
  return _impl_.quantization_;
}
inline ::qdrant::QuantizationSearchParams* PROTOBUF_NONNULL SearchParams::mutable_quantization()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::QuantizationSearchParams* _msg = _internal_mutable_quantization();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchParams.quantization)
  return _msg;
}
inline void SearchParams::set_allocated_quantization(::qdrant::QuantizationSearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quantization_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.quantization_ = reinterpret_cast<::qdrant::QuantizationSearchParams*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchParams.quantization)
}

// optional bool indexed_only = 4;
inline bool SearchParams::has_indexed_only() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void SearchParams::clear_indexed_only() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.indexed_only_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool SearchParams::indexed_only() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchParams.indexed_only)
  return _internal_indexed_only();
}
inline void SearchParams::set_indexed_only(bool value) {
  _internal_set_indexed_only(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.SearchParams.indexed_only)
}
inline bool SearchParams::_internal_indexed_only() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.indexed_only_;
}
inline void SearchParams::_internal_set_indexed_only(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.indexed_only_ = value;
}

// -------------------------------------------------------------------

// SearchPoints

// string collection_name = 1;
inline void SearchPoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& SearchPoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SearchPoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.SearchPoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL SearchPoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPoints.collection_name)
  return _s;
}
inline const ::std::string& SearchPoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void SearchPoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SearchPoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SearchPoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void SearchPoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPoints.collection_name)
}

// repeated float vector = 2;
inline int SearchPoints::_internal_vector_size() const {
  return _internal_vector().size();
}
inline int SearchPoints::vector_size() const {
  return _internal_vector_size();
}
inline void SearchPoints::clear_vector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vector_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline float SearchPoints::vector(int index) const {
  // @@protoc_insertion_point(field_get:qdrant.SearchPoints.vector)
  return _internal_vector().Get(index);
}
inline void SearchPoints::set_vector(int index, float value) {
  _internal_mutable_vector()->Set(index, value);
  // @@protoc_insertion_point(field_set:qdrant.SearchPoints.vector)
}
inline void SearchPoints::add_vector(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_vector()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.SearchPoints.vector)
}
inline const ::google::protobuf::RepeatedField<float>& SearchPoints::vector() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.SearchPoints.vector)
  return _internal_vector();
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL SearchPoints::mutable_vector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.SearchPoints.vector)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_vector();
}
inline const ::google::protobuf::RepeatedField<float>&
SearchPoints::_internal_vector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vector_;
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL
SearchPoints::_internal_mutable_vector() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.vector_;
}

// .qdrant.Filter filter = 3;
inline bool SearchPoints::has_filter() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void SearchPoints::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::Filter& SearchPoints::_internal_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Filter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& SearchPoints::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPoints.filter)
  return _internal_filter();
}
inline void SearchPoints::unsafe_arena_set_allocated_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchPoints.filter)
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE SearchPoints::release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::Filter* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE SearchPoints::unsafe_arena_release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPoints.filter)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL SearchPoints::_internal_mutable_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
    _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(p);
  }
  return _impl_.filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL SearchPoints::mutable_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPoints.filter)
  return _msg;
}
inline void SearchPoints::set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPoints.filter)
}

// uint64 limit = 4;
inline void SearchPoints::clear_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000400U);
}
inline ::uint64_t SearchPoints::limit() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchPoints.limit)
  return _internal_limit();
}
inline void SearchPoints::set_limit(::uint64_t value) {
  _internal_set_limit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  // @@protoc_insertion_point(field_set:qdrant.SearchPoints.limit)
}
inline ::uint64_t SearchPoints::_internal_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limit_;
}
inline void SearchPoints::_internal_set_limit(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = value;
}

// .qdrant.WithPayloadSelector with_payload = 6;
inline bool SearchPoints::has_with_payload() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.with_payload_ != nullptr);
  return value;
}
inline void SearchPoints::clear_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ != nullptr) _impl_.with_payload_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::WithPayloadSelector& SearchPoints::_internal_with_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithPayloadSelector* p = _impl_.with_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithPayloadSelector&>(::qdrant::_WithPayloadSelector_default_instance_);
}
inline const ::qdrant::WithPayloadSelector& SearchPoints::with_payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPoints.with_payload)
  return _internal_with_payload();
}
inline void SearchPoints::unsafe_arena_set_allocated_with_payload(
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }
  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchPoints.with_payload)
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE SearchPoints::release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::WithPayloadSelector* released = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE SearchPoints::unsafe_arena_release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPoints.with_payload)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::WithPayloadSelector* temp = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  return temp;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL SearchPoints::_internal_mutable_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithPayloadSelector>(GetArena());
    _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(p);
  }
  return _impl_.with_payload_;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL SearchPoints::mutable_with_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::WithPayloadSelector* _msg = _internal_mutable_with_payload();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPoints.with_payload)
  return _msg;
}
inline void SearchPoints::set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPoints.with_payload)
}

// .qdrant.SearchParams params = 7;
inline bool SearchPoints::has_params() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.params_ != nullptr);
  return value;
}
inline void SearchPoints::clear_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ != nullptr) _impl_.params_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::qdrant::SearchParams& SearchPoints::_internal_params() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SearchParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SearchParams&>(::qdrant::_SearchParams_default_instance_);
}
inline const ::qdrant::SearchParams& SearchPoints::params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPoints.params)
  return _internal_params();
}
inline void SearchPoints::unsafe_arena_set_allocated_params(
    ::qdrant::SearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchPoints.params)
}
inline ::qdrant::SearchParams* PROTOBUF_NULLABLE SearchPoints::release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::SearchParams* released = _impl_.params_;
  _impl_.params_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SearchParams* PROTOBUF_NULLABLE SearchPoints::unsafe_arena_release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPoints.params)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::SearchParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::qdrant::SearchParams* PROTOBUF_NONNULL SearchPoints::_internal_mutable_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SearchParams>(GetArena());
    _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(p);
  }
  return _impl_.params_;
}
inline ::qdrant::SearchParams* PROTOBUF_NONNULL SearchPoints::mutable_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::SearchParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPoints.params)
  return _msg;
}
inline void SearchPoints::set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPoints.params)
}

// optional float score_threshold = 8;
inline bool SearchPoints::has_score_threshold() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00002000U);
  return value;
}
inline void SearchPoints::clear_score_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_threshold_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00002000U);
}
inline float SearchPoints::score_threshold() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchPoints.score_threshold)
  return _internal_score_threshold();
}
inline void SearchPoints::set_score_threshold(float value) {
  _internal_set_score_threshold(value);
  SetHasBit(_impl_._has_bits_[0], 0x00002000U);
  // @@protoc_insertion_point(field_set:qdrant.SearchPoints.score_threshold)
}
inline float SearchPoints::_internal_score_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.score_threshold_;
}
inline void SearchPoints::_internal_set_score_threshold(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_threshold_ = value;
}

// optional uint64 offset = 9;
inline bool SearchPoints::has_offset() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000800U);
  return value;
}
inline void SearchPoints::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000800U);
}
inline ::uint64_t SearchPoints::offset() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchPoints.offset)
  return _internal_offset();
}
inline void SearchPoints::set_offset(::uint64_t value) {
  _internal_set_offset(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  // @@protoc_insertion_point(field_set:qdrant.SearchPoints.offset)
}
inline ::uint64_t SearchPoints::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_;
}
inline void SearchPoints::_internal_set_offset(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = value;
}

// optional string vector_name = 10;
inline bool SearchPoints::has_vector_name() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void SearchPoints::clear_vector_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vector_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& SearchPoints::vector_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPoints.vector_name)
  return _internal_vector_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SearchPoints::set_vector_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.vector_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.SearchPoints.vector_name)
}
inline ::std::string* PROTOBUF_NONNULL SearchPoints::mutable_vector_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_vector_name();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPoints.vector_name)
  return _s;
}
inline const ::std::string& SearchPoints::_internal_vector_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vector_name_.Get();
}
inline void SearchPoints::_internal_set_vector_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vector_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SearchPoints::_internal_mutable_vector_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.vector_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SearchPoints::release_vector_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPoints.vector_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.vector_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.vector_name_.Set("", GetArena());
  }
  return released;
}
inline void SearchPoints::set_allocated_vector_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.vector_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.vector_name_.IsDefault()) {
    _impl_.vector_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPoints.vector_name)
}

// optional .qdrant.WithVectorsSelector with_vectors = 11;
inline bool SearchPoints::has_with_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  PROTOBUF_ASSUME(!value || _impl_.with_vectors_ != nullptr);
  return value;
}
inline void SearchPoints::clear_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ != nullptr) _impl_.with_vectors_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::qdrant::WithVectorsSelector& SearchPoints::_internal_with_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithVectorsSelector* p = _impl_.with_vectors_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithVectorsSelector&>(::qdrant::_WithVectorsSelector_default_instance_);
}
inline const ::qdrant::WithVectorsSelector& SearchPoints::with_vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPoints.with_vectors)
  return _internal_with_vectors();
}
inline void SearchPoints::unsafe_arena_set_allocated_with_vectors(
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }
  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchPoints.with_vectors)
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE SearchPoints::release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::WithVectorsSelector* released = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE SearchPoints::unsafe_arena_release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPoints.with_vectors)

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::WithVectorsSelector* temp = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  return temp;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL SearchPoints::_internal_mutable_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithVectorsSelector>(GetArena());
    _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(p);
  }
  return _impl_.with_vectors_;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL SearchPoints::mutable_with_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::WithVectorsSelector* _msg = _internal_mutable_with_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPoints.with_vectors)
  return _msg;
}
inline void SearchPoints::set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }

  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPoints.with_vectors)
}

// optional .qdrant.ReadConsistency read_consistency = 12;
inline bool SearchPoints::has_read_consistency() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  PROTOBUF_ASSUME(!value || _impl_.read_consistency_ != nullptr);
  return value;
}
inline void SearchPoints::clear_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ != nullptr) _impl_.read_consistency_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline const ::qdrant::ReadConsistency& SearchPoints::_internal_read_consistency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ReadConsistency* p = _impl_.read_consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ReadConsistency&>(::qdrant::_ReadConsistency_default_instance_);
}
inline const ::qdrant::ReadConsistency& SearchPoints::read_consistency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPoints.read_consistency)
  return _internal_read_consistency();
}
inline void SearchPoints::unsafe_arena_set_allocated_read_consistency(
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }
  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchPoints.read_consistency)
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE SearchPoints::release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::ReadConsistency* released = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE SearchPoints::unsafe_arena_release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPoints.read_consistency)

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::ReadConsistency* temp = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  return temp;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL SearchPoints::_internal_mutable_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ReadConsistency>(GetArena());
    _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(p);
  }
  return _impl_.read_consistency_;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL SearchPoints::mutable_read_consistency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::ReadConsistency* _msg = _internal_mutable_read_consistency();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPoints.read_consistency)
  return _msg;
}
inline void SearchPoints::set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }

  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPoints.read_consistency)
}

// optional uint64 timeout = 13;
inline bool SearchPoints::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00001000U);
  return value;
}
inline void SearchPoints::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00001000U);
}
inline ::uint64_t SearchPoints::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchPoints.timeout)
  return _internal_timeout();
}
inline void SearchPoints::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00001000U);
  // @@protoc_insertion_point(field_set:qdrant.SearchPoints.timeout)
}
inline ::uint64_t SearchPoints::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void SearchPoints::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// optional .qdrant.ShardKeySelector shard_key_selector = 14;
inline bool SearchPoints::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000100U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void SearchPoints::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline const ::qdrant::ShardKeySelector& SearchPoints::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& SearchPoints::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPoints.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void SearchPoints::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchPoints.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE SearchPoints::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE SearchPoints::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPoints.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL SearchPoints::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL SearchPoints::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPoints.shard_key_selector)
  return _msg;
}
inline void SearchPoints::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPoints.shard_key_selector)
}

// optional .qdrant.SparseIndices sparse_indices = 15;
inline bool SearchPoints::has_sparse_indices() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000200U);
  PROTOBUF_ASSUME(!value || _impl_.sparse_indices_ != nullptr);
  return value;
}
inline void SearchPoints::clear_sparse_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sparse_indices_ != nullptr) _impl_.sparse_indices_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000200U);
}
inline const ::qdrant::SparseIndices& SearchPoints::_internal_sparse_indices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SparseIndices* p = _impl_.sparse_indices_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SparseIndices&>(::qdrant::_SparseIndices_default_instance_);
}
inline const ::qdrant::SparseIndices& SearchPoints::sparse_indices() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPoints.sparse_indices)
  return _internal_sparse_indices();
}
inline void SearchPoints::unsafe_arena_set_allocated_sparse_indices(
    ::qdrant::SparseIndices* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sparse_indices_);
  }
  _impl_.sparse_indices_ = reinterpret_cast<::qdrant::SparseIndices*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchPoints.sparse_indices)
}
inline ::qdrant::SparseIndices* PROTOBUF_NULLABLE SearchPoints::release_sparse_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::SparseIndices* released = _impl_.sparse_indices_;
  _impl_.sparse_indices_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SparseIndices* PROTOBUF_NULLABLE SearchPoints::unsafe_arena_release_sparse_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPoints.sparse_indices)

  ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::SparseIndices* temp = _impl_.sparse_indices_;
  _impl_.sparse_indices_ = nullptr;
  return temp;
}
inline ::qdrant::SparseIndices* PROTOBUF_NONNULL SearchPoints::_internal_mutable_sparse_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sparse_indices_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SparseIndices>(GetArena());
    _impl_.sparse_indices_ = reinterpret_cast<::qdrant::SparseIndices*>(p);
  }
  return _impl_.sparse_indices_;
}
inline ::qdrant::SparseIndices* PROTOBUF_NONNULL SearchPoints::mutable_sparse_indices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::SparseIndices* _msg = _internal_mutable_sparse_indices();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPoints.sparse_indices)
  return _msg;
}
inline void SearchPoints::set_allocated_sparse_indices(::qdrant::SparseIndices* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sparse_indices_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  }

  _impl_.sparse_indices_ = reinterpret_cast<::qdrant::SparseIndices*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPoints.sparse_indices)
}

// -------------------------------------------------------------------

// SearchBatchPoints

// string collection_name = 1;
inline void SearchBatchPoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& SearchBatchPoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchBatchPoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SearchBatchPoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.SearchBatchPoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL SearchBatchPoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchBatchPoints.collection_name)
  return _s;
}
inline const ::std::string& SearchBatchPoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void SearchBatchPoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SearchBatchPoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SearchBatchPoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchBatchPoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void SearchBatchPoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchBatchPoints.collection_name)
}

// repeated .qdrant.SearchPoints search_points = 2;
inline int SearchBatchPoints::_internal_search_points_size() const {
  return _internal_search_points().size();
}
inline int SearchBatchPoints::search_points_size() const {
  return _internal_search_points_size();
}
inline void SearchBatchPoints::clear_search_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.search_points_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::SearchPoints* PROTOBUF_NONNULL SearchBatchPoints::mutable_search_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.SearchBatchPoints.search_points)
  return _internal_mutable_search_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::SearchPoints>* PROTOBUF_NONNULL SearchBatchPoints::mutable_search_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.SearchBatchPoints.search_points)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_search_points();
}
inline const ::qdrant::SearchPoints& SearchBatchPoints::search_points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchBatchPoints.search_points)
  return _internal_search_points().Get(index);
}
inline ::qdrant::SearchPoints* PROTOBUF_NONNULL SearchBatchPoints::add_search_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::SearchPoints* _add =
      _internal_mutable_search_points()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.SearchBatchPoints.search_points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::SearchPoints>& SearchBatchPoints::search_points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.SearchBatchPoints.search_points)
  return _internal_search_points();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::SearchPoints>&
SearchBatchPoints::_internal_search_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.search_points_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::SearchPoints>* PROTOBUF_NONNULL
SearchBatchPoints::_internal_mutable_search_points() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.search_points_;
}

// optional .qdrant.ReadConsistency read_consistency = 3;
inline bool SearchBatchPoints::has_read_consistency() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.read_consistency_ != nullptr);
  return value;
}
inline void SearchBatchPoints::clear_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ != nullptr) _impl_.read_consistency_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::ReadConsistency& SearchBatchPoints::_internal_read_consistency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ReadConsistency* p = _impl_.read_consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ReadConsistency&>(::qdrant::_ReadConsistency_default_instance_);
}
inline const ::qdrant::ReadConsistency& SearchBatchPoints::read_consistency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchBatchPoints.read_consistency)
  return _internal_read_consistency();
}
inline void SearchBatchPoints::unsafe_arena_set_allocated_read_consistency(
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }
  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchBatchPoints.read_consistency)
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE SearchBatchPoints::release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ReadConsistency* released = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE SearchBatchPoints::unsafe_arena_release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchBatchPoints.read_consistency)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ReadConsistency* temp = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  return temp;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL SearchBatchPoints::_internal_mutable_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ReadConsistency>(GetArena());
    _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(p);
  }
  return _impl_.read_consistency_;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL SearchBatchPoints::mutable_read_consistency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ReadConsistency* _msg = _internal_mutable_read_consistency();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchBatchPoints.read_consistency)
  return _msg;
}
inline void SearchBatchPoints::set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchBatchPoints.read_consistency)
}

// optional uint64 timeout = 4;
inline bool SearchBatchPoints::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void SearchBatchPoints::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint64_t SearchBatchPoints::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchBatchPoints.timeout)
  return _internal_timeout();
}
inline void SearchBatchPoints::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.SearchBatchPoints.timeout)
}
inline ::uint64_t SearchBatchPoints::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void SearchBatchPoints::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// -------------------------------------------------------------------

// WithLookup

// string collection = 1;
inline void WithLookup::clear_collection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& WithLookup::collection() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.WithLookup.collection)
  return _internal_collection();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void WithLookup::set_collection(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.WithLookup.collection)
}
inline ::std::string* PROTOBUF_NONNULL WithLookup::mutable_collection()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection();
  // @@protoc_insertion_point(field_mutable:qdrant.WithLookup.collection)
  return _s;
}
inline const ::std::string& WithLookup::_internal_collection() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_.Get();
}
inline void WithLookup::_internal_set_collection(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL WithLookup::_internal_mutable_collection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE WithLookup::release_collection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.WithLookup.collection)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_.Set("", GetArena());
  }
  return released;
}
inline void WithLookup::set_allocated_collection(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_.IsDefault()) {
    _impl_.collection_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.WithLookup.collection)
}

// optional .qdrant.WithPayloadSelector with_payload = 2;
inline bool WithLookup::has_with_payload() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.with_payload_ != nullptr);
  return value;
}
inline void WithLookup::clear_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ != nullptr) _impl_.with_payload_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::WithPayloadSelector& WithLookup::_internal_with_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithPayloadSelector* p = _impl_.with_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithPayloadSelector&>(::qdrant::_WithPayloadSelector_default_instance_);
}
inline const ::qdrant::WithPayloadSelector& WithLookup::with_payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.WithLookup.with_payload)
  return _internal_with_payload();
}
inline void WithLookup::unsafe_arena_set_allocated_with_payload(
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }
  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.WithLookup.with_payload)
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE WithLookup::release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::WithPayloadSelector* released = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE WithLookup::unsafe_arena_release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.WithLookup.with_payload)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::WithPayloadSelector* temp = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  return temp;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL WithLookup::_internal_mutable_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithPayloadSelector>(GetArena());
    _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(p);
  }
  return _impl_.with_payload_;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL WithLookup::mutable_with_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::WithPayloadSelector* _msg = _internal_mutable_with_payload();
  // @@protoc_insertion_point(field_mutable:qdrant.WithLookup.with_payload)
  return _msg;
}
inline void WithLookup::set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.WithLookup.with_payload)
}

// optional .qdrant.WithVectorsSelector with_vectors = 3;
inline bool WithLookup::has_with_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.with_vectors_ != nullptr);
  return value;
}
inline void WithLookup::clear_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ != nullptr) _impl_.with_vectors_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::WithVectorsSelector& WithLookup::_internal_with_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithVectorsSelector* p = _impl_.with_vectors_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithVectorsSelector&>(::qdrant::_WithVectorsSelector_default_instance_);
}
inline const ::qdrant::WithVectorsSelector& WithLookup::with_vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.WithLookup.with_vectors)
  return _internal_with_vectors();
}
inline void WithLookup::unsafe_arena_set_allocated_with_vectors(
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }
  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.WithLookup.with_vectors)
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE WithLookup::release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WithVectorsSelector* released = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE WithLookup::unsafe_arena_release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.WithLookup.with_vectors)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WithVectorsSelector* temp = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  return temp;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL WithLookup::_internal_mutable_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithVectorsSelector>(GetArena());
    _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(p);
  }
  return _impl_.with_vectors_;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL WithLookup::mutable_with_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WithVectorsSelector* _msg = _internal_mutable_with_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.WithLookup.with_vectors)
  return _msg;
}
inline void WithLookup::set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.WithLookup.with_vectors)
}

// -------------------------------------------------------------------

// SearchPointGroups

// string collection_name = 1;
inline void SearchPointGroups::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& SearchPointGroups::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPointGroups.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SearchPointGroups::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.SearchPointGroups.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL SearchPointGroups::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPointGroups.collection_name)
  return _s;
}
inline const ::std::string& SearchPointGroups::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void SearchPointGroups::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SearchPointGroups::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SearchPointGroups::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPointGroups.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void SearchPointGroups::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPointGroups.collection_name)
}

// repeated float vector = 2;
inline int SearchPointGroups::_internal_vector_size() const {
  return _internal_vector().size();
}
inline int SearchPointGroups::vector_size() const {
  return _internal_vector_size();
}
inline void SearchPointGroups::clear_vector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vector_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline float SearchPointGroups::vector(int index) const {
  // @@protoc_insertion_point(field_get:qdrant.SearchPointGroups.vector)
  return _internal_vector().Get(index);
}
inline void SearchPointGroups::set_vector(int index, float value) {
  _internal_mutable_vector()->Set(index, value);
  // @@protoc_insertion_point(field_set:qdrant.SearchPointGroups.vector)
}
inline void SearchPointGroups::add_vector(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_vector()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.SearchPointGroups.vector)
}
inline const ::google::protobuf::RepeatedField<float>& SearchPointGroups::vector() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.SearchPointGroups.vector)
  return _internal_vector();
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL SearchPointGroups::mutable_vector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.SearchPointGroups.vector)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_vector();
}
inline const ::google::protobuf::RepeatedField<float>&
SearchPointGroups::_internal_vector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vector_;
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL
SearchPointGroups::_internal_mutable_vector() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.vector_;
}

// .qdrant.Filter filter = 3;
inline bool SearchPointGroups::has_filter() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void SearchPointGroups::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::Filter& SearchPointGroups::_internal_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Filter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& SearchPointGroups::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPointGroups.filter)
  return _internal_filter();
}
inline void SearchPointGroups::unsafe_arena_set_allocated_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchPointGroups.filter)
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE SearchPointGroups::release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Filter* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE SearchPointGroups::unsafe_arena_release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPointGroups.filter)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL SearchPointGroups::_internal_mutable_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
    _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(p);
  }
  return _impl_.filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL SearchPointGroups::mutable_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPointGroups.filter)
  return _msg;
}
inline void SearchPointGroups::set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPointGroups.filter)
}

// uint32 limit = 4;
inline void SearchPointGroups::clear_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00001000U);
}
inline ::uint32_t SearchPointGroups::limit() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchPointGroups.limit)
  return _internal_limit();
}
inline void SearchPointGroups::set_limit(::uint32_t value) {
  _internal_set_limit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00001000U);
  // @@protoc_insertion_point(field_set:qdrant.SearchPointGroups.limit)
}
inline ::uint32_t SearchPointGroups::_internal_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limit_;
}
inline void SearchPointGroups::_internal_set_limit(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = value;
}

// .qdrant.WithPayloadSelector with_payload = 5;
inline bool SearchPointGroups::has_with_payload() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.with_payload_ != nullptr);
  return value;
}
inline void SearchPointGroups::clear_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ != nullptr) _impl_.with_payload_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::qdrant::WithPayloadSelector& SearchPointGroups::_internal_with_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithPayloadSelector* p = _impl_.with_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithPayloadSelector&>(::qdrant::_WithPayloadSelector_default_instance_);
}
inline const ::qdrant::WithPayloadSelector& SearchPointGroups::with_payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPointGroups.with_payload)
  return _internal_with_payload();
}
inline void SearchPointGroups::unsafe_arena_set_allocated_with_payload(
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }
  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchPointGroups.with_payload)
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE SearchPointGroups::release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::WithPayloadSelector* released = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE SearchPointGroups::unsafe_arena_release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPointGroups.with_payload)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::WithPayloadSelector* temp = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  return temp;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL SearchPointGroups::_internal_mutable_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithPayloadSelector>(GetArena());
    _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(p);
  }
  return _impl_.with_payload_;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL SearchPointGroups::mutable_with_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::WithPayloadSelector* _msg = _internal_mutable_with_payload();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPointGroups.with_payload)
  return _msg;
}
inline void SearchPointGroups::set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPointGroups.with_payload)
}

// .qdrant.SearchParams params = 6;
inline bool SearchPointGroups::has_params() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  PROTOBUF_ASSUME(!value || _impl_.params_ != nullptr);
  return value;
}
inline void SearchPointGroups::clear_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ != nullptr) _impl_.params_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::qdrant::SearchParams& SearchPointGroups::_internal_params() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SearchParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SearchParams&>(::qdrant::_SearchParams_default_instance_);
}
inline const ::qdrant::SearchParams& SearchPointGroups::params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPointGroups.params)
  return _internal_params();
}
inline void SearchPointGroups::unsafe_arena_set_allocated_params(
    ::qdrant::SearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchPointGroups.params)
}
inline ::qdrant::SearchParams* PROTOBUF_NULLABLE SearchPointGroups::release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::SearchParams* released = _impl_.params_;
  _impl_.params_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SearchParams* PROTOBUF_NULLABLE SearchPointGroups::unsafe_arena_release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPointGroups.params)

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::SearchParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::qdrant::SearchParams* PROTOBUF_NONNULL SearchPointGroups::_internal_mutable_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SearchParams>(GetArena());
    _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(p);
  }
  return _impl_.params_;
}
inline ::qdrant::SearchParams* PROTOBUF_NONNULL SearchPointGroups::mutable_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::SearchParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPointGroups.params)
  return _msg;
}
inline void SearchPointGroups::set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }

  _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPointGroups.params)
}

// optional float score_threshold = 7;
inline bool SearchPointGroups::has_score_threshold() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00002000U);
  return value;
}
inline void SearchPointGroups::clear_score_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_threshold_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00002000U);
}
inline float SearchPointGroups::score_threshold() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchPointGroups.score_threshold)
  return _internal_score_threshold();
}
inline void SearchPointGroups::set_score_threshold(float value) {
  _internal_set_score_threshold(value);
  SetHasBit(_impl_._has_bits_[0], 0x00002000U);
  // @@protoc_insertion_point(field_set:qdrant.SearchPointGroups.score_threshold)
}
inline float SearchPointGroups::_internal_score_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.score_threshold_;
}
inline void SearchPointGroups::_internal_set_score_threshold(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_threshold_ = value;
}

// optional string vector_name = 8;
inline bool SearchPointGroups::has_vector_name() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void SearchPointGroups::clear_vector_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vector_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& SearchPointGroups::vector_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPointGroups.vector_name)
  return _internal_vector_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SearchPointGroups::set_vector_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.vector_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.SearchPointGroups.vector_name)
}
inline ::std::string* PROTOBUF_NONNULL SearchPointGroups::mutable_vector_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_vector_name();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPointGroups.vector_name)
  return _s;
}
inline const ::std::string& SearchPointGroups::_internal_vector_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vector_name_.Get();
}
inline void SearchPointGroups::_internal_set_vector_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vector_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SearchPointGroups::_internal_mutable_vector_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.vector_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SearchPointGroups::release_vector_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPointGroups.vector_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.vector_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.vector_name_.Set("", GetArena());
  }
  return released;
}
inline void SearchPointGroups::set_allocated_vector_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.vector_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.vector_name_.IsDefault()) {
    _impl_.vector_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPointGroups.vector_name)
}

// optional .qdrant.WithVectorsSelector with_vectors = 9;
inline bool SearchPointGroups::has_with_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  PROTOBUF_ASSUME(!value || _impl_.with_vectors_ != nullptr);
  return value;
}
inline void SearchPointGroups::clear_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ != nullptr) _impl_.with_vectors_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline const ::qdrant::WithVectorsSelector& SearchPointGroups::_internal_with_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithVectorsSelector* p = _impl_.with_vectors_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithVectorsSelector&>(::qdrant::_WithVectorsSelector_default_instance_);
}
inline const ::qdrant::WithVectorsSelector& SearchPointGroups::with_vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPointGroups.with_vectors)
  return _internal_with_vectors();
}
inline void SearchPointGroups::unsafe_arena_set_allocated_with_vectors(
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }
  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchPointGroups.with_vectors)
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE SearchPointGroups::release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::WithVectorsSelector* released = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE SearchPointGroups::unsafe_arena_release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPointGroups.with_vectors)

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::WithVectorsSelector* temp = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  return temp;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL SearchPointGroups::_internal_mutable_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithVectorsSelector>(GetArena());
    _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(p);
  }
  return _impl_.with_vectors_;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL SearchPointGroups::mutable_with_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::WithVectorsSelector* _msg = _internal_mutable_with_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPointGroups.with_vectors)
  return _msg;
}
inline void SearchPointGroups::set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }

  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPointGroups.with_vectors)
}

// string group_by = 10;
inline void SearchPointGroups::clear_group_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_by_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::std::string& SearchPointGroups::group_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPointGroups.group_by)
  return _internal_group_by();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SearchPointGroups::set_group_by(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  _impl_.group_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.SearchPointGroups.group_by)
}
inline ::std::string* PROTOBUF_NONNULL SearchPointGroups::mutable_group_by()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::std::string* _s = _internal_mutable_group_by();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPointGroups.group_by)
  return _s;
}
inline const ::std::string& SearchPointGroups::_internal_group_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_by_.Get();
}
inline void SearchPointGroups::_internal_set_group_by(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_by_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SearchPointGroups::_internal_mutable_group_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.group_by_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SearchPointGroups::release_group_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPointGroups.group_by)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000008U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  auto* released = _impl_.group_by_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.group_by_.Set("", GetArena());
  }
  return released;
}
inline void SearchPointGroups::set_allocated_group_by(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  _impl_.group_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.group_by_.IsDefault()) {
    _impl_.group_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPointGroups.group_by)
}

// uint32 group_size = 11;
inline void SearchPointGroups::clear_group_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_size_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00008000U);
}
inline ::uint32_t SearchPointGroups::group_size() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchPointGroups.group_size)
  return _internal_group_size();
}
inline void SearchPointGroups::set_group_size(::uint32_t value) {
  _internal_set_group_size(value);
  SetHasBit(_impl_._has_bits_[0], 0x00008000U);
  // @@protoc_insertion_point(field_set:qdrant.SearchPointGroups.group_size)
}
inline ::uint32_t SearchPointGroups::_internal_group_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_size_;
}
inline void SearchPointGroups::_internal_set_group_size(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_size_ = value;
}

// optional .qdrant.ReadConsistency read_consistency = 12;
inline bool SearchPointGroups::has_read_consistency() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000100U);
  PROTOBUF_ASSUME(!value || _impl_.read_consistency_ != nullptr);
  return value;
}
inline void SearchPointGroups::clear_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ != nullptr) _impl_.read_consistency_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline const ::qdrant::ReadConsistency& SearchPointGroups::_internal_read_consistency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ReadConsistency* p = _impl_.read_consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ReadConsistency&>(::qdrant::_ReadConsistency_default_instance_);
}
inline const ::qdrant::ReadConsistency& SearchPointGroups::read_consistency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPointGroups.read_consistency)
  return _internal_read_consistency();
}
inline void SearchPointGroups::unsafe_arena_set_allocated_read_consistency(
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }
  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchPointGroups.read_consistency)
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE SearchPointGroups::release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::ReadConsistency* released = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE SearchPointGroups::unsafe_arena_release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPointGroups.read_consistency)

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::ReadConsistency* temp = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  return temp;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL SearchPointGroups::_internal_mutable_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ReadConsistency>(GetArena());
    _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(p);
  }
  return _impl_.read_consistency_;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL SearchPointGroups::mutable_read_consistency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::ReadConsistency* _msg = _internal_mutable_read_consistency();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPointGroups.read_consistency)
  return _msg;
}
inline void SearchPointGroups::set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }

  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPointGroups.read_consistency)
}

// optional .qdrant.WithLookup with_lookup = 13;
inline bool SearchPointGroups::has_with_lookup() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000200U);
  PROTOBUF_ASSUME(!value || _impl_.with_lookup_ != nullptr);
  return value;
}
inline void SearchPointGroups::clear_with_lookup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_lookup_ != nullptr) _impl_.with_lookup_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000200U);
}
inline const ::qdrant::WithLookup& SearchPointGroups::_internal_with_lookup() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithLookup* p = _impl_.with_lookup_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithLookup&>(::qdrant::_WithLookup_default_instance_);
}
inline const ::qdrant::WithLookup& SearchPointGroups::with_lookup() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPointGroups.with_lookup)
  return _internal_with_lookup();
}
inline void SearchPointGroups::unsafe_arena_set_allocated_with_lookup(
    ::qdrant::WithLookup* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_lookup_);
  }
  _impl_.with_lookup_ = reinterpret_cast<::qdrant::WithLookup*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchPointGroups.with_lookup)
}
inline ::qdrant::WithLookup* PROTOBUF_NULLABLE SearchPointGroups::release_with_lookup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::WithLookup* released = _impl_.with_lookup_;
  _impl_.with_lookup_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithLookup* PROTOBUF_NULLABLE SearchPointGroups::unsafe_arena_release_with_lookup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPointGroups.with_lookup)

  ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::WithLookup* temp = _impl_.with_lookup_;
  _impl_.with_lookup_ = nullptr;
  return temp;
}
inline ::qdrant::WithLookup* PROTOBUF_NONNULL SearchPointGroups::_internal_mutable_with_lookup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_lookup_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithLookup>(GetArena());
    _impl_.with_lookup_ = reinterpret_cast<::qdrant::WithLookup*>(p);
  }
  return _impl_.with_lookup_;
}
inline ::qdrant::WithLookup* PROTOBUF_NONNULL SearchPointGroups::mutable_with_lookup()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::WithLookup* _msg = _internal_mutable_with_lookup();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPointGroups.with_lookup)
  return _msg;
}
inline void SearchPointGroups::set_allocated_with_lookup(::qdrant::WithLookup* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_lookup_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  }

  _impl_.with_lookup_ = reinterpret_cast<::qdrant::WithLookup*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPointGroups.with_lookup)
}

// optional uint64 timeout = 14;
inline bool SearchPointGroups::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00004000U);
  return value;
}
inline void SearchPointGroups::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00004000U);
}
inline ::uint64_t SearchPointGroups::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchPointGroups.timeout)
  return _internal_timeout();
}
inline void SearchPointGroups::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00004000U);
  // @@protoc_insertion_point(field_set:qdrant.SearchPointGroups.timeout)
}
inline ::uint64_t SearchPointGroups::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void SearchPointGroups::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// optional .qdrant.ShardKeySelector shard_key_selector = 15;
inline bool SearchPointGroups::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000400U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void SearchPointGroups::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000400U);
}
inline const ::qdrant::ShardKeySelector& SearchPointGroups::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& SearchPointGroups::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPointGroups.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void SearchPointGroups::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchPointGroups.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE SearchPointGroups::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE SearchPointGroups::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPointGroups.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL SearchPointGroups::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL SearchPointGroups::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPointGroups.shard_key_selector)
  return _msg;
}
inline void SearchPointGroups::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPointGroups.shard_key_selector)
}

// optional .qdrant.SparseIndices sparse_indices = 16;
inline bool SearchPointGroups::has_sparse_indices() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000800U);
  PROTOBUF_ASSUME(!value || _impl_.sparse_indices_ != nullptr);
  return value;
}
inline void SearchPointGroups::clear_sparse_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sparse_indices_ != nullptr) _impl_.sparse_indices_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000800U);
}
inline const ::qdrant::SparseIndices& SearchPointGroups::_internal_sparse_indices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SparseIndices* p = _impl_.sparse_indices_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SparseIndices&>(::qdrant::_SparseIndices_default_instance_);
}
inline const ::qdrant::SparseIndices& SearchPointGroups::sparse_indices() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchPointGroups.sparse_indices)
  return _internal_sparse_indices();
}
inline void SearchPointGroups::unsafe_arena_set_allocated_sparse_indices(
    ::qdrant::SparseIndices* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sparse_indices_);
  }
  _impl_.sparse_indices_ = reinterpret_cast<::qdrant::SparseIndices*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000800U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchPointGroups.sparse_indices)
}
inline ::qdrant::SparseIndices* PROTOBUF_NULLABLE SearchPointGroups::release_sparse_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000800U);
  ::qdrant::SparseIndices* released = _impl_.sparse_indices_;
  _impl_.sparse_indices_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SparseIndices* PROTOBUF_NULLABLE SearchPointGroups::unsafe_arena_release_sparse_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchPointGroups.sparse_indices)

  ClearHasBit(_impl_._has_bits_[0], 0x00000800U);
  ::qdrant::SparseIndices* temp = _impl_.sparse_indices_;
  _impl_.sparse_indices_ = nullptr;
  return temp;
}
inline ::qdrant::SparseIndices* PROTOBUF_NONNULL SearchPointGroups::_internal_mutable_sparse_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sparse_indices_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SparseIndices>(GetArena());
    _impl_.sparse_indices_ = reinterpret_cast<::qdrant::SparseIndices*>(p);
  }
  return _impl_.sparse_indices_;
}
inline ::qdrant::SparseIndices* PROTOBUF_NONNULL SearchPointGroups::mutable_sparse_indices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  ::qdrant::SparseIndices* _msg = _internal_mutable_sparse_indices();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchPointGroups.sparse_indices)
  return _msg;
}
inline void SearchPointGroups::set_allocated_sparse_indices(::qdrant::SparseIndices* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sparse_indices_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000800U);
  }

  _impl_.sparse_indices_ = reinterpret_cast<::qdrant::SparseIndices*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchPointGroups.sparse_indices)
}

// -------------------------------------------------------------------

// StartFrom

// double float = 1;
inline bool StartFrom::has_float_() const {
  return value_case() == kFloat;
}
inline void StartFrom::set_has_float_() {
  _impl_._oneof_case_[0] = kFloat;
}
inline void StartFrom::clear_float_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kFloat) {
    _impl_.value_.float__ = 0;
    clear_has_value();
  }
}
inline double StartFrom::float_() const {
  // @@protoc_insertion_point(field_get:qdrant.StartFrom.float)
  return _internal_float_();
}
inline void StartFrom::set_float_(double value) {
  if (value_case() != kFloat) {
    clear_value();
    set_has_float_();
  }
  _impl_.value_.float__ = value;
  // @@protoc_insertion_point(field_set:qdrant.StartFrom.float)
}
inline double StartFrom::_internal_float_() const {
  if (value_case() == kFloat) {
    return _impl_.value_.float__;
  }
  return 0;
}

// int64 integer = 2;
inline bool StartFrom::has_integer() const {
  return value_case() == kInteger;
}
inline void StartFrom::set_has_integer() {
  _impl_._oneof_case_[0] = kInteger;
}
inline void StartFrom::clear_integer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kInteger) {
    _impl_.value_.integer_ = ::int64_t{0};
    clear_has_value();
  }
}
inline ::int64_t StartFrom::integer() const {
  // @@protoc_insertion_point(field_get:qdrant.StartFrom.integer)
  return _internal_integer();
}
inline void StartFrom::set_integer(::int64_t value) {
  if (value_case() != kInteger) {
    clear_value();
    set_has_integer();
  }
  _impl_.value_.integer_ = value;
  // @@protoc_insertion_point(field_set:qdrant.StartFrom.integer)
}
inline ::int64_t StartFrom::_internal_integer() const {
  if (value_case() == kInteger) {
    return _impl_.value_.integer_;
  }
  return ::int64_t{0};
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool StartFrom::has_timestamp() const {
  return value_case() == kTimestamp;
}
inline bool StartFrom::_internal_has_timestamp() const {
  return value_case() == kTimestamp;
}
inline void StartFrom::set_has_timestamp() {
  _impl_._oneof_case_[0] = kTimestamp;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE StartFrom::release_timestamp() {
  // @@protoc_insertion_point(field_release:qdrant.StartFrom.timestamp)
  if (value_case() == kTimestamp) {
    clear_has_value();
    auto* temp = _impl_.value_.timestamp_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.timestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Timestamp& StartFrom::_internal_timestamp() const {
  return value_case() == kTimestamp ? static_cast<const ::google::protobuf::Timestamp&>(*_impl_.value_.timestamp_)
                     : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& StartFrom::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.StartFrom.timestamp)
  return _internal_timestamp();
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE StartFrom::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.StartFrom.timestamp)
  if (value_case() == kTimestamp) {
    clear_has_value();
    auto* temp = _impl_.value_.timestamp_;
    _impl_.value_.timestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StartFrom::unsafe_arena_set_allocated_timestamp(
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_timestamp();
    _impl_.value_.timestamp_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.StartFrom.timestamp)
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL StartFrom::_internal_mutable_timestamp() {
  if (value_case() != kTimestamp) {
    clear_value();
    set_has_timestamp();
    _impl_.value_.timestamp_ = 
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
  }
  return _impl_.value_.timestamp_;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL StartFrom::mutable_timestamp()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:qdrant.StartFrom.timestamp)
  return _msg;
}

// string datetime = 4;
inline bool StartFrom::has_datetime() const {
  return value_case() == kDatetime;
}
inline void StartFrom::set_has_datetime() {
  _impl_._oneof_case_[0] = kDatetime;
}
inline void StartFrom::clear_datetime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kDatetime) {
    _impl_.value_.datetime_.Destroy();
    clear_has_value();
  }
}
inline const ::std::string& StartFrom::datetime() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.StartFrom.datetime)
  return _internal_datetime();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StartFrom::set_datetime(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() != kDatetime) {
    clear_value();

    set_has_datetime();
    _impl_.value_.datetime_.InitDefault();
  }
  _impl_.value_.datetime_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.StartFrom.datetime)
}
inline ::std::string* PROTOBUF_NONNULL StartFrom::mutable_datetime()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  if (value_case() != kDatetime) {
    clear_value();

    set_has_datetime();
    _impl_.value_.datetime_.InitDefault();
  }
  ::std::string* _s = _internal_mutable_datetime();
  // @@protoc_insertion_point(field_mutable:qdrant.StartFrom.datetime)
  return _s;
}
inline const ::std::string& StartFrom::_internal_datetime() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (value_case() != kDatetime) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.value_.datetime_.Get();
}
inline void StartFrom::_internal_set_datetime(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.datetime_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL StartFrom::_internal_mutable_datetime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.value_.datetime_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE StartFrom::release_datetime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.StartFrom.datetime)
  if (value_case() != kDatetime) {
    return nullptr;
  }
  clear_has_value();
  return _impl_.value_.datetime_.Release();
}
inline void StartFrom::set_allocated_datetime(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_value()) {
    clear_value();
  }
  if (value != nullptr) {
    set_has_datetime();
    _impl_.value_.datetime_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.StartFrom.datetime)
}

inline bool StartFrom::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void StartFrom::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline StartFrom::ValueCase StartFrom::value_case() const {
  return StartFrom::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OrderBy

// string key = 1;
inline void OrderBy::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& OrderBy::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.OrderBy.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void OrderBy::set_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.OrderBy.key)
}
inline ::std::string* PROTOBUF_NONNULL OrderBy::mutable_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:qdrant.OrderBy.key)
  return _s;
}
inline const ::std::string& OrderBy::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void OrderBy::_internal_set_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL OrderBy::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE OrderBy::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.OrderBy.key)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.key_.Set("", GetArena());
  }
  return released;
}
inline void OrderBy::set_allocated_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.OrderBy.key)
}

// optional .qdrant.Direction direction = 2;
inline bool OrderBy::has_direction() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void OrderBy::clear_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::qdrant::Direction OrderBy::direction() const {
  // @@protoc_insertion_point(field_get:qdrant.OrderBy.direction)
  return _internal_direction();
}
inline void OrderBy::set_direction(::qdrant::Direction value) {
  _internal_set_direction(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.OrderBy.direction)
}
inline ::qdrant::Direction OrderBy::_internal_direction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::Direction>(_impl_.direction_);
}
inline void OrderBy::_internal_set_direction(::qdrant::Direction value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_ = value;
}

// optional .qdrant.StartFrom start_from = 3;
inline bool OrderBy::has_start_from() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.start_from_ != nullptr);
  return value;
}
inline void OrderBy::clear_start_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.start_from_ != nullptr) _impl_.start_from_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::StartFrom& OrderBy::_internal_start_from() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::StartFrom* p = _impl_.start_from_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::StartFrom&>(::qdrant::_StartFrom_default_instance_);
}
inline const ::qdrant::StartFrom& OrderBy::start_from() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.OrderBy.start_from)
  return _internal_start_from();
}
inline void OrderBy::unsafe_arena_set_allocated_start_from(
    ::qdrant::StartFrom* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_from_);
  }
  _impl_.start_from_ = reinterpret_cast<::qdrant::StartFrom*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.OrderBy.start_from)
}
inline ::qdrant::StartFrom* PROTOBUF_NULLABLE OrderBy::release_start_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::StartFrom* released = _impl_.start_from_;
  _impl_.start_from_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::StartFrom* PROTOBUF_NULLABLE OrderBy::unsafe_arena_release_start_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.OrderBy.start_from)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::StartFrom* temp = _impl_.start_from_;
  _impl_.start_from_ = nullptr;
  return temp;
}
inline ::qdrant::StartFrom* PROTOBUF_NONNULL OrderBy::_internal_mutable_start_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.start_from_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::StartFrom>(GetArena());
    _impl_.start_from_ = reinterpret_cast<::qdrant::StartFrom*>(p);
  }
  return _impl_.start_from_;
}
inline ::qdrant::StartFrom* PROTOBUF_NONNULL OrderBy::mutable_start_from()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::StartFrom* _msg = _internal_mutable_start_from();
  // @@protoc_insertion_point(field_mutable:qdrant.OrderBy.start_from)
  return _msg;
}
inline void OrderBy::set_allocated_start_from(::qdrant::StartFrom* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_from_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.start_from_ = reinterpret_cast<::qdrant::StartFrom*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.OrderBy.start_from)
}

// -------------------------------------------------------------------

// ScrollPoints

// string collection_name = 1;
inline void ScrollPoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ScrollPoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ScrollPoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ScrollPoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.ScrollPoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL ScrollPoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.ScrollPoints.collection_name)
  return _s;
}
inline const ::std::string& ScrollPoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void ScrollPoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ScrollPoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ScrollPoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ScrollPoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void ScrollPoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.ScrollPoints.collection_name)
}

// .qdrant.Filter filter = 2;
inline bool ScrollPoints::has_filter() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void ScrollPoints::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Filter& ScrollPoints::_internal_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Filter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& ScrollPoints::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ScrollPoints.filter)
  return _internal_filter();
}
inline void ScrollPoints::unsafe_arena_set_allocated_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ScrollPoints.filter)
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE ScrollPoints::release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Filter* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE ScrollPoints::unsafe_arena_release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ScrollPoints.filter)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL ScrollPoints::_internal_mutable_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
    _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(p);
  }
  return _impl_.filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL ScrollPoints::mutable_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.ScrollPoints.filter)
  return _msg;
}
inline void ScrollPoints::set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ScrollPoints.filter)
}

// optional .qdrant.PointId offset = 3;
inline bool ScrollPoints::has_offset() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.offset_ != nullptr);
  return value;
}
inline void ScrollPoints::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.offset_ != nullptr) _impl_.offset_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::PointId& ScrollPoints::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointId* p = _impl_.offset_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointId&>(::qdrant::_PointId_default_instance_);
}
inline const ::qdrant::PointId& ScrollPoints::offset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ScrollPoints.offset)
  return _internal_offset();
}
inline void ScrollPoints::unsafe_arena_set_allocated_offset(
    ::qdrant::PointId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.offset_);
  }
  _impl_.offset_ = reinterpret_cast<::qdrant::PointId*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ScrollPoints.offset)
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE ScrollPoints::release_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::PointId* released = _impl_.offset_;
  _impl_.offset_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE ScrollPoints::unsafe_arena_release_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ScrollPoints.offset)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::PointId* temp = _impl_.offset_;
  _impl_.offset_ = nullptr;
  return temp;
}
inline ::qdrant::PointId* PROTOBUF_NONNULL ScrollPoints::_internal_mutable_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.offset_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointId>(GetArena());
    _impl_.offset_ = reinterpret_cast<::qdrant::PointId*>(p);
  }
  return _impl_.offset_;
}
inline ::qdrant::PointId* PROTOBUF_NONNULL ScrollPoints::mutable_offset()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::PointId* _msg = _internal_mutable_offset();
  // @@protoc_insertion_point(field_mutable:qdrant.ScrollPoints.offset)
  return _msg;
}
inline void ScrollPoints::set_allocated_offset(::qdrant::PointId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.offset_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.offset_ = reinterpret_cast<::qdrant::PointId*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ScrollPoints.offset)
}

// optional uint32 limit = 4;
inline bool ScrollPoints::has_limit() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000200U);
  return value;
}
inline void ScrollPoints::clear_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000200U);
}
inline ::uint32_t ScrollPoints::limit() const {
  // @@protoc_insertion_point(field_get:qdrant.ScrollPoints.limit)
  return _internal_limit();
}
inline void ScrollPoints::set_limit(::uint32_t value) {
  _internal_set_limit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  // @@protoc_insertion_point(field_set:qdrant.ScrollPoints.limit)
}
inline ::uint32_t ScrollPoints::_internal_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limit_;
}
inline void ScrollPoints::_internal_set_limit(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = value;
}

// .qdrant.WithPayloadSelector with_payload = 6;
inline bool ScrollPoints::has_with_payload() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.with_payload_ != nullptr);
  return value;
}
inline void ScrollPoints::clear_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ != nullptr) _impl_.with_payload_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::WithPayloadSelector& ScrollPoints::_internal_with_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithPayloadSelector* p = _impl_.with_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithPayloadSelector&>(::qdrant::_WithPayloadSelector_default_instance_);
}
inline const ::qdrant::WithPayloadSelector& ScrollPoints::with_payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ScrollPoints.with_payload)
  return _internal_with_payload();
}
inline void ScrollPoints::unsafe_arena_set_allocated_with_payload(
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }
  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ScrollPoints.with_payload)
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE ScrollPoints::release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WithPayloadSelector* released = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE ScrollPoints::unsafe_arena_release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ScrollPoints.with_payload)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WithPayloadSelector* temp = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  return temp;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL ScrollPoints::_internal_mutable_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithPayloadSelector>(GetArena());
    _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(p);
  }
  return _impl_.with_payload_;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL ScrollPoints::mutable_with_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WithPayloadSelector* _msg = _internal_mutable_with_payload();
  // @@protoc_insertion_point(field_mutable:qdrant.ScrollPoints.with_payload)
  return _msg;
}
inline void ScrollPoints::set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ScrollPoints.with_payload)
}

// optional .qdrant.WithVectorsSelector with_vectors = 7;
inline bool ScrollPoints::has_with_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.with_vectors_ != nullptr);
  return value;
}
inline void ScrollPoints::clear_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ != nullptr) _impl_.with_vectors_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::WithVectorsSelector& ScrollPoints::_internal_with_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithVectorsSelector* p = _impl_.with_vectors_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithVectorsSelector&>(::qdrant::_WithVectorsSelector_default_instance_);
}
inline const ::qdrant::WithVectorsSelector& ScrollPoints::with_vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ScrollPoints.with_vectors)
  return _internal_with_vectors();
}
inline void ScrollPoints::unsafe_arena_set_allocated_with_vectors(
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }
  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ScrollPoints.with_vectors)
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE ScrollPoints::release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::WithVectorsSelector* released = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE ScrollPoints::unsafe_arena_release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ScrollPoints.with_vectors)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::WithVectorsSelector* temp = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  return temp;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL ScrollPoints::_internal_mutable_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithVectorsSelector>(GetArena());
    _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(p);
  }
  return _impl_.with_vectors_;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL ScrollPoints::mutable_with_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::WithVectorsSelector* _msg = _internal_mutable_with_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.ScrollPoints.with_vectors)
  return _msg;
}
inline void ScrollPoints::set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ScrollPoints.with_vectors)
}

// optional .qdrant.ReadConsistency read_consistency = 8;
inline bool ScrollPoints::has_read_consistency() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.read_consistency_ != nullptr);
  return value;
}
inline void ScrollPoints::clear_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ != nullptr) _impl_.read_consistency_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::qdrant::ReadConsistency& ScrollPoints::_internal_read_consistency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ReadConsistency* p = _impl_.read_consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ReadConsistency&>(::qdrant::_ReadConsistency_default_instance_);
}
inline const ::qdrant::ReadConsistency& ScrollPoints::read_consistency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ScrollPoints.read_consistency)
  return _internal_read_consistency();
}
inline void ScrollPoints::unsafe_arena_set_allocated_read_consistency(
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }
  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ScrollPoints.read_consistency)
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE ScrollPoints::release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::ReadConsistency* released = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE ScrollPoints::unsafe_arena_release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ScrollPoints.read_consistency)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::ReadConsistency* temp = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  return temp;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL ScrollPoints::_internal_mutable_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ReadConsistency>(GetArena());
    _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(p);
  }
  return _impl_.read_consistency_;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL ScrollPoints::mutable_read_consistency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::ReadConsistency* _msg = _internal_mutable_read_consistency();
  // @@protoc_insertion_point(field_mutable:qdrant.ScrollPoints.read_consistency)
  return _msg;
}
inline void ScrollPoints::set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ScrollPoints.read_consistency)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 9;
inline bool ScrollPoints::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void ScrollPoints::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::qdrant::ShardKeySelector& ScrollPoints::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& ScrollPoints::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ScrollPoints.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void ScrollPoints::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ScrollPoints.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE ScrollPoints::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE ScrollPoints::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ScrollPoints.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL ScrollPoints::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL ScrollPoints::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.ScrollPoints.shard_key_selector)
  return _msg;
}
inline void ScrollPoints::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ScrollPoints.shard_key_selector)
}

// optional .qdrant.OrderBy order_by = 10;
inline bool ScrollPoints::has_order_by() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  PROTOBUF_ASSUME(!value || _impl_.order_by_ != nullptr);
  return value;
}
inline void ScrollPoints::clear_order_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.order_by_ != nullptr) _impl_.order_by_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline const ::qdrant::OrderBy& ScrollPoints::_internal_order_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::OrderBy* p = _impl_.order_by_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::OrderBy&>(::qdrant::_OrderBy_default_instance_);
}
inline const ::qdrant::OrderBy& ScrollPoints::order_by() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ScrollPoints.order_by)
  return _internal_order_by();
}
inline void ScrollPoints::unsafe_arena_set_allocated_order_by(
    ::qdrant::OrderBy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.order_by_);
  }
  _impl_.order_by_ = reinterpret_cast<::qdrant::OrderBy*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ScrollPoints.order_by)
}
inline ::qdrant::OrderBy* PROTOBUF_NULLABLE ScrollPoints::release_order_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::OrderBy* released = _impl_.order_by_;
  _impl_.order_by_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::OrderBy* PROTOBUF_NULLABLE ScrollPoints::unsafe_arena_release_order_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ScrollPoints.order_by)

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::OrderBy* temp = _impl_.order_by_;
  _impl_.order_by_ = nullptr;
  return temp;
}
inline ::qdrant::OrderBy* PROTOBUF_NONNULL ScrollPoints::_internal_mutable_order_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.order_by_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::OrderBy>(GetArena());
    _impl_.order_by_ = reinterpret_cast<::qdrant::OrderBy*>(p);
  }
  return _impl_.order_by_;
}
inline ::qdrant::OrderBy* PROTOBUF_NONNULL ScrollPoints::mutable_order_by()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::OrderBy* _msg = _internal_mutable_order_by();
  // @@protoc_insertion_point(field_mutable:qdrant.ScrollPoints.order_by)
  return _msg;
}
inline void ScrollPoints::set_allocated_order_by(::qdrant::OrderBy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.order_by_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }

  _impl_.order_by_ = reinterpret_cast<::qdrant::OrderBy*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ScrollPoints.order_by)
}

// optional uint64 timeout = 11;
inline bool ScrollPoints::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000100U);
  return value;
}
inline void ScrollPoints::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline ::uint64_t ScrollPoints::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.ScrollPoints.timeout)
  return _internal_timeout();
}
inline void ScrollPoints::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  // @@protoc_insertion_point(field_set:qdrant.ScrollPoints.timeout)
}
inline ::uint64_t ScrollPoints::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void ScrollPoints::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// -------------------------------------------------------------------

// LookupLocation

// string collection_name = 1;
inline void LookupLocation::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& LookupLocation::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.LookupLocation.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void LookupLocation::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.LookupLocation.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL LookupLocation::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.LookupLocation.collection_name)
  return _s;
}
inline const ::std::string& LookupLocation::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void LookupLocation::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL LookupLocation::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE LookupLocation::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.LookupLocation.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void LookupLocation::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.LookupLocation.collection_name)
}

// optional string vector_name = 2;
inline bool LookupLocation::has_vector_name() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void LookupLocation::clear_vector_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vector_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& LookupLocation::vector_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.LookupLocation.vector_name)
  return _internal_vector_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void LookupLocation::set_vector_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.vector_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.LookupLocation.vector_name)
}
inline ::std::string* PROTOBUF_NONNULL LookupLocation::mutable_vector_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_vector_name();
  // @@protoc_insertion_point(field_mutable:qdrant.LookupLocation.vector_name)
  return _s;
}
inline const ::std::string& LookupLocation::_internal_vector_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vector_name_.Get();
}
inline void LookupLocation::_internal_set_vector_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vector_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL LookupLocation::_internal_mutable_vector_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.vector_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE LookupLocation::release_vector_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.LookupLocation.vector_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.vector_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.vector_name_.Set("", GetArena());
  }
  return released;
}
inline void LookupLocation::set_allocated_vector_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.vector_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.vector_name_.IsDefault()) {
    _impl_.vector_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.LookupLocation.vector_name)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 3;
inline bool LookupLocation::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void LookupLocation::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::ShardKeySelector& LookupLocation::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& LookupLocation::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.LookupLocation.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void LookupLocation::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.LookupLocation.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE LookupLocation::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE LookupLocation::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.LookupLocation.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL LookupLocation::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL LookupLocation::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.LookupLocation.shard_key_selector)
  return _msg;
}
inline void LookupLocation::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.LookupLocation.shard_key_selector)
}

// -------------------------------------------------------------------

// RecommendPoints

// string collection_name = 1;
inline void RecommendPoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::std::string& RecommendPoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RecommendPoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.RecommendPoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL RecommendPoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPoints.collection_name)
  return _s;
}
inline const ::std::string& RecommendPoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void RecommendPoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RecommendPoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RecommendPoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000010U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void RecommendPoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPoints.collection_name)
}

// repeated .qdrant.PointId positive = 2;
inline int RecommendPoints::_internal_positive_size() const {
  return _internal_positive().size();
}
inline int RecommendPoints::positive_size() const {
  return _internal_positive_size();
}
inline void RecommendPoints::clear_positive() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.positive_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::PointId* PROTOBUF_NONNULL RecommendPoints::mutable_positive(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPoints.positive)
  return _internal_mutable_positive()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL RecommendPoints::mutable_positive()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.RecommendPoints.positive)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_positive();
}
inline const ::qdrant::PointId& RecommendPoints::positive(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.positive)
  return _internal_positive().Get(index);
}
inline ::qdrant::PointId* PROTOBUF_NONNULL RecommendPoints::add_positive()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::PointId* _add =
      _internal_mutable_positive()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.RecommendPoints.positive)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& RecommendPoints::positive() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.RecommendPoints.positive)
  return _internal_positive();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>&
RecommendPoints::_internal_positive() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.positive_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL
RecommendPoints::_internal_mutable_positive() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.positive_;
}

// repeated .qdrant.PointId negative = 3;
inline int RecommendPoints::_internal_negative_size() const {
  return _internal_negative().size();
}
inline int RecommendPoints::negative_size() const {
  return _internal_negative_size();
}
inline void RecommendPoints::clear_negative() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.negative_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::qdrant::PointId* PROTOBUF_NONNULL RecommendPoints::mutable_negative(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPoints.negative)
  return _internal_mutable_negative()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL RecommendPoints::mutable_negative()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.RecommendPoints.negative)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_negative();
}
inline const ::qdrant::PointId& RecommendPoints::negative(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.negative)
  return _internal_negative().Get(index);
}
inline ::qdrant::PointId* PROTOBUF_NONNULL RecommendPoints::add_negative()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::PointId* _add =
      _internal_mutable_negative()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:qdrant.RecommendPoints.negative)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& RecommendPoints::negative() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.RecommendPoints.negative)
  return _internal_negative();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>&
RecommendPoints::_internal_negative() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.negative_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL
RecommendPoints::_internal_mutable_negative() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.negative_;
}

// .qdrant.Filter filter = 4;
inline bool RecommendPoints::has_filter() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void RecommendPoints::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::qdrant::Filter& RecommendPoints::_internal_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Filter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& RecommendPoints::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.filter)
  return _internal_filter();
}
inline void RecommendPoints::unsafe_arena_set_allocated_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendPoints.filter)
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE RecommendPoints::release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::Filter* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE RecommendPoints::unsafe_arena_release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPoints.filter)

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL RecommendPoints::_internal_mutable_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
    _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(p);
  }
  return _impl_.filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL RecommendPoints::mutable_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPoints.filter)
  return _msg;
}
inline void RecommendPoints::set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }

  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPoints.filter)
}

// uint64 limit = 5;
inline void RecommendPoints::clear_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00002000U);
}
inline ::uint64_t RecommendPoints::limit() const {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.limit)
  return _internal_limit();
}
inline void RecommendPoints::set_limit(::uint64_t value) {
  _internal_set_limit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00002000U);
  // @@protoc_insertion_point(field_set:qdrant.RecommendPoints.limit)
}
inline ::uint64_t RecommendPoints::_internal_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limit_;
}
inline void RecommendPoints::_internal_set_limit(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = value;
}

// .qdrant.WithPayloadSelector with_payload = 7;
inline bool RecommendPoints::has_with_payload() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  PROTOBUF_ASSUME(!value || _impl_.with_payload_ != nullptr);
  return value;
}
inline void RecommendPoints::clear_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ != nullptr) _impl_.with_payload_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline const ::qdrant::WithPayloadSelector& RecommendPoints::_internal_with_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithPayloadSelector* p = _impl_.with_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithPayloadSelector&>(::qdrant::_WithPayloadSelector_default_instance_);
}
inline const ::qdrant::WithPayloadSelector& RecommendPoints::with_payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.with_payload)
  return _internal_with_payload();
}
inline void RecommendPoints::unsafe_arena_set_allocated_with_payload(
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }
  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendPoints.with_payload)
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE RecommendPoints::release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::WithPayloadSelector* released = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE RecommendPoints::unsafe_arena_release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPoints.with_payload)

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::WithPayloadSelector* temp = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  return temp;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL RecommendPoints::_internal_mutable_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithPayloadSelector>(GetArena());
    _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(p);
  }
  return _impl_.with_payload_;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL RecommendPoints::mutable_with_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::WithPayloadSelector* _msg = _internal_mutable_with_payload();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPoints.with_payload)
  return _msg;
}
inline void RecommendPoints::set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }

  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPoints.with_payload)
}

// .qdrant.SearchParams params = 8;
inline bool RecommendPoints::has_params() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000100U);
  PROTOBUF_ASSUME(!value || _impl_.params_ != nullptr);
  return value;
}
inline void RecommendPoints::clear_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ != nullptr) _impl_.params_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline const ::qdrant::SearchParams& RecommendPoints::_internal_params() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SearchParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SearchParams&>(::qdrant::_SearchParams_default_instance_);
}
inline const ::qdrant::SearchParams& RecommendPoints::params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.params)
  return _internal_params();
}
inline void RecommendPoints::unsafe_arena_set_allocated_params(
    ::qdrant::SearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendPoints.params)
}
inline ::qdrant::SearchParams* PROTOBUF_NULLABLE RecommendPoints::release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::SearchParams* released = _impl_.params_;
  _impl_.params_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SearchParams* PROTOBUF_NULLABLE RecommendPoints::unsafe_arena_release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPoints.params)

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::SearchParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::qdrant::SearchParams* PROTOBUF_NONNULL RecommendPoints::_internal_mutable_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SearchParams>(GetArena());
    _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(p);
  }
  return _impl_.params_;
}
inline ::qdrant::SearchParams* PROTOBUF_NONNULL RecommendPoints::mutable_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::SearchParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPoints.params)
  return _msg;
}
inline void RecommendPoints::set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }

  _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPoints.params)
}

// optional float score_threshold = 9;
inline bool RecommendPoints::has_score_threshold() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00008000U);
  return value;
}
inline void RecommendPoints::clear_score_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_threshold_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00008000U);
}
inline float RecommendPoints::score_threshold() const {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.score_threshold)
  return _internal_score_threshold();
}
inline void RecommendPoints::set_score_threshold(float value) {
  _internal_set_score_threshold(value);
  SetHasBit(_impl_._has_bits_[0], 0x00008000U);
  // @@protoc_insertion_point(field_set:qdrant.RecommendPoints.score_threshold)
}
inline float RecommendPoints::_internal_score_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.score_threshold_;
}
inline void RecommendPoints::_internal_set_score_threshold(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_threshold_ = value;
}

// optional uint64 offset = 10;
inline bool RecommendPoints::has_offset() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00004000U);
  return value;
}
inline void RecommendPoints::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00004000U);
}
inline ::uint64_t RecommendPoints::offset() const {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.offset)
  return _internal_offset();
}
inline void RecommendPoints::set_offset(::uint64_t value) {
  _internal_set_offset(value);
  SetHasBit(_impl_._has_bits_[0], 0x00004000U);
  // @@protoc_insertion_point(field_set:qdrant.RecommendPoints.offset)
}
inline ::uint64_t RecommendPoints::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_;
}
inline void RecommendPoints::_internal_set_offset(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = value;
}

// optional string using = 11;
inline bool RecommendPoints::has_using_() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void RecommendPoints::clear_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.using__.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::std::string& RecommendPoints::using_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.using)
  return _internal_using_();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RecommendPoints::set_using_(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  _impl_.using__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.RecommendPoints.using)
}
inline ::std::string* PROTOBUF_NONNULL RecommendPoints::mutable_using_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::std::string* _s = _internal_mutable_using_();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPoints.using)
  return _s;
}
inline const ::std::string& RecommendPoints::_internal_using_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.using__.Get();
}
inline void RecommendPoints::_internal_set_using_(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.using__.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RecommendPoints::_internal_mutable_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.using__.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RecommendPoints::release_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPoints.using)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000020U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  auto* released = _impl_.using__.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.using__.Set("", GetArena());
  }
  return released;
}
inline void RecommendPoints::set_allocated_using_(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  _impl_.using__.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.using__.IsDefault()) {
    _impl_.using__.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPoints.using)
}

// optional .qdrant.WithVectorsSelector with_vectors = 12;
inline bool RecommendPoints::has_with_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000200U);
  PROTOBUF_ASSUME(!value || _impl_.with_vectors_ != nullptr);
  return value;
}
inline void RecommendPoints::clear_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ != nullptr) _impl_.with_vectors_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000200U);
}
inline const ::qdrant::WithVectorsSelector& RecommendPoints::_internal_with_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithVectorsSelector* p = _impl_.with_vectors_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithVectorsSelector&>(::qdrant::_WithVectorsSelector_default_instance_);
}
inline const ::qdrant::WithVectorsSelector& RecommendPoints::with_vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.with_vectors)
  return _internal_with_vectors();
}
inline void RecommendPoints::unsafe_arena_set_allocated_with_vectors(
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }
  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendPoints.with_vectors)
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE RecommendPoints::release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::WithVectorsSelector* released = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE RecommendPoints::unsafe_arena_release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPoints.with_vectors)

  ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::WithVectorsSelector* temp = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  return temp;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL RecommendPoints::_internal_mutable_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithVectorsSelector>(GetArena());
    _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(p);
  }
  return _impl_.with_vectors_;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL RecommendPoints::mutable_with_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::WithVectorsSelector* _msg = _internal_mutable_with_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPoints.with_vectors)
  return _msg;
}
inline void RecommendPoints::set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  }

  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPoints.with_vectors)
}

// optional .qdrant.LookupLocation lookup_from = 13;
inline bool RecommendPoints::has_lookup_from() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000400U);
  PROTOBUF_ASSUME(!value || _impl_.lookup_from_ != nullptr);
  return value;
}
inline void RecommendPoints::clear_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lookup_from_ != nullptr) _impl_.lookup_from_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000400U);
}
inline const ::qdrant::LookupLocation& RecommendPoints::_internal_lookup_from() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::LookupLocation* p = _impl_.lookup_from_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::LookupLocation&>(::qdrant::_LookupLocation_default_instance_);
}
inline const ::qdrant::LookupLocation& RecommendPoints::lookup_from() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.lookup_from)
  return _internal_lookup_from();
}
inline void RecommendPoints::unsafe_arena_set_allocated_lookup_from(
    ::qdrant::LookupLocation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lookup_from_);
  }
  _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendPoints.lookup_from)
}
inline ::qdrant::LookupLocation* PROTOBUF_NULLABLE RecommendPoints::release_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::LookupLocation* released = _impl_.lookup_from_;
  _impl_.lookup_from_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::LookupLocation* PROTOBUF_NULLABLE RecommendPoints::unsafe_arena_release_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPoints.lookup_from)

  ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::LookupLocation* temp = _impl_.lookup_from_;
  _impl_.lookup_from_ = nullptr;
  return temp;
}
inline ::qdrant::LookupLocation* PROTOBUF_NONNULL RecommendPoints::_internal_mutable_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lookup_from_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::LookupLocation>(GetArena());
    _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(p);
  }
  return _impl_.lookup_from_;
}
inline ::qdrant::LookupLocation* PROTOBUF_NONNULL RecommendPoints::mutable_lookup_from()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::LookupLocation* _msg = _internal_mutable_lookup_from();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPoints.lookup_from)
  return _msg;
}
inline void RecommendPoints::set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lookup_from_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  }

  _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPoints.lookup_from)
}

// optional .qdrant.ReadConsistency read_consistency = 14;
inline bool RecommendPoints::has_read_consistency() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000800U);
  PROTOBUF_ASSUME(!value || _impl_.read_consistency_ != nullptr);
  return value;
}
inline void RecommendPoints::clear_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ != nullptr) _impl_.read_consistency_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000800U);
}
inline const ::qdrant::ReadConsistency& RecommendPoints::_internal_read_consistency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ReadConsistency* p = _impl_.read_consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ReadConsistency&>(::qdrant::_ReadConsistency_default_instance_);
}
inline const ::qdrant::ReadConsistency& RecommendPoints::read_consistency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.read_consistency)
  return _internal_read_consistency();
}
inline void RecommendPoints::unsafe_arena_set_allocated_read_consistency(
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }
  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000800U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendPoints.read_consistency)
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE RecommendPoints::release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000800U);
  ::qdrant::ReadConsistency* released = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE RecommendPoints::unsafe_arena_release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPoints.read_consistency)

  ClearHasBit(_impl_._has_bits_[0], 0x00000800U);
  ::qdrant::ReadConsistency* temp = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  return temp;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL RecommendPoints::_internal_mutable_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ReadConsistency>(GetArena());
    _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(p);
  }
  return _impl_.read_consistency_;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL RecommendPoints::mutable_read_consistency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  ::qdrant::ReadConsistency* _msg = _internal_mutable_read_consistency();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPoints.read_consistency)
  return _msg;
}
inline void RecommendPoints::set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000800U);
  }

  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPoints.read_consistency)
}

// optional .qdrant.RecommendStrategy strategy = 16;
inline bool RecommendPoints::has_strategy() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00010000U);
  return value;
}
inline void RecommendPoints::clear_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategy_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00010000U);
}
inline ::qdrant::RecommendStrategy RecommendPoints::strategy() const {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.strategy)
  return _internal_strategy();
}
inline void RecommendPoints::set_strategy(::qdrant::RecommendStrategy value) {
  _internal_set_strategy(value);
  SetHasBit(_impl_._has_bits_[0], 0x00010000U);
  // @@protoc_insertion_point(field_set:qdrant.RecommendPoints.strategy)
}
inline ::qdrant::RecommendStrategy RecommendPoints::_internal_strategy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::RecommendStrategy>(_impl_.strategy_);
}
inline void RecommendPoints::_internal_set_strategy(::qdrant::RecommendStrategy value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategy_ = value;
}

// repeated .qdrant.Vector positive_vectors = 17;
inline int RecommendPoints::_internal_positive_vectors_size() const {
  return _internal_positive_vectors().size();
}
inline int RecommendPoints::positive_vectors_size() const {
  return _internal_positive_vectors_size();
}
inline void RecommendPoints::clear_positive_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.positive_vectors_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::qdrant::Vector* PROTOBUF_NONNULL RecommendPoints::mutable_positive_vectors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPoints.positive_vectors)
  return _internal_mutable_positive_vectors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Vector>* PROTOBUF_NONNULL RecommendPoints::mutable_positive_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.RecommendPoints.positive_vectors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_positive_vectors();
}
inline const ::qdrant::Vector& RecommendPoints::positive_vectors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.positive_vectors)
  return _internal_positive_vectors().Get(index);
}
inline ::qdrant::Vector* PROTOBUF_NONNULL RecommendPoints::add_positive_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::Vector* _add =
      _internal_mutable_positive_vectors()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:qdrant.RecommendPoints.positive_vectors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Vector>& RecommendPoints::positive_vectors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.RecommendPoints.positive_vectors)
  return _internal_positive_vectors();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Vector>&
RecommendPoints::_internal_positive_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.positive_vectors_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Vector>* PROTOBUF_NONNULL
RecommendPoints::_internal_mutable_positive_vectors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.positive_vectors_;
}

// repeated .qdrant.Vector negative_vectors = 18;
inline int RecommendPoints::_internal_negative_vectors_size() const {
  return _internal_negative_vectors().size();
}
inline int RecommendPoints::negative_vectors_size() const {
  return _internal_negative_vectors_size();
}
inline void RecommendPoints::clear_negative_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.negative_vectors_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::qdrant::Vector* PROTOBUF_NONNULL RecommendPoints::mutable_negative_vectors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPoints.negative_vectors)
  return _internal_mutable_negative_vectors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Vector>* PROTOBUF_NONNULL RecommendPoints::mutable_negative_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.RecommendPoints.negative_vectors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_negative_vectors();
}
inline const ::qdrant::Vector& RecommendPoints::negative_vectors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.negative_vectors)
  return _internal_negative_vectors().Get(index);
}
inline ::qdrant::Vector* PROTOBUF_NONNULL RecommendPoints::add_negative_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::Vector* _add =
      _internal_mutable_negative_vectors()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_add:qdrant.RecommendPoints.negative_vectors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Vector>& RecommendPoints::negative_vectors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.RecommendPoints.negative_vectors)
  return _internal_negative_vectors();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Vector>&
RecommendPoints::_internal_negative_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.negative_vectors_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Vector>* PROTOBUF_NONNULL
RecommendPoints::_internal_mutable_negative_vectors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.negative_vectors_;
}

// optional uint64 timeout = 19;
inline bool RecommendPoints::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00020000U);
  return value;
}
inline void RecommendPoints::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00020000U);
}
inline ::uint64_t RecommendPoints::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.timeout)
  return _internal_timeout();
}
inline void RecommendPoints::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00020000U);
  // @@protoc_insertion_point(field_set:qdrant.RecommendPoints.timeout)
}
inline ::uint64_t RecommendPoints::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void RecommendPoints::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// optional .qdrant.ShardKeySelector shard_key_selector = 20;
inline bool RecommendPoints::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00001000U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void RecommendPoints::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00001000U);
}
inline const ::qdrant::ShardKeySelector& RecommendPoints::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& RecommendPoints::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPoints.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void RecommendPoints::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00001000U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00001000U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendPoints.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE RecommendPoints::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00001000U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE RecommendPoints::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPoints.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00001000U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL RecommendPoints::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL RecommendPoints::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00001000U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPoints.shard_key_selector)
  return _msg;
}
inline void RecommendPoints::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00001000U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00001000U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPoints.shard_key_selector)
}

// -------------------------------------------------------------------

// RecommendBatchPoints

// string collection_name = 1;
inline void RecommendBatchPoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& RecommendBatchPoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendBatchPoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RecommendBatchPoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.RecommendBatchPoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL RecommendBatchPoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendBatchPoints.collection_name)
  return _s;
}
inline const ::std::string& RecommendBatchPoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void RecommendBatchPoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RecommendBatchPoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RecommendBatchPoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendBatchPoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void RecommendBatchPoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendBatchPoints.collection_name)
}

// repeated .qdrant.RecommendPoints recommend_points = 2;
inline int RecommendBatchPoints::_internal_recommend_points_size() const {
  return _internal_recommend_points().size();
}
inline int RecommendBatchPoints::recommend_points_size() const {
  return _internal_recommend_points_size();
}
inline void RecommendBatchPoints::clear_recommend_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recommend_points_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::RecommendPoints* PROTOBUF_NONNULL RecommendBatchPoints::mutable_recommend_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendBatchPoints.recommend_points)
  return _internal_mutable_recommend_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::RecommendPoints>* PROTOBUF_NONNULL RecommendBatchPoints::mutable_recommend_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.RecommendBatchPoints.recommend_points)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_recommend_points();
}
inline const ::qdrant::RecommendPoints& RecommendBatchPoints::recommend_points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendBatchPoints.recommend_points)
  return _internal_recommend_points().Get(index);
}
inline ::qdrant::RecommendPoints* PROTOBUF_NONNULL RecommendBatchPoints::add_recommend_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::RecommendPoints* _add =
      _internal_mutable_recommend_points()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.RecommendBatchPoints.recommend_points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::RecommendPoints>& RecommendBatchPoints::recommend_points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.RecommendBatchPoints.recommend_points)
  return _internal_recommend_points();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::RecommendPoints>&
RecommendBatchPoints::_internal_recommend_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recommend_points_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::RecommendPoints>* PROTOBUF_NONNULL
RecommendBatchPoints::_internal_mutable_recommend_points() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.recommend_points_;
}

// optional .qdrant.ReadConsistency read_consistency = 3;
inline bool RecommendBatchPoints::has_read_consistency() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.read_consistency_ != nullptr);
  return value;
}
inline void RecommendBatchPoints::clear_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ != nullptr) _impl_.read_consistency_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::ReadConsistency& RecommendBatchPoints::_internal_read_consistency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ReadConsistency* p = _impl_.read_consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ReadConsistency&>(::qdrant::_ReadConsistency_default_instance_);
}
inline const ::qdrant::ReadConsistency& RecommendBatchPoints::read_consistency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendBatchPoints.read_consistency)
  return _internal_read_consistency();
}
inline void RecommendBatchPoints::unsafe_arena_set_allocated_read_consistency(
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }
  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendBatchPoints.read_consistency)
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE RecommendBatchPoints::release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ReadConsistency* released = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE RecommendBatchPoints::unsafe_arena_release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendBatchPoints.read_consistency)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ReadConsistency* temp = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  return temp;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL RecommendBatchPoints::_internal_mutable_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ReadConsistency>(GetArena());
    _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(p);
  }
  return _impl_.read_consistency_;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL RecommendBatchPoints::mutable_read_consistency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ReadConsistency* _msg = _internal_mutable_read_consistency();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendBatchPoints.read_consistency)
  return _msg;
}
inline void RecommendBatchPoints::set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendBatchPoints.read_consistency)
}

// optional uint64 timeout = 4;
inline bool RecommendBatchPoints::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void RecommendBatchPoints::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint64_t RecommendBatchPoints::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.RecommendBatchPoints.timeout)
  return _internal_timeout();
}
inline void RecommendBatchPoints::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.RecommendBatchPoints.timeout)
}
inline ::uint64_t RecommendBatchPoints::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void RecommendBatchPoints::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// -------------------------------------------------------------------

// RecommendPointGroups

// string collection_name = 1;
inline void RecommendPointGroups::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::std::string& RecommendPointGroups::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RecommendPointGroups::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.RecommendPointGroups.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL RecommendPointGroups::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPointGroups.collection_name)
  return _s;
}
inline const ::std::string& RecommendPointGroups::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void RecommendPointGroups::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RecommendPointGroups::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RecommendPointGroups::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPointGroups.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000010U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void RecommendPointGroups::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPointGroups.collection_name)
}

// repeated .qdrant.PointId positive = 2;
inline int RecommendPointGroups::_internal_positive_size() const {
  return _internal_positive().size();
}
inline int RecommendPointGroups::positive_size() const {
  return _internal_positive_size();
}
inline void RecommendPointGroups::clear_positive() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.positive_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::PointId* PROTOBUF_NONNULL RecommendPointGroups::mutable_positive(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPointGroups.positive)
  return _internal_mutable_positive()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL RecommendPointGroups::mutable_positive()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.RecommendPointGroups.positive)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_positive();
}
inline const ::qdrant::PointId& RecommendPointGroups::positive(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.positive)
  return _internal_positive().Get(index);
}
inline ::qdrant::PointId* PROTOBUF_NONNULL RecommendPointGroups::add_positive()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::PointId* _add =
      _internal_mutable_positive()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.RecommendPointGroups.positive)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& RecommendPointGroups::positive() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.RecommendPointGroups.positive)
  return _internal_positive();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>&
RecommendPointGroups::_internal_positive() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.positive_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL
RecommendPointGroups::_internal_mutable_positive() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.positive_;
}

// repeated .qdrant.PointId negative = 3;
inline int RecommendPointGroups::_internal_negative_size() const {
  return _internal_negative().size();
}
inline int RecommendPointGroups::negative_size() const {
  return _internal_negative_size();
}
inline void RecommendPointGroups::clear_negative() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.negative_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::qdrant::PointId* PROTOBUF_NONNULL RecommendPointGroups::mutable_negative(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPointGroups.negative)
  return _internal_mutable_negative()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL RecommendPointGroups::mutable_negative()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.RecommendPointGroups.negative)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_negative();
}
inline const ::qdrant::PointId& RecommendPointGroups::negative(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.negative)
  return _internal_negative().Get(index);
}
inline ::qdrant::PointId* PROTOBUF_NONNULL RecommendPointGroups::add_negative()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::PointId* _add =
      _internal_mutable_negative()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:qdrant.RecommendPointGroups.negative)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& RecommendPointGroups::negative() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.RecommendPointGroups.negative)
  return _internal_negative();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>&
RecommendPointGroups::_internal_negative() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.negative_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL
RecommendPointGroups::_internal_mutable_negative() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.negative_;
}

// .qdrant.Filter filter = 4;
inline bool RecommendPointGroups::has_filter() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void RecommendPointGroups::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline const ::qdrant::Filter& RecommendPointGroups::_internal_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Filter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& RecommendPointGroups::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.filter)
  return _internal_filter();
}
inline void RecommendPointGroups::unsafe_arena_set_allocated_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendPointGroups.filter)
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE RecommendPointGroups::release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::Filter* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE RecommendPointGroups::unsafe_arena_release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPointGroups.filter)

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL RecommendPointGroups::_internal_mutable_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
    _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(p);
  }
  return _impl_.filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL RecommendPointGroups::mutable_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPointGroups.filter)
  return _msg;
}
inline void RecommendPointGroups::set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }

  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPointGroups.filter)
}

// uint32 limit = 5;
inline void RecommendPointGroups::clear_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00008000U);
}
inline ::uint32_t RecommendPointGroups::limit() const {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.limit)
  return _internal_limit();
}
inline void RecommendPointGroups::set_limit(::uint32_t value) {
  _internal_set_limit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00008000U);
  // @@protoc_insertion_point(field_set:qdrant.RecommendPointGroups.limit)
}
inline ::uint32_t RecommendPointGroups::_internal_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limit_;
}
inline void RecommendPointGroups::_internal_set_limit(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = value;
}

// .qdrant.WithPayloadSelector with_payload = 6;
inline bool RecommendPointGroups::has_with_payload() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000100U);
  PROTOBUF_ASSUME(!value || _impl_.with_payload_ != nullptr);
  return value;
}
inline void RecommendPointGroups::clear_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ != nullptr) _impl_.with_payload_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline const ::qdrant::WithPayloadSelector& RecommendPointGroups::_internal_with_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithPayloadSelector* p = _impl_.with_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithPayloadSelector&>(::qdrant::_WithPayloadSelector_default_instance_);
}
inline const ::qdrant::WithPayloadSelector& RecommendPointGroups::with_payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.with_payload)
  return _internal_with_payload();
}
inline void RecommendPointGroups::unsafe_arena_set_allocated_with_payload(
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }
  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendPointGroups.with_payload)
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE RecommendPointGroups::release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::WithPayloadSelector* released = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE RecommendPointGroups::unsafe_arena_release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPointGroups.with_payload)

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::WithPayloadSelector* temp = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  return temp;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL RecommendPointGroups::_internal_mutable_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithPayloadSelector>(GetArena());
    _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(p);
  }
  return _impl_.with_payload_;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL RecommendPointGroups::mutable_with_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::WithPayloadSelector* _msg = _internal_mutable_with_payload();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPointGroups.with_payload)
  return _msg;
}
inline void RecommendPointGroups::set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }

  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPointGroups.with_payload)
}

// .qdrant.SearchParams params = 7;
inline bool RecommendPointGroups::has_params() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000200U);
  PROTOBUF_ASSUME(!value || _impl_.params_ != nullptr);
  return value;
}
inline void RecommendPointGroups::clear_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ != nullptr) _impl_.params_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000200U);
}
inline const ::qdrant::SearchParams& RecommendPointGroups::_internal_params() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SearchParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SearchParams&>(::qdrant::_SearchParams_default_instance_);
}
inline const ::qdrant::SearchParams& RecommendPointGroups::params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.params)
  return _internal_params();
}
inline void RecommendPointGroups::unsafe_arena_set_allocated_params(
    ::qdrant::SearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendPointGroups.params)
}
inline ::qdrant::SearchParams* PROTOBUF_NULLABLE RecommendPointGroups::release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::SearchParams* released = _impl_.params_;
  _impl_.params_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SearchParams* PROTOBUF_NULLABLE RecommendPointGroups::unsafe_arena_release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPointGroups.params)

  ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::SearchParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::qdrant::SearchParams* PROTOBUF_NONNULL RecommendPointGroups::_internal_mutable_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SearchParams>(GetArena());
    _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(p);
  }
  return _impl_.params_;
}
inline ::qdrant::SearchParams* PROTOBUF_NONNULL RecommendPointGroups::mutable_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::SearchParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPointGroups.params)
  return _msg;
}
inline void RecommendPointGroups::set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  }

  _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPointGroups.params)
}

// optional float score_threshold = 8;
inline bool RecommendPointGroups::has_score_threshold() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00010000U);
  return value;
}
inline void RecommendPointGroups::clear_score_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_threshold_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00010000U);
}
inline float RecommendPointGroups::score_threshold() const {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.score_threshold)
  return _internal_score_threshold();
}
inline void RecommendPointGroups::set_score_threshold(float value) {
  _internal_set_score_threshold(value);
  SetHasBit(_impl_._has_bits_[0], 0x00010000U);
  // @@protoc_insertion_point(field_set:qdrant.RecommendPointGroups.score_threshold)
}
inline float RecommendPointGroups::_internal_score_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.score_threshold_;
}
inline void RecommendPointGroups::_internal_set_score_threshold(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_threshold_ = value;
}

// optional string using = 9;
inline bool RecommendPointGroups::has_using_() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void RecommendPointGroups::clear_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.using__.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::std::string& RecommendPointGroups::using_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.using)
  return _internal_using_();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RecommendPointGroups::set_using_(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  _impl_.using__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.RecommendPointGroups.using)
}
inline ::std::string* PROTOBUF_NONNULL RecommendPointGroups::mutable_using_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::std::string* _s = _internal_mutable_using_();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPointGroups.using)
  return _s;
}
inline const ::std::string& RecommendPointGroups::_internal_using_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.using__.Get();
}
inline void RecommendPointGroups::_internal_set_using_(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.using__.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RecommendPointGroups::_internal_mutable_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.using__.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RecommendPointGroups::release_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPointGroups.using)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000020U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  auto* released = _impl_.using__.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.using__.Set("", GetArena());
  }
  return released;
}
inline void RecommendPointGroups::set_allocated_using_(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  _impl_.using__.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.using__.IsDefault()) {
    _impl_.using__.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPointGroups.using)
}

// optional .qdrant.WithVectorsSelector with_vectors = 10;
inline bool RecommendPointGroups::has_with_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000400U);
  PROTOBUF_ASSUME(!value || _impl_.with_vectors_ != nullptr);
  return value;
}
inline void RecommendPointGroups::clear_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ != nullptr) _impl_.with_vectors_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000400U);
}
inline const ::qdrant::WithVectorsSelector& RecommendPointGroups::_internal_with_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithVectorsSelector* p = _impl_.with_vectors_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithVectorsSelector&>(::qdrant::_WithVectorsSelector_default_instance_);
}
inline const ::qdrant::WithVectorsSelector& RecommendPointGroups::with_vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.with_vectors)
  return _internal_with_vectors();
}
inline void RecommendPointGroups::unsafe_arena_set_allocated_with_vectors(
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }
  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendPointGroups.with_vectors)
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE RecommendPointGroups::release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::WithVectorsSelector* released = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE RecommendPointGroups::unsafe_arena_release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPointGroups.with_vectors)

  ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::WithVectorsSelector* temp = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  return temp;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL RecommendPointGroups::_internal_mutable_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithVectorsSelector>(GetArena());
    _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(p);
  }
  return _impl_.with_vectors_;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL RecommendPointGroups::mutable_with_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::WithVectorsSelector* _msg = _internal_mutable_with_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPointGroups.with_vectors)
  return _msg;
}
inline void RecommendPointGroups::set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  }

  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPointGroups.with_vectors)
}

// optional .qdrant.LookupLocation lookup_from = 11;
inline bool RecommendPointGroups::has_lookup_from() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000800U);
  PROTOBUF_ASSUME(!value || _impl_.lookup_from_ != nullptr);
  return value;
}
inline void RecommendPointGroups::clear_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lookup_from_ != nullptr) _impl_.lookup_from_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000800U);
}
inline const ::qdrant::LookupLocation& RecommendPointGroups::_internal_lookup_from() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::LookupLocation* p = _impl_.lookup_from_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::LookupLocation&>(::qdrant::_LookupLocation_default_instance_);
}
inline const ::qdrant::LookupLocation& RecommendPointGroups::lookup_from() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.lookup_from)
  return _internal_lookup_from();
}
inline void RecommendPointGroups::unsafe_arena_set_allocated_lookup_from(
    ::qdrant::LookupLocation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lookup_from_);
  }
  _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000800U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendPointGroups.lookup_from)
}
inline ::qdrant::LookupLocation* PROTOBUF_NULLABLE RecommendPointGroups::release_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000800U);
  ::qdrant::LookupLocation* released = _impl_.lookup_from_;
  _impl_.lookup_from_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::LookupLocation* PROTOBUF_NULLABLE RecommendPointGroups::unsafe_arena_release_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPointGroups.lookup_from)

  ClearHasBit(_impl_._has_bits_[0], 0x00000800U);
  ::qdrant::LookupLocation* temp = _impl_.lookup_from_;
  _impl_.lookup_from_ = nullptr;
  return temp;
}
inline ::qdrant::LookupLocation* PROTOBUF_NONNULL RecommendPointGroups::_internal_mutable_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lookup_from_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::LookupLocation>(GetArena());
    _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(p);
  }
  return _impl_.lookup_from_;
}
inline ::qdrant::LookupLocation* PROTOBUF_NONNULL RecommendPointGroups::mutable_lookup_from()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  ::qdrant::LookupLocation* _msg = _internal_mutable_lookup_from();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPointGroups.lookup_from)
  return _msg;
}
inline void RecommendPointGroups::set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lookup_from_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000800U);
  }

  _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPointGroups.lookup_from)
}

// string group_by = 12;
inline void RecommendPointGroups::clear_group_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_by_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::std::string& RecommendPointGroups::group_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.group_by)
  return _internal_group_by();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RecommendPointGroups::set_group_by(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  _impl_.group_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.RecommendPointGroups.group_by)
}
inline ::std::string* PROTOBUF_NONNULL RecommendPointGroups::mutable_group_by()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::std::string* _s = _internal_mutable_group_by();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPointGroups.group_by)
  return _s;
}
inline const ::std::string& RecommendPointGroups::_internal_group_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_by_.Get();
}
inline void RecommendPointGroups::_internal_set_group_by(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_by_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RecommendPointGroups::_internal_mutable_group_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.group_by_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RecommendPointGroups::release_group_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPointGroups.group_by)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000040U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  auto* released = _impl_.group_by_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.group_by_.Set("", GetArena());
  }
  return released;
}
inline void RecommendPointGroups::set_allocated_group_by(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  _impl_.group_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.group_by_.IsDefault()) {
    _impl_.group_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPointGroups.group_by)
}

// uint32 group_size = 13;
inline void RecommendPointGroups::clear_group_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_size_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00020000U);
}
inline ::uint32_t RecommendPointGroups::group_size() const {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.group_size)
  return _internal_group_size();
}
inline void RecommendPointGroups::set_group_size(::uint32_t value) {
  _internal_set_group_size(value);
  SetHasBit(_impl_._has_bits_[0], 0x00020000U);
  // @@protoc_insertion_point(field_set:qdrant.RecommendPointGroups.group_size)
}
inline ::uint32_t RecommendPointGroups::_internal_group_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_size_;
}
inline void RecommendPointGroups::_internal_set_group_size(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_size_ = value;
}

// optional .qdrant.ReadConsistency read_consistency = 14;
inline bool RecommendPointGroups::has_read_consistency() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00001000U);
  PROTOBUF_ASSUME(!value || _impl_.read_consistency_ != nullptr);
  return value;
}
inline void RecommendPointGroups::clear_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ != nullptr) _impl_.read_consistency_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00001000U);
}
inline const ::qdrant::ReadConsistency& RecommendPointGroups::_internal_read_consistency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ReadConsistency* p = _impl_.read_consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ReadConsistency&>(::qdrant::_ReadConsistency_default_instance_);
}
inline const ::qdrant::ReadConsistency& RecommendPointGroups::read_consistency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.read_consistency)
  return _internal_read_consistency();
}
inline void RecommendPointGroups::unsafe_arena_set_allocated_read_consistency(
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }
  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00001000U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00001000U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendPointGroups.read_consistency)
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE RecommendPointGroups::release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00001000U);
  ::qdrant::ReadConsistency* released = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE RecommendPointGroups::unsafe_arena_release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPointGroups.read_consistency)

  ClearHasBit(_impl_._has_bits_[0], 0x00001000U);
  ::qdrant::ReadConsistency* temp = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  return temp;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL RecommendPointGroups::_internal_mutable_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ReadConsistency>(GetArena());
    _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(p);
  }
  return _impl_.read_consistency_;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL RecommendPointGroups::mutable_read_consistency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00001000U);
  ::qdrant::ReadConsistency* _msg = _internal_mutable_read_consistency();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPointGroups.read_consistency)
  return _msg;
}
inline void RecommendPointGroups::set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00001000U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00001000U);
  }

  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPointGroups.read_consistency)
}

// optional .qdrant.WithLookup with_lookup = 15;
inline bool RecommendPointGroups::has_with_lookup() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00002000U);
  PROTOBUF_ASSUME(!value || _impl_.with_lookup_ != nullptr);
  return value;
}
inline void RecommendPointGroups::clear_with_lookup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_lookup_ != nullptr) _impl_.with_lookup_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00002000U);
}
inline const ::qdrant::WithLookup& RecommendPointGroups::_internal_with_lookup() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithLookup* p = _impl_.with_lookup_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithLookup&>(::qdrant::_WithLookup_default_instance_);
}
inline const ::qdrant::WithLookup& RecommendPointGroups::with_lookup() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.with_lookup)
  return _internal_with_lookup();
}
inline void RecommendPointGroups::unsafe_arena_set_allocated_with_lookup(
    ::qdrant::WithLookup* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_lookup_);
  }
  _impl_.with_lookup_ = reinterpret_cast<::qdrant::WithLookup*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00002000U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00002000U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendPointGroups.with_lookup)
}
inline ::qdrant::WithLookup* PROTOBUF_NULLABLE RecommendPointGroups::release_with_lookup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00002000U);
  ::qdrant::WithLookup* released = _impl_.with_lookup_;
  _impl_.with_lookup_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithLookup* PROTOBUF_NULLABLE RecommendPointGroups::unsafe_arena_release_with_lookup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPointGroups.with_lookup)

  ClearHasBit(_impl_._has_bits_[0], 0x00002000U);
  ::qdrant::WithLookup* temp = _impl_.with_lookup_;
  _impl_.with_lookup_ = nullptr;
  return temp;
}
inline ::qdrant::WithLookup* PROTOBUF_NONNULL RecommendPointGroups::_internal_mutable_with_lookup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_lookup_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithLookup>(GetArena());
    _impl_.with_lookup_ = reinterpret_cast<::qdrant::WithLookup*>(p);
  }
  return _impl_.with_lookup_;
}
inline ::qdrant::WithLookup* PROTOBUF_NONNULL RecommendPointGroups::mutable_with_lookup()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00002000U);
  ::qdrant::WithLookup* _msg = _internal_mutable_with_lookup();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPointGroups.with_lookup)
  return _msg;
}
inline void RecommendPointGroups::set_allocated_with_lookup(::qdrant::WithLookup* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_lookup_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00002000U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00002000U);
  }

  _impl_.with_lookup_ = reinterpret_cast<::qdrant::WithLookup*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPointGroups.with_lookup)
}

// optional .qdrant.RecommendStrategy strategy = 17;
inline bool RecommendPointGroups::has_strategy() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00040000U);
  return value;
}
inline void RecommendPointGroups::clear_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategy_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00040000U);
}
inline ::qdrant::RecommendStrategy RecommendPointGroups::strategy() const {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.strategy)
  return _internal_strategy();
}
inline void RecommendPointGroups::set_strategy(::qdrant::RecommendStrategy value) {
  _internal_set_strategy(value);
  SetHasBit(_impl_._has_bits_[0], 0x00040000U);
  // @@protoc_insertion_point(field_set:qdrant.RecommendPointGroups.strategy)
}
inline ::qdrant::RecommendStrategy RecommendPointGroups::_internal_strategy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::RecommendStrategy>(_impl_.strategy_);
}
inline void RecommendPointGroups::_internal_set_strategy(::qdrant::RecommendStrategy value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategy_ = value;
}

// repeated .qdrant.Vector positive_vectors = 18;
inline int RecommendPointGroups::_internal_positive_vectors_size() const {
  return _internal_positive_vectors().size();
}
inline int RecommendPointGroups::positive_vectors_size() const {
  return _internal_positive_vectors_size();
}
inline void RecommendPointGroups::clear_positive_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.positive_vectors_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::qdrant::Vector* PROTOBUF_NONNULL RecommendPointGroups::mutable_positive_vectors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPointGroups.positive_vectors)
  return _internal_mutable_positive_vectors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Vector>* PROTOBUF_NONNULL RecommendPointGroups::mutable_positive_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.RecommendPointGroups.positive_vectors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_positive_vectors();
}
inline const ::qdrant::Vector& RecommendPointGroups::positive_vectors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.positive_vectors)
  return _internal_positive_vectors().Get(index);
}
inline ::qdrant::Vector* PROTOBUF_NONNULL RecommendPointGroups::add_positive_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::Vector* _add =
      _internal_mutable_positive_vectors()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:qdrant.RecommendPointGroups.positive_vectors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Vector>& RecommendPointGroups::positive_vectors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.RecommendPointGroups.positive_vectors)
  return _internal_positive_vectors();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Vector>&
RecommendPointGroups::_internal_positive_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.positive_vectors_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Vector>* PROTOBUF_NONNULL
RecommendPointGroups::_internal_mutable_positive_vectors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.positive_vectors_;
}

// repeated .qdrant.Vector negative_vectors = 19;
inline int RecommendPointGroups::_internal_negative_vectors_size() const {
  return _internal_negative_vectors().size();
}
inline int RecommendPointGroups::negative_vectors_size() const {
  return _internal_negative_vectors_size();
}
inline void RecommendPointGroups::clear_negative_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.negative_vectors_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::qdrant::Vector* PROTOBUF_NONNULL RecommendPointGroups::mutable_negative_vectors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPointGroups.negative_vectors)
  return _internal_mutable_negative_vectors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Vector>* PROTOBUF_NONNULL RecommendPointGroups::mutable_negative_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.RecommendPointGroups.negative_vectors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_negative_vectors();
}
inline const ::qdrant::Vector& RecommendPointGroups::negative_vectors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.negative_vectors)
  return _internal_negative_vectors().Get(index);
}
inline ::qdrant::Vector* PROTOBUF_NONNULL RecommendPointGroups::add_negative_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::Vector* _add =
      _internal_mutable_negative_vectors()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_add:qdrant.RecommendPointGroups.negative_vectors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Vector>& RecommendPointGroups::negative_vectors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.RecommendPointGroups.negative_vectors)
  return _internal_negative_vectors();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Vector>&
RecommendPointGroups::_internal_negative_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.negative_vectors_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Vector>* PROTOBUF_NONNULL
RecommendPointGroups::_internal_mutable_negative_vectors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.negative_vectors_;
}

// optional uint64 timeout = 20;
inline bool RecommendPointGroups::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00080000U);
  return value;
}
inline void RecommendPointGroups::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00080000U);
}
inline ::uint64_t RecommendPointGroups::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.timeout)
  return _internal_timeout();
}
inline void RecommendPointGroups::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00080000U);
  // @@protoc_insertion_point(field_set:qdrant.RecommendPointGroups.timeout)
}
inline ::uint64_t RecommendPointGroups::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void RecommendPointGroups::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// optional .qdrant.ShardKeySelector shard_key_selector = 21;
inline bool RecommendPointGroups::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00004000U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void RecommendPointGroups::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00004000U);
}
inline const ::qdrant::ShardKeySelector& RecommendPointGroups::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& RecommendPointGroups::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendPointGroups.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void RecommendPointGroups::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00004000U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00004000U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendPointGroups.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE RecommendPointGroups::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00004000U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE RecommendPointGroups::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendPointGroups.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00004000U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL RecommendPointGroups::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL RecommendPointGroups::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00004000U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendPointGroups.shard_key_selector)
  return _msg;
}
inline void RecommendPointGroups::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00004000U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00004000U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendPointGroups.shard_key_selector)
}

// -------------------------------------------------------------------

// TargetVector

// .qdrant.VectorExample single = 1;
inline bool TargetVector::has_single() const {
  return target_case() == kSingle;
}
inline bool TargetVector::_internal_has_single() const {
  return target_case() == kSingle;
}
inline void TargetVector::set_has_single() {
  _impl_._oneof_case_[0] = kSingle;
}
inline void TargetVector::clear_single() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (target_case() == kSingle) {
    if (GetArena() == nullptr) {
      delete _impl_.target_.single_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.target_.single_);
    }
    clear_has_target();
  }
}
inline ::qdrant::VectorExample* PROTOBUF_NULLABLE TargetVector::release_single() {
  // @@protoc_insertion_point(field_release:qdrant.TargetVector.single)
  if (target_case() == kSingle) {
    clear_has_target();
    auto* temp = _impl_.target_.single_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.target_.single_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::VectorExample& TargetVector::_internal_single() const {
  return target_case() == kSingle ? static_cast<const ::qdrant::VectorExample&>(*_impl_.target_.single_)
                     : reinterpret_cast<const ::qdrant::VectorExample&>(::qdrant::_VectorExample_default_instance_);
}
inline const ::qdrant::VectorExample& TargetVector::single() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.TargetVector.single)
  return _internal_single();
}
inline ::qdrant::VectorExample* PROTOBUF_NULLABLE TargetVector::unsafe_arena_release_single() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.TargetVector.single)
  if (target_case() == kSingle) {
    clear_has_target();
    auto* temp = _impl_.target_.single_;
    _impl_.target_.single_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TargetVector::unsafe_arena_set_allocated_single(
    ::qdrant::VectorExample* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_target();
  if (value) {
    set_has_single();
    _impl_.target_.single_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.TargetVector.single)
}
inline ::qdrant::VectorExample* PROTOBUF_NONNULL TargetVector::_internal_mutable_single() {
  if (target_case() != kSingle) {
    clear_target();
    set_has_single();
    _impl_.target_.single_ = 
        ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorExample>(GetArena());
  }
  return _impl_.target_.single_;
}
inline ::qdrant::VectorExample* PROTOBUF_NONNULL TargetVector::mutable_single()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::VectorExample* _msg = _internal_mutable_single();
  // @@protoc_insertion_point(field_mutable:qdrant.TargetVector.single)
  return _msg;
}

inline bool TargetVector::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void TargetVector::clear_has_target() {
  _impl_._oneof_case_[0] = TARGET_NOT_SET;
}
inline TargetVector::TargetCase TargetVector::target_case() const {
  return TargetVector::TargetCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VectorExample

// .qdrant.PointId id = 1;
inline bool VectorExample::has_id() const {
  return example_case() == kId;
}
inline bool VectorExample::_internal_has_id() const {
  return example_case() == kId;
}
inline void VectorExample::set_has_id() {
  _impl_._oneof_case_[0] = kId;
}
inline void VectorExample::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (example_case() == kId) {
    if (GetArena() == nullptr) {
      delete _impl_.example_.id_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.example_.id_);
    }
    clear_has_example();
  }
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE VectorExample::release_id() {
  // @@protoc_insertion_point(field_release:qdrant.VectorExample.id)
  if (example_case() == kId) {
    clear_has_example();
    auto* temp = _impl_.example_.id_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.example_.id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::PointId& VectorExample::_internal_id() const {
  return example_case() == kId ? static_cast<const ::qdrant::PointId&>(*_impl_.example_.id_)
                     : reinterpret_cast<const ::qdrant::PointId&>(::qdrant::_PointId_default_instance_);
}
inline const ::qdrant::PointId& VectorExample::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorExample.id)
  return _internal_id();
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE VectorExample::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorExample.id)
  if (example_case() == kId) {
    clear_has_example();
    auto* temp = _impl_.example_.id_;
    _impl_.example_.id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorExample::unsafe_arena_set_allocated_id(
    ::qdrant::PointId* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_example();
  if (value) {
    set_has_id();
    _impl_.example_.id_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorExample.id)
}
inline ::qdrant::PointId* PROTOBUF_NONNULL VectorExample::_internal_mutable_id() {
  if (example_case() != kId) {
    clear_example();
    set_has_id();
    _impl_.example_.id_ = 
        ::google::protobuf::Message::DefaultConstruct<::qdrant::PointId>(GetArena());
  }
  return _impl_.example_.id_;
}
inline ::qdrant::PointId* PROTOBUF_NONNULL VectorExample::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::PointId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorExample.id)
  return _msg;
}

// .qdrant.Vector vector = 2;
inline bool VectorExample::has_vector() const {
  return example_case() == kVector;
}
inline bool VectorExample::_internal_has_vector() const {
  return example_case() == kVector;
}
inline void VectorExample::set_has_vector() {
  _impl_._oneof_case_[0] = kVector;
}
inline void VectorExample::clear_vector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (example_case() == kVector) {
    if (GetArena() == nullptr) {
      delete _impl_.example_.vector_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.example_.vector_);
    }
    clear_has_example();
  }
}
inline ::qdrant::Vector* PROTOBUF_NULLABLE VectorExample::release_vector() {
  // @@protoc_insertion_point(field_release:qdrant.VectorExample.vector)
  if (example_case() == kVector) {
    clear_has_example();
    auto* temp = _impl_.example_.vector_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.example_.vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Vector& VectorExample::_internal_vector() const {
  return example_case() == kVector ? static_cast<const ::qdrant::Vector&>(*_impl_.example_.vector_)
                     : reinterpret_cast<const ::qdrant::Vector&>(::qdrant::_Vector_default_instance_);
}
inline const ::qdrant::Vector& VectorExample::vector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorExample.vector)
  return _internal_vector();
}
inline ::qdrant::Vector* PROTOBUF_NULLABLE VectorExample::unsafe_arena_release_vector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorExample.vector)
  if (example_case() == kVector) {
    clear_has_example();
    auto* temp = _impl_.example_.vector_;
    _impl_.example_.vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorExample::unsafe_arena_set_allocated_vector(
    ::qdrant::Vector* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_example();
  if (value) {
    set_has_vector();
    _impl_.example_.vector_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorExample.vector)
}
inline ::qdrant::Vector* PROTOBUF_NONNULL VectorExample::_internal_mutable_vector() {
  if (example_case() != kVector) {
    clear_example();
    set_has_vector();
    _impl_.example_.vector_ = 
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Vector>(GetArena());
  }
  return _impl_.example_.vector_;
}
inline ::qdrant::Vector* PROTOBUF_NONNULL VectorExample::mutable_vector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Vector* _msg = _internal_mutable_vector();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorExample.vector)
  return _msg;
}

inline bool VectorExample::has_example() const {
  return example_case() != EXAMPLE_NOT_SET;
}
inline void VectorExample::clear_has_example() {
  _impl_._oneof_case_[0] = EXAMPLE_NOT_SET;
}
inline VectorExample::ExampleCase VectorExample::example_case() const {
  return VectorExample::ExampleCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ContextExamplePair

// .qdrant.VectorExample positive = 1;
inline bool ContextExamplePair::has_positive() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.positive_ != nullptr);
  return value;
}
inline void ContextExamplePair::clear_positive() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.positive_ != nullptr) _impl_.positive_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::VectorExample& ContextExamplePair::_internal_positive() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::VectorExample* p = _impl_.positive_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::VectorExample&>(::qdrant::_VectorExample_default_instance_);
}
inline const ::qdrant::VectorExample& ContextExamplePair::positive() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ContextExamplePair.positive)
  return _internal_positive();
}
inline void ContextExamplePair::unsafe_arena_set_allocated_positive(
    ::qdrant::VectorExample* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.positive_);
  }
  _impl_.positive_ = reinterpret_cast<::qdrant::VectorExample*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ContextExamplePair.positive)
}
inline ::qdrant::VectorExample* PROTOBUF_NULLABLE ContextExamplePair::release_positive() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::VectorExample* released = _impl_.positive_;
  _impl_.positive_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::VectorExample* PROTOBUF_NULLABLE ContextExamplePair::unsafe_arena_release_positive() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ContextExamplePair.positive)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::VectorExample* temp = _impl_.positive_;
  _impl_.positive_ = nullptr;
  return temp;
}
inline ::qdrant::VectorExample* PROTOBUF_NONNULL ContextExamplePair::_internal_mutable_positive() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.positive_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorExample>(GetArena());
    _impl_.positive_ = reinterpret_cast<::qdrant::VectorExample*>(p);
  }
  return _impl_.positive_;
}
inline ::qdrant::VectorExample* PROTOBUF_NONNULL ContextExamplePair::mutable_positive()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::VectorExample* _msg = _internal_mutable_positive();
  // @@protoc_insertion_point(field_mutable:qdrant.ContextExamplePair.positive)
  return _msg;
}
inline void ContextExamplePair::set_allocated_positive(::qdrant::VectorExample* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.positive_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.positive_ = reinterpret_cast<::qdrant::VectorExample*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ContextExamplePair.positive)
}

// .qdrant.VectorExample negative = 2;
inline bool ContextExamplePair::has_negative() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.negative_ != nullptr);
  return value;
}
inline void ContextExamplePair::clear_negative() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.negative_ != nullptr) _impl_.negative_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::VectorExample& ContextExamplePair::_internal_negative() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::VectorExample* p = _impl_.negative_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::VectorExample&>(::qdrant::_VectorExample_default_instance_);
}
inline const ::qdrant::VectorExample& ContextExamplePair::negative() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ContextExamplePair.negative)
  return _internal_negative();
}
inline void ContextExamplePair::unsafe_arena_set_allocated_negative(
    ::qdrant::VectorExample* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.negative_);
  }
  _impl_.negative_ = reinterpret_cast<::qdrant::VectorExample*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ContextExamplePair.negative)
}
inline ::qdrant::VectorExample* PROTOBUF_NULLABLE ContextExamplePair::release_negative() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::VectorExample* released = _impl_.negative_;
  _impl_.negative_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::VectorExample* PROTOBUF_NULLABLE ContextExamplePair::unsafe_arena_release_negative() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ContextExamplePair.negative)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::VectorExample* temp = _impl_.negative_;
  _impl_.negative_ = nullptr;
  return temp;
}
inline ::qdrant::VectorExample* PROTOBUF_NONNULL ContextExamplePair::_internal_mutable_negative() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.negative_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorExample>(GetArena());
    _impl_.negative_ = reinterpret_cast<::qdrant::VectorExample*>(p);
  }
  return _impl_.negative_;
}
inline ::qdrant::VectorExample* PROTOBUF_NONNULL ContextExamplePair::mutable_negative()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::VectorExample* _msg = _internal_mutable_negative();
  // @@protoc_insertion_point(field_mutable:qdrant.ContextExamplePair.negative)
  return _msg;
}
inline void ContextExamplePair::set_allocated_negative(::qdrant::VectorExample* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.negative_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.negative_ = reinterpret_cast<::qdrant::VectorExample*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ContextExamplePair.negative)
}

// -------------------------------------------------------------------

// DiscoverPoints

// string collection_name = 1;
inline void DiscoverPoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& DiscoverPoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverPoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DiscoverPoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.DiscoverPoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL DiscoverPoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverPoints.collection_name)
  return _s;
}
inline const ::std::string& DiscoverPoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void DiscoverPoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DiscoverPoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DiscoverPoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DiscoverPoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void DiscoverPoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.DiscoverPoints.collection_name)
}

// .qdrant.TargetVector target = 2;
inline bool DiscoverPoints::has_target() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline void DiscoverPoints::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_ != nullptr) _impl_.target_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::TargetVector& DiscoverPoints::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::TargetVector* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::TargetVector&>(::qdrant::_TargetVector_default_instance_);
}
inline const ::qdrant::TargetVector& DiscoverPoints::target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverPoints.target)
  return _internal_target();
}
inline void DiscoverPoints::unsafe_arena_set_allocated_target(
    ::qdrant::TargetVector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = reinterpret_cast<::qdrant::TargetVector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DiscoverPoints.target)
}
inline ::qdrant::TargetVector* PROTOBUF_NULLABLE DiscoverPoints::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::TargetVector* released = _impl_.target_;
  _impl_.target_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::TargetVector* PROTOBUF_NULLABLE DiscoverPoints::unsafe_arena_release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DiscoverPoints.target)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::TargetVector* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::qdrant::TargetVector* PROTOBUF_NONNULL DiscoverPoints::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::TargetVector>(GetArena());
    _impl_.target_ = reinterpret_cast<::qdrant::TargetVector*>(p);
  }
  return _impl_.target_;
}
inline ::qdrant::TargetVector* PROTOBUF_NONNULL DiscoverPoints::mutable_target()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::TargetVector* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverPoints.target)
  return _msg;
}
inline void DiscoverPoints::set_allocated_target(::qdrant::TargetVector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.target_ = reinterpret_cast<::qdrant::TargetVector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DiscoverPoints.target)
}

// repeated .qdrant.ContextExamplePair context = 3;
inline int DiscoverPoints::_internal_context_size() const {
  return _internal_context().size();
}
inline int DiscoverPoints::context_size() const {
  return _internal_context_size();
}
inline void DiscoverPoints::clear_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.context_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::ContextExamplePair* PROTOBUF_NONNULL DiscoverPoints::mutable_context(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverPoints.context)
  return _internal_mutable_context()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ContextExamplePair>* PROTOBUF_NONNULL DiscoverPoints::mutable_context()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.DiscoverPoints.context)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_context();
}
inline const ::qdrant::ContextExamplePair& DiscoverPoints::context(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverPoints.context)
  return _internal_context().Get(index);
}
inline ::qdrant::ContextExamplePair* PROTOBUF_NONNULL DiscoverPoints::add_context()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::ContextExamplePair* _add =
      _internal_mutable_context()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.DiscoverPoints.context)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ContextExamplePair>& DiscoverPoints::context() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.DiscoverPoints.context)
  return _internal_context();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ContextExamplePair>&
DiscoverPoints::_internal_context() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.context_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ContextExamplePair>* PROTOBUF_NONNULL
DiscoverPoints::_internal_mutable_context() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.context_;
}

// .qdrant.Filter filter = 4;
inline bool DiscoverPoints::has_filter() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void DiscoverPoints::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::Filter& DiscoverPoints::_internal_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Filter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& DiscoverPoints::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverPoints.filter)
  return _internal_filter();
}
inline void DiscoverPoints::unsafe_arena_set_allocated_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DiscoverPoints.filter)
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE DiscoverPoints::release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Filter* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE DiscoverPoints::unsafe_arena_release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DiscoverPoints.filter)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL DiscoverPoints::_internal_mutable_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
    _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(p);
  }
  return _impl_.filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL DiscoverPoints::mutable_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverPoints.filter)
  return _msg;
}
inline void DiscoverPoints::set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DiscoverPoints.filter)
}

// uint64 limit = 5;
inline void DiscoverPoints::clear_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000800U);
}
inline ::uint64_t DiscoverPoints::limit() const {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverPoints.limit)
  return _internal_limit();
}
inline void DiscoverPoints::set_limit(::uint64_t value) {
  _internal_set_limit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  // @@protoc_insertion_point(field_set:qdrant.DiscoverPoints.limit)
}
inline ::uint64_t DiscoverPoints::_internal_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limit_;
}
inline void DiscoverPoints::_internal_set_limit(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = value;
}

// .qdrant.WithPayloadSelector with_payload = 6;
inline bool DiscoverPoints::has_with_payload() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.with_payload_ != nullptr);
  return value;
}
inline void DiscoverPoints::clear_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ != nullptr) _impl_.with_payload_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::qdrant::WithPayloadSelector& DiscoverPoints::_internal_with_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithPayloadSelector* p = _impl_.with_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithPayloadSelector&>(::qdrant::_WithPayloadSelector_default_instance_);
}
inline const ::qdrant::WithPayloadSelector& DiscoverPoints::with_payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverPoints.with_payload)
  return _internal_with_payload();
}
inline void DiscoverPoints::unsafe_arena_set_allocated_with_payload(
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }
  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DiscoverPoints.with_payload)
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE DiscoverPoints::release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::WithPayloadSelector* released = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE DiscoverPoints::unsafe_arena_release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DiscoverPoints.with_payload)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::WithPayloadSelector* temp = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  return temp;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL DiscoverPoints::_internal_mutable_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithPayloadSelector>(GetArena());
    _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(p);
  }
  return _impl_.with_payload_;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL DiscoverPoints::mutable_with_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::WithPayloadSelector* _msg = _internal_mutable_with_payload();
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverPoints.with_payload)
  return _msg;
}
inline void DiscoverPoints::set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DiscoverPoints.with_payload)
}

// .qdrant.SearchParams params = 7;
inline bool DiscoverPoints::has_params() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  PROTOBUF_ASSUME(!value || _impl_.params_ != nullptr);
  return value;
}
inline void DiscoverPoints::clear_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ != nullptr) _impl_.params_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::qdrant::SearchParams& DiscoverPoints::_internal_params() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SearchParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SearchParams&>(::qdrant::_SearchParams_default_instance_);
}
inline const ::qdrant::SearchParams& DiscoverPoints::params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverPoints.params)
  return _internal_params();
}
inline void DiscoverPoints::unsafe_arena_set_allocated_params(
    ::qdrant::SearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DiscoverPoints.params)
}
inline ::qdrant::SearchParams* PROTOBUF_NULLABLE DiscoverPoints::release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::SearchParams* released = _impl_.params_;
  _impl_.params_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SearchParams* PROTOBUF_NULLABLE DiscoverPoints::unsafe_arena_release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DiscoverPoints.params)

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::SearchParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::qdrant::SearchParams* PROTOBUF_NONNULL DiscoverPoints::_internal_mutable_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SearchParams>(GetArena());
    _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(p);
  }
  return _impl_.params_;
}
inline ::qdrant::SearchParams* PROTOBUF_NONNULL DiscoverPoints::mutable_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::SearchParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverPoints.params)
  return _msg;
}
inline void DiscoverPoints::set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }

  _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DiscoverPoints.params)
}

// optional uint64 offset = 8;
inline bool DiscoverPoints::has_offset() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00001000U);
  return value;
}
inline void DiscoverPoints::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00001000U);
}
inline ::uint64_t DiscoverPoints::offset() const {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverPoints.offset)
  return _internal_offset();
}
inline void DiscoverPoints::set_offset(::uint64_t value) {
  _internal_set_offset(value);
  SetHasBit(_impl_._has_bits_[0], 0x00001000U);
  // @@protoc_insertion_point(field_set:qdrant.DiscoverPoints.offset)
}
inline ::uint64_t DiscoverPoints::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_;
}
inline void DiscoverPoints::_internal_set_offset(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = value;
}

// optional string using = 9;
inline bool DiscoverPoints::has_using_() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void DiscoverPoints::clear_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.using__.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& DiscoverPoints::using_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverPoints.using)
  return _internal_using_();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DiscoverPoints::set_using_(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.using__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.DiscoverPoints.using)
}
inline ::std::string* PROTOBUF_NONNULL DiscoverPoints::mutable_using_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_using_();
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverPoints.using)
  return _s;
}
inline const ::std::string& DiscoverPoints::_internal_using_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.using__.Get();
}
inline void DiscoverPoints::_internal_set_using_(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.using__.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DiscoverPoints::_internal_mutable_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.using__.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DiscoverPoints::release_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DiscoverPoints.using)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.using__.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.using__.Set("", GetArena());
  }
  return released;
}
inline void DiscoverPoints::set_allocated_using_(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.using__.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.using__.IsDefault()) {
    _impl_.using__.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.DiscoverPoints.using)
}

// optional .qdrant.WithVectorsSelector with_vectors = 10;
inline bool DiscoverPoints::has_with_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  PROTOBUF_ASSUME(!value || _impl_.with_vectors_ != nullptr);
  return value;
}
inline void DiscoverPoints::clear_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ != nullptr) _impl_.with_vectors_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline const ::qdrant::WithVectorsSelector& DiscoverPoints::_internal_with_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithVectorsSelector* p = _impl_.with_vectors_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithVectorsSelector&>(::qdrant::_WithVectorsSelector_default_instance_);
}
inline const ::qdrant::WithVectorsSelector& DiscoverPoints::with_vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverPoints.with_vectors)
  return _internal_with_vectors();
}
inline void DiscoverPoints::unsafe_arena_set_allocated_with_vectors(
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }
  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DiscoverPoints.with_vectors)
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE DiscoverPoints::release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::WithVectorsSelector* released = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE DiscoverPoints::unsafe_arena_release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DiscoverPoints.with_vectors)

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::WithVectorsSelector* temp = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  return temp;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL DiscoverPoints::_internal_mutable_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithVectorsSelector>(GetArena());
    _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(p);
  }
  return _impl_.with_vectors_;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL DiscoverPoints::mutable_with_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::WithVectorsSelector* _msg = _internal_mutable_with_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverPoints.with_vectors)
  return _msg;
}
inline void DiscoverPoints::set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }

  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DiscoverPoints.with_vectors)
}

// optional .qdrant.LookupLocation lookup_from = 11;
inline bool DiscoverPoints::has_lookup_from() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000100U);
  PROTOBUF_ASSUME(!value || _impl_.lookup_from_ != nullptr);
  return value;
}
inline void DiscoverPoints::clear_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lookup_from_ != nullptr) _impl_.lookup_from_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline const ::qdrant::LookupLocation& DiscoverPoints::_internal_lookup_from() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::LookupLocation* p = _impl_.lookup_from_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::LookupLocation&>(::qdrant::_LookupLocation_default_instance_);
}
inline const ::qdrant::LookupLocation& DiscoverPoints::lookup_from() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverPoints.lookup_from)
  return _internal_lookup_from();
}
inline void DiscoverPoints::unsafe_arena_set_allocated_lookup_from(
    ::qdrant::LookupLocation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lookup_from_);
  }
  _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DiscoverPoints.lookup_from)
}
inline ::qdrant::LookupLocation* PROTOBUF_NULLABLE DiscoverPoints::release_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::LookupLocation* released = _impl_.lookup_from_;
  _impl_.lookup_from_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::LookupLocation* PROTOBUF_NULLABLE DiscoverPoints::unsafe_arena_release_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DiscoverPoints.lookup_from)

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::LookupLocation* temp = _impl_.lookup_from_;
  _impl_.lookup_from_ = nullptr;
  return temp;
}
inline ::qdrant::LookupLocation* PROTOBUF_NONNULL DiscoverPoints::_internal_mutable_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lookup_from_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::LookupLocation>(GetArena());
    _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(p);
  }
  return _impl_.lookup_from_;
}
inline ::qdrant::LookupLocation* PROTOBUF_NONNULL DiscoverPoints::mutable_lookup_from()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::LookupLocation* _msg = _internal_mutable_lookup_from();
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverPoints.lookup_from)
  return _msg;
}
inline void DiscoverPoints::set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lookup_from_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }

  _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DiscoverPoints.lookup_from)
}

// optional .qdrant.ReadConsistency read_consistency = 12;
inline bool DiscoverPoints::has_read_consistency() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000200U);
  PROTOBUF_ASSUME(!value || _impl_.read_consistency_ != nullptr);
  return value;
}
inline void DiscoverPoints::clear_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ != nullptr) _impl_.read_consistency_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000200U);
}
inline const ::qdrant::ReadConsistency& DiscoverPoints::_internal_read_consistency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ReadConsistency* p = _impl_.read_consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ReadConsistency&>(::qdrant::_ReadConsistency_default_instance_);
}
inline const ::qdrant::ReadConsistency& DiscoverPoints::read_consistency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverPoints.read_consistency)
  return _internal_read_consistency();
}
inline void DiscoverPoints::unsafe_arena_set_allocated_read_consistency(
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }
  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DiscoverPoints.read_consistency)
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE DiscoverPoints::release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::ReadConsistency* released = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE DiscoverPoints::unsafe_arena_release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DiscoverPoints.read_consistency)

  ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::ReadConsistency* temp = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  return temp;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL DiscoverPoints::_internal_mutable_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ReadConsistency>(GetArena());
    _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(p);
  }
  return _impl_.read_consistency_;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL DiscoverPoints::mutable_read_consistency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::ReadConsistency* _msg = _internal_mutable_read_consistency();
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverPoints.read_consistency)
  return _msg;
}
inline void DiscoverPoints::set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  }

  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DiscoverPoints.read_consistency)
}

// optional uint64 timeout = 13;
inline bool DiscoverPoints::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00002000U);
  return value;
}
inline void DiscoverPoints::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00002000U);
}
inline ::uint64_t DiscoverPoints::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverPoints.timeout)
  return _internal_timeout();
}
inline void DiscoverPoints::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00002000U);
  // @@protoc_insertion_point(field_set:qdrant.DiscoverPoints.timeout)
}
inline ::uint64_t DiscoverPoints::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void DiscoverPoints::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// optional .qdrant.ShardKeySelector shard_key_selector = 14;
inline bool DiscoverPoints::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000400U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void DiscoverPoints::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000400U);
}
inline const ::qdrant::ShardKeySelector& DiscoverPoints::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& DiscoverPoints::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverPoints.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void DiscoverPoints::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DiscoverPoints.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE DiscoverPoints::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE DiscoverPoints::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DiscoverPoints.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL DiscoverPoints::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL DiscoverPoints::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverPoints.shard_key_selector)
  return _msg;
}
inline void DiscoverPoints::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DiscoverPoints.shard_key_selector)
}

// -------------------------------------------------------------------

// DiscoverBatchPoints

// string collection_name = 1;
inline void DiscoverBatchPoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& DiscoverBatchPoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverBatchPoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DiscoverBatchPoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.DiscoverBatchPoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL DiscoverBatchPoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverBatchPoints.collection_name)
  return _s;
}
inline const ::std::string& DiscoverBatchPoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void DiscoverBatchPoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DiscoverBatchPoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DiscoverBatchPoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DiscoverBatchPoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void DiscoverBatchPoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.DiscoverBatchPoints.collection_name)
}

// repeated .qdrant.DiscoverPoints discover_points = 2;
inline int DiscoverBatchPoints::_internal_discover_points_size() const {
  return _internal_discover_points().size();
}
inline int DiscoverBatchPoints::discover_points_size() const {
  return _internal_discover_points_size();
}
inline void DiscoverBatchPoints::clear_discover_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.discover_points_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::DiscoverPoints* PROTOBUF_NONNULL DiscoverBatchPoints::mutable_discover_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverBatchPoints.discover_points)
  return _internal_mutable_discover_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::DiscoverPoints>* PROTOBUF_NONNULL DiscoverBatchPoints::mutable_discover_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.DiscoverBatchPoints.discover_points)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_discover_points();
}
inline const ::qdrant::DiscoverPoints& DiscoverBatchPoints::discover_points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverBatchPoints.discover_points)
  return _internal_discover_points().Get(index);
}
inline ::qdrant::DiscoverPoints* PROTOBUF_NONNULL DiscoverBatchPoints::add_discover_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::DiscoverPoints* _add =
      _internal_mutable_discover_points()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.DiscoverBatchPoints.discover_points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::DiscoverPoints>& DiscoverBatchPoints::discover_points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.DiscoverBatchPoints.discover_points)
  return _internal_discover_points();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::DiscoverPoints>&
DiscoverBatchPoints::_internal_discover_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.discover_points_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::DiscoverPoints>* PROTOBUF_NONNULL
DiscoverBatchPoints::_internal_mutable_discover_points() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.discover_points_;
}

// optional .qdrant.ReadConsistency read_consistency = 3;
inline bool DiscoverBatchPoints::has_read_consistency() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.read_consistency_ != nullptr);
  return value;
}
inline void DiscoverBatchPoints::clear_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ != nullptr) _impl_.read_consistency_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::ReadConsistency& DiscoverBatchPoints::_internal_read_consistency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ReadConsistency* p = _impl_.read_consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ReadConsistency&>(::qdrant::_ReadConsistency_default_instance_);
}
inline const ::qdrant::ReadConsistency& DiscoverBatchPoints::read_consistency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverBatchPoints.read_consistency)
  return _internal_read_consistency();
}
inline void DiscoverBatchPoints::unsafe_arena_set_allocated_read_consistency(
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }
  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DiscoverBatchPoints.read_consistency)
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE DiscoverBatchPoints::release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ReadConsistency* released = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE DiscoverBatchPoints::unsafe_arena_release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DiscoverBatchPoints.read_consistency)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ReadConsistency* temp = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  return temp;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL DiscoverBatchPoints::_internal_mutable_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ReadConsistency>(GetArena());
    _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(p);
  }
  return _impl_.read_consistency_;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL DiscoverBatchPoints::mutable_read_consistency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ReadConsistency* _msg = _internal_mutable_read_consistency();
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverBatchPoints.read_consistency)
  return _msg;
}
inline void DiscoverBatchPoints::set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DiscoverBatchPoints.read_consistency)
}

// optional uint64 timeout = 4;
inline bool DiscoverBatchPoints::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void DiscoverBatchPoints::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint64_t DiscoverBatchPoints::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverBatchPoints.timeout)
  return _internal_timeout();
}
inline void DiscoverBatchPoints::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.DiscoverBatchPoints.timeout)
}
inline ::uint64_t DiscoverBatchPoints::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void DiscoverBatchPoints::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// -------------------------------------------------------------------

// CountPoints

// string collection_name = 1;
inline void CountPoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& CountPoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CountPoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CountPoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.CountPoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL CountPoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.CountPoints.collection_name)
  return _s;
}
inline const ::std::string& CountPoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void CountPoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CountPoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CountPoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CountPoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void CountPoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.CountPoints.collection_name)
}

// .qdrant.Filter filter = 2;
inline bool CountPoints::has_filter() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void CountPoints::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Filter& CountPoints::_internal_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Filter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& CountPoints::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CountPoints.filter)
  return _internal_filter();
}
inline void CountPoints::unsafe_arena_set_allocated_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CountPoints.filter)
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE CountPoints::release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Filter* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE CountPoints::unsafe_arena_release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CountPoints.filter)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL CountPoints::_internal_mutable_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
    _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(p);
  }
  return _impl_.filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL CountPoints::mutable_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.CountPoints.filter)
  return _msg;
}
inline void CountPoints::set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CountPoints.filter)
}

// optional bool exact = 3;
inline bool CountPoints::has_exact() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void CountPoints::clear_exact() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exact_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool CountPoints::exact() const {
  // @@protoc_insertion_point(field_get:qdrant.CountPoints.exact)
  return _internal_exact();
}
inline void CountPoints::set_exact(bool value) {
  _internal_set_exact(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.CountPoints.exact)
}
inline bool CountPoints::_internal_exact() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exact_;
}
inline void CountPoints::_internal_set_exact(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exact_ = value;
}

// optional .qdrant.ReadConsistency read_consistency = 4;
inline bool CountPoints::has_read_consistency() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.read_consistency_ != nullptr);
  return value;
}
inline void CountPoints::clear_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ != nullptr) _impl_.read_consistency_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::ReadConsistency& CountPoints::_internal_read_consistency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ReadConsistency* p = _impl_.read_consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ReadConsistency&>(::qdrant::_ReadConsistency_default_instance_);
}
inline const ::qdrant::ReadConsistency& CountPoints::read_consistency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CountPoints.read_consistency)
  return _internal_read_consistency();
}
inline void CountPoints::unsafe_arena_set_allocated_read_consistency(
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }
  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CountPoints.read_consistency)
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE CountPoints::release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ReadConsistency* released = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE CountPoints::unsafe_arena_release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CountPoints.read_consistency)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ReadConsistency* temp = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  return temp;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL CountPoints::_internal_mutable_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ReadConsistency>(GetArena());
    _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(p);
  }
  return _impl_.read_consistency_;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL CountPoints::mutable_read_consistency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ReadConsistency* _msg = _internal_mutable_read_consistency();
  // @@protoc_insertion_point(field_mutable:qdrant.CountPoints.read_consistency)
  return _msg;
}
inline void CountPoints::set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CountPoints.read_consistency)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 5;
inline bool CountPoints::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void CountPoints::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::ShardKeySelector& CountPoints::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& CountPoints::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CountPoints.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void CountPoints::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CountPoints.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE CountPoints::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE CountPoints::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CountPoints.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL CountPoints::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL CountPoints::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.CountPoints.shard_key_selector)
  return _msg;
}
inline void CountPoints::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CountPoints.shard_key_selector)
}

// optional uint64 timeout = 6;
inline bool CountPoints::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void CountPoints::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::uint64_t CountPoints::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.CountPoints.timeout)
  return _internal_timeout();
}
inline void CountPoints::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.CountPoints.timeout)
}
inline ::uint64_t CountPoints::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void CountPoints::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// -------------------------------------------------------------------

// RecommendInput

// repeated .qdrant.VectorInput positive = 1;
inline int RecommendInput::_internal_positive_size() const {
  return _internal_positive().size();
}
inline int RecommendInput::positive_size() const {
  return _internal_positive_size();
}
inline void RecommendInput::clear_positive() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.positive_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::VectorInput* PROTOBUF_NONNULL RecommendInput::mutable_positive(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendInput.positive)
  return _internal_mutable_positive()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::VectorInput>* PROTOBUF_NONNULL RecommendInput::mutable_positive()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.RecommendInput.positive)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_positive();
}
inline const ::qdrant::VectorInput& RecommendInput::positive(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendInput.positive)
  return _internal_positive().Get(index);
}
inline ::qdrant::VectorInput* PROTOBUF_NONNULL RecommendInput::add_positive()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::VectorInput* _add =
      _internal_mutable_positive()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.RecommendInput.positive)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::VectorInput>& RecommendInput::positive() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.RecommendInput.positive)
  return _internal_positive();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::VectorInput>&
RecommendInput::_internal_positive() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.positive_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::VectorInput>* PROTOBUF_NONNULL
RecommendInput::_internal_mutable_positive() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.positive_;
}

// repeated .qdrant.VectorInput negative = 2;
inline int RecommendInput::_internal_negative_size() const {
  return _internal_negative().size();
}
inline int RecommendInput::negative_size() const {
  return _internal_negative_size();
}
inline void RecommendInput::clear_negative() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.negative_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::qdrant::VectorInput* PROTOBUF_NONNULL RecommendInput::mutable_negative(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendInput.negative)
  return _internal_mutable_negative()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::VectorInput>* PROTOBUF_NONNULL RecommendInput::mutable_negative()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.RecommendInput.negative)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_negative();
}
inline const ::qdrant::VectorInput& RecommendInput::negative(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendInput.negative)
  return _internal_negative().Get(index);
}
inline ::qdrant::VectorInput* PROTOBUF_NONNULL RecommendInput::add_negative()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::VectorInput* _add =
      _internal_mutable_negative()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:qdrant.RecommendInput.negative)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::VectorInput>& RecommendInput::negative() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.RecommendInput.negative)
  return _internal_negative();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::VectorInput>&
RecommendInput::_internal_negative() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.negative_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::VectorInput>* PROTOBUF_NONNULL
RecommendInput::_internal_mutable_negative() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.negative_;
}

// optional .qdrant.RecommendStrategy strategy = 3;
inline bool RecommendInput::has_strategy() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void RecommendInput::clear_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategy_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::qdrant::RecommendStrategy RecommendInput::strategy() const {
  // @@protoc_insertion_point(field_get:qdrant.RecommendInput.strategy)
  return _internal_strategy();
}
inline void RecommendInput::set_strategy(::qdrant::RecommendStrategy value) {
  _internal_set_strategy(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.RecommendInput.strategy)
}
inline ::qdrant::RecommendStrategy RecommendInput::_internal_strategy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::RecommendStrategy>(_impl_.strategy_);
}
inline void RecommendInput::_internal_set_strategy(::qdrant::RecommendStrategy value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategy_ = value;
}

// -------------------------------------------------------------------

// ContextInputPair

// .qdrant.VectorInput positive = 1;
inline bool ContextInputPair::has_positive() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.positive_ != nullptr);
  return value;
}
inline void ContextInputPair::clear_positive() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.positive_ != nullptr) _impl_.positive_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::VectorInput& ContextInputPair::_internal_positive() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::VectorInput* p = _impl_.positive_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::VectorInput&>(::qdrant::_VectorInput_default_instance_);
}
inline const ::qdrant::VectorInput& ContextInputPair::positive() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ContextInputPair.positive)
  return _internal_positive();
}
inline void ContextInputPair::unsafe_arena_set_allocated_positive(
    ::qdrant::VectorInput* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.positive_);
  }
  _impl_.positive_ = reinterpret_cast<::qdrant::VectorInput*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ContextInputPair.positive)
}
inline ::qdrant::VectorInput* PROTOBUF_NULLABLE ContextInputPair::release_positive() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::VectorInput* released = _impl_.positive_;
  _impl_.positive_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::VectorInput* PROTOBUF_NULLABLE ContextInputPair::unsafe_arena_release_positive() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ContextInputPair.positive)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::VectorInput* temp = _impl_.positive_;
  _impl_.positive_ = nullptr;
  return temp;
}
inline ::qdrant::VectorInput* PROTOBUF_NONNULL ContextInputPair::_internal_mutable_positive() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.positive_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorInput>(GetArena());
    _impl_.positive_ = reinterpret_cast<::qdrant::VectorInput*>(p);
  }
  return _impl_.positive_;
}
inline ::qdrant::VectorInput* PROTOBUF_NONNULL ContextInputPair::mutable_positive()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::VectorInput* _msg = _internal_mutable_positive();
  // @@protoc_insertion_point(field_mutable:qdrant.ContextInputPair.positive)
  return _msg;
}
inline void ContextInputPair::set_allocated_positive(::qdrant::VectorInput* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.positive_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.positive_ = reinterpret_cast<::qdrant::VectorInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ContextInputPair.positive)
}

// .qdrant.VectorInput negative = 2;
inline bool ContextInputPair::has_negative() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.negative_ != nullptr);
  return value;
}
inline void ContextInputPair::clear_negative() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.negative_ != nullptr) _impl_.negative_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::VectorInput& ContextInputPair::_internal_negative() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::VectorInput* p = _impl_.negative_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::VectorInput&>(::qdrant::_VectorInput_default_instance_);
}
inline const ::qdrant::VectorInput& ContextInputPair::negative() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ContextInputPair.negative)
  return _internal_negative();
}
inline void ContextInputPair::unsafe_arena_set_allocated_negative(
    ::qdrant::VectorInput* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.negative_);
  }
  _impl_.negative_ = reinterpret_cast<::qdrant::VectorInput*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ContextInputPair.negative)
}
inline ::qdrant::VectorInput* PROTOBUF_NULLABLE ContextInputPair::release_negative() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::VectorInput* released = _impl_.negative_;
  _impl_.negative_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::VectorInput* PROTOBUF_NULLABLE ContextInputPair::unsafe_arena_release_negative() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ContextInputPair.negative)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::VectorInput* temp = _impl_.negative_;
  _impl_.negative_ = nullptr;
  return temp;
}
inline ::qdrant::VectorInput* PROTOBUF_NONNULL ContextInputPair::_internal_mutable_negative() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.negative_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorInput>(GetArena());
    _impl_.negative_ = reinterpret_cast<::qdrant::VectorInput*>(p);
  }
  return _impl_.negative_;
}
inline ::qdrant::VectorInput* PROTOBUF_NONNULL ContextInputPair::mutable_negative()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::VectorInput* _msg = _internal_mutable_negative();
  // @@protoc_insertion_point(field_mutable:qdrant.ContextInputPair.negative)
  return _msg;
}
inline void ContextInputPair::set_allocated_negative(::qdrant::VectorInput* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.negative_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.negative_ = reinterpret_cast<::qdrant::VectorInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ContextInputPair.negative)
}

// -------------------------------------------------------------------

// DiscoverInput

// .qdrant.VectorInput target = 1;
inline bool DiscoverInput::has_target() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline void DiscoverInput::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_ != nullptr) _impl_.target_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::VectorInput& DiscoverInput::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::VectorInput* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::VectorInput&>(::qdrant::_VectorInput_default_instance_);
}
inline const ::qdrant::VectorInput& DiscoverInput::target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverInput.target)
  return _internal_target();
}
inline void DiscoverInput::unsafe_arena_set_allocated_target(
    ::qdrant::VectorInput* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = reinterpret_cast<::qdrant::VectorInput*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DiscoverInput.target)
}
inline ::qdrant::VectorInput* PROTOBUF_NULLABLE DiscoverInput::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::VectorInput* released = _impl_.target_;
  _impl_.target_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::VectorInput* PROTOBUF_NULLABLE DiscoverInput::unsafe_arena_release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DiscoverInput.target)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::VectorInput* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::qdrant::VectorInput* PROTOBUF_NONNULL DiscoverInput::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorInput>(GetArena());
    _impl_.target_ = reinterpret_cast<::qdrant::VectorInput*>(p);
  }
  return _impl_.target_;
}
inline ::qdrant::VectorInput* PROTOBUF_NONNULL DiscoverInput::mutable_target()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::VectorInput* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverInput.target)
  return _msg;
}
inline void DiscoverInput::set_allocated_target(::qdrant::VectorInput* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.target_ = reinterpret_cast<::qdrant::VectorInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DiscoverInput.target)
}

// .qdrant.ContextInput context = 2;
inline bool DiscoverInput::has_context() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.context_ != nullptr);
  return value;
}
inline void DiscoverInput::clear_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.context_ != nullptr) _impl_.context_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::ContextInput& DiscoverInput::_internal_context() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ContextInput* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ContextInput&>(::qdrant::_ContextInput_default_instance_);
}
inline const ::qdrant::ContextInput& DiscoverInput::context() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverInput.context)
  return _internal_context();
}
inline void DiscoverInput::unsafe_arena_set_allocated_context(
    ::qdrant::ContextInput* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = reinterpret_cast<::qdrant::ContextInput*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DiscoverInput.context)
}
inline ::qdrant::ContextInput* PROTOBUF_NULLABLE DiscoverInput::release_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ContextInput* released = _impl_.context_;
  _impl_.context_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ContextInput* PROTOBUF_NULLABLE DiscoverInput::unsafe_arena_release_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DiscoverInput.context)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ContextInput* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::qdrant::ContextInput* PROTOBUF_NONNULL DiscoverInput::_internal_mutable_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.context_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ContextInput>(GetArena());
    _impl_.context_ = reinterpret_cast<::qdrant::ContextInput*>(p);
  }
  return _impl_.context_;
}
inline ::qdrant::ContextInput* PROTOBUF_NONNULL DiscoverInput::mutable_context()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ContextInput* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverInput.context)
  return _msg;
}
inline void DiscoverInput::set_allocated_context(::qdrant::ContextInput* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.context_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.context_ = reinterpret_cast<::qdrant::ContextInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DiscoverInput.context)
}

// -------------------------------------------------------------------

// ContextInput

// repeated .qdrant.ContextInputPair pairs = 1;
inline int ContextInput::_internal_pairs_size() const {
  return _internal_pairs().size();
}
inline int ContextInput::pairs_size() const {
  return _internal_pairs_size();
}
inline void ContextInput::clear_pairs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pairs_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::ContextInputPair* PROTOBUF_NONNULL ContextInput::mutable_pairs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.ContextInput.pairs)
  return _internal_mutable_pairs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ContextInputPair>* PROTOBUF_NONNULL ContextInput::mutable_pairs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.ContextInput.pairs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_pairs();
}
inline const ::qdrant::ContextInputPair& ContextInput::pairs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ContextInput.pairs)
  return _internal_pairs().Get(index);
}
inline ::qdrant::ContextInputPair* PROTOBUF_NONNULL ContextInput::add_pairs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::ContextInputPair* _add =
      _internal_mutable_pairs()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.ContextInput.pairs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ContextInputPair>& ContextInput::pairs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.ContextInput.pairs)
  return _internal_pairs();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ContextInputPair>&
ContextInput::_internal_pairs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pairs_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ContextInputPair>* PROTOBUF_NONNULL
ContextInput::_internal_mutable_pairs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.pairs_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Formula

// .qdrant.Expression expression = 1;
inline bool Formula::has_expression() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.expression_ != nullptr);
  return value;
}
inline void Formula::clear_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expression_ != nullptr) _impl_.expression_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::Expression& Formula::_internal_expression() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Expression* p = _impl_.expression_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Expression&>(::qdrant::_Expression_default_instance_);
}
inline const ::qdrant::Expression& Formula::expression() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Formula.expression)
  return _internal_expression();
}
inline void Formula::unsafe_arena_set_allocated_expression(
    ::qdrant::Expression* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expression_);
  }
  _impl_.expression_ = reinterpret_cast<::qdrant::Expression*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Formula.expression)
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE Formula::release_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::Expression* released = _impl_.expression_;
  _impl_.expression_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE Formula::unsafe_arena_release_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.Formula.expression)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::Expression* temp = _impl_.expression_;
  _impl_.expression_ = nullptr;
  return temp;
}
inline ::qdrant::Expression* PROTOBUF_NONNULL Formula::_internal_mutable_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expression_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Expression>(GetArena());
    _impl_.expression_ = reinterpret_cast<::qdrant::Expression*>(p);
  }
  return _impl_.expression_;
}
inline ::qdrant::Expression* PROTOBUF_NONNULL Formula::mutable_expression()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::Expression* _msg = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:qdrant.Formula.expression)
  return _msg;
}
inline void Formula::set_allocated_expression(::qdrant::Expression* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expression_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.expression_ = reinterpret_cast<::qdrant::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.Formula.expression)
}

// map<string, .qdrant.Value> defaults = 2;
inline int Formula::_internal_defaults_size() const {
  return _internal_defaults().size();
}
inline int Formula::defaults_size() const {
  return _internal_defaults_size();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& Formula::_internal_defaults() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.defaults_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& Formula::defaults() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.Formula.defaults)
  return _internal_defaults();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL Formula::_internal_mutable_defaults() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.defaults_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL Formula::mutable_defaults()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.Formula.defaults)
  return _internal_mutable_defaults();
}

// -------------------------------------------------------------------

// Expression

// float constant = 1;
inline bool Expression::has_constant() const {
  return variant_case() == kConstant;
}
inline void Expression::set_has_constant() {
  _impl_._oneof_case_[0] = kConstant;
}
inline void Expression::clear_constant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kConstant) {
    _impl_.variant_.constant_ = 0;
    clear_has_variant();
  }
}
inline float Expression::constant() const {
  // @@protoc_insertion_point(field_get:qdrant.Expression.constant)
  return _internal_constant();
}
inline void Expression::set_constant(float value) {
  if (variant_case() != kConstant) {
    clear_variant();
    set_has_constant();
  }
  _impl_.variant_.constant_ = value;
  // @@protoc_insertion_point(field_set:qdrant.Expression.constant)
}
inline float Expression::_internal_constant() const {
  if (variant_case() == kConstant) {
    return _impl_.variant_.constant_;
  }
  return 0;
}

// string variable = 2;
inline bool Expression::has_variable() const {
  return variant_case() == kVariable;
}
inline void Expression::set_has_variable() {
  _impl_._oneof_case_[0] = kVariable;
}
inline void Expression::clear_variable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kVariable) {
    _impl_.variant_.variable_.Destroy();
    clear_has_variant();
  }
}
inline const ::std::string& Expression::variable() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.variable)
  return _internal_variable();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Expression::set_variable(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() != kVariable) {
    clear_variant();

    set_has_variable();
    _impl_.variant_.variable_.InitDefault();
  }
  _impl_.variant_.variable_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.Expression.variable)
}
inline ::std::string* PROTOBUF_NONNULL Expression::mutable_variable()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  if (variant_case() != kVariable) {
    clear_variant();

    set_has_variable();
    _impl_.variant_.variable_.InitDefault();
  }
  ::std::string* _s = _internal_mutable_variable();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.variable)
  return _s;
}
inline const ::std::string& Expression::_internal_variable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (variant_case() != kVariable) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.variant_.variable_.Get();
}
inline void Expression::_internal_set_variable(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.variant_.variable_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Expression::_internal_mutable_variable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.variant_.variable_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Expression::release_variable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.Expression.variable)
  if (variant_case() != kVariable) {
    return nullptr;
  }
  clear_has_variant();
  return _impl_.variant_.variable_.Release();
}
inline void Expression::set_allocated_variable(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_variant()) {
    clear_variant();
  }
  if (value != nullptr) {
    set_has_variable();
    _impl_.variant_.variable_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.Expression.variable)
}

// .qdrant.Condition condition = 3;
inline bool Expression::has_condition() const {
  return variant_case() == kCondition;
}
inline bool Expression::_internal_has_condition() const {
  return variant_case() == kCondition;
}
inline void Expression::set_has_condition() {
  _impl_._oneof_case_[0] = kCondition;
}
inline void Expression::clear_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kCondition) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.condition_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.condition_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::Condition* PROTOBUF_NULLABLE Expression::release_condition() {
  // @@protoc_insertion_point(field_release:qdrant.Expression.condition)
  if (variant_case() == kCondition) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Condition*>(_impl_.variant_.condition_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Condition& Expression::_internal_condition() const {
  return variant_case() == kCondition ? static_cast<const ::qdrant::Condition&>(*reinterpret_cast<::qdrant::Condition*>(_impl_.variant_.condition_))
                     : reinterpret_cast<const ::qdrant::Condition&>(::qdrant::_Condition_default_instance_);
}
inline const ::qdrant::Condition& Expression::condition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.condition)
  return _internal_condition();
}
inline ::qdrant::Condition* PROTOBUF_NULLABLE Expression::unsafe_arena_release_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Expression.condition)
  if (variant_case() == kCondition) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Condition*>(_impl_.variant_.condition_);
    _impl_.variant_.condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_condition(
    ::qdrant::Condition* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_condition();
    _impl_.variant_.condition_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Expression.condition)
}
inline ::qdrant::Condition* PROTOBUF_NONNULL Expression::_internal_mutable_condition() {
  if (variant_case() != kCondition) {
    clear_variant();
    set_has_condition();
    _impl_.variant_.condition_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Condition>(GetArena()));
  }
  return reinterpret_cast<::qdrant::Condition*>(_impl_.variant_.condition_);
}
inline ::qdrant::Condition* PROTOBUF_NONNULL Expression::mutable_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Condition* _msg = _internal_mutable_condition();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.condition)
  return _msg;
}

// .qdrant.GeoDistance geo_distance = 4;
inline bool Expression::has_geo_distance() const {
  return variant_case() == kGeoDistance;
}
inline bool Expression::_internal_has_geo_distance() const {
  return variant_case() == kGeoDistance;
}
inline void Expression::set_has_geo_distance() {
  _impl_._oneof_case_[0] = kGeoDistance;
}
inline void Expression::clear_geo_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kGeoDistance) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.geo_distance_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.geo_distance_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::GeoDistance* PROTOBUF_NULLABLE Expression::release_geo_distance() {
  // @@protoc_insertion_point(field_release:qdrant.Expression.geo_distance)
  if (variant_case() == kGeoDistance) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::GeoDistance*>(_impl_.variant_.geo_distance_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.geo_distance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::GeoDistance& Expression::_internal_geo_distance() const {
  return variant_case() == kGeoDistance ? static_cast<const ::qdrant::GeoDistance&>(*reinterpret_cast<::qdrant::GeoDistance*>(_impl_.variant_.geo_distance_))
                     : reinterpret_cast<const ::qdrant::GeoDistance&>(::qdrant::_GeoDistance_default_instance_);
}
inline const ::qdrant::GeoDistance& Expression::geo_distance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.geo_distance)
  return _internal_geo_distance();
}
inline ::qdrant::GeoDistance* PROTOBUF_NULLABLE Expression::unsafe_arena_release_geo_distance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Expression.geo_distance)
  if (variant_case() == kGeoDistance) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::GeoDistance*>(_impl_.variant_.geo_distance_);
    _impl_.variant_.geo_distance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_geo_distance(
    ::qdrant::GeoDistance* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_geo_distance();
    _impl_.variant_.geo_distance_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Expression.geo_distance)
}
inline ::qdrant::GeoDistance* PROTOBUF_NONNULL Expression::_internal_mutable_geo_distance() {
  if (variant_case() != kGeoDistance) {
    clear_variant();
    set_has_geo_distance();
    _impl_.variant_.geo_distance_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::GeoDistance>(GetArena()));
  }
  return reinterpret_cast<::qdrant::GeoDistance*>(_impl_.variant_.geo_distance_);
}
inline ::qdrant::GeoDistance* PROTOBUF_NONNULL Expression::mutable_geo_distance()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::GeoDistance* _msg = _internal_mutable_geo_distance();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.geo_distance)
  return _msg;
}

// string datetime = 5;
inline bool Expression::has_datetime() const {
  return variant_case() == kDatetime;
}
inline void Expression::set_has_datetime() {
  _impl_._oneof_case_[0] = kDatetime;
}
inline void Expression::clear_datetime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kDatetime) {
    _impl_.variant_.datetime_.Destroy();
    clear_has_variant();
  }
}
inline const ::std::string& Expression::datetime() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.datetime)
  return _internal_datetime();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Expression::set_datetime(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() != kDatetime) {
    clear_variant();

    set_has_datetime();
    _impl_.variant_.datetime_.InitDefault();
  }
  _impl_.variant_.datetime_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.Expression.datetime)
}
inline ::std::string* PROTOBUF_NONNULL Expression::mutable_datetime()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  if (variant_case() != kDatetime) {
    clear_variant();

    set_has_datetime();
    _impl_.variant_.datetime_.InitDefault();
  }
  ::std::string* _s = _internal_mutable_datetime();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.datetime)
  return _s;
}
inline const ::std::string& Expression::_internal_datetime() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (variant_case() != kDatetime) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.variant_.datetime_.Get();
}
inline void Expression::_internal_set_datetime(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.variant_.datetime_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Expression::_internal_mutable_datetime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.variant_.datetime_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Expression::release_datetime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.Expression.datetime)
  if (variant_case() != kDatetime) {
    return nullptr;
  }
  clear_has_variant();
  return _impl_.variant_.datetime_.Release();
}
inline void Expression::set_allocated_datetime(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_variant()) {
    clear_variant();
  }
  if (value != nullptr) {
    set_has_datetime();
    _impl_.variant_.datetime_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.Expression.datetime)
}

// string datetime_key = 6;
inline bool Expression::has_datetime_key() const {
  return variant_case() == kDatetimeKey;
}
inline void Expression::set_has_datetime_key() {
  _impl_._oneof_case_[0] = kDatetimeKey;
}
inline void Expression::clear_datetime_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kDatetimeKey) {
    _impl_.variant_.datetime_key_.Destroy();
    clear_has_variant();
  }
}
inline const ::std::string& Expression::datetime_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.datetime_key)
  return _internal_datetime_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Expression::set_datetime_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() != kDatetimeKey) {
    clear_variant();

    set_has_datetime_key();
    _impl_.variant_.datetime_key_.InitDefault();
  }
  _impl_.variant_.datetime_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.Expression.datetime_key)
}
inline ::std::string* PROTOBUF_NONNULL Expression::mutable_datetime_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  if (variant_case() != kDatetimeKey) {
    clear_variant();

    set_has_datetime_key();
    _impl_.variant_.datetime_key_.InitDefault();
  }
  ::std::string* _s = _internal_mutable_datetime_key();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.datetime_key)
  return _s;
}
inline const ::std::string& Expression::_internal_datetime_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (variant_case() != kDatetimeKey) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.variant_.datetime_key_.Get();
}
inline void Expression::_internal_set_datetime_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.variant_.datetime_key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Expression::_internal_mutable_datetime_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.variant_.datetime_key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Expression::release_datetime_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.Expression.datetime_key)
  if (variant_case() != kDatetimeKey) {
    return nullptr;
  }
  clear_has_variant();
  return _impl_.variant_.datetime_key_.Release();
}
inline void Expression::set_allocated_datetime_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_variant()) {
    clear_variant();
  }
  if (value != nullptr) {
    set_has_datetime_key();
    _impl_.variant_.datetime_key_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.Expression.datetime_key)
}

// .qdrant.MultExpression mult = 7;
inline bool Expression::has_mult() const {
  return variant_case() == kMult;
}
inline bool Expression::_internal_has_mult() const {
  return variant_case() == kMult;
}
inline void Expression::set_has_mult() {
  _impl_._oneof_case_[0] = kMult;
}
inline void Expression::clear_mult() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kMult) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.mult_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.mult_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::MultExpression* PROTOBUF_NULLABLE Expression::release_mult() {
  // @@protoc_insertion_point(field_release:qdrant.Expression.mult)
  if (variant_case() == kMult) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::MultExpression*>(_impl_.variant_.mult_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.mult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::MultExpression& Expression::_internal_mult() const {
  return variant_case() == kMult ? static_cast<const ::qdrant::MultExpression&>(*reinterpret_cast<::qdrant::MultExpression*>(_impl_.variant_.mult_))
                     : reinterpret_cast<const ::qdrant::MultExpression&>(::qdrant::_MultExpression_default_instance_);
}
inline const ::qdrant::MultExpression& Expression::mult() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.mult)
  return _internal_mult();
}
inline ::qdrant::MultExpression* PROTOBUF_NULLABLE Expression::unsafe_arena_release_mult() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Expression.mult)
  if (variant_case() == kMult) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::MultExpression*>(_impl_.variant_.mult_);
    _impl_.variant_.mult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_mult(
    ::qdrant::MultExpression* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_mult();
    _impl_.variant_.mult_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Expression.mult)
}
inline ::qdrant::MultExpression* PROTOBUF_NONNULL Expression::_internal_mutable_mult() {
  if (variant_case() != kMult) {
    clear_variant();
    set_has_mult();
    _impl_.variant_.mult_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::MultExpression>(GetArena()));
  }
  return reinterpret_cast<::qdrant::MultExpression*>(_impl_.variant_.mult_);
}
inline ::qdrant::MultExpression* PROTOBUF_NONNULL Expression::mutable_mult()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::MultExpression* _msg = _internal_mutable_mult();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.mult)
  return _msg;
}

// .qdrant.SumExpression sum = 8;
inline bool Expression::has_sum() const {
  return variant_case() == kSum;
}
inline bool Expression::_internal_has_sum() const {
  return variant_case() == kSum;
}
inline void Expression::set_has_sum() {
  _impl_._oneof_case_[0] = kSum;
}
inline void Expression::clear_sum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kSum) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.sum_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.sum_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::SumExpression* PROTOBUF_NULLABLE Expression::release_sum() {
  // @@protoc_insertion_point(field_release:qdrant.Expression.sum)
  if (variant_case() == kSum) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::SumExpression*>(_impl_.variant_.sum_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::SumExpression& Expression::_internal_sum() const {
  return variant_case() == kSum ? static_cast<const ::qdrant::SumExpression&>(*reinterpret_cast<::qdrant::SumExpression*>(_impl_.variant_.sum_))
                     : reinterpret_cast<const ::qdrant::SumExpression&>(::qdrant::_SumExpression_default_instance_);
}
inline const ::qdrant::SumExpression& Expression::sum() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.sum)
  return _internal_sum();
}
inline ::qdrant::SumExpression* PROTOBUF_NULLABLE Expression::unsafe_arena_release_sum() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Expression.sum)
  if (variant_case() == kSum) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::SumExpression*>(_impl_.variant_.sum_);
    _impl_.variant_.sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_sum(
    ::qdrant::SumExpression* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_sum();
    _impl_.variant_.sum_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Expression.sum)
}
inline ::qdrant::SumExpression* PROTOBUF_NONNULL Expression::_internal_mutable_sum() {
  if (variant_case() != kSum) {
    clear_variant();
    set_has_sum();
    _impl_.variant_.sum_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::SumExpression>(GetArena()));
  }
  return reinterpret_cast<::qdrant::SumExpression*>(_impl_.variant_.sum_);
}
inline ::qdrant::SumExpression* PROTOBUF_NONNULL Expression::mutable_sum()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::SumExpression* _msg = _internal_mutable_sum();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.sum)
  return _msg;
}

// .qdrant.DivExpression div = 9;
inline bool Expression::has_div() const {
  return variant_case() == kDiv;
}
inline bool Expression::_internal_has_div() const {
  return variant_case() == kDiv;
}
inline void Expression::set_has_div() {
  _impl_._oneof_case_[0] = kDiv;
}
inline void Expression::clear_div() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kDiv) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.div_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.div_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::DivExpression* PROTOBUF_NULLABLE Expression::release_div() {
  // @@protoc_insertion_point(field_release:qdrant.Expression.div)
  if (variant_case() == kDiv) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::DivExpression*>(_impl_.variant_.div_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.div_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::DivExpression& Expression::_internal_div() const {
  return variant_case() == kDiv ? static_cast<const ::qdrant::DivExpression&>(*reinterpret_cast<::qdrant::DivExpression*>(_impl_.variant_.div_))
                     : reinterpret_cast<const ::qdrant::DivExpression&>(::qdrant::_DivExpression_default_instance_);
}
inline const ::qdrant::DivExpression& Expression::div() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.div)
  return _internal_div();
}
inline ::qdrant::DivExpression* PROTOBUF_NULLABLE Expression::unsafe_arena_release_div() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Expression.div)
  if (variant_case() == kDiv) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::DivExpression*>(_impl_.variant_.div_);
    _impl_.variant_.div_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_div(
    ::qdrant::DivExpression* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_div();
    _impl_.variant_.div_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Expression.div)
}
inline ::qdrant::DivExpression* PROTOBUF_NONNULL Expression::_internal_mutable_div() {
  if (variant_case() != kDiv) {
    clear_variant();
    set_has_div();
    _impl_.variant_.div_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::DivExpression>(GetArena()));
  }
  return reinterpret_cast<::qdrant::DivExpression*>(_impl_.variant_.div_);
}
inline ::qdrant::DivExpression* PROTOBUF_NONNULL Expression::mutable_div()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::DivExpression* _msg = _internal_mutable_div();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.div)
  return _msg;
}

// .qdrant.Expression neg = 10;
inline bool Expression::has_neg() const {
  return variant_case() == kNeg;
}
inline bool Expression::_internal_has_neg() const {
  return variant_case() == kNeg;
}
inline void Expression::set_has_neg() {
  _impl_._oneof_case_[0] = kNeg;
}
inline void Expression::clear_neg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kNeg) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.neg_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.neg_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE Expression::release_neg() {
  // @@protoc_insertion_point(field_release:qdrant.Expression.neg)
  if (variant_case() == kNeg) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.neg_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.neg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Expression& Expression::_internal_neg() const {
  return variant_case() == kNeg ? static_cast<const ::qdrant::Expression&>(*reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.neg_))
                     : reinterpret_cast<const ::qdrant::Expression&>(::qdrant::_Expression_default_instance_);
}
inline const ::qdrant::Expression& Expression::neg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.neg)
  return _internal_neg();
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE Expression::unsafe_arena_release_neg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Expression.neg)
  if (variant_case() == kNeg) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.neg_);
    _impl_.variant_.neg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_neg(
    ::qdrant::Expression* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_neg();
    _impl_.variant_.neg_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Expression.neg)
}
inline ::qdrant::Expression* PROTOBUF_NONNULL Expression::_internal_mutable_neg() {
  if (variant_case() != kNeg) {
    clear_variant();
    set_has_neg();
    _impl_.variant_.neg_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Expression>(GetArena()));
  }
  return reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.neg_);
}
inline ::qdrant::Expression* PROTOBUF_NONNULL Expression::mutable_neg()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Expression* _msg = _internal_mutable_neg();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.neg)
  return _msg;
}

// .qdrant.Expression abs = 11;
inline bool Expression::has_abs() const {
  return variant_case() == kAbs;
}
inline bool Expression::_internal_has_abs() const {
  return variant_case() == kAbs;
}
inline void Expression::set_has_abs() {
  _impl_._oneof_case_[0] = kAbs;
}
inline void Expression::clear_abs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kAbs) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.abs_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.abs_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE Expression::release_abs() {
  // @@protoc_insertion_point(field_release:qdrant.Expression.abs)
  if (variant_case() == kAbs) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.abs_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.abs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Expression& Expression::_internal_abs() const {
  return variant_case() == kAbs ? static_cast<const ::qdrant::Expression&>(*reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.abs_))
                     : reinterpret_cast<const ::qdrant::Expression&>(::qdrant::_Expression_default_instance_);
}
inline const ::qdrant::Expression& Expression::abs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.abs)
  return _internal_abs();
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE Expression::unsafe_arena_release_abs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Expression.abs)
  if (variant_case() == kAbs) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.abs_);
    _impl_.variant_.abs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_abs(
    ::qdrant::Expression* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_abs();
    _impl_.variant_.abs_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Expression.abs)
}
inline ::qdrant::Expression* PROTOBUF_NONNULL Expression::_internal_mutable_abs() {
  if (variant_case() != kAbs) {
    clear_variant();
    set_has_abs();
    _impl_.variant_.abs_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Expression>(GetArena()));
  }
  return reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.abs_);
}
inline ::qdrant::Expression* PROTOBUF_NONNULL Expression::mutable_abs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Expression* _msg = _internal_mutable_abs();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.abs)
  return _msg;
}

// .qdrant.Expression sqrt = 12;
inline bool Expression::has_sqrt() const {
  return variant_case() == kSqrt;
}
inline bool Expression::_internal_has_sqrt() const {
  return variant_case() == kSqrt;
}
inline void Expression::set_has_sqrt() {
  _impl_._oneof_case_[0] = kSqrt;
}
inline void Expression::clear_sqrt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kSqrt) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.sqrt_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.sqrt_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE Expression::release_sqrt() {
  // @@protoc_insertion_point(field_release:qdrant.Expression.sqrt)
  if (variant_case() == kSqrt) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.sqrt_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.sqrt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Expression& Expression::_internal_sqrt() const {
  return variant_case() == kSqrt ? static_cast<const ::qdrant::Expression&>(*reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.sqrt_))
                     : reinterpret_cast<const ::qdrant::Expression&>(::qdrant::_Expression_default_instance_);
}
inline const ::qdrant::Expression& Expression::sqrt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.sqrt)
  return _internal_sqrt();
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE Expression::unsafe_arena_release_sqrt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Expression.sqrt)
  if (variant_case() == kSqrt) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.sqrt_);
    _impl_.variant_.sqrt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_sqrt(
    ::qdrant::Expression* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_sqrt();
    _impl_.variant_.sqrt_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Expression.sqrt)
}
inline ::qdrant::Expression* PROTOBUF_NONNULL Expression::_internal_mutable_sqrt() {
  if (variant_case() != kSqrt) {
    clear_variant();
    set_has_sqrt();
    _impl_.variant_.sqrt_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Expression>(GetArena()));
  }
  return reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.sqrt_);
}
inline ::qdrant::Expression* PROTOBUF_NONNULL Expression::mutable_sqrt()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Expression* _msg = _internal_mutable_sqrt();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.sqrt)
  return _msg;
}

// .qdrant.PowExpression pow = 13;
inline bool Expression::has_pow() const {
  return variant_case() == kPow;
}
inline bool Expression::_internal_has_pow() const {
  return variant_case() == kPow;
}
inline void Expression::set_has_pow() {
  _impl_._oneof_case_[0] = kPow;
}
inline void Expression::clear_pow() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kPow) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.pow_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.pow_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::PowExpression* PROTOBUF_NULLABLE Expression::release_pow() {
  // @@protoc_insertion_point(field_release:qdrant.Expression.pow)
  if (variant_case() == kPow) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::PowExpression*>(_impl_.variant_.pow_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.pow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::PowExpression& Expression::_internal_pow() const {
  return variant_case() == kPow ? static_cast<const ::qdrant::PowExpression&>(*reinterpret_cast<::qdrant::PowExpression*>(_impl_.variant_.pow_))
                     : reinterpret_cast<const ::qdrant::PowExpression&>(::qdrant::_PowExpression_default_instance_);
}
inline const ::qdrant::PowExpression& Expression::pow() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.pow)
  return _internal_pow();
}
inline ::qdrant::PowExpression* PROTOBUF_NULLABLE Expression::unsafe_arena_release_pow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Expression.pow)
  if (variant_case() == kPow) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::PowExpression*>(_impl_.variant_.pow_);
    _impl_.variant_.pow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_pow(
    ::qdrant::PowExpression* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_pow();
    _impl_.variant_.pow_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Expression.pow)
}
inline ::qdrant::PowExpression* PROTOBUF_NONNULL Expression::_internal_mutable_pow() {
  if (variant_case() != kPow) {
    clear_variant();
    set_has_pow();
    _impl_.variant_.pow_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::PowExpression>(GetArena()));
  }
  return reinterpret_cast<::qdrant::PowExpression*>(_impl_.variant_.pow_);
}
inline ::qdrant::PowExpression* PROTOBUF_NONNULL Expression::mutable_pow()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::PowExpression* _msg = _internal_mutable_pow();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.pow)
  return _msg;
}

// .qdrant.Expression exp = 14;
inline bool Expression::has_exp() const {
  return variant_case() == kExp;
}
inline bool Expression::_internal_has_exp() const {
  return variant_case() == kExp;
}
inline void Expression::set_has_exp() {
  _impl_._oneof_case_[0] = kExp;
}
inline void Expression::clear_exp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kExp) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.exp_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.exp_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE Expression::release_exp() {
  // @@protoc_insertion_point(field_release:qdrant.Expression.exp)
  if (variant_case() == kExp) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.exp_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.exp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Expression& Expression::_internal_exp() const {
  return variant_case() == kExp ? static_cast<const ::qdrant::Expression&>(*reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.exp_))
                     : reinterpret_cast<const ::qdrant::Expression&>(::qdrant::_Expression_default_instance_);
}
inline const ::qdrant::Expression& Expression::exp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.exp)
  return _internal_exp();
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE Expression::unsafe_arena_release_exp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Expression.exp)
  if (variant_case() == kExp) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.exp_);
    _impl_.variant_.exp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_exp(
    ::qdrant::Expression* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_exp();
    _impl_.variant_.exp_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Expression.exp)
}
inline ::qdrant::Expression* PROTOBUF_NONNULL Expression::_internal_mutable_exp() {
  if (variant_case() != kExp) {
    clear_variant();
    set_has_exp();
    _impl_.variant_.exp_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Expression>(GetArena()));
  }
  return reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.exp_);
}
inline ::qdrant::Expression* PROTOBUF_NONNULL Expression::mutable_exp()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Expression* _msg = _internal_mutable_exp();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.exp)
  return _msg;
}

// .qdrant.Expression log10 = 15;
inline bool Expression::has_log10() const {
  return variant_case() == kLog10;
}
inline bool Expression::_internal_has_log10() const {
  return variant_case() == kLog10;
}
inline void Expression::set_has_log10() {
  _impl_._oneof_case_[0] = kLog10;
}
inline void Expression::clear_log10() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kLog10) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.log10_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.log10_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE Expression::release_log10() {
  // @@protoc_insertion_point(field_release:qdrant.Expression.log10)
  if (variant_case() == kLog10) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.log10_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.log10_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Expression& Expression::_internal_log10() const {
  return variant_case() == kLog10 ? static_cast<const ::qdrant::Expression&>(*reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.log10_))
                     : reinterpret_cast<const ::qdrant::Expression&>(::qdrant::_Expression_default_instance_);
}
inline const ::qdrant::Expression& Expression::log10() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.log10)
  return _internal_log10();
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE Expression::unsafe_arena_release_log10() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Expression.log10)
  if (variant_case() == kLog10) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.log10_);
    _impl_.variant_.log10_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_log10(
    ::qdrant::Expression* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_log10();
    _impl_.variant_.log10_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Expression.log10)
}
inline ::qdrant::Expression* PROTOBUF_NONNULL Expression::_internal_mutable_log10() {
  if (variant_case() != kLog10) {
    clear_variant();
    set_has_log10();
    _impl_.variant_.log10_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Expression>(GetArena()));
  }
  return reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.log10_);
}
inline ::qdrant::Expression* PROTOBUF_NONNULL Expression::mutable_log10()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Expression* _msg = _internal_mutable_log10();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.log10)
  return _msg;
}

// .qdrant.Expression ln = 16;
inline bool Expression::has_ln() const {
  return variant_case() == kLn;
}
inline bool Expression::_internal_has_ln() const {
  return variant_case() == kLn;
}
inline void Expression::set_has_ln() {
  _impl_._oneof_case_[0] = kLn;
}
inline void Expression::clear_ln() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kLn) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.ln_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.ln_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE Expression::release_ln() {
  // @@protoc_insertion_point(field_release:qdrant.Expression.ln)
  if (variant_case() == kLn) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.ln_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.ln_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Expression& Expression::_internal_ln() const {
  return variant_case() == kLn ? static_cast<const ::qdrant::Expression&>(*reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.ln_))
                     : reinterpret_cast<const ::qdrant::Expression&>(::qdrant::_Expression_default_instance_);
}
inline const ::qdrant::Expression& Expression::ln() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.ln)
  return _internal_ln();
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE Expression::unsafe_arena_release_ln() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Expression.ln)
  if (variant_case() == kLn) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.ln_);
    _impl_.variant_.ln_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_ln(
    ::qdrant::Expression* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_ln();
    _impl_.variant_.ln_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Expression.ln)
}
inline ::qdrant::Expression* PROTOBUF_NONNULL Expression::_internal_mutable_ln() {
  if (variant_case() != kLn) {
    clear_variant();
    set_has_ln();
    _impl_.variant_.ln_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Expression>(GetArena()));
  }
  return reinterpret_cast<::qdrant::Expression*>(_impl_.variant_.ln_);
}
inline ::qdrant::Expression* PROTOBUF_NONNULL Expression::mutable_ln()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Expression* _msg = _internal_mutable_ln();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.ln)
  return _msg;
}

// .qdrant.DecayParamsExpression exp_decay = 17;
inline bool Expression::has_exp_decay() const {
  return variant_case() == kExpDecay;
}
inline bool Expression::_internal_has_exp_decay() const {
  return variant_case() == kExpDecay;
}
inline void Expression::set_has_exp_decay() {
  _impl_._oneof_case_[0] = kExpDecay;
}
inline void Expression::clear_exp_decay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kExpDecay) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.exp_decay_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.exp_decay_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE Expression::release_exp_decay() {
  // @@protoc_insertion_point(field_release:qdrant.Expression.exp_decay)
  if (variant_case() == kExpDecay) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::DecayParamsExpression*>(_impl_.variant_.exp_decay_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.exp_decay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::DecayParamsExpression& Expression::_internal_exp_decay() const {
  return variant_case() == kExpDecay ? static_cast<const ::qdrant::DecayParamsExpression&>(*reinterpret_cast<::qdrant::DecayParamsExpression*>(_impl_.variant_.exp_decay_))
                     : reinterpret_cast<const ::qdrant::DecayParamsExpression&>(::qdrant::_DecayParamsExpression_default_instance_);
}
inline const ::qdrant::DecayParamsExpression& Expression::exp_decay() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.exp_decay)
  return _internal_exp_decay();
}
inline ::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE Expression::unsafe_arena_release_exp_decay() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Expression.exp_decay)
  if (variant_case() == kExpDecay) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::DecayParamsExpression*>(_impl_.variant_.exp_decay_);
    _impl_.variant_.exp_decay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_exp_decay(
    ::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_exp_decay();
    _impl_.variant_.exp_decay_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Expression.exp_decay)
}
inline ::qdrant::DecayParamsExpression* PROTOBUF_NONNULL Expression::_internal_mutable_exp_decay() {
  if (variant_case() != kExpDecay) {
    clear_variant();
    set_has_exp_decay();
    _impl_.variant_.exp_decay_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::DecayParamsExpression>(GetArena()));
  }
  return reinterpret_cast<::qdrant::DecayParamsExpression*>(_impl_.variant_.exp_decay_);
}
inline ::qdrant::DecayParamsExpression* PROTOBUF_NONNULL Expression::mutable_exp_decay()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::DecayParamsExpression* _msg = _internal_mutable_exp_decay();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.exp_decay)
  return _msg;
}

// .qdrant.DecayParamsExpression gauss_decay = 18;
inline bool Expression::has_gauss_decay() const {
  return variant_case() == kGaussDecay;
}
inline bool Expression::_internal_has_gauss_decay() const {
  return variant_case() == kGaussDecay;
}
inline void Expression::set_has_gauss_decay() {
  _impl_._oneof_case_[0] = kGaussDecay;
}
inline void Expression::clear_gauss_decay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kGaussDecay) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.gauss_decay_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.gauss_decay_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE Expression::release_gauss_decay() {
  // @@protoc_insertion_point(field_release:qdrant.Expression.gauss_decay)
  if (variant_case() == kGaussDecay) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::DecayParamsExpression*>(_impl_.variant_.gauss_decay_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.gauss_decay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::DecayParamsExpression& Expression::_internal_gauss_decay() const {
  return variant_case() == kGaussDecay ? static_cast<const ::qdrant::DecayParamsExpression&>(*reinterpret_cast<::qdrant::DecayParamsExpression*>(_impl_.variant_.gauss_decay_))
                     : reinterpret_cast<const ::qdrant::DecayParamsExpression&>(::qdrant::_DecayParamsExpression_default_instance_);
}
inline const ::qdrant::DecayParamsExpression& Expression::gauss_decay() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.gauss_decay)
  return _internal_gauss_decay();
}
inline ::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE Expression::unsafe_arena_release_gauss_decay() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Expression.gauss_decay)
  if (variant_case() == kGaussDecay) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::DecayParamsExpression*>(_impl_.variant_.gauss_decay_);
    _impl_.variant_.gauss_decay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_gauss_decay(
    ::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_gauss_decay();
    _impl_.variant_.gauss_decay_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Expression.gauss_decay)
}
inline ::qdrant::DecayParamsExpression* PROTOBUF_NONNULL Expression::_internal_mutable_gauss_decay() {
  if (variant_case() != kGaussDecay) {
    clear_variant();
    set_has_gauss_decay();
    _impl_.variant_.gauss_decay_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::DecayParamsExpression>(GetArena()));
  }
  return reinterpret_cast<::qdrant::DecayParamsExpression*>(_impl_.variant_.gauss_decay_);
}
inline ::qdrant::DecayParamsExpression* PROTOBUF_NONNULL Expression::mutable_gauss_decay()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::DecayParamsExpression* _msg = _internal_mutable_gauss_decay();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.gauss_decay)
  return _msg;
}

// .qdrant.DecayParamsExpression lin_decay = 19;
inline bool Expression::has_lin_decay() const {
  return variant_case() == kLinDecay;
}
inline bool Expression::_internal_has_lin_decay() const {
  return variant_case() == kLinDecay;
}
inline void Expression::set_has_lin_decay() {
  _impl_._oneof_case_[0] = kLinDecay;
}
inline void Expression::clear_lin_decay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kLinDecay) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.lin_decay_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.lin_decay_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE Expression::release_lin_decay() {
  // @@protoc_insertion_point(field_release:qdrant.Expression.lin_decay)
  if (variant_case() == kLinDecay) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::DecayParamsExpression*>(_impl_.variant_.lin_decay_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.lin_decay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::DecayParamsExpression& Expression::_internal_lin_decay() const {
  return variant_case() == kLinDecay ? static_cast<const ::qdrant::DecayParamsExpression&>(*reinterpret_cast<::qdrant::DecayParamsExpression*>(_impl_.variant_.lin_decay_))
                     : reinterpret_cast<const ::qdrant::DecayParamsExpression&>(::qdrant::_DecayParamsExpression_default_instance_);
}
inline const ::qdrant::DecayParamsExpression& Expression::lin_decay() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Expression.lin_decay)
  return _internal_lin_decay();
}
inline ::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE Expression::unsafe_arena_release_lin_decay() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Expression.lin_decay)
  if (variant_case() == kLinDecay) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::DecayParamsExpression*>(_impl_.variant_.lin_decay_);
    _impl_.variant_.lin_decay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_lin_decay(
    ::qdrant::DecayParamsExpression* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_lin_decay();
    _impl_.variant_.lin_decay_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Expression.lin_decay)
}
inline ::qdrant::DecayParamsExpression* PROTOBUF_NONNULL Expression::_internal_mutable_lin_decay() {
  if (variant_case() != kLinDecay) {
    clear_variant();
    set_has_lin_decay();
    _impl_.variant_.lin_decay_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::DecayParamsExpression>(GetArena()));
  }
  return reinterpret_cast<::qdrant::DecayParamsExpression*>(_impl_.variant_.lin_decay_);
}
inline ::qdrant::DecayParamsExpression* PROTOBUF_NONNULL Expression::mutable_lin_decay()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::DecayParamsExpression* _msg = _internal_mutable_lin_decay();
  // @@protoc_insertion_point(field_mutable:qdrant.Expression.lin_decay)
  return _msg;
}

inline bool Expression::has_variant() const {
  return variant_case() != VARIANT_NOT_SET;
}
inline void Expression::clear_has_variant() {
  _impl_._oneof_case_[0] = VARIANT_NOT_SET;
}
inline Expression::VariantCase Expression::variant_case() const {
  return Expression::VariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GeoDistance

// .qdrant.GeoPoint origin = 1;
inline bool GeoDistance::has_origin() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.origin_ != nullptr);
  return value;
}
inline void GeoDistance::clear_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::GeoPoint& GeoDistance::_internal_origin() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::GeoPoint* p = _impl_.origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::GeoPoint&>(::qdrant::_GeoPoint_default_instance_);
}
inline const ::qdrant::GeoPoint& GeoDistance::origin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GeoDistance.origin)
  return _internal_origin();
}
inline void GeoDistance::unsafe_arena_set_allocated_origin(
    ::qdrant::GeoPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.origin_);
  }
  _impl_.origin_ = reinterpret_cast<::qdrant::GeoPoint*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.GeoDistance.origin)
}
inline ::qdrant::GeoPoint* PROTOBUF_NULLABLE GeoDistance::release_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::GeoPoint* released = _impl_.origin_;
  _impl_.origin_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::GeoPoint* PROTOBUF_NULLABLE GeoDistance::unsafe_arena_release_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.GeoDistance.origin)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::GeoPoint* temp = _impl_.origin_;
  _impl_.origin_ = nullptr;
  return temp;
}
inline ::qdrant::GeoPoint* PROTOBUF_NONNULL GeoDistance::_internal_mutable_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.origin_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::GeoPoint>(GetArena());
    _impl_.origin_ = reinterpret_cast<::qdrant::GeoPoint*>(p);
  }
  return _impl_.origin_;
}
inline ::qdrant::GeoPoint* PROTOBUF_NONNULL GeoDistance::mutable_origin()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::GeoPoint* _msg = _internal_mutable_origin();
  // @@protoc_insertion_point(field_mutable:qdrant.GeoDistance.origin)
  return _msg;
}
inline void GeoDistance::set_allocated_origin(::qdrant::GeoPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.origin_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.origin_ = reinterpret_cast<::qdrant::GeoPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.GeoDistance.origin)
}

// string to = 2;
inline void GeoDistance::clear_to() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& GeoDistance::to() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GeoDistance.to)
  return _internal_to();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GeoDistance::set_to(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.to_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.GeoDistance.to)
}
inline ::std::string* PROTOBUF_NONNULL GeoDistance::mutable_to()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:qdrant.GeoDistance.to)
  return _s;
}
inline const ::std::string& GeoDistance::_internal_to() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_.Get();
}
inline void GeoDistance::_internal_set_to(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GeoDistance::_internal_mutable_to() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.to_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GeoDistance::release_to() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.GeoDistance.to)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.to_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.to_.Set("", GetArena());
  }
  return released;
}
inline void GeoDistance::set_allocated_to(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.to_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.to_.IsDefault()) {
    _impl_.to_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.GeoDistance.to)
}

// -------------------------------------------------------------------

// MultExpression

// repeated .qdrant.Expression mult = 1;
inline int MultExpression::_internal_mult_size() const {
  return _internal_mult().size();
}
inline int MultExpression::mult_size() const {
  return _internal_mult_size();
}
inline void MultExpression::clear_mult() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mult_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::Expression* PROTOBUF_NONNULL MultExpression::mutable_mult(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.MultExpression.mult)
  return _internal_mutable_mult()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Expression>* PROTOBUF_NONNULL MultExpression::mutable_mult()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.MultExpression.mult)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_mult();
}
inline const ::qdrant::Expression& MultExpression::mult(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.MultExpression.mult)
  return _internal_mult().Get(index);
}
inline ::qdrant::Expression* PROTOBUF_NONNULL MultExpression::add_mult()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::Expression* _add =
      _internal_mutable_mult()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.MultExpression.mult)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Expression>& MultExpression::mult() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.MultExpression.mult)
  return _internal_mult();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Expression>&
MultExpression::_internal_mult() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mult_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Expression>* PROTOBUF_NONNULL
MultExpression::_internal_mutable_mult() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.mult_;
}

// -------------------------------------------------------------------

// SumExpression

// repeated .qdrant.Expression sum = 1;
inline int SumExpression::_internal_sum_size() const {
  return _internal_sum().size();
}
inline int SumExpression::sum_size() const {
  return _internal_sum_size();
}
inline void SumExpression::clear_sum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sum_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::Expression* PROTOBUF_NONNULL SumExpression::mutable_sum(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.SumExpression.sum)
  return _internal_mutable_sum()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Expression>* PROTOBUF_NONNULL SumExpression::mutable_sum()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.SumExpression.sum)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_sum();
}
inline const ::qdrant::Expression& SumExpression::sum(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SumExpression.sum)
  return _internal_sum().Get(index);
}
inline ::qdrant::Expression* PROTOBUF_NONNULL SumExpression::add_sum()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::Expression* _add =
      _internal_mutable_sum()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.SumExpression.sum)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Expression>& SumExpression::sum() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.SumExpression.sum)
  return _internal_sum();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Expression>&
SumExpression::_internal_sum() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sum_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Expression>* PROTOBUF_NONNULL
SumExpression::_internal_mutable_sum() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.sum_;
}

// -------------------------------------------------------------------

// DivExpression

// .qdrant.Expression left = 1;
inline bool DivExpression::has_left() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline void DivExpression::clear_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::Expression& DivExpression::_internal_left() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Expression* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Expression&>(::qdrant::_Expression_default_instance_);
}
inline const ::qdrant::Expression& DivExpression::left() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DivExpression.left)
  return _internal_left();
}
inline void DivExpression::unsafe_arena_set_allocated_left(
    ::qdrant::Expression* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = reinterpret_cast<::qdrant::Expression*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DivExpression.left)
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE DivExpression::release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::Expression* released = _impl_.left_;
  _impl_.left_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE DivExpression::unsafe_arena_release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DivExpression.left)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::Expression* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::qdrant::Expression* PROTOBUF_NONNULL DivExpression::_internal_mutable_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Expression>(GetArena());
    _impl_.left_ = reinterpret_cast<::qdrant::Expression*>(p);
  }
  return _impl_.left_;
}
inline ::qdrant::Expression* PROTOBUF_NONNULL DivExpression::mutable_left()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::Expression* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:qdrant.DivExpression.left)
  return _msg;
}
inline void DivExpression::set_allocated_left(::qdrant::Expression* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.left_ = reinterpret_cast<::qdrant::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DivExpression.left)
}

// .qdrant.Expression right = 2;
inline bool DivExpression::has_right() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline void DivExpression::clear_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Expression& DivExpression::_internal_right() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Expression* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Expression&>(::qdrant::_Expression_default_instance_);
}
inline const ::qdrant::Expression& DivExpression::right() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DivExpression.right)
  return _internal_right();
}
inline void DivExpression::unsafe_arena_set_allocated_right(
    ::qdrant::Expression* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = reinterpret_cast<::qdrant::Expression*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DivExpression.right)
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE DivExpression::release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Expression* released = _impl_.right_;
  _impl_.right_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE DivExpression::unsafe_arena_release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DivExpression.right)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Expression* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::qdrant::Expression* PROTOBUF_NONNULL DivExpression::_internal_mutable_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Expression>(GetArena());
    _impl_.right_ = reinterpret_cast<::qdrant::Expression*>(p);
  }
  return _impl_.right_;
}
inline ::qdrant::Expression* PROTOBUF_NONNULL DivExpression::mutable_right()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Expression* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:qdrant.DivExpression.right)
  return _msg;
}
inline void DivExpression::set_allocated_right(::qdrant::Expression* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.right_ = reinterpret_cast<::qdrant::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DivExpression.right)
}

// optional float by_zero_default = 3;
inline bool DivExpression::has_by_zero_default() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void DivExpression::clear_by_zero_default() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.by_zero_default_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline float DivExpression::by_zero_default() const {
  // @@protoc_insertion_point(field_get:qdrant.DivExpression.by_zero_default)
  return _internal_by_zero_default();
}
inline void DivExpression::set_by_zero_default(float value) {
  _internal_set_by_zero_default(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.DivExpression.by_zero_default)
}
inline float DivExpression::_internal_by_zero_default() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.by_zero_default_;
}
inline void DivExpression::_internal_set_by_zero_default(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.by_zero_default_ = value;
}

// -------------------------------------------------------------------

// PowExpression

// .qdrant.Expression base = 1;
inline bool PowExpression::has_base() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.base_ != nullptr);
  return value;
}
inline void PowExpression::clear_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.base_ != nullptr) _impl_.base_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::Expression& PowExpression::_internal_base() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Expression* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Expression&>(::qdrant::_Expression_default_instance_);
}
inline const ::qdrant::Expression& PowExpression::base() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PowExpression.base)
  return _internal_base();
}
inline void PowExpression::unsafe_arena_set_allocated_base(
    ::qdrant::Expression* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = reinterpret_cast<::qdrant::Expression*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PowExpression.base)
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE PowExpression::release_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::Expression* released = _impl_.base_;
  _impl_.base_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE PowExpression::unsafe_arena_release_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PowExpression.base)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::Expression* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::qdrant::Expression* PROTOBUF_NONNULL PowExpression::_internal_mutable_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.base_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Expression>(GetArena());
    _impl_.base_ = reinterpret_cast<::qdrant::Expression*>(p);
  }
  return _impl_.base_;
}
inline ::qdrant::Expression* PROTOBUF_NONNULL PowExpression::mutable_base()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::Expression* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:qdrant.PowExpression.base)
  return _msg;
}
inline void PowExpression::set_allocated_base(::qdrant::Expression* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.base_ = reinterpret_cast<::qdrant::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PowExpression.base)
}

// .qdrant.Expression exponent = 2;
inline bool PowExpression::has_exponent() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.exponent_ != nullptr);
  return value;
}
inline void PowExpression::clear_exponent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.exponent_ != nullptr) _impl_.exponent_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Expression& PowExpression::_internal_exponent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Expression* p = _impl_.exponent_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Expression&>(::qdrant::_Expression_default_instance_);
}
inline const ::qdrant::Expression& PowExpression::exponent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PowExpression.exponent)
  return _internal_exponent();
}
inline void PowExpression::unsafe_arena_set_allocated_exponent(
    ::qdrant::Expression* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.exponent_);
  }
  _impl_.exponent_ = reinterpret_cast<::qdrant::Expression*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PowExpression.exponent)
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE PowExpression::release_exponent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Expression* released = _impl_.exponent_;
  _impl_.exponent_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE PowExpression::unsafe_arena_release_exponent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PowExpression.exponent)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Expression* temp = _impl_.exponent_;
  _impl_.exponent_ = nullptr;
  return temp;
}
inline ::qdrant::Expression* PROTOBUF_NONNULL PowExpression::_internal_mutable_exponent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.exponent_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Expression>(GetArena());
    _impl_.exponent_ = reinterpret_cast<::qdrant::Expression*>(p);
  }
  return _impl_.exponent_;
}
inline ::qdrant::Expression* PROTOBUF_NONNULL PowExpression::mutable_exponent()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Expression* _msg = _internal_mutable_exponent();
  // @@protoc_insertion_point(field_mutable:qdrant.PowExpression.exponent)
  return _msg;
}
inline void PowExpression::set_allocated_exponent(::qdrant::Expression* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.exponent_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.exponent_ = reinterpret_cast<::qdrant::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PowExpression.exponent)
}

// -------------------------------------------------------------------

// DecayParamsExpression

// .qdrant.Expression x = 1;
inline bool DecayParamsExpression::has_x() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.x_ != nullptr);
  return value;
}
inline void DecayParamsExpression::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.x_ != nullptr) _impl_.x_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::Expression& DecayParamsExpression::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Expression* p = _impl_.x_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Expression&>(::qdrant::_Expression_default_instance_);
}
inline const ::qdrant::Expression& DecayParamsExpression::x() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DecayParamsExpression.x)
  return _internal_x();
}
inline void DecayParamsExpression::unsafe_arena_set_allocated_x(
    ::qdrant::Expression* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }
  _impl_.x_ = reinterpret_cast<::qdrant::Expression*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DecayParamsExpression.x)
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE DecayParamsExpression::release_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::Expression* released = _impl_.x_;
  _impl_.x_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE DecayParamsExpression::unsafe_arena_release_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DecayParamsExpression.x)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::Expression* temp = _impl_.x_;
  _impl_.x_ = nullptr;
  return temp;
}
inline ::qdrant::Expression* PROTOBUF_NONNULL DecayParamsExpression::_internal_mutable_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.x_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Expression>(GetArena());
    _impl_.x_ = reinterpret_cast<::qdrant::Expression*>(p);
  }
  return _impl_.x_;
}
inline ::qdrant::Expression* PROTOBUF_NONNULL DecayParamsExpression::mutable_x()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::Expression* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:qdrant.DecayParamsExpression.x)
  return _msg;
}
inline void DecayParamsExpression::set_allocated_x(::qdrant::Expression* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.x_ = reinterpret_cast<::qdrant::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DecayParamsExpression.x)
}

// optional .qdrant.Expression target = 2;
inline bool DecayParamsExpression::has_target() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline void DecayParamsExpression::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_ != nullptr) _impl_.target_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Expression& DecayParamsExpression::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Expression* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Expression&>(::qdrant::_Expression_default_instance_);
}
inline const ::qdrant::Expression& DecayParamsExpression::target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DecayParamsExpression.target)
  return _internal_target();
}
inline void DecayParamsExpression::unsafe_arena_set_allocated_target(
    ::qdrant::Expression* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = reinterpret_cast<::qdrant::Expression*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DecayParamsExpression.target)
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE DecayParamsExpression::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Expression* released = _impl_.target_;
  _impl_.target_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Expression* PROTOBUF_NULLABLE DecayParamsExpression::unsafe_arena_release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DecayParamsExpression.target)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Expression* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::qdrant::Expression* PROTOBUF_NONNULL DecayParamsExpression::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Expression>(GetArena());
    _impl_.target_ = reinterpret_cast<::qdrant::Expression*>(p);
  }
  return _impl_.target_;
}
inline ::qdrant::Expression* PROTOBUF_NONNULL DecayParamsExpression::mutable_target()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Expression* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:qdrant.DecayParamsExpression.target)
  return _msg;
}
inline void DecayParamsExpression::set_allocated_target(::qdrant::Expression* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.target_ = reinterpret_cast<::qdrant::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DecayParamsExpression.target)
}

// optional float scale = 3;
inline bool DecayParamsExpression::has_scale() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void DecayParamsExpression::clear_scale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scale_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline float DecayParamsExpression::scale() const {
  // @@protoc_insertion_point(field_get:qdrant.DecayParamsExpression.scale)
  return _internal_scale();
}
inline void DecayParamsExpression::set_scale(float value) {
  _internal_set_scale(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.DecayParamsExpression.scale)
}
inline float DecayParamsExpression::_internal_scale() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.scale_;
}
inline void DecayParamsExpression::_internal_set_scale(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scale_ = value;
}

// optional float midpoint = 4;
inline bool DecayParamsExpression::has_midpoint() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void DecayParamsExpression::clear_midpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.midpoint_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline float DecayParamsExpression::midpoint() const {
  // @@protoc_insertion_point(field_get:qdrant.DecayParamsExpression.midpoint)
  return _internal_midpoint();
}
inline void DecayParamsExpression::set_midpoint(float value) {
  _internal_set_midpoint(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.DecayParamsExpression.midpoint)
}
inline float DecayParamsExpression::_internal_midpoint() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.midpoint_;
}
inline void DecayParamsExpression::_internal_set_midpoint(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.midpoint_ = value;
}

// -------------------------------------------------------------------

// NearestInputWithMmr

// .qdrant.VectorInput nearest = 1;
inline bool NearestInputWithMmr::has_nearest() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.nearest_ != nullptr);
  return value;
}
inline void NearestInputWithMmr::clear_nearest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.nearest_ != nullptr) _impl_.nearest_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::VectorInput& NearestInputWithMmr::_internal_nearest() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::VectorInput* p = _impl_.nearest_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::VectorInput&>(::qdrant::_VectorInput_default_instance_);
}
inline const ::qdrant::VectorInput& NearestInputWithMmr::nearest() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.NearestInputWithMmr.nearest)
  return _internal_nearest();
}
inline void NearestInputWithMmr::unsafe_arena_set_allocated_nearest(
    ::qdrant::VectorInput* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.nearest_);
  }
  _impl_.nearest_ = reinterpret_cast<::qdrant::VectorInput*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.NearestInputWithMmr.nearest)
}
inline ::qdrant::VectorInput* PROTOBUF_NULLABLE NearestInputWithMmr::release_nearest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::VectorInput* released = _impl_.nearest_;
  _impl_.nearest_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::VectorInput* PROTOBUF_NULLABLE NearestInputWithMmr::unsafe_arena_release_nearest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.NearestInputWithMmr.nearest)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::VectorInput* temp = _impl_.nearest_;
  _impl_.nearest_ = nullptr;
  return temp;
}
inline ::qdrant::VectorInput* PROTOBUF_NONNULL NearestInputWithMmr::_internal_mutable_nearest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.nearest_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorInput>(GetArena());
    _impl_.nearest_ = reinterpret_cast<::qdrant::VectorInput*>(p);
  }
  return _impl_.nearest_;
}
inline ::qdrant::VectorInput* PROTOBUF_NONNULL NearestInputWithMmr::mutable_nearest()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::VectorInput* _msg = _internal_mutable_nearest();
  // @@protoc_insertion_point(field_mutable:qdrant.NearestInputWithMmr.nearest)
  return _msg;
}
inline void NearestInputWithMmr::set_allocated_nearest(::qdrant::VectorInput* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.nearest_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.nearest_ = reinterpret_cast<::qdrant::VectorInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.NearestInputWithMmr.nearest)
}

// .qdrant.Mmr mmr = 2;
inline bool NearestInputWithMmr::has_mmr() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.mmr_ != nullptr);
  return value;
}
inline void NearestInputWithMmr::clear_mmr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mmr_ != nullptr) _impl_.mmr_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Mmr& NearestInputWithMmr::_internal_mmr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Mmr* p = _impl_.mmr_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Mmr&>(::qdrant::_Mmr_default_instance_);
}
inline const ::qdrant::Mmr& NearestInputWithMmr::mmr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.NearestInputWithMmr.mmr)
  return _internal_mmr();
}
inline void NearestInputWithMmr::unsafe_arena_set_allocated_mmr(
    ::qdrant::Mmr* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mmr_);
  }
  _impl_.mmr_ = reinterpret_cast<::qdrant::Mmr*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.NearestInputWithMmr.mmr)
}
inline ::qdrant::Mmr* PROTOBUF_NULLABLE NearestInputWithMmr::release_mmr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Mmr* released = _impl_.mmr_;
  _impl_.mmr_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Mmr* PROTOBUF_NULLABLE NearestInputWithMmr::unsafe_arena_release_mmr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.NearestInputWithMmr.mmr)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Mmr* temp = _impl_.mmr_;
  _impl_.mmr_ = nullptr;
  return temp;
}
inline ::qdrant::Mmr* PROTOBUF_NONNULL NearestInputWithMmr::_internal_mutable_mmr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mmr_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Mmr>(GetArena());
    _impl_.mmr_ = reinterpret_cast<::qdrant::Mmr*>(p);
  }
  return _impl_.mmr_;
}
inline ::qdrant::Mmr* PROTOBUF_NONNULL NearestInputWithMmr::mutable_mmr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Mmr* _msg = _internal_mutable_mmr();
  // @@protoc_insertion_point(field_mutable:qdrant.NearestInputWithMmr.mmr)
  return _msg;
}
inline void NearestInputWithMmr::set_allocated_mmr(::qdrant::Mmr* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mmr_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.mmr_ = reinterpret_cast<::qdrant::Mmr*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.NearestInputWithMmr.mmr)
}

// -------------------------------------------------------------------

// Mmr

// optional float diversity = 2;
inline bool Mmr::has_diversity() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void Mmr::clear_diversity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.diversity_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline float Mmr::diversity() const {
  // @@protoc_insertion_point(field_get:qdrant.Mmr.diversity)
  return _internal_diversity();
}
inline void Mmr::set_diversity(float value) {
  _internal_set_diversity(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.Mmr.diversity)
}
inline float Mmr::_internal_diversity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.diversity_;
}
inline void Mmr::_internal_set_diversity(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.diversity_ = value;
}

// optional uint32 candidates_limit = 3;
inline bool Mmr::has_candidates_limit() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void Mmr::clear_candidates_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.candidates_limit_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint32_t Mmr::candidates_limit() const {
  // @@protoc_insertion_point(field_get:qdrant.Mmr.candidates_limit)
  return _internal_candidates_limit();
}
inline void Mmr::set_candidates_limit(::uint32_t value) {
  _internal_set_candidates_limit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.Mmr.candidates_limit)
}
inline ::uint32_t Mmr::_internal_candidates_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.candidates_limit_;
}
inline void Mmr::_internal_set_candidates_limit(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.candidates_limit_ = value;
}

// -------------------------------------------------------------------

// Rrf

// optional uint32 k = 1;
inline bool Rrf::has_k() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void Rrf::clear_k() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.k_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint32_t Rrf::k() const {
  // @@protoc_insertion_point(field_get:qdrant.Rrf.k)
  return _internal_k();
}
inline void Rrf::set_k(::uint32_t value) {
  _internal_set_k(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.Rrf.k)
}
inline ::uint32_t Rrf::_internal_k() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.k_;
}
inline void Rrf::_internal_set_k(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.k_ = value;
}

// -------------------------------------------------------------------

// Query

// .qdrant.VectorInput nearest = 1;
inline bool Query::has_nearest() const {
  return variant_case() == kNearest;
}
inline bool Query::_internal_has_nearest() const {
  return variant_case() == kNearest;
}
inline void Query::set_has_nearest() {
  _impl_._oneof_case_[0] = kNearest;
}
inline void Query::clear_nearest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kNearest) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.nearest_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.nearest_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::VectorInput* PROTOBUF_NULLABLE Query::release_nearest() {
  // @@protoc_insertion_point(field_release:qdrant.Query.nearest)
  if (variant_case() == kNearest) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::VectorInput*>(_impl_.variant_.nearest_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.nearest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::VectorInput& Query::_internal_nearest() const {
  return variant_case() == kNearest ? static_cast<const ::qdrant::VectorInput&>(*reinterpret_cast<::qdrant::VectorInput*>(_impl_.variant_.nearest_))
                     : reinterpret_cast<const ::qdrant::VectorInput&>(::qdrant::_VectorInput_default_instance_);
}
inline const ::qdrant::VectorInput& Query::nearest() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Query.nearest)
  return _internal_nearest();
}
inline ::qdrant::VectorInput* PROTOBUF_NULLABLE Query::unsafe_arena_release_nearest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Query.nearest)
  if (variant_case() == kNearest) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::VectorInput*>(_impl_.variant_.nearest_);
    _impl_.variant_.nearest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query::unsafe_arena_set_allocated_nearest(
    ::qdrant::VectorInput* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_nearest();
    _impl_.variant_.nearest_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Query.nearest)
}
inline ::qdrant::VectorInput* PROTOBUF_NONNULL Query::_internal_mutable_nearest() {
  if (variant_case() != kNearest) {
    clear_variant();
    set_has_nearest();
    _impl_.variant_.nearest_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorInput>(GetArena()));
  }
  return reinterpret_cast<::qdrant::VectorInput*>(_impl_.variant_.nearest_);
}
inline ::qdrant::VectorInput* PROTOBUF_NONNULL Query::mutable_nearest()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::VectorInput* _msg = _internal_mutable_nearest();
  // @@protoc_insertion_point(field_mutable:qdrant.Query.nearest)
  return _msg;
}

// .qdrant.RecommendInput recommend = 2;
inline bool Query::has_recommend() const {
  return variant_case() == kRecommend;
}
inline bool Query::_internal_has_recommend() const {
  return variant_case() == kRecommend;
}
inline void Query::set_has_recommend() {
  _impl_._oneof_case_[0] = kRecommend;
}
inline void Query::clear_recommend() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kRecommend) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.recommend_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.recommend_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::RecommendInput* PROTOBUF_NULLABLE Query::release_recommend() {
  // @@protoc_insertion_point(field_release:qdrant.Query.recommend)
  if (variant_case() == kRecommend) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::RecommendInput*>(_impl_.variant_.recommend_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.recommend_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::RecommendInput& Query::_internal_recommend() const {
  return variant_case() == kRecommend ? static_cast<const ::qdrant::RecommendInput&>(*reinterpret_cast<::qdrant::RecommendInput*>(_impl_.variant_.recommend_))
                     : reinterpret_cast<const ::qdrant::RecommendInput&>(::qdrant::_RecommendInput_default_instance_);
}
inline const ::qdrant::RecommendInput& Query::recommend() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Query.recommend)
  return _internal_recommend();
}
inline ::qdrant::RecommendInput* PROTOBUF_NULLABLE Query::unsafe_arena_release_recommend() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Query.recommend)
  if (variant_case() == kRecommend) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::RecommendInput*>(_impl_.variant_.recommend_);
    _impl_.variant_.recommend_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query::unsafe_arena_set_allocated_recommend(
    ::qdrant::RecommendInput* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_recommend();
    _impl_.variant_.recommend_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Query.recommend)
}
inline ::qdrant::RecommendInput* PROTOBUF_NONNULL Query::_internal_mutable_recommend() {
  if (variant_case() != kRecommend) {
    clear_variant();
    set_has_recommend();
    _impl_.variant_.recommend_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::RecommendInput>(GetArena()));
  }
  return reinterpret_cast<::qdrant::RecommendInput*>(_impl_.variant_.recommend_);
}
inline ::qdrant::RecommendInput* PROTOBUF_NONNULL Query::mutable_recommend()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::RecommendInput* _msg = _internal_mutable_recommend();
  // @@protoc_insertion_point(field_mutable:qdrant.Query.recommend)
  return _msg;
}

// .qdrant.DiscoverInput discover = 3;
inline bool Query::has_discover() const {
  return variant_case() == kDiscover;
}
inline bool Query::_internal_has_discover() const {
  return variant_case() == kDiscover;
}
inline void Query::set_has_discover() {
  _impl_._oneof_case_[0] = kDiscover;
}
inline void Query::clear_discover() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kDiscover) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.discover_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.discover_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::DiscoverInput* PROTOBUF_NULLABLE Query::release_discover() {
  // @@protoc_insertion_point(field_release:qdrant.Query.discover)
  if (variant_case() == kDiscover) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::DiscoverInput*>(_impl_.variant_.discover_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.discover_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::DiscoverInput& Query::_internal_discover() const {
  return variant_case() == kDiscover ? static_cast<const ::qdrant::DiscoverInput&>(*reinterpret_cast<::qdrant::DiscoverInput*>(_impl_.variant_.discover_))
                     : reinterpret_cast<const ::qdrant::DiscoverInput&>(::qdrant::_DiscoverInput_default_instance_);
}
inline const ::qdrant::DiscoverInput& Query::discover() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Query.discover)
  return _internal_discover();
}
inline ::qdrant::DiscoverInput* PROTOBUF_NULLABLE Query::unsafe_arena_release_discover() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Query.discover)
  if (variant_case() == kDiscover) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::DiscoverInput*>(_impl_.variant_.discover_);
    _impl_.variant_.discover_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query::unsafe_arena_set_allocated_discover(
    ::qdrant::DiscoverInput* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_discover();
    _impl_.variant_.discover_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Query.discover)
}
inline ::qdrant::DiscoverInput* PROTOBUF_NONNULL Query::_internal_mutable_discover() {
  if (variant_case() != kDiscover) {
    clear_variant();
    set_has_discover();
    _impl_.variant_.discover_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::DiscoverInput>(GetArena()));
  }
  return reinterpret_cast<::qdrant::DiscoverInput*>(_impl_.variant_.discover_);
}
inline ::qdrant::DiscoverInput* PROTOBUF_NONNULL Query::mutable_discover()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::DiscoverInput* _msg = _internal_mutable_discover();
  // @@protoc_insertion_point(field_mutable:qdrant.Query.discover)
  return _msg;
}

// .qdrant.ContextInput context = 4;
inline bool Query::has_context() const {
  return variant_case() == kContext;
}
inline bool Query::_internal_has_context() const {
  return variant_case() == kContext;
}
inline void Query::set_has_context() {
  _impl_._oneof_case_[0] = kContext;
}
inline void Query::clear_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kContext) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.context_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.context_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::ContextInput* PROTOBUF_NULLABLE Query::release_context() {
  // @@protoc_insertion_point(field_release:qdrant.Query.context)
  if (variant_case() == kContext) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::ContextInput*>(_impl_.variant_.context_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.context_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::ContextInput& Query::_internal_context() const {
  return variant_case() == kContext ? static_cast<const ::qdrant::ContextInput&>(*reinterpret_cast<::qdrant::ContextInput*>(_impl_.variant_.context_))
                     : reinterpret_cast<const ::qdrant::ContextInput&>(::qdrant::_ContextInput_default_instance_);
}
inline const ::qdrant::ContextInput& Query::context() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Query.context)
  return _internal_context();
}
inline ::qdrant::ContextInput* PROTOBUF_NULLABLE Query::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Query.context)
  if (variant_case() == kContext) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::ContextInput*>(_impl_.variant_.context_);
    _impl_.variant_.context_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query::unsafe_arena_set_allocated_context(
    ::qdrant::ContextInput* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_context();
    _impl_.variant_.context_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Query.context)
}
inline ::qdrant::ContextInput* PROTOBUF_NONNULL Query::_internal_mutable_context() {
  if (variant_case() != kContext) {
    clear_variant();
    set_has_context();
    _impl_.variant_.context_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::ContextInput>(GetArena()));
  }
  return reinterpret_cast<::qdrant::ContextInput*>(_impl_.variant_.context_);
}
inline ::qdrant::ContextInput* PROTOBUF_NONNULL Query::mutable_context()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::ContextInput* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:qdrant.Query.context)
  return _msg;
}

// .qdrant.OrderBy order_by = 5;
inline bool Query::has_order_by() const {
  return variant_case() == kOrderBy;
}
inline bool Query::_internal_has_order_by() const {
  return variant_case() == kOrderBy;
}
inline void Query::set_has_order_by() {
  _impl_._oneof_case_[0] = kOrderBy;
}
inline void Query::clear_order_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kOrderBy) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.order_by_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.order_by_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::OrderBy* PROTOBUF_NULLABLE Query::release_order_by() {
  // @@protoc_insertion_point(field_release:qdrant.Query.order_by)
  if (variant_case() == kOrderBy) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::OrderBy*>(_impl_.variant_.order_by_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.order_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::OrderBy& Query::_internal_order_by() const {
  return variant_case() == kOrderBy ? static_cast<const ::qdrant::OrderBy&>(*reinterpret_cast<::qdrant::OrderBy*>(_impl_.variant_.order_by_))
                     : reinterpret_cast<const ::qdrant::OrderBy&>(::qdrant::_OrderBy_default_instance_);
}
inline const ::qdrant::OrderBy& Query::order_by() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Query.order_by)
  return _internal_order_by();
}
inline ::qdrant::OrderBy* PROTOBUF_NULLABLE Query::unsafe_arena_release_order_by() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Query.order_by)
  if (variant_case() == kOrderBy) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::OrderBy*>(_impl_.variant_.order_by_);
    _impl_.variant_.order_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query::unsafe_arena_set_allocated_order_by(
    ::qdrant::OrderBy* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_order_by();
    _impl_.variant_.order_by_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Query.order_by)
}
inline ::qdrant::OrderBy* PROTOBUF_NONNULL Query::_internal_mutable_order_by() {
  if (variant_case() != kOrderBy) {
    clear_variant();
    set_has_order_by();
    _impl_.variant_.order_by_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::OrderBy>(GetArena()));
  }
  return reinterpret_cast<::qdrant::OrderBy*>(_impl_.variant_.order_by_);
}
inline ::qdrant::OrderBy* PROTOBUF_NONNULL Query::mutable_order_by()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::OrderBy* _msg = _internal_mutable_order_by();
  // @@protoc_insertion_point(field_mutable:qdrant.Query.order_by)
  return _msg;
}

// .qdrant.Fusion fusion = 6;
inline bool Query::has_fusion() const {
  return variant_case() == kFusion;
}
inline void Query::set_has_fusion() {
  _impl_._oneof_case_[0] = kFusion;
}
inline void Query::clear_fusion() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kFusion) {
    _impl_.variant_.fusion_ = 0;
    clear_has_variant();
  }
}
inline ::qdrant::Fusion Query::fusion() const {
  // @@protoc_insertion_point(field_get:qdrant.Query.fusion)
  return _internal_fusion();
}
inline void Query::set_fusion(::qdrant::Fusion value) {
  if (variant_case() != kFusion) {
    clear_variant();
    set_has_fusion();
  }
  _impl_.variant_.fusion_ = value;
  // @@protoc_insertion_point(field_set:qdrant.Query.fusion)
}
inline ::qdrant::Fusion Query::_internal_fusion() const {
  if (variant_case() == kFusion) {
    return static_cast<::qdrant::Fusion>(_impl_.variant_.fusion_);
  }
  return static_cast<::qdrant::Fusion>(0);
}

// .qdrant.Sample sample = 7;
inline bool Query::has_sample() const {
  return variant_case() == kSample;
}
inline void Query::set_has_sample() {
  _impl_._oneof_case_[0] = kSample;
}
inline void Query::clear_sample() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kSample) {
    _impl_.variant_.sample_ = 0;
    clear_has_variant();
  }
}
inline ::qdrant::Sample Query::sample() const {
  // @@protoc_insertion_point(field_get:qdrant.Query.sample)
  return _internal_sample();
}
inline void Query::set_sample(::qdrant::Sample value) {
  if (variant_case() != kSample) {
    clear_variant();
    set_has_sample();
  }
  _impl_.variant_.sample_ = value;
  // @@protoc_insertion_point(field_set:qdrant.Query.sample)
}
inline ::qdrant::Sample Query::_internal_sample() const {
  if (variant_case() == kSample) {
    return static_cast<::qdrant::Sample>(_impl_.variant_.sample_);
  }
  return static_cast<::qdrant::Sample>(0);
}

// .qdrant.Formula formula = 8;
inline bool Query::has_formula() const {
  return variant_case() == kFormula;
}
inline bool Query::_internal_has_formula() const {
  return variant_case() == kFormula;
}
inline void Query::set_has_formula() {
  _impl_._oneof_case_[0] = kFormula;
}
inline void Query::clear_formula() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kFormula) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.formula_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.formula_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::Formula* PROTOBUF_NULLABLE Query::release_formula() {
  // @@protoc_insertion_point(field_release:qdrant.Query.formula)
  if (variant_case() == kFormula) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Formula*>(_impl_.variant_.formula_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.formula_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Formula& Query::_internal_formula() const {
  return variant_case() == kFormula ? static_cast<const ::qdrant::Formula&>(*reinterpret_cast<::qdrant::Formula*>(_impl_.variant_.formula_))
                     : reinterpret_cast<const ::qdrant::Formula&>(::qdrant::_Formula_default_instance_);
}
inline const ::qdrant::Formula& Query::formula() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Query.formula)
  return _internal_formula();
}
inline ::qdrant::Formula* PROTOBUF_NULLABLE Query::unsafe_arena_release_formula() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Query.formula)
  if (variant_case() == kFormula) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Formula*>(_impl_.variant_.formula_);
    _impl_.variant_.formula_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query::unsafe_arena_set_allocated_formula(
    ::qdrant::Formula* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_formula();
    _impl_.variant_.formula_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Query.formula)
}
inline ::qdrant::Formula* PROTOBUF_NONNULL Query::_internal_mutable_formula() {
  if (variant_case() != kFormula) {
    clear_variant();
    set_has_formula();
    _impl_.variant_.formula_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Formula>(GetArena()));
  }
  return reinterpret_cast<::qdrant::Formula*>(_impl_.variant_.formula_);
}
inline ::qdrant::Formula* PROTOBUF_NONNULL Query::mutable_formula()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Formula* _msg = _internal_mutable_formula();
  // @@protoc_insertion_point(field_mutable:qdrant.Query.formula)
  return _msg;
}

// .qdrant.NearestInputWithMmr nearest_with_mmr = 9;
inline bool Query::has_nearest_with_mmr() const {
  return variant_case() == kNearestWithMmr;
}
inline bool Query::_internal_has_nearest_with_mmr() const {
  return variant_case() == kNearestWithMmr;
}
inline void Query::set_has_nearest_with_mmr() {
  _impl_._oneof_case_[0] = kNearestWithMmr;
}
inline void Query::clear_nearest_with_mmr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kNearestWithMmr) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.nearest_with_mmr_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.nearest_with_mmr_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::NearestInputWithMmr* PROTOBUF_NULLABLE Query::release_nearest_with_mmr() {
  // @@protoc_insertion_point(field_release:qdrant.Query.nearest_with_mmr)
  if (variant_case() == kNearestWithMmr) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::NearestInputWithMmr*>(_impl_.variant_.nearest_with_mmr_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.nearest_with_mmr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::NearestInputWithMmr& Query::_internal_nearest_with_mmr() const {
  return variant_case() == kNearestWithMmr ? static_cast<const ::qdrant::NearestInputWithMmr&>(*reinterpret_cast<::qdrant::NearestInputWithMmr*>(_impl_.variant_.nearest_with_mmr_))
                     : reinterpret_cast<const ::qdrant::NearestInputWithMmr&>(::qdrant::_NearestInputWithMmr_default_instance_);
}
inline const ::qdrant::NearestInputWithMmr& Query::nearest_with_mmr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Query.nearest_with_mmr)
  return _internal_nearest_with_mmr();
}
inline ::qdrant::NearestInputWithMmr* PROTOBUF_NULLABLE Query::unsafe_arena_release_nearest_with_mmr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Query.nearest_with_mmr)
  if (variant_case() == kNearestWithMmr) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::NearestInputWithMmr*>(_impl_.variant_.nearest_with_mmr_);
    _impl_.variant_.nearest_with_mmr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query::unsafe_arena_set_allocated_nearest_with_mmr(
    ::qdrant::NearestInputWithMmr* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_nearest_with_mmr();
    _impl_.variant_.nearest_with_mmr_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Query.nearest_with_mmr)
}
inline ::qdrant::NearestInputWithMmr* PROTOBUF_NONNULL Query::_internal_mutable_nearest_with_mmr() {
  if (variant_case() != kNearestWithMmr) {
    clear_variant();
    set_has_nearest_with_mmr();
    _impl_.variant_.nearest_with_mmr_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::NearestInputWithMmr>(GetArena()));
  }
  return reinterpret_cast<::qdrant::NearestInputWithMmr*>(_impl_.variant_.nearest_with_mmr_);
}
inline ::qdrant::NearestInputWithMmr* PROTOBUF_NONNULL Query::mutable_nearest_with_mmr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::NearestInputWithMmr* _msg = _internal_mutable_nearest_with_mmr();
  // @@protoc_insertion_point(field_mutable:qdrant.Query.nearest_with_mmr)
  return _msg;
}

// .qdrant.Rrf rrf = 10;
inline bool Query::has_rrf() const {
  return variant_case() == kRrf;
}
inline bool Query::_internal_has_rrf() const {
  return variant_case() == kRrf;
}
inline void Query::set_has_rrf() {
  _impl_._oneof_case_[0] = kRrf;
}
inline void Query::clear_rrf() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kRrf) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.rrf_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.rrf_);
    }
    clear_has_variant();
  }
}
inline ::qdrant::Rrf* PROTOBUF_NULLABLE Query::release_rrf() {
  // @@protoc_insertion_point(field_release:qdrant.Query.rrf)
  if (variant_case() == kRrf) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Rrf*>(_impl_.variant_.rrf_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.rrf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Rrf& Query::_internal_rrf() const {
  return variant_case() == kRrf ? static_cast<const ::qdrant::Rrf&>(*reinterpret_cast<::qdrant::Rrf*>(_impl_.variant_.rrf_))
                     : reinterpret_cast<const ::qdrant::Rrf&>(::qdrant::_Rrf_default_instance_);
}
inline const ::qdrant::Rrf& Query::rrf() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Query.rrf)
  return _internal_rrf();
}
inline ::qdrant::Rrf* PROTOBUF_NULLABLE Query::unsafe_arena_release_rrf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Query.rrf)
  if (variant_case() == kRrf) {
    clear_has_variant();
    auto* temp = reinterpret_cast<::qdrant::Rrf*>(_impl_.variant_.rrf_);
    _impl_.variant_.rrf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query::unsafe_arena_set_allocated_rrf(
    ::qdrant::Rrf* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_rrf();
    _impl_.variant_.rrf_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Query.rrf)
}
inline ::qdrant::Rrf* PROTOBUF_NONNULL Query::_internal_mutable_rrf() {
  if (variant_case() != kRrf) {
    clear_variant();
    set_has_rrf();
    _impl_.variant_.rrf_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Rrf>(GetArena()));
  }
  return reinterpret_cast<::qdrant::Rrf*>(_impl_.variant_.rrf_);
}
inline ::qdrant::Rrf* PROTOBUF_NONNULL Query::mutable_rrf()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Rrf* _msg = _internal_mutable_rrf();
  // @@protoc_insertion_point(field_mutable:qdrant.Query.rrf)
  return _msg;
}

inline bool Query::has_variant() const {
  return variant_case() != VARIANT_NOT_SET;
}
inline void Query::clear_has_variant() {
  _impl_._oneof_case_[0] = VARIANT_NOT_SET;
}
inline Query::VariantCase Query::variant_case() const {
  return Query::VariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PrefetchQuery

// repeated .qdrant.PrefetchQuery prefetch = 1;
inline int PrefetchQuery::_internal_prefetch_size() const {
  return _internal_prefetch().size();
}
inline int PrefetchQuery::prefetch_size() const {
  return _internal_prefetch_size();
}
inline void PrefetchQuery::clear_prefetch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefetch_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::PrefetchQuery* PROTOBUF_NONNULL PrefetchQuery::mutable_prefetch(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.PrefetchQuery.prefetch)
  return _internal_mutable_prefetch()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>* PROTOBUF_NONNULL PrefetchQuery::mutable_prefetch()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.PrefetchQuery.prefetch)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_prefetch();
}
inline const ::qdrant::PrefetchQuery& PrefetchQuery::prefetch(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PrefetchQuery.prefetch)
  return _internal_prefetch().Get(index);
}
inline ::qdrant::PrefetchQuery* PROTOBUF_NONNULL PrefetchQuery::add_prefetch()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::PrefetchQuery* _add =
      _internal_mutable_prefetch()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.PrefetchQuery.prefetch)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>& PrefetchQuery::prefetch() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.PrefetchQuery.prefetch)
  return _internal_prefetch();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>&
PrefetchQuery::_internal_prefetch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prefetch_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>* PROTOBUF_NONNULL
PrefetchQuery::_internal_mutable_prefetch() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.prefetch_;
}

// optional .qdrant.Query query = 2;
inline bool PrefetchQuery::has_query() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.query_ != nullptr);
  return value;
}
inline void PrefetchQuery::clear_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.query_ != nullptr) _impl_.query_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::Query& PrefetchQuery::_internal_query() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Query* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Query&>(::qdrant::_Query_default_instance_);
}
inline const ::qdrant::Query& PrefetchQuery::query() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PrefetchQuery.query)
  return _internal_query();
}
inline void PrefetchQuery::unsafe_arena_set_allocated_query(
    ::qdrant::Query* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = reinterpret_cast<::qdrant::Query*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PrefetchQuery.query)
}
inline ::qdrant::Query* PROTOBUF_NULLABLE PrefetchQuery::release_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Query* released = _impl_.query_;
  _impl_.query_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Query* PROTOBUF_NULLABLE PrefetchQuery::unsafe_arena_release_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PrefetchQuery.query)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Query* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::qdrant::Query* PROTOBUF_NONNULL PrefetchQuery::_internal_mutable_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.query_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Query>(GetArena());
    _impl_.query_ = reinterpret_cast<::qdrant::Query*>(p);
  }
  return _impl_.query_;
}
inline ::qdrant::Query* PROTOBUF_NONNULL PrefetchQuery::mutable_query()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Query* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:qdrant.PrefetchQuery.query)
  return _msg;
}
inline void PrefetchQuery::set_allocated_query(::qdrant::Query* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.query_ = reinterpret_cast<::qdrant::Query*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PrefetchQuery.query)
}

// optional string using = 3;
inline bool PrefetchQuery::has_using_() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void PrefetchQuery::clear_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.using__.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& PrefetchQuery::using_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PrefetchQuery.using)
  return _internal_using_();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PrefetchQuery::set_using_(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.using__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.PrefetchQuery.using)
}
inline ::std::string* PROTOBUF_NONNULL PrefetchQuery::mutable_using_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_using_();
  // @@protoc_insertion_point(field_mutable:qdrant.PrefetchQuery.using)
  return _s;
}
inline const ::std::string& PrefetchQuery::_internal_using_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.using__.Get();
}
inline void PrefetchQuery::_internal_set_using_(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.using__.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PrefetchQuery::_internal_mutable_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.using__.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PrefetchQuery::release_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PrefetchQuery.using)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.using__.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.using__.Set("", GetArena());
  }
  return released;
}
inline void PrefetchQuery::set_allocated_using_(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.using__.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.using__.IsDefault()) {
    _impl_.using__.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.PrefetchQuery.using)
}

// optional .qdrant.Filter filter = 4;
inline bool PrefetchQuery::has_filter() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void PrefetchQuery::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::Filter& PrefetchQuery::_internal_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Filter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& PrefetchQuery::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PrefetchQuery.filter)
  return _internal_filter();
}
inline void PrefetchQuery::unsafe_arena_set_allocated_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PrefetchQuery.filter)
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE PrefetchQuery::release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::Filter* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE PrefetchQuery::unsafe_arena_release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PrefetchQuery.filter)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL PrefetchQuery::_internal_mutable_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
    _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(p);
  }
  return _impl_.filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL PrefetchQuery::mutable_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.PrefetchQuery.filter)
  return _msg;
}
inline void PrefetchQuery::set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PrefetchQuery.filter)
}

// optional .qdrant.SearchParams params = 5;
inline bool PrefetchQuery::has_params() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.params_ != nullptr);
  return value;
}
inline void PrefetchQuery::clear_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ != nullptr) _impl_.params_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::SearchParams& PrefetchQuery::_internal_params() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SearchParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SearchParams&>(::qdrant::_SearchParams_default_instance_);
}
inline const ::qdrant::SearchParams& PrefetchQuery::params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PrefetchQuery.params)
  return _internal_params();
}
inline void PrefetchQuery::unsafe_arena_set_allocated_params(
    ::qdrant::SearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PrefetchQuery.params)
}
inline ::qdrant::SearchParams* PROTOBUF_NULLABLE PrefetchQuery::release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::SearchParams* released = _impl_.params_;
  _impl_.params_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SearchParams* PROTOBUF_NULLABLE PrefetchQuery::unsafe_arena_release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PrefetchQuery.params)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::SearchParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::qdrant::SearchParams* PROTOBUF_NONNULL PrefetchQuery::_internal_mutable_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SearchParams>(GetArena());
    _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(p);
  }
  return _impl_.params_;
}
inline ::qdrant::SearchParams* PROTOBUF_NONNULL PrefetchQuery::mutable_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::SearchParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:qdrant.PrefetchQuery.params)
  return _msg;
}
inline void PrefetchQuery::set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PrefetchQuery.params)
}

// optional float score_threshold = 6;
inline bool PrefetchQuery::has_score_threshold() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  return value;
}
inline void PrefetchQuery::clear_score_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_threshold_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline float PrefetchQuery::score_threshold() const {
  // @@protoc_insertion_point(field_get:qdrant.PrefetchQuery.score_threshold)
  return _internal_score_threshold();
}
inline void PrefetchQuery::set_score_threshold(float value) {
  _internal_set_score_threshold(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  // @@protoc_insertion_point(field_set:qdrant.PrefetchQuery.score_threshold)
}
inline float PrefetchQuery::_internal_score_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.score_threshold_;
}
inline void PrefetchQuery::_internal_set_score_threshold(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_threshold_ = value;
}

// optional uint64 limit = 7;
inline bool PrefetchQuery::has_limit() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  return value;
}
inline void PrefetchQuery::clear_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline ::uint64_t PrefetchQuery::limit() const {
  // @@protoc_insertion_point(field_get:qdrant.PrefetchQuery.limit)
  return _internal_limit();
}
inline void PrefetchQuery::set_limit(::uint64_t value) {
  _internal_set_limit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:qdrant.PrefetchQuery.limit)
}
inline ::uint64_t PrefetchQuery::_internal_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limit_;
}
inline void PrefetchQuery::_internal_set_limit(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = value;
}

// optional .qdrant.LookupLocation lookup_from = 8;
inline bool PrefetchQuery::has_lookup_from() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.lookup_from_ != nullptr);
  return value;
}
inline void PrefetchQuery::clear_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lookup_from_ != nullptr) _impl_.lookup_from_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::qdrant::LookupLocation& PrefetchQuery::_internal_lookup_from() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::LookupLocation* p = _impl_.lookup_from_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::LookupLocation&>(::qdrant::_LookupLocation_default_instance_);
}
inline const ::qdrant::LookupLocation& PrefetchQuery::lookup_from() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PrefetchQuery.lookup_from)
  return _internal_lookup_from();
}
inline void PrefetchQuery::unsafe_arena_set_allocated_lookup_from(
    ::qdrant::LookupLocation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lookup_from_);
  }
  _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PrefetchQuery.lookup_from)
}
inline ::qdrant::LookupLocation* PROTOBUF_NULLABLE PrefetchQuery::release_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::LookupLocation* released = _impl_.lookup_from_;
  _impl_.lookup_from_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::LookupLocation* PROTOBUF_NULLABLE PrefetchQuery::unsafe_arena_release_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PrefetchQuery.lookup_from)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::LookupLocation* temp = _impl_.lookup_from_;
  _impl_.lookup_from_ = nullptr;
  return temp;
}
inline ::qdrant::LookupLocation* PROTOBUF_NONNULL PrefetchQuery::_internal_mutable_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lookup_from_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::LookupLocation>(GetArena());
    _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(p);
  }
  return _impl_.lookup_from_;
}
inline ::qdrant::LookupLocation* PROTOBUF_NONNULL PrefetchQuery::mutable_lookup_from()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::LookupLocation* _msg = _internal_mutable_lookup_from();
  // @@protoc_insertion_point(field_mutable:qdrant.PrefetchQuery.lookup_from)
  return _msg;
}
inline void PrefetchQuery::set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lookup_from_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PrefetchQuery.lookup_from)
}

// -------------------------------------------------------------------

// QueryPoints

// string collection_name = 1;
inline void QueryPoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& QueryPoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void QueryPoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.QueryPoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL QueryPoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPoints.collection_name)
  return _s;
}
inline const ::std::string& QueryPoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void QueryPoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL QueryPoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE QueryPoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void QueryPoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPoints.collection_name)
}

// repeated .qdrant.PrefetchQuery prefetch = 2;
inline int QueryPoints::_internal_prefetch_size() const {
  return _internal_prefetch().size();
}
inline int QueryPoints::prefetch_size() const {
  return _internal_prefetch_size();
}
inline void QueryPoints::clear_prefetch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefetch_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::PrefetchQuery* PROTOBUF_NONNULL QueryPoints::mutable_prefetch(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPoints.prefetch)
  return _internal_mutable_prefetch()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>* PROTOBUF_NONNULL QueryPoints::mutable_prefetch()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.QueryPoints.prefetch)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_prefetch();
}
inline const ::qdrant::PrefetchQuery& QueryPoints::prefetch(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPoints.prefetch)
  return _internal_prefetch().Get(index);
}
inline ::qdrant::PrefetchQuery* PROTOBUF_NONNULL QueryPoints::add_prefetch()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::PrefetchQuery* _add =
      _internal_mutable_prefetch()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.QueryPoints.prefetch)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>& QueryPoints::prefetch() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.QueryPoints.prefetch)
  return _internal_prefetch();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>&
QueryPoints::_internal_prefetch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prefetch_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>* PROTOBUF_NONNULL
QueryPoints::_internal_mutable_prefetch() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.prefetch_;
}

// optional .qdrant.Query query = 3;
inline bool QueryPoints::has_query() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.query_ != nullptr);
  return value;
}
inline void QueryPoints::clear_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.query_ != nullptr) _impl_.query_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::Query& QueryPoints::_internal_query() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Query* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Query&>(::qdrant::_Query_default_instance_);
}
inline const ::qdrant::Query& QueryPoints::query() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPoints.query)
  return _internal_query();
}
inline void QueryPoints::unsafe_arena_set_allocated_query(
    ::qdrant::Query* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = reinterpret_cast<::qdrant::Query*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryPoints.query)
}
inline ::qdrant::Query* PROTOBUF_NULLABLE QueryPoints::release_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::Query* released = _impl_.query_;
  _impl_.query_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Query* PROTOBUF_NULLABLE QueryPoints::unsafe_arena_release_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPoints.query)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::Query* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::qdrant::Query* PROTOBUF_NONNULL QueryPoints::_internal_mutable_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.query_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Query>(GetArena());
    _impl_.query_ = reinterpret_cast<::qdrant::Query*>(p);
  }
  return _impl_.query_;
}
inline ::qdrant::Query* PROTOBUF_NONNULL QueryPoints::mutable_query()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::Query* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPoints.query)
  return _msg;
}
inline void QueryPoints::set_allocated_query(::qdrant::Query* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.query_ = reinterpret_cast<::qdrant::Query*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPoints.query)
}

// optional string using = 4;
inline bool QueryPoints::has_using_() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void QueryPoints::clear_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.using__.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& QueryPoints::using_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPoints.using)
  return _internal_using_();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void QueryPoints::set_using_(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.using__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.QueryPoints.using)
}
inline ::std::string* PROTOBUF_NONNULL QueryPoints::mutable_using_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_using_();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPoints.using)
  return _s;
}
inline const ::std::string& QueryPoints::_internal_using_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.using__.Get();
}
inline void QueryPoints::_internal_set_using_(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.using__.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL QueryPoints::_internal_mutable_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.using__.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE QueryPoints::release_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPoints.using)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.using__.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.using__.Set("", GetArena());
  }
  return released;
}
inline void QueryPoints::set_allocated_using_(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.using__.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.using__.IsDefault()) {
    _impl_.using__.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPoints.using)
}

// optional .qdrant.Filter filter = 5;
inline bool QueryPoints::has_filter() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void QueryPoints::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::Filter& QueryPoints::_internal_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Filter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& QueryPoints::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPoints.filter)
  return _internal_filter();
}
inline void QueryPoints::unsafe_arena_set_allocated_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryPoints.filter)
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE QueryPoints::release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Filter* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE QueryPoints::unsafe_arena_release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPoints.filter)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL QueryPoints::_internal_mutable_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
    _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(p);
  }
  return _impl_.filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL QueryPoints::mutable_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPoints.filter)
  return _msg;
}
inline void QueryPoints::set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPoints.filter)
}

// optional .qdrant.SearchParams params = 6;
inline bool QueryPoints::has_params() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.params_ != nullptr);
  return value;
}
inline void QueryPoints::clear_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ != nullptr) _impl_.params_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::qdrant::SearchParams& QueryPoints::_internal_params() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SearchParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SearchParams&>(::qdrant::_SearchParams_default_instance_);
}
inline const ::qdrant::SearchParams& QueryPoints::params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPoints.params)
  return _internal_params();
}
inline void QueryPoints::unsafe_arena_set_allocated_params(
    ::qdrant::SearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryPoints.params)
}
inline ::qdrant::SearchParams* PROTOBUF_NULLABLE QueryPoints::release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::SearchParams* released = _impl_.params_;
  _impl_.params_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SearchParams* PROTOBUF_NULLABLE QueryPoints::unsafe_arena_release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPoints.params)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::SearchParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::qdrant::SearchParams* PROTOBUF_NONNULL QueryPoints::_internal_mutable_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SearchParams>(GetArena());
    _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(p);
  }
  return _impl_.params_;
}
inline ::qdrant::SearchParams* PROTOBUF_NONNULL QueryPoints::mutable_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::SearchParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPoints.params)
  return _msg;
}
inline void QueryPoints::set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPoints.params)
}

// optional float score_threshold = 7;
inline bool QueryPoints::has_score_threshold() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00004000U);
  return value;
}
inline void QueryPoints::clear_score_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_threshold_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00004000U);
}
inline float QueryPoints::score_threshold() const {
  // @@protoc_insertion_point(field_get:qdrant.QueryPoints.score_threshold)
  return _internal_score_threshold();
}
inline void QueryPoints::set_score_threshold(float value) {
  _internal_set_score_threshold(value);
  SetHasBit(_impl_._has_bits_[0], 0x00004000U);
  // @@protoc_insertion_point(field_set:qdrant.QueryPoints.score_threshold)
}
inline float QueryPoints::_internal_score_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.score_threshold_;
}
inline void QueryPoints::_internal_set_score_threshold(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_threshold_ = value;
}

// optional uint64 limit = 8;
inline bool QueryPoints::has_limit() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000800U);
  return value;
}
inline void QueryPoints::clear_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000800U);
}
inline ::uint64_t QueryPoints::limit() const {
  // @@protoc_insertion_point(field_get:qdrant.QueryPoints.limit)
  return _internal_limit();
}
inline void QueryPoints::set_limit(::uint64_t value) {
  _internal_set_limit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  // @@protoc_insertion_point(field_set:qdrant.QueryPoints.limit)
}
inline ::uint64_t QueryPoints::_internal_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limit_;
}
inline void QueryPoints::_internal_set_limit(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = value;
}

// optional uint64 offset = 9;
inline bool QueryPoints::has_offset() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00001000U);
  return value;
}
inline void QueryPoints::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00001000U);
}
inline ::uint64_t QueryPoints::offset() const {
  // @@protoc_insertion_point(field_get:qdrant.QueryPoints.offset)
  return _internal_offset();
}
inline void QueryPoints::set_offset(::uint64_t value) {
  _internal_set_offset(value);
  SetHasBit(_impl_._has_bits_[0], 0x00001000U);
  // @@protoc_insertion_point(field_set:qdrant.QueryPoints.offset)
}
inline ::uint64_t QueryPoints::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_;
}
inline void QueryPoints::_internal_set_offset(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = value;
}

// optional .qdrant.WithVectorsSelector with_vectors = 10;
inline bool QueryPoints::has_with_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  PROTOBUF_ASSUME(!value || _impl_.with_vectors_ != nullptr);
  return value;
}
inline void QueryPoints::clear_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ != nullptr) _impl_.with_vectors_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::qdrant::WithVectorsSelector& QueryPoints::_internal_with_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithVectorsSelector* p = _impl_.with_vectors_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithVectorsSelector&>(::qdrant::_WithVectorsSelector_default_instance_);
}
inline const ::qdrant::WithVectorsSelector& QueryPoints::with_vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPoints.with_vectors)
  return _internal_with_vectors();
}
inline void QueryPoints::unsafe_arena_set_allocated_with_vectors(
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }
  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryPoints.with_vectors)
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE QueryPoints::release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::WithVectorsSelector* released = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE QueryPoints::unsafe_arena_release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPoints.with_vectors)

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::WithVectorsSelector* temp = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  return temp;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL QueryPoints::_internal_mutable_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithVectorsSelector>(GetArena());
    _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(p);
  }
  return _impl_.with_vectors_;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL QueryPoints::mutable_with_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::WithVectorsSelector* _msg = _internal_mutable_with_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPoints.with_vectors)
  return _msg;
}
inline void QueryPoints::set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }

  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPoints.with_vectors)
}

// optional .qdrant.WithPayloadSelector with_payload = 11;
inline bool QueryPoints::has_with_payload() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  PROTOBUF_ASSUME(!value || _impl_.with_payload_ != nullptr);
  return value;
}
inline void QueryPoints::clear_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ != nullptr) _impl_.with_payload_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline const ::qdrant::WithPayloadSelector& QueryPoints::_internal_with_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithPayloadSelector* p = _impl_.with_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithPayloadSelector&>(::qdrant::_WithPayloadSelector_default_instance_);
}
inline const ::qdrant::WithPayloadSelector& QueryPoints::with_payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPoints.with_payload)
  return _internal_with_payload();
}
inline void QueryPoints::unsafe_arena_set_allocated_with_payload(
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }
  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryPoints.with_payload)
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE QueryPoints::release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::WithPayloadSelector* released = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE QueryPoints::unsafe_arena_release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPoints.with_payload)

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::WithPayloadSelector* temp = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  return temp;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL QueryPoints::_internal_mutable_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithPayloadSelector>(GetArena());
    _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(p);
  }
  return _impl_.with_payload_;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL QueryPoints::mutable_with_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::WithPayloadSelector* _msg = _internal_mutable_with_payload();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPoints.with_payload)
  return _msg;
}
inline void QueryPoints::set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }

  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPoints.with_payload)
}

// optional .qdrant.ReadConsistency read_consistency = 12;
inline bool QueryPoints::has_read_consistency() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000100U);
  PROTOBUF_ASSUME(!value || _impl_.read_consistency_ != nullptr);
  return value;
}
inline void QueryPoints::clear_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ != nullptr) _impl_.read_consistency_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline const ::qdrant::ReadConsistency& QueryPoints::_internal_read_consistency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ReadConsistency* p = _impl_.read_consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ReadConsistency&>(::qdrant::_ReadConsistency_default_instance_);
}
inline const ::qdrant::ReadConsistency& QueryPoints::read_consistency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPoints.read_consistency)
  return _internal_read_consistency();
}
inline void QueryPoints::unsafe_arena_set_allocated_read_consistency(
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }
  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryPoints.read_consistency)
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE QueryPoints::release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::ReadConsistency* released = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE QueryPoints::unsafe_arena_release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPoints.read_consistency)

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::ReadConsistency* temp = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  return temp;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL QueryPoints::_internal_mutable_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ReadConsistency>(GetArena());
    _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(p);
  }
  return _impl_.read_consistency_;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL QueryPoints::mutable_read_consistency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::ReadConsistency* _msg = _internal_mutable_read_consistency();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPoints.read_consistency)
  return _msg;
}
inline void QueryPoints::set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }

  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPoints.read_consistency)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 13;
inline bool QueryPoints::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000200U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void QueryPoints::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000200U);
}
inline const ::qdrant::ShardKeySelector& QueryPoints::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& QueryPoints::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPoints.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void QueryPoints::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryPoints.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE QueryPoints::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE QueryPoints::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPoints.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL QueryPoints::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL QueryPoints::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPoints.shard_key_selector)
  return _msg;
}
inline void QueryPoints::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPoints.shard_key_selector)
}

// optional .qdrant.LookupLocation lookup_from = 14;
inline bool QueryPoints::has_lookup_from() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000400U);
  PROTOBUF_ASSUME(!value || _impl_.lookup_from_ != nullptr);
  return value;
}
inline void QueryPoints::clear_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lookup_from_ != nullptr) _impl_.lookup_from_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000400U);
}
inline const ::qdrant::LookupLocation& QueryPoints::_internal_lookup_from() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::LookupLocation* p = _impl_.lookup_from_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::LookupLocation&>(::qdrant::_LookupLocation_default_instance_);
}
inline const ::qdrant::LookupLocation& QueryPoints::lookup_from() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPoints.lookup_from)
  return _internal_lookup_from();
}
inline void QueryPoints::unsafe_arena_set_allocated_lookup_from(
    ::qdrant::LookupLocation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lookup_from_);
  }
  _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryPoints.lookup_from)
}
inline ::qdrant::LookupLocation* PROTOBUF_NULLABLE QueryPoints::release_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::LookupLocation* released = _impl_.lookup_from_;
  _impl_.lookup_from_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::LookupLocation* PROTOBUF_NULLABLE QueryPoints::unsafe_arena_release_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPoints.lookup_from)

  ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::LookupLocation* temp = _impl_.lookup_from_;
  _impl_.lookup_from_ = nullptr;
  return temp;
}
inline ::qdrant::LookupLocation* PROTOBUF_NONNULL QueryPoints::_internal_mutable_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lookup_from_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::LookupLocation>(GetArena());
    _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(p);
  }
  return _impl_.lookup_from_;
}
inline ::qdrant::LookupLocation* PROTOBUF_NONNULL QueryPoints::mutable_lookup_from()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::LookupLocation* _msg = _internal_mutable_lookup_from();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPoints.lookup_from)
  return _msg;
}
inline void QueryPoints::set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lookup_from_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  }

  _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPoints.lookup_from)
}

// optional uint64 timeout = 15;
inline bool QueryPoints::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00002000U);
  return value;
}
inline void QueryPoints::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00002000U);
}
inline ::uint64_t QueryPoints::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.QueryPoints.timeout)
  return _internal_timeout();
}
inline void QueryPoints::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00002000U);
  // @@protoc_insertion_point(field_set:qdrant.QueryPoints.timeout)
}
inline ::uint64_t QueryPoints::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void QueryPoints::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// -------------------------------------------------------------------

// QueryBatchPoints

// string collection_name = 1;
inline void QueryBatchPoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& QueryBatchPoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryBatchPoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void QueryBatchPoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.QueryBatchPoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL QueryBatchPoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryBatchPoints.collection_name)
  return _s;
}
inline const ::std::string& QueryBatchPoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void QueryBatchPoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL QueryBatchPoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE QueryBatchPoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryBatchPoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void QueryBatchPoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryBatchPoints.collection_name)
}

// repeated .qdrant.QueryPoints query_points = 2;
inline int QueryBatchPoints::_internal_query_points_size() const {
  return _internal_query_points().size();
}
inline int QueryBatchPoints::query_points_size() const {
  return _internal_query_points_size();
}
inline void QueryBatchPoints::clear_query_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.query_points_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::QueryPoints* PROTOBUF_NONNULL QueryBatchPoints::mutable_query_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.QueryBatchPoints.query_points)
  return _internal_mutable_query_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::QueryPoints>* PROTOBUF_NONNULL QueryBatchPoints::mutable_query_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.QueryBatchPoints.query_points)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_query_points();
}
inline const ::qdrant::QueryPoints& QueryBatchPoints::query_points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryBatchPoints.query_points)
  return _internal_query_points().Get(index);
}
inline ::qdrant::QueryPoints* PROTOBUF_NONNULL QueryBatchPoints::add_query_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::QueryPoints* _add =
      _internal_mutable_query_points()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.QueryBatchPoints.query_points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::QueryPoints>& QueryBatchPoints::query_points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.QueryBatchPoints.query_points)
  return _internal_query_points();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::QueryPoints>&
QueryBatchPoints::_internal_query_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.query_points_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::QueryPoints>* PROTOBUF_NONNULL
QueryBatchPoints::_internal_mutable_query_points() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.query_points_;
}

// optional .qdrant.ReadConsistency read_consistency = 3;
inline bool QueryBatchPoints::has_read_consistency() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.read_consistency_ != nullptr);
  return value;
}
inline void QueryBatchPoints::clear_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ != nullptr) _impl_.read_consistency_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::ReadConsistency& QueryBatchPoints::_internal_read_consistency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ReadConsistency* p = _impl_.read_consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ReadConsistency&>(::qdrant::_ReadConsistency_default_instance_);
}
inline const ::qdrant::ReadConsistency& QueryBatchPoints::read_consistency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryBatchPoints.read_consistency)
  return _internal_read_consistency();
}
inline void QueryBatchPoints::unsafe_arena_set_allocated_read_consistency(
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }
  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryBatchPoints.read_consistency)
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE QueryBatchPoints::release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ReadConsistency* released = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE QueryBatchPoints::unsafe_arena_release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryBatchPoints.read_consistency)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ReadConsistency* temp = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  return temp;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL QueryBatchPoints::_internal_mutable_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ReadConsistency>(GetArena());
    _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(p);
  }
  return _impl_.read_consistency_;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL QueryBatchPoints::mutable_read_consistency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ReadConsistency* _msg = _internal_mutable_read_consistency();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryBatchPoints.read_consistency)
  return _msg;
}
inline void QueryBatchPoints::set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryBatchPoints.read_consistency)
}

// optional uint64 timeout = 4;
inline bool QueryBatchPoints::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void QueryBatchPoints::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint64_t QueryBatchPoints::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.QueryBatchPoints.timeout)
  return _internal_timeout();
}
inline void QueryBatchPoints::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.QueryBatchPoints.timeout)
}
inline ::uint64_t QueryBatchPoints::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void QueryBatchPoints::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// -------------------------------------------------------------------

// QueryPointGroups

// string collection_name = 1;
inline void QueryPointGroups::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& QueryPointGroups::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPointGroups.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void QueryPointGroups::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.QueryPointGroups.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL QueryPointGroups::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPointGroups.collection_name)
  return _s;
}
inline const ::std::string& QueryPointGroups::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void QueryPointGroups::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL QueryPointGroups::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE QueryPointGroups::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPointGroups.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void QueryPointGroups::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPointGroups.collection_name)
}

// repeated .qdrant.PrefetchQuery prefetch = 2;
inline int QueryPointGroups::_internal_prefetch_size() const {
  return _internal_prefetch().size();
}
inline int QueryPointGroups::prefetch_size() const {
  return _internal_prefetch_size();
}
inline void QueryPointGroups::clear_prefetch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefetch_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::PrefetchQuery* PROTOBUF_NONNULL QueryPointGroups::mutable_prefetch(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPointGroups.prefetch)
  return _internal_mutable_prefetch()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>* PROTOBUF_NONNULL QueryPointGroups::mutable_prefetch()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.QueryPointGroups.prefetch)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_prefetch();
}
inline const ::qdrant::PrefetchQuery& QueryPointGroups::prefetch(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPointGroups.prefetch)
  return _internal_prefetch().Get(index);
}
inline ::qdrant::PrefetchQuery* PROTOBUF_NONNULL QueryPointGroups::add_prefetch()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::PrefetchQuery* _add =
      _internal_mutable_prefetch()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.QueryPointGroups.prefetch)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>& QueryPointGroups::prefetch() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.QueryPointGroups.prefetch)
  return _internal_prefetch();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>&
QueryPointGroups::_internal_prefetch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prefetch_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PrefetchQuery>* PROTOBUF_NONNULL
QueryPointGroups::_internal_mutable_prefetch() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.prefetch_;
}

// optional .qdrant.Query query = 3;
inline bool QueryPointGroups::has_query() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.query_ != nullptr);
  return value;
}
inline void QueryPointGroups::clear_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.query_ != nullptr) _impl_.query_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::Query& QueryPointGroups::_internal_query() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Query* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Query&>(::qdrant::_Query_default_instance_);
}
inline const ::qdrant::Query& QueryPointGroups::query() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPointGroups.query)
  return _internal_query();
}
inline void QueryPointGroups::unsafe_arena_set_allocated_query(
    ::qdrant::Query* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = reinterpret_cast<::qdrant::Query*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryPointGroups.query)
}
inline ::qdrant::Query* PROTOBUF_NULLABLE QueryPointGroups::release_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Query* released = _impl_.query_;
  _impl_.query_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Query* PROTOBUF_NULLABLE QueryPointGroups::unsafe_arena_release_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPointGroups.query)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Query* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::qdrant::Query* PROTOBUF_NONNULL QueryPointGroups::_internal_mutable_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.query_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Query>(GetArena());
    _impl_.query_ = reinterpret_cast<::qdrant::Query*>(p);
  }
  return _impl_.query_;
}
inline ::qdrant::Query* PROTOBUF_NONNULL QueryPointGroups::mutable_query()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::Query* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPointGroups.query)
  return _msg;
}
inline void QueryPointGroups::set_allocated_query(::qdrant::Query* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.query_ = reinterpret_cast<::qdrant::Query*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPointGroups.query)
}

// optional string using = 4;
inline bool QueryPointGroups::has_using_() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void QueryPointGroups::clear_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.using__.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& QueryPointGroups::using_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPointGroups.using)
  return _internal_using_();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void QueryPointGroups::set_using_(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.using__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.QueryPointGroups.using)
}
inline ::std::string* PROTOBUF_NONNULL QueryPointGroups::mutable_using_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_using_();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPointGroups.using)
  return _s;
}
inline const ::std::string& QueryPointGroups::_internal_using_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.using__.Get();
}
inline void QueryPointGroups::_internal_set_using_(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.using__.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL QueryPointGroups::_internal_mutable_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.using__.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE QueryPointGroups::release_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPointGroups.using)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.using__.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.using__.Set("", GetArena());
  }
  return released;
}
inline void QueryPointGroups::set_allocated_using_(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.using__.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.using__.IsDefault()) {
    _impl_.using__.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPointGroups.using)
}

// optional .qdrant.Filter filter = 5;
inline bool QueryPointGroups::has_filter() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void QueryPointGroups::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::qdrant::Filter& QueryPointGroups::_internal_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Filter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& QueryPointGroups::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPointGroups.filter)
  return _internal_filter();
}
inline void QueryPointGroups::unsafe_arena_set_allocated_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryPointGroups.filter)
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE QueryPointGroups::release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::Filter* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE QueryPointGroups::unsafe_arena_release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPointGroups.filter)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL QueryPointGroups::_internal_mutable_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
    _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(p);
  }
  return _impl_.filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL QueryPointGroups::mutable_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPointGroups.filter)
  return _msg;
}
inline void QueryPointGroups::set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPointGroups.filter)
}

// optional .qdrant.SearchParams params = 6;
inline bool QueryPointGroups::has_params() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  PROTOBUF_ASSUME(!value || _impl_.params_ != nullptr);
  return value;
}
inline void QueryPointGroups::clear_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ != nullptr) _impl_.params_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::qdrant::SearchParams& QueryPointGroups::_internal_params() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SearchParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SearchParams&>(::qdrant::_SearchParams_default_instance_);
}
inline const ::qdrant::SearchParams& QueryPointGroups::params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPointGroups.params)
  return _internal_params();
}
inline void QueryPointGroups::unsafe_arena_set_allocated_params(
    ::qdrant::SearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryPointGroups.params)
}
inline ::qdrant::SearchParams* PROTOBUF_NULLABLE QueryPointGroups::release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::SearchParams* released = _impl_.params_;
  _impl_.params_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SearchParams* PROTOBUF_NULLABLE QueryPointGroups::unsafe_arena_release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPointGroups.params)

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::SearchParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::qdrant::SearchParams* PROTOBUF_NONNULL QueryPointGroups::_internal_mutable_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SearchParams>(GetArena());
    _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(p);
  }
  return _impl_.params_;
}
inline ::qdrant::SearchParams* PROTOBUF_NONNULL QueryPointGroups::mutable_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::SearchParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPointGroups.params)
  return _msg;
}
inline void QueryPointGroups::set_allocated_params(::qdrant::SearchParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }

  _impl_.params_ = reinterpret_cast<::qdrant::SearchParams*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPointGroups.params)
}

// optional float score_threshold = 7;
inline bool QueryPointGroups::has_score_threshold() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00010000U);
  return value;
}
inline void QueryPointGroups::clear_score_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_threshold_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00010000U);
}
inline float QueryPointGroups::score_threshold() const {
  // @@protoc_insertion_point(field_get:qdrant.QueryPointGroups.score_threshold)
  return _internal_score_threshold();
}
inline void QueryPointGroups::set_score_threshold(float value) {
  _internal_set_score_threshold(value);
  SetHasBit(_impl_._has_bits_[0], 0x00010000U);
  // @@protoc_insertion_point(field_set:qdrant.QueryPointGroups.score_threshold)
}
inline float QueryPointGroups::_internal_score_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.score_threshold_;
}
inline void QueryPointGroups::_internal_set_score_threshold(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_threshold_ = value;
}

// .qdrant.WithPayloadSelector with_payload = 8;
inline bool QueryPointGroups::has_with_payload() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  PROTOBUF_ASSUME(!value || _impl_.with_payload_ != nullptr);
  return value;
}
inline void QueryPointGroups::clear_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ != nullptr) _impl_.with_payload_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline const ::qdrant::WithPayloadSelector& QueryPointGroups::_internal_with_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithPayloadSelector* p = _impl_.with_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithPayloadSelector&>(::qdrant::_WithPayloadSelector_default_instance_);
}
inline const ::qdrant::WithPayloadSelector& QueryPointGroups::with_payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPointGroups.with_payload)
  return _internal_with_payload();
}
inline void QueryPointGroups::unsafe_arena_set_allocated_with_payload(
    ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }
  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryPointGroups.with_payload)
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE QueryPointGroups::release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::WithPayloadSelector* released = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE QueryPointGroups::unsafe_arena_release_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPointGroups.with_payload)

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::WithPayloadSelector* temp = _impl_.with_payload_;
  _impl_.with_payload_ = nullptr;
  return temp;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL QueryPointGroups::_internal_mutable_with_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_payload_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithPayloadSelector>(GetArena());
    _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(p);
  }
  return _impl_.with_payload_;
}
inline ::qdrant::WithPayloadSelector* PROTOBUF_NONNULL QueryPointGroups::mutable_with_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::WithPayloadSelector* _msg = _internal_mutable_with_payload();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPointGroups.with_payload)
  return _msg;
}
inline void QueryPointGroups::set_allocated_with_payload(::qdrant::WithPayloadSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }

  _impl_.with_payload_ = reinterpret_cast<::qdrant::WithPayloadSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPointGroups.with_payload)
}

// optional .qdrant.WithVectorsSelector with_vectors = 9;
inline bool QueryPointGroups::has_with_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000100U);
  PROTOBUF_ASSUME(!value || _impl_.with_vectors_ != nullptr);
  return value;
}
inline void QueryPointGroups::clear_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ != nullptr) _impl_.with_vectors_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline const ::qdrant::WithVectorsSelector& QueryPointGroups::_internal_with_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithVectorsSelector* p = _impl_.with_vectors_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithVectorsSelector&>(::qdrant::_WithVectorsSelector_default_instance_);
}
inline const ::qdrant::WithVectorsSelector& QueryPointGroups::with_vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPointGroups.with_vectors)
  return _internal_with_vectors();
}
inline void QueryPointGroups::unsafe_arena_set_allocated_with_vectors(
    ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }
  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryPointGroups.with_vectors)
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE QueryPointGroups::release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::WithVectorsSelector* released = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE QueryPointGroups::unsafe_arena_release_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPointGroups.with_vectors)

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::WithVectorsSelector* temp = _impl_.with_vectors_;
  _impl_.with_vectors_ = nullptr;
  return temp;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL QueryPointGroups::_internal_mutable_with_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_vectors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithVectorsSelector>(GetArena());
    _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(p);
  }
  return _impl_.with_vectors_;
}
inline ::qdrant::WithVectorsSelector* PROTOBUF_NONNULL QueryPointGroups::mutable_with_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::WithVectorsSelector* _msg = _internal_mutable_with_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPointGroups.with_vectors)
  return _msg;
}
inline void QueryPointGroups::set_allocated_with_vectors(::qdrant::WithVectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_vectors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }

  _impl_.with_vectors_ = reinterpret_cast<::qdrant::WithVectorsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPointGroups.with_vectors)
}

// optional .qdrant.LookupLocation lookup_from = 10;
inline bool QueryPointGroups::has_lookup_from() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000200U);
  PROTOBUF_ASSUME(!value || _impl_.lookup_from_ != nullptr);
  return value;
}
inline void QueryPointGroups::clear_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lookup_from_ != nullptr) _impl_.lookup_from_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000200U);
}
inline const ::qdrant::LookupLocation& QueryPointGroups::_internal_lookup_from() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::LookupLocation* p = _impl_.lookup_from_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::LookupLocation&>(::qdrant::_LookupLocation_default_instance_);
}
inline const ::qdrant::LookupLocation& QueryPointGroups::lookup_from() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPointGroups.lookup_from)
  return _internal_lookup_from();
}
inline void QueryPointGroups::unsafe_arena_set_allocated_lookup_from(
    ::qdrant::LookupLocation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lookup_from_);
  }
  _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryPointGroups.lookup_from)
}
inline ::qdrant::LookupLocation* PROTOBUF_NULLABLE QueryPointGroups::release_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::LookupLocation* released = _impl_.lookup_from_;
  _impl_.lookup_from_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::LookupLocation* PROTOBUF_NULLABLE QueryPointGroups::unsafe_arena_release_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPointGroups.lookup_from)

  ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::LookupLocation* temp = _impl_.lookup_from_;
  _impl_.lookup_from_ = nullptr;
  return temp;
}
inline ::qdrant::LookupLocation* PROTOBUF_NONNULL QueryPointGroups::_internal_mutable_lookup_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lookup_from_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::LookupLocation>(GetArena());
    _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(p);
  }
  return _impl_.lookup_from_;
}
inline ::qdrant::LookupLocation* PROTOBUF_NONNULL QueryPointGroups::mutable_lookup_from()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::qdrant::LookupLocation* _msg = _internal_mutable_lookup_from();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPointGroups.lookup_from)
  return _msg;
}
inline void QueryPointGroups::set_allocated_lookup_from(::qdrant::LookupLocation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lookup_from_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  }

  _impl_.lookup_from_ = reinterpret_cast<::qdrant::LookupLocation*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPointGroups.lookup_from)
}

// optional uint64 limit = 11;
inline bool QueryPointGroups::has_limit() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00002000U);
  return value;
}
inline void QueryPointGroups::clear_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00002000U);
}
inline ::uint64_t QueryPointGroups::limit() const {
  // @@protoc_insertion_point(field_get:qdrant.QueryPointGroups.limit)
  return _internal_limit();
}
inline void QueryPointGroups::set_limit(::uint64_t value) {
  _internal_set_limit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00002000U);
  // @@protoc_insertion_point(field_set:qdrant.QueryPointGroups.limit)
}
inline ::uint64_t QueryPointGroups::_internal_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limit_;
}
inline void QueryPointGroups::_internal_set_limit(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = value;
}

// optional uint64 group_size = 12;
inline bool QueryPointGroups::has_group_size() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00004000U);
  return value;
}
inline void QueryPointGroups::clear_group_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_size_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00004000U);
}
inline ::uint64_t QueryPointGroups::group_size() const {
  // @@protoc_insertion_point(field_get:qdrant.QueryPointGroups.group_size)
  return _internal_group_size();
}
inline void QueryPointGroups::set_group_size(::uint64_t value) {
  _internal_set_group_size(value);
  SetHasBit(_impl_._has_bits_[0], 0x00004000U);
  // @@protoc_insertion_point(field_set:qdrant.QueryPointGroups.group_size)
}
inline ::uint64_t QueryPointGroups::_internal_group_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_size_;
}
inline void QueryPointGroups::_internal_set_group_size(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_size_ = value;
}

// string group_by = 13;
inline void QueryPointGroups::clear_group_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_by_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::std::string& QueryPointGroups::group_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPointGroups.group_by)
  return _internal_group_by();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void QueryPointGroups::set_group_by(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  _impl_.group_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.QueryPointGroups.group_by)
}
inline ::std::string* PROTOBUF_NONNULL QueryPointGroups::mutable_group_by()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::std::string* _s = _internal_mutable_group_by();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPointGroups.group_by)
  return _s;
}
inline const ::std::string& QueryPointGroups::_internal_group_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_by_.Get();
}
inline void QueryPointGroups::_internal_set_group_by(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_by_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL QueryPointGroups::_internal_mutable_group_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.group_by_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE QueryPointGroups::release_group_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPointGroups.group_by)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000008U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  auto* released = _impl_.group_by_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.group_by_.Set("", GetArena());
  }
  return released;
}
inline void QueryPointGroups::set_allocated_group_by(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  _impl_.group_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.group_by_.IsDefault()) {
    _impl_.group_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPointGroups.group_by)
}

// optional .qdrant.ReadConsistency read_consistency = 14;
inline bool QueryPointGroups::has_read_consistency() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000400U);
  PROTOBUF_ASSUME(!value || _impl_.read_consistency_ != nullptr);
  return value;
}
inline void QueryPointGroups::clear_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ != nullptr) _impl_.read_consistency_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000400U);
}
inline const ::qdrant::ReadConsistency& QueryPointGroups::_internal_read_consistency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ReadConsistency* p = _impl_.read_consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ReadConsistency&>(::qdrant::_ReadConsistency_default_instance_);
}
inline const ::qdrant::ReadConsistency& QueryPointGroups::read_consistency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPointGroups.read_consistency)
  return _internal_read_consistency();
}
inline void QueryPointGroups::unsafe_arena_set_allocated_read_consistency(
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }
  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryPointGroups.read_consistency)
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE QueryPointGroups::release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::ReadConsistency* released = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE QueryPointGroups::unsafe_arena_release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPointGroups.read_consistency)

  ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::ReadConsistency* temp = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  return temp;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL QueryPointGroups::_internal_mutable_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ReadConsistency>(GetArena());
    _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(p);
  }
  return _impl_.read_consistency_;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL QueryPointGroups::mutable_read_consistency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  ::qdrant::ReadConsistency* _msg = _internal_mutable_read_consistency();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPointGroups.read_consistency)
  return _msg;
}
inline void QueryPointGroups::set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000400U);
  }

  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPointGroups.read_consistency)
}

// optional .qdrant.WithLookup with_lookup = 15;
inline bool QueryPointGroups::has_with_lookup() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000800U);
  PROTOBUF_ASSUME(!value || _impl_.with_lookup_ != nullptr);
  return value;
}
inline void QueryPointGroups::clear_with_lookup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_lookup_ != nullptr) _impl_.with_lookup_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000800U);
}
inline const ::qdrant::WithLookup& QueryPointGroups::_internal_with_lookup() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WithLookup* p = _impl_.with_lookup_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WithLookup&>(::qdrant::_WithLookup_default_instance_);
}
inline const ::qdrant::WithLookup& QueryPointGroups::with_lookup() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPointGroups.with_lookup)
  return _internal_with_lookup();
}
inline void QueryPointGroups::unsafe_arena_set_allocated_with_lookup(
    ::qdrant::WithLookup* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_lookup_);
  }
  _impl_.with_lookup_ = reinterpret_cast<::qdrant::WithLookup*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000800U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryPointGroups.with_lookup)
}
inline ::qdrant::WithLookup* PROTOBUF_NULLABLE QueryPointGroups::release_with_lookup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000800U);
  ::qdrant::WithLookup* released = _impl_.with_lookup_;
  _impl_.with_lookup_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WithLookup* PROTOBUF_NULLABLE QueryPointGroups::unsafe_arena_release_with_lookup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPointGroups.with_lookup)

  ClearHasBit(_impl_._has_bits_[0], 0x00000800U);
  ::qdrant::WithLookup* temp = _impl_.with_lookup_;
  _impl_.with_lookup_ = nullptr;
  return temp;
}
inline ::qdrant::WithLookup* PROTOBUF_NONNULL QueryPointGroups::_internal_mutable_with_lookup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.with_lookup_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WithLookup>(GetArena());
    _impl_.with_lookup_ = reinterpret_cast<::qdrant::WithLookup*>(p);
  }
  return _impl_.with_lookup_;
}
inline ::qdrant::WithLookup* PROTOBUF_NONNULL QueryPointGroups::mutable_with_lookup()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  ::qdrant::WithLookup* _msg = _internal_mutable_with_lookup();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPointGroups.with_lookup)
  return _msg;
}
inline void QueryPointGroups::set_allocated_with_lookup(::qdrant::WithLookup* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.with_lookup_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000800U);
  }

  _impl_.with_lookup_ = reinterpret_cast<::qdrant::WithLookup*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPointGroups.with_lookup)
}

// optional uint64 timeout = 16;
inline bool QueryPointGroups::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00008000U);
  return value;
}
inline void QueryPointGroups::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00008000U);
}
inline ::uint64_t QueryPointGroups::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.QueryPointGroups.timeout)
  return _internal_timeout();
}
inline void QueryPointGroups::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00008000U);
  // @@protoc_insertion_point(field_set:qdrant.QueryPointGroups.timeout)
}
inline ::uint64_t QueryPointGroups::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void QueryPointGroups::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// optional .qdrant.ShardKeySelector shard_key_selector = 17;
inline bool QueryPointGroups::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00001000U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void QueryPointGroups::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00001000U);
}
inline const ::qdrant::ShardKeySelector& QueryPointGroups::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& QueryPointGroups::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryPointGroups.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void QueryPointGroups::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00001000U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00001000U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryPointGroups.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE QueryPointGroups::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00001000U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE QueryPointGroups::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryPointGroups.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00001000U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL QueryPointGroups::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL QueryPointGroups::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00001000U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryPointGroups.shard_key_selector)
  return _msg;
}
inline void QueryPointGroups::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00001000U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00001000U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryPointGroups.shard_key_selector)
}

// -------------------------------------------------------------------

// FacetCounts

// string collection_name = 1;
inline void FacetCounts::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& FacetCounts::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.FacetCounts.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FacetCounts::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.FacetCounts.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL FacetCounts::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.FacetCounts.collection_name)
  return _s;
}
inline const ::std::string& FacetCounts::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void FacetCounts::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FacetCounts::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FacetCounts::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.FacetCounts.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void FacetCounts::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.FacetCounts.collection_name)
}

// string key = 2;
inline void FacetCounts::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& FacetCounts::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.FacetCounts.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FacetCounts::set_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.FacetCounts.key)
}
inline ::std::string* PROTOBUF_NONNULL FacetCounts::mutable_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:qdrant.FacetCounts.key)
  return _s;
}
inline const ::std::string& FacetCounts::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void FacetCounts::_internal_set_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FacetCounts::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FacetCounts::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.FacetCounts.key)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.key_.Set("", GetArena());
  }
  return released;
}
inline void FacetCounts::set_allocated_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.FacetCounts.key)
}

// optional .qdrant.Filter filter = 3;
inline bool FacetCounts::has_filter() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void FacetCounts::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::Filter& FacetCounts::_internal_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Filter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& FacetCounts::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.FacetCounts.filter)
  return _internal_filter();
}
inline void FacetCounts::unsafe_arena_set_allocated_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.FacetCounts.filter)
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE FacetCounts::release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Filter* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE FacetCounts::unsafe_arena_release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.FacetCounts.filter)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL FacetCounts::_internal_mutable_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
    _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(p);
  }
  return _impl_.filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL FacetCounts::mutable_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.FacetCounts.filter)
  return _msg;
}
inline void FacetCounts::set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.FacetCounts.filter)
}

// optional uint64 limit = 4;
inline bool FacetCounts::has_limit() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void FacetCounts::clear_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::uint64_t FacetCounts::limit() const {
  // @@protoc_insertion_point(field_get:qdrant.FacetCounts.limit)
  return _internal_limit();
}
inline void FacetCounts::set_limit(::uint64_t value) {
  _internal_set_limit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.FacetCounts.limit)
}
inline ::uint64_t FacetCounts::_internal_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limit_;
}
inline void FacetCounts::_internal_set_limit(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = value;
}

// optional bool exact = 5;
inline bool FacetCounts::has_exact() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  return value;
}
inline void FacetCounts::clear_exact() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exact_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline bool FacetCounts::exact() const {
  // @@protoc_insertion_point(field_get:qdrant.FacetCounts.exact)
  return _internal_exact();
}
inline void FacetCounts::set_exact(bool value) {
  _internal_set_exact(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  // @@protoc_insertion_point(field_set:qdrant.FacetCounts.exact)
}
inline bool FacetCounts::_internal_exact() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exact_;
}
inline void FacetCounts::_internal_set_exact(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exact_ = value;
}

// optional uint64 timeout = 6;
inline bool FacetCounts::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  return value;
}
inline void FacetCounts::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline ::uint64_t FacetCounts::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.FacetCounts.timeout)
  return _internal_timeout();
}
inline void FacetCounts::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:qdrant.FacetCounts.timeout)
}
inline ::uint64_t FacetCounts::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void FacetCounts::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// optional .qdrant.ReadConsistency read_consistency = 7;
inline bool FacetCounts::has_read_consistency() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.read_consistency_ != nullptr);
  return value;
}
inline void FacetCounts::clear_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ != nullptr) _impl_.read_consistency_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::ReadConsistency& FacetCounts::_internal_read_consistency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ReadConsistency* p = _impl_.read_consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ReadConsistency&>(::qdrant::_ReadConsistency_default_instance_);
}
inline const ::qdrant::ReadConsistency& FacetCounts::read_consistency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.FacetCounts.read_consistency)
  return _internal_read_consistency();
}
inline void FacetCounts::unsafe_arena_set_allocated_read_consistency(
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }
  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.FacetCounts.read_consistency)
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE FacetCounts::release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ReadConsistency* released = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE FacetCounts::unsafe_arena_release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.FacetCounts.read_consistency)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ReadConsistency* temp = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  return temp;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL FacetCounts::_internal_mutable_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ReadConsistency>(GetArena());
    _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(p);
  }
  return _impl_.read_consistency_;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL FacetCounts::mutable_read_consistency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ReadConsistency* _msg = _internal_mutable_read_consistency();
  // @@protoc_insertion_point(field_mutable:qdrant.FacetCounts.read_consistency)
  return _msg;
}
inline void FacetCounts::set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.FacetCounts.read_consistency)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 8;
inline bool FacetCounts::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void FacetCounts::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::ShardKeySelector& FacetCounts::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& FacetCounts::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.FacetCounts.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void FacetCounts::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.FacetCounts.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE FacetCounts::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE FacetCounts::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.FacetCounts.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL FacetCounts::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL FacetCounts::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.FacetCounts.shard_key_selector)
  return _msg;
}
inline void FacetCounts::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.FacetCounts.shard_key_selector)
}

// -------------------------------------------------------------------

// FacetValue

// string string_value = 1;
inline bool FacetValue::has_string_value() const {
  return variant_case() == kStringValue;
}
inline void FacetValue::set_has_string_value() {
  _impl_._oneof_case_[0] = kStringValue;
}
inline void FacetValue::clear_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kStringValue) {
    _impl_.variant_.string_value_.Destroy();
    clear_has_variant();
  }
}
inline const ::std::string& FacetValue::string_value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.FacetValue.string_value)
  return _internal_string_value();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FacetValue::set_string_value(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() != kStringValue) {
    clear_variant();

    set_has_string_value();
    _impl_.variant_.string_value_.InitDefault();
  }
  _impl_.variant_.string_value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.FacetValue.string_value)
}
inline ::std::string* PROTOBUF_NONNULL FacetValue::mutable_string_value()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  if (variant_case() != kStringValue) {
    clear_variant();

    set_has_string_value();
    _impl_.variant_.string_value_.InitDefault();
  }
  ::std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:qdrant.FacetValue.string_value)
  return _s;
}
inline const ::std::string& FacetValue::_internal_string_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (variant_case() != kStringValue) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.variant_.string_value_.Get();
}
inline void FacetValue::_internal_set_string_value(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.variant_.string_value_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FacetValue::_internal_mutable_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.variant_.string_value_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FacetValue::release_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.FacetValue.string_value)
  if (variant_case() != kStringValue) {
    return nullptr;
  }
  clear_has_variant();
  return _impl_.variant_.string_value_.Release();
}
inline void FacetValue::set_allocated_string_value(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_variant()) {
    clear_variant();
  }
  if (value != nullptr) {
    set_has_string_value();
    _impl_.variant_.string_value_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.FacetValue.string_value)
}

// int64 integer_value = 2;
inline bool FacetValue::has_integer_value() const {
  return variant_case() == kIntegerValue;
}
inline void FacetValue::set_has_integer_value() {
  _impl_._oneof_case_[0] = kIntegerValue;
}
inline void FacetValue::clear_integer_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kIntegerValue) {
    _impl_.variant_.integer_value_ = ::int64_t{0};
    clear_has_variant();
  }
}
inline ::int64_t FacetValue::integer_value() const {
  // @@protoc_insertion_point(field_get:qdrant.FacetValue.integer_value)
  return _internal_integer_value();
}
inline void FacetValue::set_integer_value(::int64_t value) {
  if (variant_case() != kIntegerValue) {
    clear_variant();
    set_has_integer_value();
  }
  _impl_.variant_.integer_value_ = value;
  // @@protoc_insertion_point(field_set:qdrant.FacetValue.integer_value)
}
inline ::int64_t FacetValue::_internal_integer_value() const {
  if (variant_case() == kIntegerValue) {
    return _impl_.variant_.integer_value_;
  }
  return ::int64_t{0};
}

// bool bool_value = 3;
inline bool FacetValue::has_bool_value() const {
  return variant_case() == kBoolValue;
}
inline void FacetValue::set_has_bool_value() {
  _impl_._oneof_case_[0] = kBoolValue;
}
inline void FacetValue::clear_bool_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kBoolValue) {
    _impl_.variant_.bool_value_ = false;
    clear_has_variant();
  }
}
inline bool FacetValue::bool_value() const {
  // @@protoc_insertion_point(field_get:qdrant.FacetValue.bool_value)
  return _internal_bool_value();
}
inline void FacetValue::set_bool_value(bool value) {
  if (variant_case() != kBoolValue) {
    clear_variant();
    set_has_bool_value();
  }
  _impl_.variant_.bool_value_ = value;
  // @@protoc_insertion_point(field_set:qdrant.FacetValue.bool_value)
}
inline bool FacetValue::_internal_bool_value() const {
  if (variant_case() == kBoolValue) {
    return _impl_.variant_.bool_value_;
  }
  return false;
}

inline bool FacetValue::has_variant() const {
  return variant_case() != VARIANT_NOT_SET;
}
inline void FacetValue::clear_has_variant() {
  _impl_._oneof_case_[0] = VARIANT_NOT_SET;
}
inline FacetValue::VariantCase FacetValue::variant_case() const {
  return FacetValue::VariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FacetHit

// .qdrant.FacetValue value = 1;
inline bool FacetHit::has_value() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline void FacetHit::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::FacetValue& FacetHit::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::FacetValue* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::FacetValue&>(::qdrant::_FacetValue_default_instance_);
}
inline const ::qdrant::FacetValue& FacetHit::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.FacetHit.value)
  return _internal_value();
}
inline void FacetHit::unsafe_arena_set_allocated_value(
    ::qdrant::FacetValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::qdrant::FacetValue*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.FacetHit.value)
}
inline ::qdrant::FacetValue* PROTOBUF_NULLABLE FacetHit::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::FacetValue* released = _impl_.value_;
  _impl_.value_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::FacetValue* PROTOBUF_NULLABLE FacetHit::unsafe_arena_release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.FacetHit.value)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::FacetValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::qdrant::FacetValue* PROTOBUF_NONNULL FacetHit::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::FacetValue>(GetArena());
    _impl_.value_ = reinterpret_cast<::qdrant::FacetValue*>(p);
  }
  return _impl_.value_;
}
inline ::qdrant::FacetValue* PROTOBUF_NONNULL FacetHit::mutable_value()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::FacetValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:qdrant.FacetHit.value)
  return _msg;
}
inline void FacetHit::set_allocated_value(::qdrant::FacetValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.value_ = reinterpret_cast<::qdrant::FacetValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.FacetHit.value)
}

// uint64 count = 2;
inline void FacetHit::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint64_t FacetHit::count() const {
  // @@protoc_insertion_point(field_get:qdrant.FacetHit.count)
  return _internal_count();
}
inline void FacetHit::set_count(::uint64_t value) {
  _internal_set_count(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.FacetHit.count)
}
inline ::uint64_t FacetHit::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void FacetHit::_internal_set_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// SearchMatrixPoints

// string collection_name = 1;
inline void SearchMatrixPoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& SearchMatrixPoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixPoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SearchMatrixPoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.SearchMatrixPoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL SearchMatrixPoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchMatrixPoints.collection_name)
  return _s;
}
inline const ::std::string& SearchMatrixPoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void SearchMatrixPoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SearchMatrixPoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SearchMatrixPoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchMatrixPoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void SearchMatrixPoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchMatrixPoints.collection_name)
}

// optional .qdrant.Filter filter = 2;
inline bool SearchMatrixPoints::has_filter() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void SearchMatrixPoints::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::Filter& SearchMatrixPoints::_internal_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Filter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& SearchMatrixPoints::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixPoints.filter)
  return _internal_filter();
}
inline void SearchMatrixPoints::unsafe_arena_set_allocated_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchMatrixPoints.filter)
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE SearchMatrixPoints::release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Filter* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE SearchMatrixPoints::unsafe_arena_release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchMatrixPoints.filter)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL SearchMatrixPoints::_internal_mutable_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
    _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(p);
  }
  return _impl_.filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL SearchMatrixPoints::mutable_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchMatrixPoints.filter)
  return _msg;
}
inline void SearchMatrixPoints::set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchMatrixPoints.filter)
}

// optional uint64 sample = 3;
inline bool SearchMatrixPoints::has_sample() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void SearchMatrixPoints::clear_sample() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sample_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::uint64_t SearchMatrixPoints::sample() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixPoints.sample)
  return _internal_sample();
}
inline void SearchMatrixPoints::set_sample(::uint64_t value) {
  _internal_set_sample(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.SearchMatrixPoints.sample)
}
inline ::uint64_t SearchMatrixPoints::_internal_sample() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sample_;
}
inline void SearchMatrixPoints::_internal_set_sample(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sample_ = value;
}

// optional uint64 limit = 4;
inline bool SearchMatrixPoints::has_limit() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  return value;
}
inline void SearchMatrixPoints::clear_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline ::uint64_t SearchMatrixPoints::limit() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixPoints.limit)
  return _internal_limit();
}
inline void SearchMatrixPoints::set_limit(::uint64_t value) {
  _internal_set_limit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:qdrant.SearchMatrixPoints.limit)
}
inline ::uint64_t SearchMatrixPoints::_internal_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limit_;
}
inline void SearchMatrixPoints::_internal_set_limit(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = value;
}

// optional string using = 5;
inline bool SearchMatrixPoints::has_using_() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void SearchMatrixPoints::clear_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.using__.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& SearchMatrixPoints::using_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixPoints.using)
  return _internal_using_();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SearchMatrixPoints::set_using_(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.using__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.SearchMatrixPoints.using)
}
inline ::std::string* PROTOBUF_NONNULL SearchMatrixPoints::mutable_using_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_using_();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchMatrixPoints.using)
  return _s;
}
inline const ::std::string& SearchMatrixPoints::_internal_using_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.using__.Get();
}
inline void SearchMatrixPoints::_internal_set_using_(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.using__.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SearchMatrixPoints::_internal_mutable_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.using__.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SearchMatrixPoints::release_using_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchMatrixPoints.using)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.using__.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.using__.Set("", GetArena());
  }
  return released;
}
inline void SearchMatrixPoints::set_allocated_using_(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.using__.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.using__.IsDefault()) {
    _impl_.using__.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchMatrixPoints.using)
}

// optional uint64 timeout = 6;
inline bool SearchMatrixPoints::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  return value;
}
inline void SearchMatrixPoints::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline ::uint64_t SearchMatrixPoints::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixPoints.timeout)
  return _internal_timeout();
}
inline void SearchMatrixPoints::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  // @@protoc_insertion_point(field_set:qdrant.SearchMatrixPoints.timeout)
}
inline ::uint64_t SearchMatrixPoints::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void SearchMatrixPoints::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// optional .qdrant.ReadConsistency read_consistency = 7;
inline bool SearchMatrixPoints::has_read_consistency() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.read_consistency_ != nullptr);
  return value;
}
inline void SearchMatrixPoints::clear_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ != nullptr) _impl_.read_consistency_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::ReadConsistency& SearchMatrixPoints::_internal_read_consistency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ReadConsistency* p = _impl_.read_consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ReadConsistency&>(::qdrant::_ReadConsistency_default_instance_);
}
inline const ::qdrant::ReadConsistency& SearchMatrixPoints::read_consistency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixPoints.read_consistency)
  return _internal_read_consistency();
}
inline void SearchMatrixPoints::unsafe_arena_set_allocated_read_consistency(
    ::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }
  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchMatrixPoints.read_consistency)
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE SearchMatrixPoints::release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ReadConsistency* released = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NULLABLE SearchMatrixPoints::unsafe_arena_release_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchMatrixPoints.read_consistency)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ReadConsistency* temp = _impl_.read_consistency_;
  _impl_.read_consistency_ = nullptr;
  return temp;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL SearchMatrixPoints::_internal_mutable_read_consistency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.read_consistency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ReadConsistency>(GetArena());
    _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(p);
  }
  return _impl_.read_consistency_;
}
inline ::qdrant::ReadConsistency* PROTOBUF_NONNULL SearchMatrixPoints::mutable_read_consistency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::ReadConsistency* _msg = _internal_mutable_read_consistency();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchMatrixPoints.read_consistency)
  return _msg;
}
inline void SearchMatrixPoints::set_allocated_read_consistency(::qdrant::ReadConsistency* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_consistency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.read_consistency_ = reinterpret_cast<::qdrant::ReadConsistency*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchMatrixPoints.read_consistency)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 8;
inline bool SearchMatrixPoints::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void SearchMatrixPoints::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::ShardKeySelector& SearchMatrixPoints::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& SearchMatrixPoints::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixPoints.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void SearchMatrixPoints::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchMatrixPoints.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE SearchMatrixPoints::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE SearchMatrixPoints::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchMatrixPoints.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL SearchMatrixPoints::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL SearchMatrixPoints::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchMatrixPoints.shard_key_selector)
  return _msg;
}
inline void SearchMatrixPoints::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchMatrixPoints.shard_key_selector)
}

// -------------------------------------------------------------------

// SearchMatrixPairs

// repeated .qdrant.SearchMatrixPair pairs = 1;
inline int SearchMatrixPairs::_internal_pairs_size() const {
  return _internal_pairs().size();
}
inline int SearchMatrixPairs::pairs_size() const {
  return _internal_pairs_size();
}
inline void SearchMatrixPairs::clear_pairs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pairs_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::SearchMatrixPair* PROTOBUF_NONNULL SearchMatrixPairs::mutable_pairs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.SearchMatrixPairs.pairs)
  return _internal_mutable_pairs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::SearchMatrixPair>* PROTOBUF_NONNULL SearchMatrixPairs::mutable_pairs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.SearchMatrixPairs.pairs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_pairs();
}
inline const ::qdrant::SearchMatrixPair& SearchMatrixPairs::pairs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixPairs.pairs)
  return _internal_pairs().Get(index);
}
inline ::qdrant::SearchMatrixPair* PROTOBUF_NONNULL SearchMatrixPairs::add_pairs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::SearchMatrixPair* _add =
      _internal_mutable_pairs()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.SearchMatrixPairs.pairs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::SearchMatrixPair>& SearchMatrixPairs::pairs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.SearchMatrixPairs.pairs)
  return _internal_pairs();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::SearchMatrixPair>&
SearchMatrixPairs::_internal_pairs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pairs_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::SearchMatrixPair>* PROTOBUF_NONNULL
SearchMatrixPairs::_internal_mutable_pairs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.pairs_;
}

// -------------------------------------------------------------------

// SearchMatrixPair

// .qdrant.PointId a = 1;
inline bool SearchMatrixPair::has_a() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.a_ != nullptr);
  return value;
}
inline void SearchMatrixPair::clear_a() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.a_ != nullptr) _impl_.a_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::PointId& SearchMatrixPair::_internal_a() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointId* p = _impl_.a_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointId&>(::qdrant::_PointId_default_instance_);
}
inline const ::qdrant::PointId& SearchMatrixPair::a() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixPair.a)
  return _internal_a();
}
inline void SearchMatrixPair::unsafe_arena_set_allocated_a(
    ::qdrant::PointId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.a_);
  }
  _impl_.a_ = reinterpret_cast<::qdrant::PointId*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchMatrixPair.a)
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE SearchMatrixPair::release_a() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointId* released = _impl_.a_;
  _impl_.a_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE SearchMatrixPair::unsafe_arena_release_a() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchMatrixPair.a)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointId* temp = _impl_.a_;
  _impl_.a_ = nullptr;
  return temp;
}
inline ::qdrant::PointId* PROTOBUF_NONNULL SearchMatrixPair::_internal_mutable_a() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.a_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointId>(GetArena());
    _impl_.a_ = reinterpret_cast<::qdrant::PointId*>(p);
  }
  return _impl_.a_;
}
inline ::qdrant::PointId* PROTOBUF_NONNULL SearchMatrixPair::mutable_a()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointId* _msg = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchMatrixPair.a)
  return _msg;
}
inline void SearchMatrixPair::set_allocated_a(::qdrant::PointId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.a_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.a_ = reinterpret_cast<::qdrant::PointId*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchMatrixPair.a)
}

// .qdrant.PointId b = 2;
inline bool SearchMatrixPair::has_b() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.b_ != nullptr);
  return value;
}
inline void SearchMatrixPair::clear_b() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.b_ != nullptr) _impl_.b_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::PointId& SearchMatrixPair::_internal_b() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointId* p = _impl_.b_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointId&>(::qdrant::_PointId_default_instance_);
}
inline const ::qdrant::PointId& SearchMatrixPair::b() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixPair.b)
  return _internal_b();
}
inline void SearchMatrixPair::unsafe_arena_set_allocated_b(
    ::qdrant::PointId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.b_);
  }
  _impl_.b_ = reinterpret_cast<::qdrant::PointId*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchMatrixPair.b)
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE SearchMatrixPair::release_b() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointId* released = _impl_.b_;
  _impl_.b_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE SearchMatrixPair::unsafe_arena_release_b() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchMatrixPair.b)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointId* temp = _impl_.b_;
  _impl_.b_ = nullptr;
  return temp;
}
inline ::qdrant::PointId* PROTOBUF_NONNULL SearchMatrixPair::_internal_mutable_b() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.b_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointId>(GetArena());
    _impl_.b_ = reinterpret_cast<::qdrant::PointId*>(p);
  }
  return _impl_.b_;
}
inline ::qdrant::PointId* PROTOBUF_NONNULL SearchMatrixPair::mutable_b()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointId* _msg = _internal_mutable_b();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchMatrixPair.b)
  return _msg;
}
inline void SearchMatrixPair::set_allocated_b(::qdrant::PointId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.b_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.b_ = reinterpret_cast<::qdrant::PointId*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchMatrixPair.b)
}

// float score = 3;
inline void SearchMatrixPair::clear_score() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline float SearchMatrixPair::score() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixPair.score)
  return _internal_score();
}
inline void SearchMatrixPair::set_score(float value) {
  _internal_set_score(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.SearchMatrixPair.score)
}
inline float SearchMatrixPair::_internal_score() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.score_;
}
inline void SearchMatrixPair::_internal_set_score(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_ = value;
}

// -------------------------------------------------------------------

// SearchMatrixOffsets

// repeated uint64 offsets_row = 1;
inline int SearchMatrixOffsets::_internal_offsets_row_size() const {
  return _internal_offsets_row().size();
}
inline int SearchMatrixOffsets::offsets_row_size() const {
  return _internal_offsets_row_size();
}
inline void SearchMatrixOffsets::clear_offsets_row() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offsets_row_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t SearchMatrixOffsets::offsets_row(int index) const {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixOffsets.offsets_row)
  return _internal_offsets_row().Get(index);
}
inline void SearchMatrixOffsets::set_offsets_row(int index, ::uint64_t value) {
  _internal_mutable_offsets_row()->Set(index, value);
  // @@protoc_insertion_point(field_set:qdrant.SearchMatrixOffsets.offsets_row)
}
inline void SearchMatrixOffsets::add_offsets_row(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_offsets_row()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.SearchMatrixOffsets.offsets_row)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& SearchMatrixOffsets::offsets_row() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.SearchMatrixOffsets.offsets_row)
  return _internal_offsets_row();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL SearchMatrixOffsets::mutable_offsets_row()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.SearchMatrixOffsets.offsets_row)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_offsets_row();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
SearchMatrixOffsets::_internal_offsets_row() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offsets_row_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL
SearchMatrixOffsets::_internal_mutable_offsets_row() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.offsets_row_;
}

// repeated uint64 offsets_col = 2;
inline int SearchMatrixOffsets::_internal_offsets_col_size() const {
  return _internal_offsets_col().size();
}
inline int SearchMatrixOffsets::offsets_col_size() const {
  return _internal_offsets_col_size();
}
inline void SearchMatrixOffsets::clear_offsets_col() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offsets_col_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint64_t SearchMatrixOffsets::offsets_col(int index) const {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixOffsets.offsets_col)
  return _internal_offsets_col().Get(index);
}
inline void SearchMatrixOffsets::set_offsets_col(int index, ::uint64_t value) {
  _internal_mutable_offsets_col()->Set(index, value);
  // @@protoc_insertion_point(field_set:qdrant.SearchMatrixOffsets.offsets_col)
}
inline void SearchMatrixOffsets::add_offsets_col(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_offsets_col()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:qdrant.SearchMatrixOffsets.offsets_col)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& SearchMatrixOffsets::offsets_col() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.SearchMatrixOffsets.offsets_col)
  return _internal_offsets_col();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL SearchMatrixOffsets::mutable_offsets_col()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.SearchMatrixOffsets.offsets_col)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_offsets_col();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
SearchMatrixOffsets::_internal_offsets_col() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offsets_col_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL
SearchMatrixOffsets::_internal_mutable_offsets_col() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.offsets_col_;
}

// repeated float scores = 3;
inline int SearchMatrixOffsets::_internal_scores_size() const {
  return _internal_scores().size();
}
inline int SearchMatrixOffsets::scores_size() const {
  return _internal_scores_size();
}
inline void SearchMatrixOffsets::clear_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scores_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline float SearchMatrixOffsets::scores(int index) const {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixOffsets.scores)
  return _internal_scores().Get(index);
}
inline void SearchMatrixOffsets::set_scores(int index, float value) {
  _internal_mutable_scores()->Set(index, value);
  // @@protoc_insertion_point(field_set:qdrant.SearchMatrixOffsets.scores)
}
inline void SearchMatrixOffsets::add_scores(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_scores()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:qdrant.SearchMatrixOffsets.scores)
}
inline const ::google::protobuf::RepeatedField<float>& SearchMatrixOffsets::scores() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.SearchMatrixOffsets.scores)
  return _internal_scores();
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL SearchMatrixOffsets::mutable_scores()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.SearchMatrixOffsets.scores)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_scores();
}
inline const ::google::protobuf::RepeatedField<float>&
SearchMatrixOffsets::_internal_scores() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.scores_;
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL
SearchMatrixOffsets::_internal_mutable_scores() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.scores_;
}

// repeated .qdrant.PointId ids = 4;
inline int SearchMatrixOffsets::_internal_ids_size() const {
  return _internal_ids().size();
}
inline int SearchMatrixOffsets::ids_size() const {
  return _internal_ids_size();
}
inline void SearchMatrixOffsets::clear_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ids_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::qdrant::PointId* PROTOBUF_NONNULL SearchMatrixOffsets::mutable_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.SearchMatrixOffsets.ids)
  return _internal_mutable_ids()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL SearchMatrixOffsets::mutable_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.SearchMatrixOffsets.ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ids();
}
inline const ::qdrant::PointId& SearchMatrixOffsets::ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixOffsets.ids)
  return _internal_ids().Get(index);
}
inline ::qdrant::PointId* PROTOBUF_NONNULL SearchMatrixOffsets::add_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::PointId* _add =
      _internal_mutable_ids()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_add:qdrant.SearchMatrixOffsets.ids)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& SearchMatrixOffsets::ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.SearchMatrixOffsets.ids)
  return _internal_ids();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>&
SearchMatrixOffsets::_internal_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ids_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL
SearchMatrixOffsets::_internal_mutable_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ids_;
}

// -------------------------------------------------------------------

// PointsUpdateOperation_PointStructList

// repeated .qdrant.PointStruct points = 1;
inline int PointsUpdateOperation_PointStructList::_internal_points_size() const {
  return _internal_points().size();
}
inline int PointsUpdateOperation_PointStructList::points_size() const {
  return _internal_points_size();
}
inline void PointsUpdateOperation_PointStructList::clear_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.points_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::PointStruct* PROTOBUF_NONNULL PointsUpdateOperation_PointStructList::mutable_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.PointStructList.points)
  return _internal_mutable_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointStruct>* PROTOBUF_NONNULL PointsUpdateOperation_PointStructList::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.PointsUpdateOperation.PointStructList.points)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_points();
}
inline const ::qdrant::PointStruct& PointsUpdateOperation_PointStructList::points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.PointStructList.points)
  return _internal_points().Get(index);
}
inline ::qdrant::PointStruct* PROTOBUF_NONNULL PointsUpdateOperation_PointStructList::add_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::PointStruct* _add =
      _internal_mutable_points()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.PointsUpdateOperation.PointStructList.points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointStruct>& PointsUpdateOperation_PointStructList::points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.PointsUpdateOperation.PointStructList.points)
  return _internal_points();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointStruct>&
PointsUpdateOperation_PointStructList::_internal_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.points_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointStruct>* PROTOBUF_NONNULL
PointsUpdateOperation_PointStructList::_internal_mutable_points() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.points_;
}

// optional .qdrant.ShardKeySelector shard_key_selector = 2;
inline bool PointsUpdateOperation_PointStructList::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void PointsUpdateOperation_PointStructList::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::ShardKeySelector& PointsUpdateOperation_PointStructList::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& PointsUpdateOperation_PointStructList::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.PointStructList.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void PointsUpdateOperation_PointStructList::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.PointStructList.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE PointsUpdateOperation_PointStructList::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE PointsUpdateOperation_PointStructList::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.PointStructList.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL PointsUpdateOperation_PointStructList::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL PointsUpdateOperation_PointStructList::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.PointStructList.shard_key_selector)
  return _msg;
}
inline void PointsUpdateOperation_PointStructList::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.PointStructList.shard_key_selector)
}

// optional .qdrant.Filter update_filter = 3;
inline bool PointsUpdateOperation_PointStructList::has_update_filter() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.update_filter_ != nullptr);
  return value;
}
inline void PointsUpdateOperation_PointStructList::clear_update_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.update_filter_ != nullptr) _impl_.update_filter_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::Filter& PointsUpdateOperation_PointStructList::_internal_update_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Filter* p = _impl_.update_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& PointsUpdateOperation_PointStructList::update_filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.PointStructList.update_filter)
  return _internal_update_filter();
}
inline void PointsUpdateOperation_PointStructList::unsafe_arena_set_allocated_update_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_filter_);
  }
  _impl_.update_filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.PointStructList.update_filter)
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE PointsUpdateOperation_PointStructList::release_update_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Filter* released = _impl_.update_filter_;
  _impl_.update_filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE PointsUpdateOperation_PointStructList::unsafe_arena_release_update_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.PointStructList.update_filter)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Filter* temp = _impl_.update_filter_;
  _impl_.update_filter_ = nullptr;
  return temp;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL PointsUpdateOperation_PointStructList::_internal_mutable_update_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.update_filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
    _impl_.update_filter_ = reinterpret_cast<::qdrant::Filter*>(p);
  }
  return _impl_.update_filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL PointsUpdateOperation_PointStructList::mutable_update_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Filter* _msg = _internal_mutable_update_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.PointStructList.update_filter)
  return _msg;
}
inline void PointsUpdateOperation_PointStructList::set_allocated_update_filter(::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.update_filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.PointStructList.update_filter)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PointsUpdateOperation_SetPayload

// map<string, .qdrant.Value> payload = 1;
inline int PointsUpdateOperation_SetPayload::_internal_payload_size() const {
  return _internal_payload().size();
}
inline int PointsUpdateOperation_SetPayload::payload_size() const {
  return _internal_payload_size();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& PointsUpdateOperation_SetPayload::_internal_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& PointsUpdateOperation_SetPayload::payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.PointsUpdateOperation.SetPayload.payload)
  return _internal_payload();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL PointsUpdateOperation_SetPayload::_internal_mutable_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.payload_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL PointsUpdateOperation_SetPayload::mutable_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.PointsUpdateOperation.SetPayload.payload)
  return _internal_mutable_payload();
}

// optional .qdrant.PointsSelector points_selector = 2;
inline bool PointsUpdateOperation_SetPayload::has_points_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.points_selector_ != nullptr);
  return value;
}
inline void PointsUpdateOperation_SetPayload::clear_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_selector_ != nullptr) _impl_.points_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::PointsSelector& PointsUpdateOperation_SetPayload::_internal_points_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointsSelector* p = _impl_.points_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointsSelector&>(::qdrant::_PointsSelector_default_instance_);
}
inline const ::qdrant::PointsSelector& PointsUpdateOperation_SetPayload::points_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.SetPayload.points_selector)
  return _internal_points_selector();
}
inline void PointsUpdateOperation_SetPayload::unsafe_arena_set_allocated_points_selector(
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_selector_);
  }
  _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.SetPayload.points_selector)
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE PointsUpdateOperation_SetPayload::release_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* released = _impl_.points_selector_;
  _impl_.points_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE PointsUpdateOperation_SetPayload::unsafe_arena_release_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.SetPayload.points_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* temp = _impl_.points_selector_;
  _impl_.points_selector_ = nullptr;
  return temp;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL PointsUpdateOperation_SetPayload::_internal_mutable_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsSelector>(GetArena());
    _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(p);
  }
  return _impl_.points_selector_;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL PointsUpdateOperation_SetPayload::mutable_points_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* _msg = _internal_mutable_points_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.SetPayload.points_selector)
  return _msg;
}
inline void PointsUpdateOperation_SetPayload::set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.SetPayload.points_selector)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 3;
inline bool PointsUpdateOperation_SetPayload::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void PointsUpdateOperation_SetPayload::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::ShardKeySelector& PointsUpdateOperation_SetPayload::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& PointsUpdateOperation_SetPayload::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.SetPayload.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void PointsUpdateOperation_SetPayload::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.SetPayload.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE PointsUpdateOperation_SetPayload::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE PointsUpdateOperation_SetPayload::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.SetPayload.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL PointsUpdateOperation_SetPayload::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL PointsUpdateOperation_SetPayload::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.SetPayload.shard_key_selector)
  return _msg;
}
inline void PointsUpdateOperation_SetPayload::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.SetPayload.shard_key_selector)
}

// optional string key = 4;
inline bool PointsUpdateOperation_SetPayload::has_key() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void PointsUpdateOperation_SetPayload::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& PointsUpdateOperation_SetPayload::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.SetPayload.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PointsUpdateOperation_SetPayload::set_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.PointsUpdateOperation.SetPayload.key)
}
inline ::std::string* PROTOBUF_NONNULL PointsUpdateOperation_SetPayload::mutable_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.SetPayload.key)
  return _s;
}
inline const ::std::string& PointsUpdateOperation_SetPayload::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void PointsUpdateOperation_SetPayload::_internal_set_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PointsUpdateOperation_SetPayload::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PointsUpdateOperation_SetPayload::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.SetPayload.key)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.key_.Set("", GetArena());
  }
  return released;
}
inline void PointsUpdateOperation_SetPayload::set_allocated_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.SetPayload.key)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PointsUpdateOperation_OverwritePayload

// map<string, .qdrant.Value> payload = 1;
inline int PointsUpdateOperation_OverwritePayload::_internal_payload_size() const {
  return _internal_payload().size();
}
inline int PointsUpdateOperation_OverwritePayload::payload_size() const {
  return _internal_payload_size();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& PointsUpdateOperation_OverwritePayload::_internal_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& PointsUpdateOperation_OverwritePayload::payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.PointsUpdateOperation.OverwritePayload.payload)
  return _internal_payload();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL PointsUpdateOperation_OverwritePayload::_internal_mutable_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.payload_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL PointsUpdateOperation_OverwritePayload::mutable_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.PointsUpdateOperation.OverwritePayload.payload)
  return _internal_mutable_payload();
}

// optional .qdrant.PointsSelector points_selector = 2;
inline bool PointsUpdateOperation_OverwritePayload::has_points_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.points_selector_ != nullptr);
  return value;
}
inline void PointsUpdateOperation_OverwritePayload::clear_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_selector_ != nullptr) _impl_.points_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::PointsSelector& PointsUpdateOperation_OverwritePayload::_internal_points_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointsSelector* p = _impl_.points_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointsSelector&>(::qdrant::_PointsSelector_default_instance_);
}
inline const ::qdrant::PointsSelector& PointsUpdateOperation_OverwritePayload::points_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.OverwritePayload.points_selector)
  return _internal_points_selector();
}
inline void PointsUpdateOperation_OverwritePayload::unsafe_arena_set_allocated_points_selector(
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_selector_);
  }
  _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.OverwritePayload.points_selector)
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE PointsUpdateOperation_OverwritePayload::release_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* released = _impl_.points_selector_;
  _impl_.points_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE PointsUpdateOperation_OverwritePayload::unsafe_arena_release_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.OverwritePayload.points_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* temp = _impl_.points_selector_;
  _impl_.points_selector_ = nullptr;
  return temp;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL PointsUpdateOperation_OverwritePayload::_internal_mutable_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsSelector>(GetArena());
    _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(p);
  }
  return _impl_.points_selector_;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL PointsUpdateOperation_OverwritePayload::mutable_points_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* _msg = _internal_mutable_points_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.OverwritePayload.points_selector)
  return _msg;
}
inline void PointsUpdateOperation_OverwritePayload::set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.OverwritePayload.points_selector)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 3;
inline bool PointsUpdateOperation_OverwritePayload::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void PointsUpdateOperation_OverwritePayload::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::ShardKeySelector& PointsUpdateOperation_OverwritePayload::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& PointsUpdateOperation_OverwritePayload::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.OverwritePayload.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void PointsUpdateOperation_OverwritePayload::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.OverwritePayload.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE PointsUpdateOperation_OverwritePayload::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE PointsUpdateOperation_OverwritePayload::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.OverwritePayload.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL PointsUpdateOperation_OverwritePayload::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL PointsUpdateOperation_OverwritePayload::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.OverwritePayload.shard_key_selector)
  return _msg;
}
inline void PointsUpdateOperation_OverwritePayload::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.OverwritePayload.shard_key_selector)
}

// optional string key = 4;
inline bool PointsUpdateOperation_OverwritePayload::has_key() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void PointsUpdateOperation_OverwritePayload::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& PointsUpdateOperation_OverwritePayload::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.OverwritePayload.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PointsUpdateOperation_OverwritePayload::set_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.PointsUpdateOperation.OverwritePayload.key)
}
inline ::std::string* PROTOBUF_NONNULL PointsUpdateOperation_OverwritePayload::mutable_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.OverwritePayload.key)
  return _s;
}
inline const ::std::string& PointsUpdateOperation_OverwritePayload::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void PointsUpdateOperation_OverwritePayload::_internal_set_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PointsUpdateOperation_OverwritePayload::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PointsUpdateOperation_OverwritePayload::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.OverwritePayload.key)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.key_.Set("", GetArena());
  }
  return released;
}
inline void PointsUpdateOperation_OverwritePayload::set_allocated_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.OverwritePayload.key)
}

// -------------------------------------------------------------------

// PointsUpdateOperation_DeletePayload

// repeated string keys = 1;
inline int PointsUpdateOperation_DeletePayload::_internal_keys_size() const {
  return _internal_keys().size();
}
inline int PointsUpdateOperation_DeletePayload::keys_size() const {
  return _internal_keys_size();
}
inline void PointsUpdateOperation_DeletePayload::clear_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.keys_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL PointsUpdateOperation_DeletePayload::add_keys()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_keys()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:qdrant.PointsUpdateOperation.DeletePayload.keys)
  return _s;
}
inline const ::std::string& PointsUpdateOperation_DeletePayload::keys(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.DeletePayload.keys)
  return _internal_keys().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL PointsUpdateOperation_DeletePayload::mutable_keys(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.DeletePayload.keys)
  return _internal_mutable_keys()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void PointsUpdateOperation_DeletePayload::set_keys(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_keys()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:qdrant.PointsUpdateOperation.DeletePayload.keys)
}
template <typename Arg_, typename... Args_>
inline void PointsUpdateOperation_DeletePayload::add_keys(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_keys(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.PointsUpdateOperation.DeletePayload.keys)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& PointsUpdateOperation_DeletePayload::keys()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.PointsUpdateOperation.DeletePayload.keys)
  return _internal_keys();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
PointsUpdateOperation_DeletePayload::mutable_keys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.PointsUpdateOperation.DeletePayload.keys)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_keys();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
PointsUpdateOperation_DeletePayload::_internal_keys() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.keys_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
PointsUpdateOperation_DeletePayload::_internal_mutable_keys() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.keys_;
}

// optional .qdrant.PointsSelector points_selector = 2;
inline bool PointsUpdateOperation_DeletePayload::has_points_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.points_selector_ != nullptr);
  return value;
}
inline void PointsUpdateOperation_DeletePayload::clear_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_selector_ != nullptr) _impl_.points_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::PointsSelector& PointsUpdateOperation_DeletePayload::_internal_points_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointsSelector* p = _impl_.points_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointsSelector&>(::qdrant::_PointsSelector_default_instance_);
}
inline const ::qdrant::PointsSelector& PointsUpdateOperation_DeletePayload::points_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.DeletePayload.points_selector)
  return _internal_points_selector();
}
inline void PointsUpdateOperation_DeletePayload::unsafe_arena_set_allocated_points_selector(
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_selector_);
  }
  _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.DeletePayload.points_selector)
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE PointsUpdateOperation_DeletePayload::release_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* released = _impl_.points_selector_;
  _impl_.points_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE PointsUpdateOperation_DeletePayload::unsafe_arena_release_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.DeletePayload.points_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* temp = _impl_.points_selector_;
  _impl_.points_selector_ = nullptr;
  return temp;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL PointsUpdateOperation_DeletePayload::_internal_mutable_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsSelector>(GetArena());
    _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(p);
  }
  return _impl_.points_selector_;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL PointsUpdateOperation_DeletePayload::mutable_points_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointsSelector* _msg = _internal_mutable_points_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.DeletePayload.points_selector)
  return _msg;
}
inline void PointsUpdateOperation_DeletePayload::set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.DeletePayload.points_selector)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 3;
inline bool PointsUpdateOperation_DeletePayload::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void PointsUpdateOperation_DeletePayload::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::ShardKeySelector& PointsUpdateOperation_DeletePayload::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& PointsUpdateOperation_DeletePayload::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.DeletePayload.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void PointsUpdateOperation_DeletePayload::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.DeletePayload.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE PointsUpdateOperation_DeletePayload::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE PointsUpdateOperation_DeletePayload::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.DeletePayload.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL PointsUpdateOperation_DeletePayload::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL PointsUpdateOperation_DeletePayload::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.DeletePayload.shard_key_selector)
  return _msg;
}
inline void PointsUpdateOperation_DeletePayload::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.DeletePayload.shard_key_selector)
}

// -------------------------------------------------------------------

// PointsUpdateOperation_UpdateVectors

// repeated .qdrant.PointVectors points = 1;
inline int PointsUpdateOperation_UpdateVectors::_internal_points_size() const {
  return _internal_points().size();
}
inline int PointsUpdateOperation_UpdateVectors::points_size() const {
  return _internal_points_size();
}
inline void PointsUpdateOperation_UpdateVectors::clear_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.points_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::PointVectors* PROTOBUF_NONNULL PointsUpdateOperation_UpdateVectors::mutable_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.UpdateVectors.points)
  return _internal_mutable_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointVectors>* PROTOBUF_NONNULL PointsUpdateOperation_UpdateVectors::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.PointsUpdateOperation.UpdateVectors.points)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_points();
}
inline const ::qdrant::PointVectors& PointsUpdateOperation_UpdateVectors::points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.UpdateVectors.points)
  return _internal_points().Get(index);
}
inline ::qdrant::PointVectors* PROTOBUF_NONNULL PointsUpdateOperation_UpdateVectors::add_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::PointVectors* _add =
      _internal_mutable_points()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.PointsUpdateOperation.UpdateVectors.points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointVectors>& PointsUpdateOperation_UpdateVectors::points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.PointsUpdateOperation.UpdateVectors.points)
  return _internal_points();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointVectors>&
PointsUpdateOperation_UpdateVectors::_internal_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.points_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointVectors>* PROTOBUF_NONNULL
PointsUpdateOperation_UpdateVectors::_internal_mutable_points() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.points_;
}

// optional .qdrant.ShardKeySelector shard_key_selector = 2;
inline bool PointsUpdateOperation_UpdateVectors::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void PointsUpdateOperation_UpdateVectors::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::ShardKeySelector& PointsUpdateOperation_UpdateVectors::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& PointsUpdateOperation_UpdateVectors::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.UpdateVectors.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void PointsUpdateOperation_UpdateVectors::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.UpdateVectors.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE PointsUpdateOperation_UpdateVectors::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE PointsUpdateOperation_UpdateVectors::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.UpdateVectors.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL PointsUpdateOperation_UpdateVectors::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL PointsUpdateOperation_UpdateVectors::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.UpdateVectors.shard_key_selector)
  return _msg;
}
inline void PointsUpdateOperation_UpdateVectors::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.UpdateVectors.shard_key_selector)
}

// optional .qdrant.Filter update_filter = 3;
inline bool PointsUpdateOperation_UpdateVectors::has_update_filter() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.update_filter_ != nullptr);
  return value;
}
inline void PointsUpdateOperation_UpdateVectors::clear_update_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.update_filter_ != nullptr) _impl_.update_filter_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::Filter& PointsUpdateOperation_UpdateVectors::_internal_update_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Filter* p = _impl_.update_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& PointsUpdateOperation_UpdateVectors::update_filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.UpdateVectors.update_filter)
  return _internal_update_filter();
}
inline void PointsUpdateOperation_UpdateVectors::unsafe_arena_set_allocated_update_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_filter_);
  }
  _impl_.update_filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.UpdateVectors.update_filter)
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE PointsUpdateOperation_UpdateVectors::release_update_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Filter* released = _impl_.update_filter_;
  _impl_.update_filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE PointsUpdateOperation_UpdateVectors::unsafe_arena_release_update_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.UpdateVectors.update_filter)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Filter* temp = _impl_.update_filter_;
  _impl_.update_filter_ = nullptr;
  return temp;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL PointsUpdateOperation_UpdateVectors::_internal_mutable_update_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.update_filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
    _impl_.update_filter_ = reinterpret_cast<::qdrant::Filter*>(p);
  }
  return _impl_.update_filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL PointsUpdateOperation_UpdateVectors::mutable_update_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Filter* _msg = _internal_mutable_update_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.UpdateVectors.update_filter)
  return _msg;
}
inline void PointsUpdateOperation_UpdateVectors::set_allocated_update_filter(::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.update_filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.UpdateVectors.update_filter)
}

// -------------------------------------------------------------------

// PointsUpdateOperation_DeleteVectors

// .qdrant.PointsSelector points_selector = 1;
inline bool PointsUpdateOperation_DeleteVectors::has_points_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.points_selector_ != nullptr);
  return value;
}
inline void PointsUpdateOperation_DeleteVectors::clear_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_selector_ != nullptr) _impl_.points_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::PointsSelector& PointsUpdateOperation_DeleteVectors::_internal_points_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointsSelector* p = _impl_.points_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointsSelector&>(::qdrant::_PointsSelector_default_instance_);
}
inline const ::qdrant::PointsSelector& PointsUpdateOperation_DeleteVectors::points_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.DeleteVectors.points_selector)
  return _internal_points_selector();
}
inline void PointsUpdateOperation_DeleteVectors::unsafe_arena_set_allocated_points_selector(
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_selector_);
  }
  _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.DeleteVectors.points_selector)
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE PointsUpdateOperation_DeleteVectors::release_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointsSelector* released = _impl_.points_selector_;
  _impl_.points_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE PointsUpdateOperation_DeleteVectors::unsafe_arena_release_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.DeleteVectors.points_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointsSelector* temp = _impl_.points_selector_;
  _impl_.points_selector_ = nullptr;
  return temp;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL PointsUpdateOperation_DeleteVectors::_internal_mutable_points_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsSelector>(GetArena());
    _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(p);
  }
  return _impl_.points_selector_;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL PointsUpdateOperation_DeleteVectors::mutable_points_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointsSelector* _msg = _internal_mutable_points_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.DeleteVectors.points_selector)
  return _msg;
}
inline void PointsUpdateOperation_DeleteVectors::set_allocated_points_selector(::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.points_selector_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.DeleteVectors.points_selector)
}

// .qdrant.VectorsSelector vectors = 2;
inline bool PointsUpdateOperation_DeleteVectors::has_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.vectors_ != nullptr);
  return value;
}
inline void PointsUpdateOperation_DeleteVectors::clear_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_ != nullptr) _impl_.vectors_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::VectorsSelector& PointsUpdateOperation_DeleteVectors::_internal_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::VectorsSelector* p = _impl_.vectors_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::VectorsSelector&>(::qdrant::_VectorsSelector_default_instance_);
}
inline const ::qdrant::VectorsSelector& PointsUpdateOperation_DeleteVectors::vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.DeleteVectors.vectors)
  return _internal_vectors();
}
inline void PointsUpdateOperation_DeleteVectors::unsafe_arena_set_allocated_vectors(
    ::qdrant::VectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_);
  }
  _impl_.vectors_ = reinterpret_cast<::qdrant::VectorsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.DeleteVectors.vectors)
}
inline ::qdrant::VectorsSelector* PROTOBUF_NULLABLE PointsUpdateOperation_DeleteVectors::release_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::VectorsSelector* released = _impl_.vectors_;
  _impl_.vectors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::VectorsSelector* PROTOBUF_NULLABLE PointsUpdateOperation_DeleteVectors::unsafe_arena_release_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.DeleteVectors.vectors)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::VectorsSelector* temp = _impl_.vectors_;
  _impl_.vectors_ = nullptr;
  return temp;
}
inline ::qdrant::VectorsSelector* PROTOBUF_NONNULL PointsUpdateOperation_DeleteVectors::_internal_mutable_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorsSelector>(GetArena());
    _impl_.vectors_ = reinterpret_cast<::qdrant::VectorsSelector*>(p);
  }
  return _impl_.vectors_;
}
inline ::qdrant::VectorsSelector* PROTOBUF_NONNULL PointsUpdateOperation_DeleteVectors::mutable_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::VectorsSelector* _msg = _internal_mutable_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.DeleteVectors.vectors)
  return _msg;
}
inline void PointsUpdateOperation_DeleteVectors::set_allocated_vectors(::qdrant::VectorsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.vectors_ = reinterpret_cast<::qdrant::VectorsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.DeleteVectors.vectors)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 3;
inline bool PointsUpdateOperation_DeleteVectors::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void PointsUpdateOperation_DeleteVectors::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::ShardKeySelector& PointsUpdateOperation_DeleteVectors::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& PointsUpdateOperation_DeleteVectors::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.DeleteVectors.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void PointsUpdateOperation_DeleteVectors::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.DeleteVectors.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE PointsUpdateOperation_DeleteVectors::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE PointsUpdateOperation_DeleteVectors::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.DeleteVectors.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL PointsUpdateOperation_DeleteVectors::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL PointsUpdateOperation_DeleteVectors::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.DeleteVectors.shard_key_selector)
  return _msg;
}
inline void PointsUpdateOperation_DeleteVectors::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.DeleteVectors.shard_key_selector)
}

// -------------------------------------------------------------------

// PointsUpdateOperation_DeletePoints

// .qdrant.PointsSelector points = 1;
inline bool PointsUpdateOperation_DeletePoints::has_points() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.points_ != nullptr);
  return value;
}
inline void PointsUpdateOperation_DeletePoints::clear_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_ != nullptr) _impl_.points_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::PointsSelector& PointsUpdateOperation_DeletePoints::_internal_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointsSelector* p = _impl_.points_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointsSelector&>(::qdrant::_PointsSelector_default_instance_);
}
inline const ::qdrant::PointsSelector& PointsUpdateOperation_DeletePoints::points() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.DeletePoints.points)
  return _internal_points();
}
inline void PointsUpdateOperation_DeletePoints::unsafe_arena_set_allocated_points(
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_);
  }
  _impl_.points_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.DeletePoints.points)
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE PointsUpdateOperation_DeletePoints::release_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointsSelector* released = _impl_.points_;
  _impl_.points_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE PointsUpdateOperation_DeletePoints::unsafe_arena_release_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.DeletePoints.points)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointsSelector* temp = _impl_.points_;
  _impl_.points_ = nullptr;
  return temp;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL PointsUpdateOperation_DeletePoints::_internal_mutable_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsSelector>(GetArena());
    _impl_.points_ = reinterpret_cast<::qdrant::PointsSelector*>(p);
  }
  return _impl_.points_;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL PointsUpdateOperation_DeletePoints::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointsSelector* _msg = _internal_mutable_points();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.DeletePoints.points)
  return _msg;
}
inline void PointsUpdateOperation_DeletePoints::set_allocated_points(::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.points_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.DeletePoints.points)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 2;
inline bool PointsUpdateOperation_DeletePoints::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void PointsUpdateOperation_DeletePoints::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::ShardKeySelector& PointsUpdateOperation_DeletePoints::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& PointsUpdateOperation_DeletePoints::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.DeletePoints.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void PointsUpdateOperation_DeletePoints::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.DeletePoints.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE PointsUpdateOperation_DeletePoints::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE PointsUpdateOperation_DeletePoints::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.DeletePoints.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL PointsUpdateOperation_DeletePoints::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL PointsUpdateOperation_DeletePoints::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.DeletePoints.shard_key_selector)
  return _msg;
}
inline void PointsUpdateOperation_DeletePoints::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.DeletePoints.shard_key_selector)
}

// -------------------------------------------------------------------

// PointsUpdateOperation_ClearPayload

// .qdrant.PointsSelector points = 1;
inline bool PointsUpdateOperation_ClearPayload::has_points() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.points_ != nullptr);
  return value;
}
inline void PointsUpdateOperation_ClearPayload::clear_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_ != nullptr) _impl_.points_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::PointsSelector& PointsUpdateOperation_ClearPayload::_internal_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointsSelector* p = _impl_.points_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointsSelector&>(::qdrant::_PointsSelector_default_instance_);
}
inline const ::qdrant::PointsSelector& PointsUpdateOperation_ClearPayload::points() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.ClearPayload.points)
  return _internal_points();
}
inline void PointsUpdateOperation_ClearPayload::unsafe_arena_set_allocated_points(
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_);
  }
  _impl_.points_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.ClearPayload.points)
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE PointsUpdateOperation_ClearPayload::release_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointsSelector* released = _impl_.points_;
  _impl_.points_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE PointsUpdateOperation_ClearPayload::unsafe_arena_release_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.ClearPayload.points)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointsSelector* temp = _impl_.points_;
  _impl_.points_ = nullptr;
  return temp;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL PointsUpdateOperation_ClearPayload::_internal_mutable_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.points_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsSelector>(GetArena());
    _impl_.points_ = reinterpret_cast<::qdrant::PointsSelector*>(p);
  }
  return _impl_.points_;
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL PointsUpdateOperation_ClearPayload::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointsSelector* _msg = _internal_mutable_points();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.ClearPayload.points)
  return _msg;
}
inline void PointsUpdateOperation_ClearPayload::set_allocated_points(::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.points_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.points_ = reinterpret_cast<::qdrant::PointsSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.ClearPayload.points)
}

// optional .qdrant.ShardKeySelector shard_key_selector = 2;
inline bool PointsUpdateOperation_ClearPayload::has_shard_key_selector() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_selector_ != nullptr);
  return value;
}
inline void PointsUpdateOperation_ClearPayload::clear_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ != nullptr) _impl_.shard_key_selector_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::ShardKeySelector& PointsUpdateOperation_ClearPayload::_internal_shard_key_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKeySelector* p = _impl_.shard_key_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKeySelector&>(::qdrant::_ShardKeySelector_default_instance_);
}
inline const ::qdrant::ShardKeySelector& PointsUpdateOperation_ClearPayload::shard_key_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.ClearPayload.shard_key_selector)
  return _internal_shard_key_selector();
}
inline void PointsUpdateOperation_ClearPayload::unsafe_arena_set_allocated_shard_key_selector(
    ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }
  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.ClearPayload.shard_key_selector)
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE PointsUpdateOperation_ClearPayload::release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ShardKeySelector* released = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NULLABLE PointsUpdateOperation_ClearPayload::unsafe_arena_release_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.ClearPayload.shard_key_selector)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ShardKeySelector* temp = _impl_.shard_key_selector_;
  _impl_.shard_key_selector_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL PointsUpdateOperation_ClearPayload::_internal_mutable_shard_key_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKeySelector>(GetArena());
    _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(p);
  }
  return _impl_.shard_key_selector_;
}
inline ::qdrant::ShardKeySelector* PROTOBUF_NONNULL PointsUpdateOperation_ClearPayload::mutable_shard_key_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ShardKeySelector* _msg = _internal_mutable_shard_key_selector();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.ClearPayload.shard_key_selector)
  return _msg;
}
inline void PointsUpdateOperation_ClearPayload::set_allocated_shard_key_selector(::qdrant::ShardKeySelector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.shard_key_selector_ = reinterpret_cast<::qdrant::ShardKeySelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsUpdateOperation.ClearPayload.shard_key_selector)
}

// -------------------------------------------------------------------

// PointsUpdateOperation

// .qdrant.PointsUpdateOperation.PointStructList upsert = 1;
inline bool PointsUpdateOperation::has_upsert() const {
  return operation_case() == kUpsert;
}
inline bool PointsUpdateOperation::_internal_has_upsert() const {
  return operation_case() == kUpsert;
}
inline void PointsUpdateOperation::set_has_upsert() {
  _impl_._oneof_case_[0] = kUpsert;
}
inline void PointsUpdateOperation::clear_upsert() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kUpsert) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.upsert_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.upsert_);
    }
    clear_has_operation();
  }
}
inline ::qdrant::PointsUpdateOperation_PointStructList* PROTOBUF_NULLABLE PointsUpdateOperation::release_upsert() {
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.upsert)
  if (operation_case() == kUpsert) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsUpdateOperation_PointStructList*>(_impl_.operation_.upsert_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.upsert_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::PointsUpdateOperation_PointStructList& PointsUpdateOperation::_internal_upsert() const {
  return operation_case() == kUpsert ? static_cast<const ::qdrant::PointsUpdateOperation_PointStructList&>(*reinterpret_cast<::qdrant::PointsUpdateOperation_PointStructList*>(_impl_.operation_.upsert_))
                     : reinterpret_cast<const ::qdrant::PointsUpdateOperation_PointStructList&>(::qdrant::_PointsUpdateOperation_PointStructList_default_instance_);
}
inline const ::qdrant::PointsUpdateOperation_PointStructList& PointsUpdateOperation::upsert() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.upsert)
  return _internal_upsert();
}
inline ::qdrant::PointsUpdateOperation_PointStructList* PROTOBUF_NULLABLE PointsUpdateOperation::unsafe_arena_release_upsert() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PointsUpdateOperation.upsert)
  if (operation_case() == kUpsert) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsUpdateOperation_PointStructList*>(_impl_.operation_.upsert_);
    _impl_.operation_.upsert_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PointsUpdateOperation::unsafe_arena_set_allocated_upsert(
    ::qdrant::PointsUpdateOperation_PointStructList* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_upsert();
    _impl_.operation_.upsert_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.upsert)
}
inline ::qdrant::PointsUpdateOperation_PointStructList* PROTOBUF_NONNULL PointsUpdateOperation::_internal_mutable_upsert() {
  if (operation_case() != kUpsert) {
    clear_operation();
    set_has_upsert();
    _impl_.operation_.upsert_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsUpdateOperation_PointStructList>(GetArena()));
  }
  return reinterpret_cast<::qdrant::PointsUpdateOperation_PointStructList*>(_impl_.operation_.upsert_);
}
inline ::qdrant::PointsUpdateOperation_PointStructList* PROTOBUF_NONNULL PointsUpdateOperation::mutable_upsert()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::PointsUpdateOperation_PointStructList* _msg = _internal_mutable_upsert();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.upsert)
  return _msg;
}

// .qdrant.PointsSelector delete_deprecated = 2 [deprecated = true];
inline bool PointsUpdateOperation::has_delete_deprecated() const {
  return operation_case() == kDeleteDeprecated;
}
inline bool PointsUpdateOperation::_internal_has_delete_deprecated() const {
  return operation_case() == kDeleteDeprecated;
}
inline void PointsUpdateOperation::set_has_delete_deprecated() {
  _impl_._oneof_case_[0] = kDeleteDeprecated;
}
inline void PointsUpdateOperation::clear_delete_deprecated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kDeleteDeprecated) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.delete_deprecated_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.delete_deprecated_);
    }
    clear_has_operation();
  }
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE PointsUpdateOperation::release_delete_deprecated() {
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.delete_deprecated)
  if (operation_case() == kDeleteDeprecated) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsSelector*>(_impl_.operation_.delete_deprecated_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.delete_deprecated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::PointsSelector& PointsUpdateOperation::_internal_delete_deprecated() const {
  return operation_case() == kDeleteDeprecated ? static_cast<const ::qdrant::PointsSelector&>(*reinterpret_cast<::qdrant::PointsSelector*>(_impl_.operation_.delete_deprecated_))
                     : reinterpret_cast<const ::qdrant::PointsSelector&>(::qdrant::_PointsSelector_default_instance_);
}
inline const ::qdrant::PointsSelector& PointsUpdateOperation::delete_deprecated() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.delete_deprecated)
  return _internal_delete_deprecated();
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE PointsUpdateOperation::unsafe_arena_release_delete_deprecated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PointsUpdateOperation.delete_deprecated)
  if (operation_case() == kDeleteDeprecated) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsSelector*>(_impl_.operation_.delete_deprecated_);
    _impl_.operation_.delete_deprecated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PointsUpdateOperation::unsafe_arena_set_allocated_delete_deprecated(
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_delete_deprecated();
    _impl_.operation_.delete_deprecated_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.delete_deprecated)
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL PointsUpdateOperation::_internal_mutable_delete_deprecated() {
  if (operation_case() != kDeleteDeprecated) {
    clear_operation();
    set_has_delete_deprecated();
    _impl_.operation_.delete_deprecated_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsSelector>(GetArena()));
  }
  return reinterpret_cast<::qdrant::PointsSelector*>(_impl_.operation_.delete_deprecated_);
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL PointsUpdateOperation::mutable_delete_deprecated()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::PointsSelector* _msg = _internal_mutable_delete_deprecated();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.delete_deprecated)
  return _msg;
}

// .qdrant.PointsUpdateOperation.SetPayload set_payload = 3;
inline bool PointsUpdateOperation::has_set_payload() const {
  return operation_case() == kSetPayload;
}
inline bool PointsUpdateOperation::_internal_has_set_payload() const {
  return operation_case() == kSetPayload;
}
inline void PointsUpdateOperation::set_has_set_payload() {
  _impl_._oneof_case_[0] = kSetPayload;
}
inline void PointsUpdateOperation::clear_set_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kSetPayload) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.set_payload_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.set_payload_);
    }
    clear_has_operation();
  }
}
inline ::qdrant::PointsUpdateOperation_SetPayload* PROTOBUF_NULLABLE PointsUpdateOperation::release_set_payload() {
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.set_payload)
  if (operation_case() == kSetPayload) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsUpdateOperation_SetPayload*>(_impl_.operation_.set_payload_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.set_payload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::PointsUpdateOperation_SetPayload& PointsUpdateOperation::_internal_set_payload() const {
  return operation_case() == kSetPayload ? static_cast<const ::qdrant::PointsUpdateOperation_SetPayload&>(*reinterpret_cast<::qdrant::PointsUpdateOperation_SetPayload*>(_impl_.operation_.set_payload_))
                     : reinterpret_cast<const ::qdrant::PointsUpdateOperation_SetPayload&>(::qdrant::_PointsUpdateOperation_SetPayload_default_instance_);
}
inline const ::qdrant::PointsUpdateOperation_SetPayload& PointsUpdateOperation::set_payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.set_payload)
  return _internal_set_payload();
}
inline ::qdrant::PointsUpdateOperation_SetPayload* PROTOBUF_NULLABLE PointsUpdateOperation::unsafe_arena_release_set_payload() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PointsUpdateOperation.set_payload)
  if (operation_case() == kSetPayload) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsUpdateOperation_SetPayload*>(_impl_.operation_.set_payload_);
    _impl_.operation_.set_payload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PointsUpdateOperation::unsafe_arena_set_allocated_set_payload(
    ::qdrant::PointsUpdateOperation_SetPayload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_set_payload();
    _impl_.operation_.set_payload_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.set_payload)
}
inline ::qdrant::PointsUpdateOperation_SetPayload* PROTOBUF_NONNULL PointsUpdateOperation::_internal_mutable_set_payload() {
  if (operation_case() != kSetPayload) {
    clear_operation();
    set_has_set_payload();
    _impl_.operation_.set_payload_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsUpdateOperation_SetPayload>(GetArena()));
  }
  return reinterpret_cast<::qdrant::PointsUpdateOperation_SetPayload*>(_impl_.operation_.set_payload_);
}
inline ::qdrant::PointsUpdateOperation_SetPayload* PROTOBUF_NONNULL PointsUpdateOperation::mutable_set_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::PointsUpdateOperation_SetPayload* _msg = _internal_mutable_set_payload();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.set_payload)
  return _msg;
}

// .qdrant.PointsUpdateOperation.OverwritePayload overwrite_payload = 4;
inline bool PointsUpdateOperation::has_overwrite_payload() const {
  return operation_case() == kOverwritePayload;
}
inline bool PointsUpdateOperation::_internal_has_overwrite_payload() const {
  return operation_case() == kOverwritePayload;
}
inline void PointsUpdateOperation::set_has_overwrite_payload() {
  _impl_._oneof_case_[0] = kOverwritePayload;
}
inline void PointsUpdateOperation::clear_overwrite_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kOverwritePayload) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.overwrite_payload_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.overwrite_payload_);
    }
    clear_has_operation();
  }
}
inline ::qdrant::PointsUpdateOperation_OverwritePayload* PROTOBUF_NULLABLE PointsUpdateOperation::release_overwrite_payload() {
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.overwrite_payload)
  if (operation_case() == kOverwritePayload) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsUpdateOperation_OverwritePayload*>(_impl_.operation_.overwrite_payload_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.overwrite_payload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::PointsUpdateOperation_OverwritePayload& PointsUpdateOperation::_internal_overwrite_payload() const {
  return operation_case() == kOverwritePayload ? static_cast<const ::qdrant::PointsUpdateOperation_OverwritePayload&>(*reinterpret_cast<::qdrant::PointsUpdateOperation_OverwritePayload*>(_impl_.operation_.overwrite_payload_))
                     : reinterpret_cast<const ::qdrant::PointsUpdateOperation_OverwritePayload&>(::qdrant::_PointsUpdateOperation_OverwritePayload_default_instance_);
}
inline const ::qdrant::PointsUpdateOperation_OverwritePayload& PointsUpdateOperation::overwrite_payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.overwrite_payload)
  return _internal_overwrite_payload();
}
inline ::qdrant::PointsUpdateOperation_OverwritePayload* PROTOBUF_NULLABLE PointsUpdateOperation::unsafe_arena_release_overwrite_payload() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PointsUpdateOperation.overwrite_payload)
  if (operation_case() == kOverwritePayload) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsUpdateOperation_OverwritePayload*>(_impl_.operation_.overwrite_payload_);
    _impl_.operation_.overwrite_payload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PointsUpdateOperation::unsafe_arena_set_allocated_overwrite_payload(
    ::qdrant::PointsUpdateOperation_OverwritePayload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_overwrite_payload();
    _impl_.operation_.overwrite_payload_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.overwrite_payload)
}
inline ::qdrant::PointsUpdateOperation_OverwritePayload* PROTOBUF_NONNULL PointsUpdateOperation::_internal_mutable_overwrite_payload() {
  if (operation_case() != kOverwritePayload) {
    clear_operation();
    set_has_overwrite_payload();
    _impl_.operation_.overwrite_payload_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsUpdateOperation_OverwritePayload>(GetArena()));
  }
  return reinterpret_cast<::qdrant::PointsUpdateOperation_OverwritePayload*>(_impl_.operation_.overwrite_payload_);
}
inline ::qdrant::PointsUpdateOperation_OverwritePayload* PROTOBUF_NONNULL PointsUpdateOperation::mutable_overwrite_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::PointsUpdateOperation_OverwritePayload* _msg = _internal_mutable_overwrite_payload();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.overwrite_payload)
  return _msg;
}

// .qdrant.PointsUpdateOperation.DeletePayload delete_payload = 5;
inline bool PointsUpdateOperation::has_delete_payload() const {
  return operation_case() == kDeletePayload;
}
inline bool PointsUpdateOperation::_internal_has_delete_payload() const {
  return operation_case() == kDeletePayload;
}
inline void PointsUpdateOperation::set_has_delete_payload() {
  _impl_._oneof_case_[0] = kDeletePayload;
}
inline void PointsUpdateOperation::clear_delete_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kDeletePayload) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.delete_payload_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.delete_payload_);
    }
    clear_has_operation();
  }
}
inline ::qdrant::PointsUpdateOperation_DeletePayload* PROTOBUF_NULLABLE PointsUpdateOperation::release_delete_payload() {
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.delete_payload)
  if (operation_case() == kDeletePayload) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsUpdateOperation_DeletePayload*>(_impl_.operation_.delete_payload_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.delete_payload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::PointsUpdateOperation_DeletePayload& PointsUpdateOperation::_internal_delete_payload() const {
  return operation_case() == kDeletePayload ? static_cast<const ::qdrant::PointsUpdateOperation_DeletePayload&>(*reinterpret_cast<::qdrant::PointsUpdateOperation_DeletePayload*>(_impl_.operation_.delete_payload_))
                     : reinterpret_cast<const ::qdrant::PointsUpdateOperation_DeletePayload&>(::qdrant::_PointsUpdateOperation_DeletePayload_default_instance_);
}
inline const ::qdrant::PointsUpdateOperation_DeletePayload& PointsUpdateOperation::delete_payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.delete_payload)
  return _internal_delete_payload();
}
inline ::qdrant::PointsUpdateOperation_DeletePayload* PROTOBUF_NULLABLE PointsUpdateOperation::unsafe_arena_release_delete_payload() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PointsUpdateOperation.delete_payload)
  if (operation_case() == kDeletePayload) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsUpdateOperation_DeletePayload*>(_impl_.operation_.delete_payload_);
    _impl_.operation_.delete_payload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PointsUpdateOperation::unsafe_arena_set_allocated_delete_payload(
    ::qdrant::PointsUpdateOperation_DeletePayload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_delete_payload();
    _impl_.operation_.delete_payload_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.delete_payload)
}
inline ::qdrant::PointsUpdateOperation_DeletePayload* PROTOBUF_NONNULL PointsUpdateOperation::_internal_mutable_delete_payload() {
  if (operation_case() != kDeletePayload) {
    clear_operation();
    set_has_delete_payload();
    _impl_.operation_.delete_payload_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsUpdateOperation_DeletePayload>(GetArena()));
  }
  return reinterpret_cast<::qdrant::PointsUpdateOperation_DeletePayload*>(_impl_.operation_.delete_payload_);
}
inline ::qdrant::PointsUpdateOperation_DeletePayload* PROTOBUF_NONNULL PointsUpdateOperation::mutable_delete_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::PointsUpdateOperation_DeletePayload* _msg = _internal_mutable_delete_payload();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.delete_payload)
  return _msg;
}

// .qdrant.PointsSelector clear_payload_deprecated = 6 [deprecated = true];
inline bool PointsUpdateOperation::has_clear_payload_deprecated() const {
  return operation_case() == kClearPayloadDeprecated;
}
inline bool PointsUpdateOperation::_internal_has_clear_payload_deprecated() const {
  return operation_case() == kClearPayloadDeprecated;
}
inline void PointsUpdateOperation::set_has_clear_payload_deprecated() {
  _impl_._oneof_case_[0] = kClearPayloadDeprecated;
}
inline void PointsUpdateOperation::clear_clear_payload_deprecated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kClearPayloadDeprecated) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.clear_payload_deprecated_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.clear_payload_deprecated_);
    }
    clear_has_operation();
  }
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE PointsUpdateOperation::release_clear_payload_deprecated() {
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.clear_payload_deprecated)
  if (operation_case() == kClearPayloadDeprecated) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsSelector*>(_impl_.operation_.clear_payload_deprecated_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.clear_payload_deprecated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::PointsSelector& PointsUpdateOperation::_internal_clear_payload_deprecated() const {
  return operation_case() == kClearPayloadDeprecated ? static_cast<const ::qdrant::PointsSelector&>(*reinterpret_cast<::qdrant::PointsSelector*>(_impl_.operation_.clear_payload_deprecated_))
                     : reinterpret_cast<const ::qdrant::PointsSelector&>(::qdrant::_PointsSelector_default_instance_);
}
inline const ::qdrant::PointsSelector& PointsUpdateOperation::clear_payload_deprecated() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.clear_payload_deprecated)
  return _internal_clear_payload_deprecated();
}
inline ::qdrant::PointsSelector* PROTOBUF_NULLABLE PointsUpdateOperation::unsafe_arena_release_clear_payload_deprecated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PointsUpdateOperation.clear_payload_deprecated)
  if (operation_case() == kClearPayloadDeprecated) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsSelector*>(_impl_.operation_.clear_payload_deprecated_);
    _impl_.operation_.clear_payload_deprecated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PointsUpdateOperation::unsafe_arena_set_allocated_clear_payload_deprecated(
    ::qdrant::PointsSelector* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_clear_payload_deprecated();
    _impl_.operation_.clear_payload_deprecated_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.clear_payload_deprecated)
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL PointsUpdateOperation::_internal_mutable_clear_payload_deprecated() {
  if (operation_case() != kClearPayloadDeprecated) {
    clear_operation();
    set_has_clear_payload_deprecated();
    _impl_.operation_.clear_payload_deprecated_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsSelector>(GetArena()));
  }
  return reinterpret_cast<::qdrant::PointsSelector*>(_impl_.operation_.clear_payload_deprecated_);
}
inline ::qdrant::PointsSelector* PROTOBUF_NONNULL PointsUpdateOperation::mutable_clear_payload_deprecated()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::PointsSelector* _msg = _internal_mutable_clear_payload_deprecated();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.clear_payload_deprecated)
  return _msg;
}

// .qdrant.PointsUpdateOperation.UpdateVectors update_vectors = 7;
inline bool PointsUpdateOperation::has_update_vectors() const {
  return operation_case() == kUpdateVectors;
}
inline bool PointsUpdateOperation::_internal_has_update_vectors() const {
  return operation_case() == kUpdateVectors;
}
inline void PointsUpdateOperation::set_has_update_vectors() {
  _impl_._oneof_case_[0] = kUpdateVectors;
}
inline void PointsUpdateOperation::clear_update_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kUpdateVectors) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.update_vectors_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.update_vectors_);
    }
    clear_has_operation();
  }
}
inline ::qdrant::PointsUpdateOperation_UpdateVectors* PROTOBUF_NULLABLE PointsUpdateOperation::release_update_vectors() {
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.update_vectors)
  if (operation_case() == kUpdateVectors) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsUpdateOperation_UpdateVectors*>(_impl_.operation_.update_vectors_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.update_vectors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::PointsUpdateOperation_UpdateVectors& PointsUpdateOperation::_internal_update_vectors() const {
  return operation_case() == kUpdateVectors ? static_cast<const ::qdrant::PointsUpdateOperation_UpdateVectors&>(*reinterpret_cast<::qdrant::PointsUpdateOperation_UpdateVectors*>(_impl_.operation_.update_vectors_))
                     : reinterpret_cast<const ::qdrant::PointsUpdateOperation_UpdateVectors&>(::qdrant::_PointsUpdateOperation_UpdateVectors_default_instance_);
}
inline const ::qdrant::PointsUpdateOperation_UpdateVectors& PointsUpdateOperation::update_vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.update_vectors)
  return _internal_update_vectors();
}
inline ::qdrant::PointsUpdateOperation_UpdateVectors* PROTOBUF_NULLABLE PointsUpdateOperation::unsafe_arena_release_update_vectors() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PointsUpdateOperation.update_vectors)
  if (operation_case() == kUpdateVectors) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsUpdateOperation_UpdateVectors*>(_impl_.operation_.update_vectors_);
    _impl_.operation_.update_vectors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PointsUpdateOperation::unsafe_arena_set_allocated_update_vectors(
    ::qdrant::PointsUpdateOperation_UpdateVectors* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_update_vectors();
    _impl_.operation_.update_vectors_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.update_vectors)
}
inline ::qdrant::PointsUpdateOperation_UpdateVectors* PROTOBUF_NONNULL PointsUpdateOperation::_internal_mutable_update_vectors() {
  if (operation_case() != kUpdateVectors) {
    clear_operation();
    set_has_update_vectors();
    _impl_.operation_.update_vectors_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsUpdateOperation_UpdateVectors>(GetArena()));
  }
  return reinterpret_cast<::qdrant::PointsUpdateOperation_UpdateVectors*>(_impl_.operation_.update_vectors_);
}
inline ::qdrant::PointsUpdateOperation_UpdateVectors* PROTOBUF_NONNULL PointsUpdateOperation::mutable_update_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::PointsUpdateOperation_UpdateVectors* _msg = _internal_mutable_update_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.update_vectors)
  return _msg;
}

// .qdrant.PointsUpdateOperation.DeleteVectors delete_vectors = 8;
inline bool PointsUpdateOperation::has_delete_vectors() const {
  return operation_case() == kDeleteVectors;
}
inline bool PointsUpdateOperation::_internal_has_delete_vectors() const {
  return operation_case() == kDeleteVectors;
}
inline void PointsUpdateOperation::set_has_delete_vectors() {
  _impl_._oneof_case_[0] = kDeleteVectors;
}
inline void PointsUpdateOperation::clear_delete_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kDeleteVectors) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.delete_vectors_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.delete_vectors_);
    }
    clear_has_operation();
  }
}
inline ::qdrant::PointsUpdateOperation_DeleteVectors* PROTOBUF_NULLABLE PointsUpdateOperation::release_delete_vectors() {
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.delete_vectors)
  if (operation_case() == kDeleteVectors) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsUpdateOperation_DeleteVectors*>(_impl_.operation_.delete_vectors_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.delete_vectors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::PointsUpdateOperation_DeleteVectors& PointsUpdateOperation::_internal_delete_vectors() const {
  return operation_case() == kDeleteVectors ? static_cast<const ::qdrant::PointsUpdateOperation_DeleteVectors&>(*reinterpret_cast<::qdrant::PointsUpdateOperation_DeleteVectors*>(_impl_.operation_.delete_vectors_))
                     : reinterpret_cast<const ::qdrant::PointsUpdateOperation_DeleteVectors&>(::qdrant::_PointsUpdateOperation_DeleteVectors_default_instance_);
}
inline const ::qdrant::PointsUpdateOperation_DeleteVectors& PointsUpdateOperation::delete_vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.delete_vectors)
  return _internal_delete_vectors();
}
inline ::qdrant::PointsUpdateOperation_DeleteVectors* PROTOBUF_NULLABLE PointsUpdateOperation::unsafe_arena_release_delete_vectors() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PointsUpdateOperation.delete_vectors)
  if (operation_case() == kDeleteVectors) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsUpdateOperation_DeleteVectors*>(_impl_.operation_.delete_vectors_);
    _impl_.operation_.delete_vectors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PointsUpdateOperation::unsafe_arena_set_allocated_delete_vectors(
    ::qdrant::PointsUpdateOperation_DeleteVectors* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_delete_vectors();
    _impl_.operation_.delete_vectors_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.delete_vectors)
}
inline ::qdrant::PointsUpdateOperation_DeleteVectors* PROTOBUF_NONNULL PointsUpdateOperation::_internal_mutable_delete_vectors() {
  if (operation_case() != kDeleteVectors) {
    clear_operation();
    set_has_delete_vectors();
    _impl_.operation_.delete_vectors_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsUpdateOperation_DeleteVectors>(GetArena()));
  }
  return reinterpret_cast<::qdrant::PointsUpdateOperation_DeleteVectors*>(_impl_.operation_.delete_vectors_);
}
inline ::qdrant::PointsUpdateOperation_DeleteVectors* PROTOBUF_NONNULL PointsUpdateOperation::mutable_delete_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::PointsUpdateOperation_DeleteVectors* _msg = _internal_mutable_delete_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.delete_vectors)
  return _msg;
}

// .qdrant.PointsUpdateOperation.DeletePoints delete_points = 9;
inline bool PointsUpdateOperation::has_delete_points() const {
  return operation_case() == kDeletePoints;
}
inline bool PointsUpdateOperation::_internal_has_delete_points() const {
  return operation_case() == kDeletePoints;
}
inline void PointsUpdateOperation::set_has_delete_points() {
  _impl_._oneof_case_[0] = kDeletePoints;
}
inline void PointsUpdateOperation::clear_delete_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kDeletePoints) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.delete_points_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.delete_points_);
    }
    clear_has_operation();
  }
}
inline ::qdrant::PointsUpdateOperation_DeletePoints* PROTOBUF_NULLABLE PointsUpdateOperation::release_delete_points() {
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.delete_points)
  if (operation_case() == kDeletePoints) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsUpdateOperation_DeletePoints*>(_impl_.operation_.delete_points_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.delete_points_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::PointsUpdateOperation_DeletePoints& PointsUpdateOperation::_internal_delete_points() const {
  return operation_case() == kDeletePoints ? static_cast<const ::qdrant::PointsUpdateOperation_DeletePoints&>(*reinterpret_cast<::qdrant::PointsUpdateOperation_DeletePoints*>(_impl_.operation_.delete_points_))
                     : reinterpret_cast<const ::qdrant::PointsUpdateOperation_DeletePoints&>(::qdrant::_PointsUpdateOperation_DeletePoints_default_instance_);
}
inline const ::qdrant::PointsUpdateOperation_DeletePoints& PointsUpdateOperation::delete_points() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.delete_points)
  return _internal_delete_points();
}
inline ::qdrant::PointsUpdateOperation_DeletePoints* PROTOBUF_NULLABLE PointsUpdateOperation::unsafe_arena_release_delete_points() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PointsUpdateOperation.delete_points)
  if (operation_case() == kDeletePoints) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsUpdateOperation_DeletePoints*>(_impl_.operation_.delete_points_);
    _impl_.operation_.delete_points_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PointsUpdateOperation::unsafe_arena_set_allocated_delete_points(
    ::qdrant::PointsUpdateOperation_DeletePoints* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_delete_points();
    _impl_.operation_.delete_points_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.delete_points)
}
inline ::qdrant::PointsUpdateOperation_DeletePoints* PROTOBUF_NONNULL PointsUpdateOperation::_internal_mutable_delete_points() {
  if (operation_case() != kDeletePoints) {
    clear_operation();
    set_has_delete_points();
    _impl_.operation_.delete_points_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsUpdateOperation_DeletePoints>(GetArena()));
  }
  return reinterpret_cast<::qdrant::PointsUpdateOperation_DeletePoints*>(_impl_.operation_.delete_points_);
}
inline ::qdrant::PointsUpdateOperation_DeletePoints* PROTOBUF_NONNULL PointsUpdateOperation::mutable_delete_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::PointsUpdateOperation_DeletePoints* _msg = _internal_mutable_delete_points();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.delete_points)
  return _msg;
}

// .qdrant.PointsUpdateOperation.ClearPayload clear_payload = 10;
inline bool PointsUpdateOperation::has_clear_payload() const {
  return operation_case() == kClearPayload;
}
inline bool PointsUpdateOperation::_internal_has_clear_payload() const {
  return operation_case() == kClearPayload;
}
inline void PointsUpdateOperation::set_has_clear_payload() {
  _impl_._oneof_case_[0] = kClearPayload;
}
inline void PointsUpdateOperation::clear_clear_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kClearPayload) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.clear_payload_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.clear_payload_);
    }
    clear_has_operation();
  }
}
inline ::qdrant::PointsUpdateOperation_ClearPayload* PROTOBUF_NULLABLE PointsUpdateOperation::release_clear_payload() {
  // @@protoc_insertion_point(field_release:qdrant.PointsUpdateOperation.clear_payload)
  if (operation_case() == kClearPayload) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsUpdateOperation_ClearPayload*>(_impl_.operation_.clear_payload_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.clear_payload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::PointsUpdateOperation_ClearPayload& PointsUpdateOperation::_internal_clear_payload() const {
  return operation_case() == kClearPayload ? static_cast<const ::qdrant::PointsUpdateOperation_ClearPayload&>(*reinterpret_cast<::qdrant::PointsUpdateOperation_ClearPayload*>(_impl_.operation_.clear_payload_))
                     : reinterpret_cast<const ::qdrant::PointsUpdateOperation_ClearPayload&>(::qdrant::_PointsUpdateOperation_ClearPayload_default_instance_);
}
inline const ::qdrant::PointsUpdateOperation_ClearPayload& PointsUpdateOperation::clear_payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsUpdateOperation.clear_payload)
  return _internal_clear_payload();
}
inline ::qdrant::PointsUpdateOperation_ClearPayload* PROTOBUF_NULLABLE PointsUpdateOperation::unsafe_arena_release_clear_payload() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PointsUpdateOperation.clear_payload)
  if (operation_case() == kClearPayload) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::PointsUpdateOperation_ClearPayload*>(_impl_.operation_.clear_payload_);
    _impl_.operation_.clear_payload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PointsUpdateOperation::unsafe_arena_set_allocated_clear_payload(
    ::qdrant::PointsUpdateOperation_ClearPayload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_clear_payload();
    _impl_.operation_.clear_payload_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsUpdateOperation.clear_payload)
}
inline ::qdrant::PointsUpdateOperation_ClearPayload* PROTOBUF_NONNULL PointsUpdateOperation::_internal_mutable_clear_payload() {
  if (operation_case() != kClearPayload) {
    clear_operation();
    set_has_clear_payload();
    _impl_.operation_.clear_payload_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsUpdateOperation_ClearPayload>(GetArena()));
  }
  return reinterpret_cast<::qdrant::PointsUpdateOperation_ClearPayload*>(_impl_.operation_.clear_payload_);
}
inline ::qdrant::PointsUpdateOperation_ClearPayload* PROTOBUF_NONNULL PointsUpdateOperation::mutable_clear_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::PointsUpdateOperation_ClearPayload* _msg = _internal_mutable_clear_payload();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsUpdateOperation.clear_payload)
  return _msg;
}

inline bool PointsUpdateOperation::has_operation() const {
  return operation_case() != OPERATION_NOT_SET;
}
inline void PointsUpdateOperation::clear_has_operation() {
  _impl_._oneof_case_[0] = OPERATION_NOT_SET;
}
inline PointsUpdateOperation::OperationCase PointsUpdateOperation::operation_case() const {
  return PointsUpdateOperation::OperationCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateBatchPoints

// string collection_name = 1;
inline void UpdateBatchPoints::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& UpdateBatchPoints::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateBatchPoints.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateBatchPoints::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.UpdateBatchPoints.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL UpdateBatchPoints::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateBatchPoints.collection_name)
  return _s;
}
inline const ::std::string& UpdateBatchPoints::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void UpdateBatchPoints::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UpdateBatchPoints::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UpdateBatchPoints::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpdateBatchPoints.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void UpdateBatchPoints::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpdateBatchPoints.collection_name)
}

// optional bool wait = 2;
inline bool UpdateBatchPoints::has_wait() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void UpdateBatchPoints::clear_wait() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool UpdateBatchPoints::wait() const {
  // @@protoc_insertion_point(field_get:qdrant.UpdateBatchPoints.wait)
  return _internal_wait();
}
inline void UpdateBatchPoints::set_wait(bool value) {
  _internal_set_wait(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.UpdateBatchPoints.wait)
}
inline bool UpdateBatchPoints::_internal_wait() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wait_;
}
inline void UpdateBatchPoints::_internal_set_wait(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_ = value;
}

// repeated .qdrant.PointsUpdateOperation operations = 3;
inline int UpdateBatchPoints::_internal_operations_size() const {
  return _internal_operations().size();
}
inline int UpdateBatchPoints::operations_size() const {
  return _internal_operations_size();
}
inline void UpdateBatchPoints::clear_operations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operations_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::PointsUpdateOperation* PROTOBUF_NONNULL UpdateBatchPoints::mutable_operations(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateBatchPoints.operations)
  return _internal_mutable_operations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointsUpdateOperation>* PROTOBUF_NONNULL UpdateBatchPoints::mutable_operations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.UpdateBatchPoints.operations)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_operations();
}
inline const ::qdrant::PointsUpdateOperation& UpdateBatchPoints::operations(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateBatchPoints.operations)
  return _internal_operations().Get(index);
}
inline ::qdrant::PointsUpdateOperation* PROTOBUF_NONNULL UpdateBatchPoints::add_operations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::PointsUpdateOperation* _add =
      _internal_mutable_operations()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.UpdateBatchPoints.operations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointsUpdateOperation>& UpdateBatchPoints::operations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.UpdateBatchPoints.operations)
  return _internal_operations();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointsUpdateOperation>&
UpdateBatchPoints::_internal_operations() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operations_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointsUpdateOperation>* PROTOBUF_NONNULL
UpdateBatchPoints::_internal_mutable_operations() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.operations_;
}

// optional .qdrant.WriteOrdering ordering = 4;
inline bool UpdateBatchPoints::has_ordering() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.ordering_ != nullptr);
  return value;
}
inline void UpdateBatchPoints::clear_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ != nullptr) _impl_.ordering_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::WriteOrdering& UpdateBatchPoints::_internal_ordering() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WriteOrdering* p = _impl_.ordering_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WriteOrdering&>(::qdrant::_WriteOrdering_default_instance_);
}
inline const ::qdrant::WriteOrdering& UpdateBatchPoints::ordering() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateBatchPoints.ordering)
  return _internal_ordering();
}
inline void UpdateBatchPoints::unsafe_arena_set_allocated_ordering(
    ::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }
  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdateBatchPoints.ordering)
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE UpdateBatchPoints::release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* released = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NULLABLE UpdateBatchPoints::unsafe_arena_release_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpdateBatchPoints.ordering)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* temp = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  return temp;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL UpdateBatchPoints::_internal_mutable_ordering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ordering_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WriteOrdering>(GetArena());
    _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(p);
  }
  return _impl_.ordering_;
}
inline ::qdrant::WriteOrdering* PROTOBUF_NONNULL UpdateBatchPoints::mutable_ordering()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::WriteOrdering* _msg = _internal_mutable_ordering();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateBatchPoints.ordering)
  return _msg;
}
inline void UpdateBatchPoints::set_allocated_ordering(::qdrant::WriteOrdering* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ordering_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.ordering_ = reinterpret_cast<::qdrant::WriteOrdering*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpdateBatchPoints.ordering)
}

// -------------------------------------------------------------------

// PointsOperationResponse

// .qdrant.UpdateResult result = 1;
inline bool PointsOperationResponse::has_result() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void PointsOperationResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::UpdateResult& PointsOperationResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::UpdateResult* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::UpdateResult&>(::qdrant::_UpdateResult_default_instance_);
}
inline const ::qdrant::UpdateResult& PointsOperationResponse::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsOperationResponse.result)
  return _internal_result();
}
inline void PointsOperationResponse::unsafe_arena_set_allocated_result(
    ::qdrant::UpdateResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::qdrant::UpdateResult*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsOperationResponse.result)
}
inline ::qdrant::UpdateResult* PROTOBUF_NULLABLE PointsOperationResponse::release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::UpdateResult* released = _impl_.result_;
  _impl_.result_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::UpdateResult* PROTOBUF_NULLABLE PointsOperationResponse::unsafe_arena_release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsOperationResponse.result)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::UpdateResult* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::qdrant::UpdateResult* PROTOBUF_NONNULL PointsOperationResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::UpdateResult>(GetArena());
    _impl_.result_ = reinterpret_cast<::qdrant::UpdateResult*>(p);
  }
  return _impl_.result_;
}
inline ::qdrant::UpdateResult* PROTOBUF_NONNULL PointsOperationResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::UpdateResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsOperationResponse.result)
  return _msg;
}
inline void PointsOperationResponse::set_allocated_result(::qdrant::UpdateResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.result_ = reinterpret_cast<::qdrant::UpdateResult*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsOperationResponse.result)
}

// double time = 2;
inline void PointsOperationResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double PointsOperationResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.PointsOperationResponse.time)
  return _internal_time();
}
inline void PointsOperationResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.PointsOperationResponse.time)
}
inline double PointsOperationResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void PointsOperationResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool PointsOperationResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void PointsOperationResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& PointsOperationResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& PointsOperationResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsOperationResponse.usage)
  return _internal_usage();
}
inline void PointsOperationResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsOperationResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE PointsOperationResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE PointsOperationResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointsOperationResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL PointsOperationResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL PointsOperationResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsOperationResponse.usage)
  return _msg;
}
inline void PointsOperationResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointsOperationResponse.usage)
}

// -------------------------------------------------------------------

// UpdateResult

// optional uint64 operation_id = 1;
inline bool UpdateResult::has_operation_id() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void UpdateResult::clear_operation_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_id_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t UpdateResult::operation_id() const {
  // @@protoc_insertion_point(field_get:qdrant.UpdateResult.operation_id)
  return _internal_operation_id();
}
inline void UpdateResult::set_operation_id(::uint64_t value) {
  _internal_set_operation_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.UpdateResult.operation_id)
}
inline ::uint64_t UpdateResult::_internal_operation_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operation_id_;
}
inline void UpdateResult::_internal_set_operation_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_id_ = value;
}

// .qdrant.UpdateStatus status = 2;
inline void UpdateResult::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::qdrant::UpdateStatus UpdateResult::status() const {
  // @@protoc_insertion_point(field_get:qdrant.UpdateResult.status)
  return _internal_status();
}
inline void UpdateResult::set_status(::qdrant::UpdateStatus value) {
  _internal_set_status(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.UpdateResult.status)
}
inline ::qdrant::UpdateStatus UpdateResult::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::UpdateStatus>(_impl_.status_);
}
inline void UpdateResult::_internal_set_status(::qdrant::UpdateStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// OrderValue

// int64 int = 1;
inline bool OrderValue::has_int_() const {
  return variant_case() == kInt;
}
inline void OrderValue::set_has_int_() {
  _impl_._oneof_case_[0] = kInt;
}
inline void OrderValue::clear_int_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kInt) {
    _impl_.variant_.int__ = ::int64_t{0};
    clear_has_variant();
  }
}
inline ::int64_t OrderValue::int_() const {
  // @@protoc_insertion_point(field_get:qdrant.OrderValue.int)
  return _internal_int_();
}
inline void OrderValue::set_int_(::int64_t value) {
  if (variant_case() != kInt) {
    clear_variant();
    set_has_int_();
  }
  _impl_.variant_.int__ = value;
  // @@protoc_insertion_point(field_set:qdrant.OrderValue.int)
}
inline ::int64_t OrderValue::_internal_int_() const {
  if (variant_case() == kInt) {
    return _impl_.variant_.int__;
  }
  return ::int64_t{0};
}

// double float = 2;
inline bool OrderValue::has_float_() const {
  return variant_case() == kFloat;
}
inline void OrderValue::set_has_float_() {
  _impl_._oneof_case_[0] = kFloat;
}
inline void OrderValue::clear_float_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kFloat) {
    _impl_.variant_.float__ = 0;
    clear_has_variant();
  }
}
inline double OrderValue::float_() const {
  // @@protoc_insertion_point(field_get:qdrant.OrderValue.float)
  return _internal_float_();
}
inline void OrderValue::set_float_(double value) {
  if (variant_case() != kFloat) {
    clear_variant();
    set_has_float_();
  }
  _impl_.variant_.float__ = value;
  // @@protoc_insertion_point(field_set:qdrant.OrderValue.float)
}
inline double OrderValue::_internal_float_() const {
  if (variant_case() == kFloat) {
    return _impl_.variant_.float__;
  }
  return 0;
}

inline bool OrderValue::has_variant() const {
  return variant_case() != VARIANT_NOT_SET;
}
inline void OrderValue::clear_has_variant() {
  _impl_._oneof_case_[0] = VARIANT_NOT_SET;
}
inline OrderValue::VariantCase OrderValue::variant_case() const {
  return OrderValue::VariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ScoredPoint

// .qdrant.PointId id = 1;
inline bool ScoredPoint::has_id() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline void ScoredPoint::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::PointId& ScoredPoint::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointId&>(::qdrant::_PointId_default_instance_);
}
inline const ::qdrant::PointId& ScoredPoint::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ScoredPoint.id)
  return _internal_id();
}
inline void ScoredPoint::unsafe_arena_set_allocated_id(
    ::qdrant::PointId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::qdrant::PointId*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ScoredPoint.id)
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE ScoredPoint::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointId* released = _impl_.id_;
  _impl_.id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE ScoredPoint::unsafe_arena_release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ScoredPoint.id)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::qdrant::PointId* PROTOBUF_NONNULL ScoredPoint::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointId>(GetArena());
    _impl_.id_ = reinterpret_cast<::qdrant::PointId*>(p);
  }
  return _impl_.id_;
}
inline ::qdrant::PointId* PROTOBUF_NONNULL ScoredPoint::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:qdrant.ScoredPoint.id)
  return _msg;
}
inline void ScoredPoint::set_allocated_id(::qdrant::PointId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.id_ = reinterpret_cast<::qdrant::PointId*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ScoredPoint.id)
}

// map<string, .qdrant.Value> payload = 2;
inline int ScoredPoint::_internal_payload_size() const {
  return _internal_payload().size();
}
inline int ScoredPoint::payload_size() const {
  return _internal_payload_size();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& ScoredPoint::_internal_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& ScoredPoint::payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.ScoredPoint.payload)
  return _internal_payload();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL ScoredPoint::_internal_mutable_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.payload_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL ScoredPoint::mutable_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.ScoredPoint.payload)
  return _internal_mutable_payload();
}

// float score = 3;
inline void ScoredPoint::clear_score() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline float ScoredPoint::score() const {
  // @@protoc_insertion_point(field_get:qdrant.ScoredPoint.score)
  return _internal_score();
}
inline void ScoredPoint::set_score(float value) {
  _internal_set_score(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.ScoredPoint.score)
}
inline float ScoredPoint::_internal_score() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.score_;
}
inline void ScoredPoint::_internal_set_score(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_ = value;
}

// uint64 version = 5;
inline void ScoredPoint::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::uint64_t ScoredPoint::version() const {
  // @@protoc_insertion_point(field_get:qdrant.ScoredPoint.version)
  return _internal_version();
}
inline void ScoredPoint::set_version(::uint64_t value) {
  _internal_set_version(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.ScoredPoint.version)
}
inline ::uint64_t ScoredPoint::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_;
}
inline void ScoredPoint::_internal_set_version(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = value;
}

// optional .qdrant.VectorsOutput vectors = 6;
inline bool ScoredPoint::has_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.vectors_ != nullptr);
  return value;
}
inline void ScoredPoint::clear_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_ != nullptr) _impl_.vectors_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::VectorsOutput& ScoredPoint::_internal_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::VectorsOutput* p = _impl_.vectors_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::VectorsOutput&>(::qdrant::_VectorsOutput_default_instance_);
}
inline const ::qdrant::VectorsOutput& ScoredPoint::vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ScoredPoint.vectors)
  return _internal_vectors();
}
inline void ScoredPoint::unsafe_arena_set_allocated_vectors(
    ::qdrant::VectorsOutput* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_);
  }
  _impl_.vectors_ = reinterpret_cast<::qdrant::VectorsOutput*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ScoredPoint.vectors)
}
inline ::qdrant::VectorsOutput* PROTOBUF_NULLABLE ScoredPoint::release_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::VectorsOutput* released = _impl_.vectors_;
  _impl_.vectors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::VectorsOutput* PROTOBUF_NULLABLE ScoredPoint::unsafe_arena_release_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ScoredPoint.vectors)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::VectorsOutput* temp = _impl_.vectors_;
  _impl_.vectors_ = nullptr;
  return temp;
}
inline ::qdrant::VectorsOutput* PROTOBUF_NONNULL ScoredPoint::_internal_mutable_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorsOutput>(GetArena());
    _impl_.vectors_ = reinterpret_cast<::qdrant::VectorsOutput*>(p);
  }
  return _impl_.vectors_;
}
inline ::qdrant::VectorsOutput* PROTOBUF_NONNULL ScoredPoint::mutable_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::VectorsOutput* _msg = _internal_mutable_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.ScoredPoint.vectors)
  return _msg;
}
inline void ScoredPoint::set_allocated_vectors(::qdrant::VectorsOutput* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.vectors_ = reinterpret_cast<::qdrant::VectorsOutput*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ScoredPoint.vectors)
}

// optional .qdrant.ShardKey shard_key = 7;
inline bool ScoredPoint::has_shard_key() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_ != nullptr);
  return value;
}
inline const ::qdrant::ShardKey& ScoredPoint::_internal_shard_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKey* p = _impl_.shard_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKey&>(::qdrant::_ShardKey_default_instance_);
}
inline const ::qdrant::ShardKey& ScoredPoint::shard_key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ScoredPoint.shard_key)
  return _internal_shard_key();
}
inline void ScoredPoint::unsafe_arena_set_allocated_shard_key(
    ::qdrant::ShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_);
  }
  _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ScoredPoint.shard_key)
}
inline ::qdrant::ShardKey* PROTOBUF_NULLABLE ScoredPoint::release_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKey* released = _impl_.shard_key_;
  _impl_.shard_key_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKey* PROTOBUF_NULLABLE ScoredPoint::unsafe_arena_release_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ScoredPoint.shard_key)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKey* temp = _impl_.shard_key_;
  _impl_.shard_key_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKey* PROTOBUF_NONNULL ScoredPoint::_internal_mutable_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKey>(GetArena());
    _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(p);
  }
  return _impl_.shard_key_;
}
inline ::qdrant::ShardKey* PROTOBUF_NONNULL ScoredPoint::mutable_shard_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKey* _msg = _internal_mutable_shard_key();
  // @@protoc_insertion_point(field_mutable:qdrant.ScoredPoint.shard_key)
  return _msg;
}
inline void ScoredPoint::set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ScoredPoint.shard_key)
}

// optional .qdrant.OrderValue order_value = 8;
inline bool ScoredPoint::has_order_value() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.order_value_ != nullptr);
  return value;
}
inline void ScoredPoint::clear_order_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.order_value_ != nullptr) _impl_.order_value_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::OrderValue& ScoredPoint::_internal_order_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::OrderValue* p = _impl_.order_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::OrderValue&>(::qdrant::_OrderValue_default_instance_);
}
inline const ::qdrant::OrderValue& ScoredPoint::order_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ScoredPoint.order_value)
  return _internal_order_value();
}
inline void ScoredPoint::unsafe_arena_set_allocated_order_value(
    ::qdrant::OrderValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.order_value_);
  }
  _impl_.order_value_ = reinterpret_cast<::qdrant::OrderValue*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ScoredPoint.order_value)
}
inline ::qdrant::OrderValue* PROTOBUF_NULLABLE ScoredPoint::release_order_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::OrderValue* released = _impl_.order_value_;
  _impl_.order_value_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::OrderValue* PROTOBUF_NULLABLE ScoredPoint::unsafe_arena_release_order_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ScoredPoint.order_value)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::OrderValue* temp = _impl_.order_value_;
  _impl_.order_value_ = nullptr;
  return temp;
}
inline ::qdrant::OrderValue* PROTOBUF_NONNULL ScoredPoint::_internal_mutable_order_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.order_value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::OrderValue>(GetArena());
    _impl_.order_value_ = reinterpret_cast<::qdrant::OrderValue*>(p);
  }
  return _impl_.order_value_;
}
inline ::qdrant::OrderValue* PROTOBUF_NONNULL ScoredPoint::mutable_order_value()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::OrderValue* _msg = _internal_mutable_order_value();
  // @@protoc_insertion_point(field_mutable:qdrant.ScoredPoint.order_value)
  return _msg;
}
inline void ScoredPoint::set_allocated_order_value(::qdrant::OrderValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.order_value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.order_value_ = reinterpret_cast<::qdrant::OrderValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ScoredPoint.order_value)
}

// -------------------------------------------------------------------

// GroupId

// uint64 unsigned_value = 1;
inline bool GroupId::has_unsigned_value() const {
  return kind_case() == kUnsignedValue;
}
inline void GroupId::set_has_unsigned_value() {
  _impl_._oneof_case_[0] = kUnsignedValue;
}
inline void GroupId::clear_unsigned_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kUnsignedValue) {
    _impl_.kind_.unsigned_value_ = ::uint64_t{0u};
    clear_has_kind();
  }
}
inline ::uint64_t GroupId::unsigned_value() const {
  // @@protoc_insertion_point(field_get:qdrant.GroupId.unsigned_value)
  return _internal_unsigned_value();
}
inline void GroupId::set_unsigned_value(::uint64_t value) {
  if (kind_case() != kUnsignedValue) {
    clear_kind();
    set_has_unsigned_value();
  }
  _impl_.kind_.unsigned_value_ = value;
  // @@protoc_insertion_point(field_set:qdrant.GroupId.unsigned_value)
}
inline ::uint64_t GroupId::_internal_unsigned_value() const {
  if (kind_case() == kUnsignedValue) {
    return _impl_.kind_.unsigned_value_;
  }
  return ::uint64_t{0u};
}

// int64 integer_value = 2;
inline bool GroupId::has_integer_value() const {
  return kind_case() == kIntegerValue;
}
inline void GroupId::set_has_integer_value() {
  _impl_._oneof_case_[0] = kIntegerValue;
}
inline void GroupId::clear_integer_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kIntegerValue) {
    _impl_.kind_.integer_value_ = ::int64_t{0};
    clear_has_kind();
  }
}
inline ::int64_t GroupId::integer_value() const {
  // @@protoc_insertion_point(field_get:qdrant.GroupId.integer_value)
  return _internal_integer_value();
}
inline void GroupId::set_integer_value(::int64_t value) {
  if (kind_case() != kIntegerValue) {
    clear_kind();
    set_has_integer_value();
  }
  _impl_.kind_.integer_value_ = value;
  // @@protoc_insertion_point(field_set:qdrant.GroupId.integer_value)
}
inline ::int64_t GroupId::_internal_integer_value() const {
  if (kind_case() == kIntegerValue) {
    return _impl_.kind_.integer_value_;
  }
  return ::int64_t{0};
}

// string string_value = 3;
inline bool GroupId::has_string_value() const {
  return kind_case() == kStringValue;
}
inline void GroupId::set_has_string_value() {
  _impl_._oneof_case_[0] = kStringValue;
}
inline void GroupId::clear_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kStringValue) {
    _impl_.kind_.string_value_.Destroy();
    clear_has_kind();
  }
}
inline const ::std::string& GroupId::string_value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GroupId.string_value)
  return _internal_string_value();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GroupId::set_string_value(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() != kStringValue) {
    clear_kind();

    set_has_string_value();
    _impl_.kind_.string_value_.InitDefault();
  }
  _impl_.kind_.string_value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.GroupId.string_value)
}
inline ::std::string* PROTOBUF_NONNULL GroupId::mutable_string_value()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  if (kind_case() != kStringValue) {
    clear_kind();

    set_has_string_value();
    _impl_.kind_.string_value_.InitDefault();
  }
  ::std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:qdrant.GroupId.string_value)
  return _s;
}
inline const ::std::string& GroupId::_internal_string_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (kind_case() != kStringValue) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.kind_.string_value_.Get();
}
inline void GroupId::_internal_set_string_value(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kind_.string_value_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GroupId::_internal_mutable_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.kind_.string_value_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GroupId::release_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.GroupId.string_value)
  if (kind_case() != kStringValue) {
    return nullptr;
  }
  clear_has_kind();
  return _impl_.kind_.string_value_.Release();
}
inline void GroupId::set_allocated_string_value(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_kind()) {
    clear_kind();
  }
  if (value != nullptr) {
    set_has_string_value();
    _impl_.kind_.string_value_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.GroupId.string_value)
}

inline bool GroupId::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void GroupId::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline GroupId::KindCase GroupId::kind_case() const {
  return GroupId::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PointGroup

// .qdrant.GroupId id = 1;
inline bool PointGroup::has_id() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline void PointGroup::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::GroupId& PointGroup::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::GroupId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::GroupId&>(::qdrant::_GroupId_default_instance_);
}
inline const ::qdrant::GroupId& PointGroup::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointGroup.id)
  return _internal_id();
}
inline void PointGroup::unsafe_arena_set_allocated_id(
    ::qdrant::GroupId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::qdrant::GroupId*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointGroup.id)
}
inline ::qdrant::GroupId* PROTOBUF_NULLABLE PointGroup::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::GroupId* released = _impl_.id_;
  _impl_.id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::GroupId* PROTOBUF_NULLABLE PointGroup::unsafe_arena_release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointGroup.id)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::GroupId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::qdrant::GroupId* PROTOBUF_NONNULL PointGroup::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::GroupId>(GetArena());
    _impl_.id_ = reinterpret_cast<::qdrant::GroupId*>(p);
  }
  return _impl_.id_;
}
inline ::qdrant::GroupId* PROTOBUF_NONNULL PointGroup::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::GroupId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:qdrant.PointGroup.id)
  return _msg;
}
inline void PointGroup::set_allocated_id(::qdrant::GroupId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.id_ = reinterpret_cast<::qdrant::GroupId*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointGroup.id)
}

// repeated .qdrant.ScoredPoint hits = 2;
inline int PointGroup::_internal_hits_size() const {
  return _internal_hits().size();
}
inline int PointGroup::hits_size() const {
  return _internal_hits_size();
}
inline void PointGroup::clear_hits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hits_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::ScoredPoint* PROTOBUF_NONNULL PointGroup::mutable_hits(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.PointGroup.hits)
  return _internal_mutable_hits()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL PointGroup::mutable_hits()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.PointGroup.hits)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hits();
}
inline const ::qdrant::ScoredPoint& PointGroup::hits(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointGroup.hits)
  return _internal_hits().Get(index);
}
inline ::qdrant::ScoredPoint* PROTOBUF_NONNULL PointGroup::add_hits()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::ScoredPoint* _add =
      _internal_mutable_hits()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.PointGroup.hits)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& PointGroup::hits() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.PointGroup.hits)
  return _internal_hits();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>&
PointGroup::_internal_hits() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hits_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL
PointGroup::_internal_mutable_hits() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hits_;
}

// .qdrant.RetrievedPoint lookup = 3;
inline bool PointGroup::has_lookup() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.lookup_ != nullptr);
  return value;
}
inline void PointGroup::clear_lookup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lookup_ != nullptr) _impl_.lookup_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::RetrievedPoint& PointGroup::_internal_lookup() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::RetrievedPoint* p = _impl_.lookup_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::RetrievedPoint&>(::qdrant::_RetrievedPoint_default_instance_);
}
inline const ::qdrant::RetrievedPoint& PointGroup::lookup() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointGroup.lookup)
  return _internal_lookup();
}
inline void PointGroup::unsafe_arena_set_allocated_lookup(
    ::qdrant::RetrievedPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lookup_);
  }
  _impl_.lookup_ = reinterpret_cast<::qdrant::RetrievedPoint*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointGroup.lookup)
}
inline ::qdrant::RetrievedPoint* PROTOBUF_NULLABLE PointGroup::release_lookup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::RetrievedPoint* released = _impl_.lookup_;
  _impl_.lookup_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::RetrievedPoint* PROTOBUF_NULLABLE PointGroup::unsafe_arena_release_lookup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointGroup.lookup)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::RetrievedPoint* temp = _impl_.lookup_;
  _impl_.lookup_ = nullptr;
  return temp;
}
inline ::qdrant::RetrievedPoint* PROTOBUF_NONNULL PointGroup::_internal_mutable_lookup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lookup_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::RetrievedPoint>(GetArena());
    _impl_.lookup_ = reinterpret_cast<::qdrant::RetrievedPoint*>(p);
  }
  return _impl_.lookup_;
}
inline ::qdrant::RetrievedPoint* PROTOBUF_NONNULL PointGroup::mutable_lookup()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::RetrievedPoint* _msg = _internal_mutable_lookup();
  // @@protoc_insertion_point(field_mutable:qdrant.PointGroup.lookup)
  return _msg;
}
inline void PointGroup::set_allocated_lookup(::qdrant::RetrievedPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lookup_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.lookup_ = reinterpret_cast<::qdrant::RetrievedPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointGroup.lookup)
}

// -------------------------------------------------------------------

// GroupsResult

// repeated .qdrant.PointGroup groups = 1;
inline int GroupsResult::_internal_groups_size() const {
  return _internal_groups().size();
}
inline int GroupsResult::groups_size() const {
  return _internal_groups_size();
}
inline void GroupsResult::clear_groups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.groups_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::PointGroup* PROTOBUF_NONNULL GroupsResult::mutable_groups(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.GroupsResult.groups)
  return _internal_mutable_groups()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointGroup>* PROTOBUF_NONNULL GroupsResult::mutable_groups()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.GroupsResult.groups)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_groups();
}
inline const ::qdrant::PointGroup& GroupsResult::groups(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GroupsResult.groups)
  return _internal_groups().Get(index);
}
inline ::qdrant::PointGroup* PROTOBUF_NONNULL GroupsResult::add_groups()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::PointGroup* _add =
      _internal_mutable_groups()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.GroupsResult.groups)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointGroup>& GroupsResult::groups() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.GroupsResult.groups)
  return _internal_groups();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointGroup>&
GroupsResult::_internal_groups() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.groups_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointGroup>* PROTOBUF_NONNULL
GroupsResult::_internal_mutable_groups() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.groups_;
}

// -------------------------------------------------------------------

// SearchResponse

// repeated .qdrant.ScoredPoint result = 1;
inline int SearchResponse::_internal_result_size() const {
  return _internal_result().size();
}
inline int SearchResponse::result_size() const {
  return _internal_result_size();
}
inline void SearchResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::ScoredPoint* PROTOBUF_NONNULL SearchResponse::mutable_result(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.SearchResponse.result)
  return _internal_mutable_result()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL SearchResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.SearchResponse.result)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_result();
}
inline const ::qdrant::ScoredPoint& SearchResponse::result(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchResponse.result)
  return _internal_result().Get(index);
}
inline ::qdrant::ScoredPoint* PROTOBUF_NONNULL SearchResponse::add_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::ScoredPoint* _add =
      _internal_mutable_result()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.SearchResponse.result)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& SearchResponse::result() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.SearchResponse.result)
  return _internal_result();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>&
SearchResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL
SearchResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.result_;
}

// double time = 2;
inline void SearchResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double SearchResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchResponse.time)
  return _internal_time();
}
inline void SearchResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.SearchResponse.time)
}
inline double SearchResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void SearchResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool SearchResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void SearchResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& SearchResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& SearchResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchResponse.usage)
  return _internal_usage();
}
inline void SearchResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE SearchResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE SearchResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL SearchResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL SearchResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchResponse.usage)
  return _msg;
}
inline void SearchResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchResponse.usage)
}

// -------------------------------------------------------------------

// QueryResponse

// repeated .qdrant.ScoredPoint result = 1;
inline int QueryResponse::_internal_result_size() const {
  return _internal_result().size();
}
inline int QueryResponse::result_size() const {
  return _internal_result_size();
}
inline void QueryResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::ScoredPoint* PROTOBUF_NONNULL QueryResponse::mutable_result(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.QueryResponse.result)
  return _internal_mutable_result()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL QueryResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.QueryResponse.result)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_result();
}
inline const ::qdrant::ScoredPoint& QueryResponse::result(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryResponse.result)
  return _internal_result().Get(index);
}
inline ::qdrant::ScoredPoint* PROTOBUF_NONNULL QueryResponse::add_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::ScoredPoint* _add =
      _internal_mutable_result()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.QueryResponse.result)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& QueryResponse::result() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.QueryResponse.result)
  return _internal_result();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>&
QueryResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL
QueryResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.result_;
}

// double time = 2;
inline void QueryResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double QueryResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.QueryResponse.time)
  return _internal_time();
}
inline void QueryResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.QueryResponse.time)
}
inline double QueryResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void QueryResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool QueryResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void QueryResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& QueryResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& QueryResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryResponse.usage)
  return _internal_usage();
}
inline void QueryResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE QueryResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE QueryResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL QueryResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL QueryResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryResponse.usage)
  return _msg;
}
inline void QueryResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryResponse.usage)
}

// -------------------------------------------------------------------

// QueryBatchResponse

// repeated .qdrant.BatchResult result = 1;
inline int QueryBatchResponse::_internal_result_size() const {
  return _internal_result().size();
}
inline int QueryBatchResponse::result_size() const {
  return _internal_result_size();
}
inline void QueryBatchResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::BatchResult* PROTOBUF_NONNULL QueryBatchResponse::mutable_result(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.QueryBatchResponse.result)
  return _internal_mutable_result()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>* PROTOBUF_NONNULL QueryBatchResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.QueryBatchResponse.result)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_result();
}
inline const ::qdrant::BatchResult& QueryBatchResponse::result(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryBatchResponse.result)
  return _internal_result().Get(index);
}
inline ::qdrant::BatchResult* PROTOBUF_NONNULL QueryBatchResponse::add_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::BatchResult* _add =
      _internal_mutable_result()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.QueryBatchResponse.result)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>& QueryBatchResponse::result() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.QueryBatchResponse.result)
  return _internal_result();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>&
QueryBatchResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>* PROTOBUF_NONNULL
QueryBatchResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.result_;
}

// double time = 2;
inline void QueryBatchResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double QueryBatchResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.QueryBatchResponse.time)
  return _internal_time();
}
inline void QueryBatchResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.QueryBatchResponse.time)
}
inline double QueryBatchResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void QueryBatchResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool QueryBatchResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void QueryBatchResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& QueryBatchResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& QueryBatchResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryBatchResponse.usage)
  return _internal_usage();
}
inline void QueryBatchResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryBatchResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE QueryBatchResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE QueryBatchResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryBatchResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL QueryBatchResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL QueryBatchResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryBatchResponse.usage)
  return _msg;
}
inline void QueryBatchResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryBatchResponse.usage)
}

// -------------------------------------------------------------------

// QueryGroupsResponse

// .qdrant.GroupsResult result = 1;
inline bool QueryGroupsResponse::has_result() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void QueryGroupsResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::GroupsResult& QueryGroupsResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::GroupsResult* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::GroupsResult&>(::qdrant::_GroupsResult_default_instance_);
}
inline const ::qdrant::GroupsResult& QueryGroupsResponse::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryGroupsResponse.result)
  return _internal_result();
}
inline void QueryGroupsResponse::unsafe_arena_set_allocated_result(
    ::qdrant::GroupsResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::qdrant::GroupsResult*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryGroupsResponse.result)
}
inline ::qdrant::GroupsResult* PROTOBUF_NULLABLE QueryGroupsResponse::release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::GroupsResult* released = _impl_.result_;
  _impl_.result_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::GroupsResult* PROTOBUF_NULLABLE QueryGroupsResponse::unsafe_arena_release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryGroupsResponse.result)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::GroupsResult* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::qdrant::GroupsResult* PROTOBUF_NONNULL QueryGroupsResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::GroupsResult>(GetArena());
    _impl_.result_ = reinterpret_cast<::qdrant::GroupsResult*>(p);
  }
  return _impl_.result_;
}
inline ::qdrant::GroupsResult* PROTOBUF_NONNULL QueryGroupsResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::GroupsResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryGroupsResponse.result)
  return _msg;
}
inline void QueryGroupsResponse::set_allocated_result(::qdrant::GroupsResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.result_ = reinterpret_cast<::qdrant::GroupsResult*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryGroupsResponse.result)
}

// double time = 2;
inline void QueryGroupsResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double QueryGroupsResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.QueryGroupsResponse.time)
  return _internal_time();
}
inline void QueryGroupsResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.QueryGroupsResponse.time)
}
inline double QueryGroupsResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void QueryGroupsResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool QueryGroupsResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void QueryGroupsResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& QueryGroupsResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& QueryGroupsResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QueryGroupsResponse.usage)
  return _internal_usage();
}
inline void QueryGroupsResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QueryGroupsResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE QueryGroupsResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE QueryGroupsResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.QueryGroupsResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL QueryGroupsResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL QueryGroupsResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.QueryGroupsResponse.usage)
  return _msg;
}
inline void QueryGroupsResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.QueryGroupsResponse.usage)
}

// -------------------------------------------------------------------

// BatchResult

// repeated .qdrant.ScoredPoint result = 1;
inline int BatchResult::_internal_result_size() const {
  return _internal_result().size();
}
inline int BatchResult::result_size() const {
  return _internal_result_size();
}
inline void BatchResult::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::ScoredPoint* PROTOBUF_NONNULL BatchResult::mutable_result(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.BatchResult.result)
  return _internal_mutable_result()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL BatchResult::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.BatchResult.result)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_result();
}
inline const ::qdrant::ScoredPoint& BatchResult::result(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.BatchResult.result)
  return _internal_result().Get(index);
}
inline ::qdrant::ScoredPoint* PROTOBUF_NONNULL BatchResult::add_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::ScoredPoint* _add =
      _internal_mutable_result()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.BatchResult.result)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& BatchResult::result() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.BatchResult.result)
  return _internal_result();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>&
BatchResult::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL
BatchResult::_internal_mutable_result() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.result_;
}

// -------------------------------------------------------------------

// SearchBatchResponse

// repeated .qdrant.BatchResult result = 1;
inline int SearchBatchResponse::_internal_result_size() const {
  return _internal_result().size();
}
inline int SearchBatchResponse::result_size() const {
  return _internal_result_size();
}
inline void SearchBatchResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::BatchResult* PROTOBUF_NONNULL SearchBatchResponse::mutable_result(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.SearchBatchResponse.result)
  return _internal_mutable_result()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>* PROTOBUF_NONNULL SearchBatchResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.SearchBatchResponse.result)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_result();
}
inline const ::qdrant::BatchResult& SearchBatchResponse::result(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchBatchResponse.result)
  return _internal_result().Get(index);
}
inline ::qdrant::BatchResult* PROTOBUF_NONNULL SearchBatchResponse::add_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::BatchResult* _add =
      _internal_mutable_result()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.SearchBatchResponse.result)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>& SearchBatchResponse::result() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.SearchBatchResponse.result)
  return _internal_result();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>&
SearchBatchResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>* PROTOBUF_NONNULL
SearchBatchResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.result_;
}

// double time = 2;
inline void SearchBatchResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double SearchBatchResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchBatchResponse.time)
  return _internal_time();
}
inline void SearchBatchResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.SearchBatchResponse.time)
}
inline double SearchBatchResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void SearchBatchResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool SearchBatchResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void SearchBatchResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& SearchBatchResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& SearchBatchResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchBatchResponse.usage)
  return _internal_usage();
}
inline void SearchBatchResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchBatchResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE SearchBatchResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE SearchBatchResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchBatchResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL SearchBatchResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL SearchBatchResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchBatchResponse.usage)
  return _msg;
}
inline void SearchBatchResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchBatchResponse.usage)
}

// -------------------------------------------------------------------

// SearchGroupsResponse

// .qdrant.GroupsResult result = 1;
inline bool SearchGroupsResponse::has_result() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void SearchGroupsResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::GroupsResult& SearchGroupsResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::GroupsResult* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::GroupsResult&>(::qdrant::_GroupsResult_default_instance_);
}
inline const ::qdrant::GroupsResult& SearchGroupsResponse::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchGroupsResponse.result)
  return _internal_result();
}
inline void SearchGroupsResponse::unsafe_arena_set_allocated_result(
    ::qdrant::GroupsResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::qdrant::GroupsResult*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchGroupsResponse.result)
}
inline ::qdrant::GroupsResult* PROTOBUF_NULLABLE SearchGroupsResponse::release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::GroupsResult* released = _impl_.result_;
  _impl_.result_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::GroupsResult* PROTOBUF_NULLABLE SearchGroupsResponse::unsafe_arena_release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchGroupsResponse.result)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::GroupsResult* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::qdrant::GroupsResult* PROTOBUF_NONNULL SearchGroupsResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::GroupsResult>(GetArena());
    _impl_.result_ = reinterpret_cast<::qdrant::GroupsResult*>(p);
  }
  return _impl_.result_;
}
inline ::qdrant::GroupsResult* PROTOBUF_NONNULL SearchGroupsResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::GroupsResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchGroupsResponse.result)
  return _msg;
}
inline void SearchGroupsResponse::set_allocated_result(::qdrant::GroupsResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.result_ = reinterpret_cast<::qdrant::GroupsResult*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchGroupsResponse.result)
}

// double time = 2;
inline void SearchGroupsResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double SearchGroupsResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchGroupsResponse.time)
  return _internal_time();
}
inline void SearchGroupsResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.SearchGroupsResponse.time)
}
inline double SearchGroupsResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void SearchGroupsResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool SearchGroupsResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void SearchGroupsResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& SearchGroupsResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& SearchGroupsResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchGroupsResponse.usage)
  return _internal_usage();
}
inline void SearchGroupsResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchGroupsResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE SearchGroupsResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE SearchGroupsResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchGroupsResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL SearchGroupsResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL SearchGroupsResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchGroupsResponse.usage)
  return _msg;
}
inline void SearchGroupsResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchGroupsResponse.usage)
}

// -------------------------------------------------------------------

// CountResponse

// .qdrant.CountResult result = 1;
inline bool CountResponse::has_result() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void CountResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::CountResult& CountResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::CountResult* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::CountResult&>(::qdrant::_CountResult_default_instance_);
}
inline const ::qdrant::CountResult& CountResponse::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CountResponse.result)
  return _internal_result();
}
inline void CountResponse::unsafe_arena_set_allocated_result(
    ::qdrant::CountResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::qdrant::CountResult*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CountResponse.result)
}
inline ::qdrant::CountResult* PROTOBUF_NULLABLE CountResponse::release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::CountResult* released = _impl_.result_;
  _impl_.result_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::CountResult* PROTOBUF_NULLABLE CountResponse::unsafe_arena_release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CountResponse.result)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::CountResult* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::qdrant::CountResult* PROTOBUF_NONNULL CountResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::CountResult>(GetArena());
    _impl_.result_ = reinterpret_cast<::qdrant::CountResult*>(p);
  }
  return _impl_.result_;
}
inline ::qdrant::CountResult* PROTOBUF_NONNULL CountResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::CountResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:qdrant.CountResponse.result)
  return _msg;
}
inline void CountResponse::set_allocated_result(::qdrant::CountResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.result_ = reinterpret_cast<::qdrant::CountResult*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CountResponse.result)
}

// double time = 2;
inline void CountResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double CountResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.CountResponse.time)
  return _internal_time();
}
inline void CountResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.CountResponse.time)
}
inline double CountResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void CountResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool CountResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void CountResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& CountResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& CountResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CountResponse.usage)
  return _internal_usage();
}
inline void CountResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CountResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE CountResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE CountResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CountResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL CountResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL CountResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.CountResponse.usage)
  return _msg;
}
inline void CountResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CountResponse.usage)
}

// -------------------------------------------------------------------

// ScrollResponse

// optional .qdrant.PointId next_page_offset = 1;
inline bool ScrollResponse::has_next_page_offset() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.next_page_offset_ != nullptr);
  return value;
}
inline void ScrollResponse::clear_next_page_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.next_page_offset_ != nullptr) _impl_.next_page_offset_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::PointId& ScrollResponse::_internal_next_page_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointId* p = _impl_.next_page_offset_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointId&>(::qdrant::_PointId_default_instance_);
}
inline const ::qdrant::PointId& ScrollResponse::next_page_offset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ScrollResponse.next_page_offset)
  return _internal_next_page_offset();
}
inline void ScrollResponse::unsafe_arena_set_allocated_next_page_offset(
    ::qdrant::PointId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.next_page_offset_);
  }
  _impl_.next_page_offset_ = reinterpret_cast<::qdrant::PointId*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ScrollResponse.next_page_offset)
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE ScrollResponse::release_next_page_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointId* released = _impl_.next_page_offset_;
  _impl_.next_page_offset_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE ScrollResponse::unsafe_arena_release_next_page_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ScrollResponse.next_page_offset)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointId* temp = _impl_.next_page_offset_;
  _impl_.next_page_offset_ = nullptr;
  return temp;
}
inline ::qdrant::PointId* PROTOBUF_NONNULL ScrollResponse::_internal_mutable_next_page_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.next_page_offset_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointId>(GetArena());
    _impl_.next_page_offset_ = reinterpret_cast<::qdrant::PointId*>(p);
  }
  return _impl_.next_page_offset_;
}
inline ::qdrant::PointId* PROTOBUF_NONNULL ScrollResponse::mutable_next_page_offset()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::PointId* _msg = _internal_mutable_next_page_offset();
  // @@protoc_insertion_point(field_mutable:qdrant.ScrollResponse.next_page_offset)
  return _msg;
}
inline void ScrollResponse::set_allocated_next_page_offset(::qdrant::PointId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.next_page_offset_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.next_page_offset_ = reinterpret_cast<::qdrant::PointId*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ScrollResponse.next_page_offset)
}

// repeated .qdrant.RetrievedPoint result = 2;
inline int ScrollResponse::_internal_result_size() const {
  return _internal_result().size();
}
inline int ScrollResponse::result_size() const {
  return _internal_result_size();
}
inline void ScrollResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::RetrievedPoint* PROTOBUF_NONNULL ScrollResponse::mutable_result(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.ScrollResponse.result)
  return _internal_mutable_result()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::RetrievedPoint>* PROTOBUF_NONNULL ScrollResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.ScrollResponse.result)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_result();
}
inline const ::qdrant::RetrievedPoint& ScrollResponse::result(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ScrollResponse.result)
  return _internal_result().Get(index);
}
inline ::qdrant::RetrievedPoint* PROTOBUF_NONNULL ScrollResponse::add_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::RetrievedPoint* _add =
      _internal_mutable_result()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.ScrollResponse.result)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::RetrievedPoint>& ScrollResponse::result() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.ScrollResponse.result)
  return _internal_result();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::RetrievedPoint>&
ScrollResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::RetrievedPoint>* PROTOBUF_NONNULL
ScrollResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.result_;
}

// double time = 3;
inline void ScrollResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline double ScrollResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.ScrollResponse.time)
  return _internal_time();
}
inline void ScrollResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.ScrollResponse.time)
}
inline double ScrollResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void ScrollResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 4;
inline bool ScrollResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void ScrollResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::Usage& ScrollResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& ScrollResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ScrollResponse.usage)
  return _internal_usage();
}
inline void ScrollResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ScrollResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE ScrollResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE ScrollResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ScrollResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL ScrollResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL ScrollResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.ScrollResponse.usage)
  return _msg;
}
inline void ScrollResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ScrollResponse.usage)
}

// -------------------------------------------------------------------

// CountResult

// uint64 count = 1;
inline void CountResult::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t CountResult::count() const {
  // @@protoc_insertion_point(field_get:qdrant.CountResult.count)
  return _internal_count();
}
inline void CountResult::set_count(::uint64_t value) {
  _internal_set_count(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.CountResult.count)
}
inline ::uint64_t CountResult::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void CountResult::_internal_set_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RetrievedPoint

// .qdrant.PointId id = 1;
inline bool RetrievedPoint::has_id() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline void RetrievedPoint::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::PointId& RetrievedPoint::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointId&>(::qdrant::_PointId_default_instance_);
}
inline const ::qdrant::PointId& RetrievedPoint::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RetrievedPoint.id)
  return _internal_id();
}
inline void RetrievedPoint::unsafe_arena_set_allocated_id(
    ::qdrant::PointId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::qdrant::PointId*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RetrievedPoint.id)
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE RetrievedPoint::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointId* released = _impl_.id_;
  _impl_.id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE RetrievedPoint::unsafe_arena_release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RetrievedPoint.id)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::qdrant::PointId* PROTOBUF_NONNULL RetrievedPoint::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointId>(GetArena());
    _impl_.id_ = reinterpret_cast<::qdrant::PointId*>(p);
  }
  return _impl_.id_;
}
inline ::qdrant::PointId* PROTOBUF_NONNULL RetrievedPoint::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:qdrant.RetrievedPoint.id)
  return _msg;
}
inline void RetrievedPoint::set_allocated_id(::qdrant::PointId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.id_ = reinterpret_cast<::qdrant::PointId*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RetrievedPoint.id)
}

// map<string, .qdrant.Value> payload = 2;
inline int RetrievedPoint::_internal_payload_size() const {
  return _internal_payload().size();
}
inline int RetrievedPoint::payload_size() const {
  return _internal_payload_size();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& RetrievedPoint::_internal_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& RetrievedPoint::payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.RetrievedPoint.payload)
  return _internal_payload();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL RetrievedPoint::_internal_mutable_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.payload_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL RetrievedPoint::mutable_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.RetrievedPoint.payload)
  return _internal_mutable_payload();
}

// optional .qdrant.VectorsOutput vectors = 4;
inline bool RetrievedPoint::has_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.vectors_ != nullptr);
  return value;
}
inline void RetrievedPoint::clear_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_ != nullptr) _impl_.vectors_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::VectorsOutput& RetrievedPoint::_internal_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::VectorsOutput* p = _impl_.vectors_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::VectorsOutput&>(::qdrant::_VectorsOutput_default_instance_);
}
inline const ::qdrant::VectorsOutput& RetrievedPoint::vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RetrievedPoint.vectors)
  return _internal_vectors();
}
inline void RetrievedPoint::unsafe_arena_set_allocated_vectors(
    ::qdrant::VectorsOutput* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_);
  }
  _impl_.vectors_ = reinterpret_cast<::qdrant::VectorsOutput*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RetrievedPoint.vectors)
}
inline ::qdrant::VectorsOutput* PROTOBUF_NULLABLE RetrievedPoint::release_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::VectorsOutput* released = _impl_.vectors_;
  _impl_.vectors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::VectorsOutput* PROTOBUF_NULLABLE RetrievedPoint::unsafe_arena_release_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RetrievedPoint.vectors)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::VectorsOutput* temp = _impl_.vectors_;
  _impl_.vectors_ = nullptr;
  return temp;
}
inline ::qdrant::VectorsOutput* PROTOBUF_NONNULL RetrievedPoint::_internal_mutable_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorsOutput>(GetArena());
    _impl_.vectors_ = reinterpret_cast<::qdrant::VectorsOutput*>(p);
  }
  return _impl_.vectors_;
}
inline ::qdrant::VectorsOutput* PROTOBUF_NONNULL RetrievedPoint::mutable_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::VectorsOutput* _msg = _internal_mutable_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.RetrievedPoint.vectors)
  return _msg;
}
inline void RetrievedPoint::set_allocated_vectors(::qdrant::VectorsOutput* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.vectors_ = reinterpret_cast<::qdrant::VectorsOutput*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RetrievedPoint.vectors)
}

// optional .qdrant.ShardKey shard_key = 5;
inline bool RetrievedPoint::has_shard_key() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_ != nullptr);
  return value;
}
inline const ::qdrant::ShardKey& RetrievedPoint::_internal_shard_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKey* p = _impl_.shard_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKey&>(::qdrant::_ShardKey_default_instance_);
}
inline const ::qdrant::ShardKey& RetrievedPoint::shard_key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RetrievedPoint.shard_key)
  return _internal_shard_key();
}
inline void RetrievedPoint::unsafe_arena_set_allocated_shard_key(
    ::qdrant::ShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_);
  }
  _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RetrievedPoint.shard_key)
}
inline ::qdrant::ShardKey* PROTOBUF_NULLABLE RetrievedPoint::release_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKey* released = _impl_.shard_key_;
  _impl_.shard_key_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKey* PROTOBUF_NULLABLE RetrievedPoint::unsafe_arena_release_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RetrievedPoint.shard_key)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKey* temp = _impl_.shard_key_;
  _impl_.shard_key_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKey* PROTOBUF_NONNULL RetrievedPoint::_internal_mutable_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKey>(GetArena());
    _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(p);
  }
  return _impl_.shard_key_;
}
inline ::qdrant::ShardKey* PROTOBUF_NONNULL RetrievedPoint::mutable_shard_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::ShardKey* _msg = _internal_mutable_shard_key();
  // @@protoc_insertion_point(field_mutable:qdrant.RetrievedPoint.shard_key)
  return _msg;
}
inline void RetrievedPoint::set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RetrievedPoint.shard_key)
}

// optional .qdrant.OrderValue order_value = 6;
inline bool RetrievedPoint::has_order_value() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.order_value_ != nullptr);
  return value;
}
inline void RetrievedPoint::clear_order_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.order_value_ != nullptr) _impl_.order_value_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::OrderValue& RetrievedPoint::_internal_order_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::OrderValue* p = _impl_.order_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::OrderValue&>(::qdrant::_OrderValue_default_instance_);
}
inline const ::qdrant::OrderValue& RetrievedPoint::order_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RetrievedPoint.order_value)
  return _internal_order_value();
}
inline void RetrievedPoint::unsafe_arena_set_allocated_order_value(
    ::qdrant::OrderValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.order_value_);
  }
  _impl_.order_value_ = reinterpret_cast<::qdrant::OrderValue*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RetrievedPoint.order_value)
}
inline ::qdrant::OrderValue* PROTOBUF_NULLABLE RetrievedPoint::release_order_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::OrderValue* released = _impl_.order_value_;
  _impl_.order_value_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::OrderValue* PROTOBUF_NULLABLE RetrievedPoint::unsafe_arena_release_order_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RetrievedPoint.order_value)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::OrderValue* temp = _impl_.order_value_;
  _impl_.order_value_ = nullptr;
  return temp;
}
inline ::qdrant::OrderValue* PROTOBUF_NONNULL RetrievedPoint::_internal_mutable_order_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.order_value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::OrderValue>(GetArena());
    _impl_.order_value_ = reinterpret_cast<::qdrant::OrderValue*>(p);
  }
  return _impl_.order_value_;
}
inline ::qdrant::OrderValue* PROTOBUF_NONNULL RetrievedPoint::mutable_order_value()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::OrderValue* _msg = _internal_mutable_order_value();
  // @@protoc_insertion_point(field_mutable:qdrant.RetrievedPoint.order_value)
  return _msg;
}
inline void RetrievedPoint::set_allocated_order_value(::qdrant::OrderValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.order_value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.order_value_ = reinterpret_cast<::qdrant::OrderValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RetrievedPoint.order_value)
}

// -------------------------------------------------------------------

// GetResponse

// repeated .qdrant.RetrievedPoint result = 1;
inline int GetResponse::_internal_result_size() const {
  return _internal_result().size();
}
inline int GetResponse::result_size() const {
  return _internal_result_size();
}
inline void GetResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::RetrievedPoint* PROTOBUF_NONNULL GetResponse::mutable_result(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.GetResponse.result)
  return _internal_mutable_result()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::RetrievedPoint>* PROTOBUF_NONNULL GetResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.GetResponse.result)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_result();
}
inline const ::qdrant::RetrievedPoint& GetResponse::result(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GetResponse.result)
  return _internal_result().Get(index);
}
inline ::qdrant::RetrievedPoint* PROTOBUF_NONNULL GetResponse::add_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::RetrievedPoint* _add =
      _internal_mutable_result()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.GetResponse.result)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::RetrievedPoint>& GetResponse::result() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.GetResponse.result)
  return _internal_result();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::RetrievedPoint>&
GetResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::RetrievedPoint>* PROTOBUF_NONNULL
GetResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.result_;
}

// double time = 2;
inline void GetResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double GetResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.GetResponse.time)
  return _internal_time();
}
inline void GetResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.GetResponse.time)
}
inline double GetResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void GetResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool GetResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void GetResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& GetResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& GetResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GetResponse.usage)
  return _internal_usage();
}
inline void GetResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.GetResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE GetResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE GetResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.GetResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL GetResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL GetResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.GetResponse.usage)
  return _msg;
}
inline void GetResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.GetResponse.usage)
}

// -------------------------------------------------------------------

// RecommendResponse

// repeated .qdrant.ScoredPoint result = 1;
inline int RecommendResponse::_internal_result_size() const {
  return _internal_result().size();
}
inline int RecommendResponse::result_size() const {
  return _internal_result_size();
}
inline void RecommendResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::ScoredPoint* PROTOBUF_NONNULL RecommendResponse::mutable_result(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendResponse.result)
  return _internal_mutable_result()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL RecommendResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.RecommendResponse.result)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_result();
}
inline const ::qdrant::ScoredPoint& RecommendResponse::result(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendResponse.result)
  return _internal_result().Get(index);
}
inline ::qdrant::ScoredPoint* PROTOBUF_NONNULL RecommendResponse::add_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::ScoredPoint* _add =
      _internal_mutable_result()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.RecommendResponse.result)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& RecommendResponse::result() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.RecommendResponse.result)
  return _internal_result();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>&
RecommendResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL
RecommendResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.result_;
}

// double time = 2;
inline void RecommendResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double RecommendResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.RecommendResponse.time)
  return _internal_time();
}
inline void RecommendResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.RecommendResponse.time)
}
inline double RecommendResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void RecommendResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool RecommendResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void RecommendResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& RecommendResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& RecommendResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendResponse.usage)
  return _internal_usage();
}
inline void RecommendResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE RecommendResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE RecommendResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL RecommendResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL RecommendResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendResponse.usage)
  return _msg;
}
inline void RecommendResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendResponse.usage)
}

// -------------------------------------------------------------------

// RecommendBatchResponse

// repeated .qdrant.BatchResult result = 1;
inline int RecommendBatchResponse::_internal_result_size() const {
  return _internal_result().size();
}
inline int RecommendBatchResponse::result_size() const {
  return _internal_result_size();
}
inline void RecommendBatchResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::BatchResult* PROTOBUF_NONNULL RecommendBatchResponse::mutable_result(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendBatchResponse.result)
  return _internal_mutable_result()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>* PROTOBUF_NONNULL RecommendBatchResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.RecommendBatchResponse.result)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_result();
}
inline const ::qdrant::BatchResult& RecommendBatchResponse::result(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendBatchResponse.result)
  return _internal_result().Get(index);
}
inline ::qdrant::BatchResult* PROTOBUF_NONNULL RecommendBatchResponse::add_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::BatchResult* _add =
      _internal_mutable_result()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.RecommendBatchResponse.result)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>& RecommendBatchResponse::result() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.RecommendBatchResponse.result)
  return _internal_result();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>&
RecommendBatchResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>* PROTOBUF_NONNULL
RecommendBatchResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.result_;
}

// double time = 2;
inline void RecommendBatchResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double RecommendBatchResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.RecommendBatchResponse.time)
  return _internal_time();
}
inline void RecommendBatchResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.RecommendBatchResponse.time)
}
inline double RecommendBatchResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void RecommendBatchResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool RecommendBatchResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void RecommendBatchResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& RecommendBatchResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& RecommendBatchResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendBatchResponse.usage)
  return _internal_usage();
}
inline void RecommendBatchResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendBatchResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE RecommendBatchResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE RecommendBatchResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendBatchResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL RecommendBatchResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL RecommendBatchResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendBatchResponse.usage)
  return _msg;
}
inline void RecommendBatchResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendBatchResponse.usage)
}

// -------------------------------------------------------------------

// DiscoverResponse

// repeated .qdrant.ScoredPoint result = 1;
inline int DiscoverResponse::_internal_result_size() const {
  return _internal_result().size();
}
inline int DiscoverResponse::result_size() const {
  return _internal_result_size();
}
inline void DiscoverResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::ScoredPoint* PROTOBUF_NONNULL DiscoverResponse::mutable_result(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverResponse.result)
  return _internal_mutable_result()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL DiscoverResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.DiscoverResponse.result)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_result();
}
inline const ::qdrant::ScoredPoint& DiscoverResponse::result(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverResponse.result)
  return _internal_result().Get(index);
}
inline ::qdrant::ScoredPoint* PROTOBUF_NONNULL DiscoverResponse::add_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::ScoredPoint* _add =
      _internal_mutable_result()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.DiscoverResponse.result)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>& DiscoverResponse::result() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.DiscoverResponse.result)
  return _internal_result();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>&
DiscoverResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ScoredPoint>* PROTOBUF_NONNULL
DiscoverResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.result_;
}

// double time = 2;
inline void DiscoverResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double DiscoverResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverResponse.time)
  return _internal_time();
}
inline void DiscoverResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.DiscoverResponse.time)
}
inline double DiscoverResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void DiscoverResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool DiscoverResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void DiscoverResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& DiscoverResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& DiscoverResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverResponse.usage)
  return _internal_usage();
}
inline void DiscoverResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DiscoverResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE DiscoverResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE DiscoverResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DiscoverResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL DiscoverResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL DiscoverResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverResponse.usage)
  return _msg;
}
inline void DiscoverResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DiscoverResponse.usage)
}

// -------------------------------------------------------------------

// DiscoverBatchResponse

// repeated .qdrant.BatchResult result = 1;
inline int DiscoverBatchResponse::_internal_result_size() const {
  return _internal_result().size();
}
inline int DiscoverBatchResponse::result_size() const {
  return _internal_result_size();
}
inline void DiscoverBatchResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::BatchResult* PROTOBUF_NONNULL DiscoverBatchResponse::mutable_result(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverBatchResponse.result)
  return _internal_mutable_result()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>* PROTOBUF_NONNULL DiscoverBatchResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.DiscoverBatchResponse.result)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_result();
}
inline const ::qdrant::BatchResult& DiscoverBatchResponse::result(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverBatchResponse.result)
  return _internal_result().Get(index);
}
inline ::qdrant::BatchResult* PROTOBUF_NONNULL DiscoverBatchResponse::add_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::BatchResult* _add =
      _internal_mutable_result()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.DiscoverBatchResponse.result)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>& DiscoverBatchResponse::result() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.DiscoverBatchResponse.result)
  return _internal_result();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>&
DiscoverBatchResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::BatchResult>* PROTOBUF_NONNULL
DiscoverBatchResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.result_;
}

// double time = 2;
inline void DiscoverBatchResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double DiscoverBatchResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverBatchResponse.time)
  return _internal_time();
}
inline void DiscoverBatchResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.DiscoverBatchResponse.time)
}
inline double DiscoverBatchResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void DiscoverBatchResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool DiscoverBatchResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void DiscoverBatchResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& DiscoverBatchResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& DiscoverBatchResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DiscoverBatchResponse.usage)
  return _internal_usage();
}
inline void DiscoverBatchResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DiscoverBatchResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE DiscoverBatchResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE DiscoverBatchResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DiscoverBatchResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL DiscoverBatchResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL DiscoverBatchResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.DiscoverBatchResponse.usage)
  return _msg;
}
inline void DiscoverBatchResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DiscoverBatchResponse.usage)
}

// -------------------------------------------------------------------

// RecommendGroupsResponse

// .qdrant.GroupsResult result = 1;
inline bool RecommendGroupsResponse::has_result() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void RecommendGroupsResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::GroupsResult& RecommendGroupsResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::GroupsResult* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::GroupsResult&>(::qdrant::_GroupsResult_default_instance_);
}
inline const ::qdrant::GroupsResult& RecommendGroupsResponse::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendGroupsResponse.result)
  return _internal_result();
}
inline void RecommendGroupsResponse::unsafe_arena_set_allocated_result(
    ::qdrant::GroupsResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::qdrant::GroupsResult*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendGroupsResponse.result)
}
inline ::qdrant::GroupsResult* PROTOBUF_NULLABLE RecommendGroupsResponse::release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::GroupsResult* released = _impl_.result_;
  _impl_.result_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::GroupsResult* PROTOBUF_NULLABLE RecommendGroupsResponse::unsafe_arena_release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendGroupsResponse.result)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::GroupsResult* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::qdrant::GroupsResult* PROTOBUF_NONNULL RecommendGroupsResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::GroupsResult>(GetArena());
    _impl_.result_ = reinterpret_cast<::qdrant::GroupsResult*>(p);
  }
  return _impl_.result_;
}
inline ::qdrant::GroupsResult* PROTOBUF_NONNULL RecommendGroupsResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::GroupsResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendGroupsResponse.result)
  return _msg;
}
inline void RecommendGroupsResponse::set_allocated_result(::qdrant::GroupsResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.result_ = reinterpret_cast<::qdrant::GroupsResult*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendGroupsResponse.result)
}

// double time = 2;
inline void RecommendGroupsResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double RecommendGroupsResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.RecommendGroupsResponse.time)
  return _internal_time();
}
inline void RecommendGroupsResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.RecommendGroupsResponse.time)
}
inline double RecommendGroupsResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void RecommendGroupsResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool RecommendGroupsResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void RecommendGroupsResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& RecommendGroupsResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& RecommendGroupsResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RecommendGroupsResponse.usage)
  return _internal_usage();
}
inline void RecommendGroupsResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RecommendGroupsResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE RecommendGroupsResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE RecommendGroupsResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RecommendGroupsResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL RecommendGroupsResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL RecommendGroupsResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.RecommendGroupsResponse.usage)
  return _msg;
}
inline void RecommendGroupsResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RecommendGroupsResponse.usage)
}

// -------------------------------------------------------------------

// UpdateBatchResponse

// repeated .qdrant.UpdateResult result = 1;
inline int UpdateBatchResponse::_internal_result_size() const {
  return _internal_result().size();
}
inline int UpdateBatchResponse::result_size() const {
  return _internal_result_size();
}
inline void UpdateBatchResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::UpdateResult* PROTOBUF_NONNULL UpdateBatchResponse::mutable_result(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateBatchResponse.result)
  return _internal_mutable_result()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::UpdateResult>* PROTOBUF_NONNULL UpdateBatchResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.UpdateBatchResponse.result)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_result();
}
inline const ::qdrant::UpdateResult& UpdateBatchResponse::result(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateBatchResponse.result)
  return _internal_result().Get(index);
}
inline ::qdrant::UpdateResult* PROTOBUF_NONNULL UpdateBatchResponse::add_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::UpdateResult* _add =
      _internal_mutable_result()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.UpdateBatchResponse.result)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::UpdateResult>& UpdateBatchResponse::result() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.UpdateBatchResponse.result)
  return _internal_result();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::UpdateResult>&
UpdateBatchResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::UpdateResult>* PROTOBUF_NONNULL
UpdateBatchResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.result_;
}

// double time = 2;
inline void UpdateBatchResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double UpdateBatchResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.UpdateBatchResponse.time)
  return _internal_time();
}
inline void UpdateBatchResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.UpdateBatchResponse.time)
}
inline double UpdateBatchResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void UpdateBatchResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool UpdateBatchResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void UpdateBatchResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& UpdateBatchResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& UpdateBatchResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateBatchResponse.usage)
  return _internal_usage();
}
inline void UpdateBatchResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdateBatchResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE UpdateBatchResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE UpdateBatchResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpdateBatchResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL UpdateBatchResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL UpdateBatchResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateBatchResponse.usage)
  return _msg;
}
inline void UpdateBatchResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpdateBatchResponse.usage)
}

// -------------------------------------------------------------------

// FacetResponse

// repeated .qdrant.FacetHit hits = 1;
inline int FacetResponse::_internal_hits_size() const {
  return _internal_hits().size();
}
inline int FacetResponse::hits_size() const {
  return _internal_hits_size();
}
inline void FacetResponse::clear_hits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hits_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::FacetHit* PROTOBUF_NONNULL FacetResponse::mutable_hits(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.FacetResponse.hits)
  return _internal_mutable_hits()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::FacetHit>* PROTOBUF_NONNULL FacetResponse::mutable_hits()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.FacetResponse.hits)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hits();
}
inline const ::qdrant::FacetHit& FacetResponse::hits(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.FacetResponse.hits)
  return _internal_hits().Get(index);
}
inline ::qdrant::FacetHit* PROTOBUF_NONNULL FacetResponse::add_hits()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::FacetHit* _add =
      _internal_mutable_hits()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.FacetResponse.hits)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::FacetHit>& FacetResponse::hits() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.FacetResponse.hits)
  return _internal_hits();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::FacetHit>&
FacetResponse::_internal_hits() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hits_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::FacetHit>* PROTOBUF_NONNULL
FacetResponse::_internal_mutable_hits() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hits_;
}

// double time = 2;
inline void FacetResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double FacetResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.FacetResponse.time)
  return _internal_time();
}
inline void FacetResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.FacetResponse.time)
}
inline double FacetResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void FacetResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool FacetResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void FacetResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& FacetResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& FacetResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.FacetResponse.usage)
  return _internal_usage();
}
inline void FacetResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.FacetResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE FacetResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE FacetResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.FacetResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL FacetResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL FacetResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.FacetResponse.usage)
  return _msg;
}
inline void FacetResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.FacetResponse.usage)
}

// -------------------------------------------------------------------

// SearchMatrixPairsResponse

// .qdrant.SearchMatrixPairs result = 1;
inline bool SearchMatrixPairsResponse::has_result() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void SearchMatrixPairsResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::SearchMatrixPairs& SearchMatrixPairsResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SearchMatrixPairs* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SearchMatrixPairs&>(::qdrant::_SearchMatrixPairs_default_instance_);
}
inline const ::qdrant::SearchMatrixPairs& SearchMatrixPairsResponse::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixPairsResponse.result)
  return _internal_result();
}
inline void SearchMatrixPairsResponse::unsafe_arena_set_allocated_result(
    ::qdrant::SearchMatrixPairs* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::qdrant::SearchMatrixPairs*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchMatrixPairsResponse.result)
}
inline ::qdrant::SearchMatrixPairs* PROTOBUF_NULLABLE SearchMatrixPairsResponse::release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::SearchMatrixPairs* released = _impl_.result_;
  _impl_.result_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SearchMatrixPairs* PROTOBUF_NULLABLE SearchMatrixPairsResponse::unsafe_arena_release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchMatrixPairsResponse.result)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::SearchMatrixPairs* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::qdrant::SearchMatrixPairs* PROTOBUF_NONNULL SearchMatrixPairsResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SearchMatrixPairs>(GetArena());
    _impl_.result_ = reinterpret_cast<::qdrant::SearchMatrixPairs*>(p);
  }
  return _impl_.result_;
}
inline ::qdrant::SearchMatrixPairs* PROTOBUF_NONNULL SearchMatrixPairsResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::SearchMatrixPairs* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchMatrixPairsResponse.result)
  return _msg;
}
inline void SearchMatrixPairsResponse::set_allocated_result(::qdrant::SearchMatrixPairs* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.result_ = reinterpret_cast<::qdrant::SearchMatrixPairs*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchMatrixPairsResponse.result)
}

// double time = 2;
inline void SearchMatrixPairsResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double SearchMatrixPairsResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixPairsResponse.time)
  return _internal_time();
}
inline void SearchMatrixPairsResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.SearchMatrixPairsResponse.time)
}
inline double SearchMatrixPairsResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void SearchMatrixPairsResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool SearchMatrixPairsResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void SearchMatrixPairsResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& SearchMatrixPairsResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& SearchMatrixPairsResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixPairsResponse.usage)
  return _internal_usage();
}
inline void SearchMatrixPairsResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchMatrixPairsResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE SearchMatrixPairsResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE SearchMatrixPairsResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchMatrixPairsResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL SearchMatrixPairsResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL SearchMatrixPairsResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchMatrixPairsResponse.usage)
  return _msg;
}
inline void SearchMatrixPairsResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchMatrixPairsResponse.usage)
}

// -------------------------------------------------------------------

// SearchMatrixOffsetsResponse

// .qdrant.SearchMatrixOffsets result = 1;
inline bool SearchMatrixOffsetsResponse::has_result() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void SearchMatrixOffsetsResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::SearchMatrixOffsets& SearchMatrixOffsetsResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SearchMatrixOffsets* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SearchMatrixOffsets&>(::qdrant::_SearchMatrixOffsets_default_instance_);
}
inline const ::qdrant::SearchMatrixOffsets& SearchMatrixOffsetsResponse::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixOffsetsResponse.result)
  return _internal_result();
}
inline void SearchMatrixOffsetsResponse::unsafe_arena_set_allocated_result(
    ::qdrant::SearchMatrixOffsets* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::qdrant::SearchMatrixOffsets*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchMatrixOffsetsResponse.result)
}
inline ::qdrant::SearchMatrixOffsets* PROTOBUF_NULLABLE SearchMatrixOffsetsResponse::release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::SearchMatrixOffsets* released = _impl_.result_;
  _impl_.result_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SearchMatrixOffsets* PROTOBUF_NULLABLE SearchMatrixOffsetsResponse::unsafe_arena_release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchMatrixOffsetsResponse.result)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::SearchMatrixOffsets* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::qdrant::SearchMatrixOffsets* PROTOBUF_NONNULL SearchMatrixOffsetsResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SearchMatrixOffsets>(GetArena());
    _impl_.result_ = reinterpret_cast<::qdrant::SearchMatrixOffsets*>(p);
  }
  return _impl_.result_;
}
inline ::qdrant::SearchMatrixOffsets* PROTOBUF_NONNULL SearchMatrixOffsetsResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::SearchMatrixOffsets* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchMatrixOffsetsResponse.result)
  return _msg;
}
inline void SearchMatrixOffsetsResponse::set_allocated_result(::qdrant::SearchMatrixOffsets* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.result_ = reinterpret_cast<::qdrant::SearchMatrixOffsets*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchMatrixOffsetsResponse.result)
}

// double time = 2;
inline void SearchMatrixOffsetsResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double SearchMatrixOffsetsResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixOffsetsResponse.time)
  return _internal_time();
}
inline void SearchMatrixOffsetsResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.SearchMatrixOffsetsResponse.time)
}
inline double SearchMatrixOffsetsResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void SearchMatrixOffsetsResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional .qdrant.Usage usage = 3;
inline bool SearchMatrixOffsetsResponse::has_usage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.usage_ != nullptr);
  return value;
}
inline void SearchMatrixOffsetsResponse::clear_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ != nullptr) _impl_.usage_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Usage& SearchMatrixOffsetsResponse::_internal_usage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Usage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Usage&>(::qdrant::_Usage_default_instance_);
}
inline const ::qdrant::Usage& SearchMatrixOffsetsResponse::usage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SearchMatrixOffsetsResponse.usage)
  return _internal_usage();
}
inline void SearchMatrixOffsetsResponse::unsafe_arena_set_allocated_usage(
    ::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SearchMatrixOffsetsResponse.usage)
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE SearchMatrixOffsetsResponse::release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* released = _impl_.usage_;
  _impl_.usage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Usage* PROTOBUF_NULLABLE SearchMatrixOffsetsResponse::unsafe_arena_release_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SearchMatrixOffsetsResponse.usage)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL SearchMatrixOffsetsResponse::_internal_mutable_usage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.usage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Usage>(GetArena());
    _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(p);
  }
  return _impl_.usage_;
}
inline ::qdrant::Usage* PROTOBUF_NONNULL SearchMatrixOffsetsResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Usage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:qdrant.SearchMatrixOffsetsResponse.usage)
  return _msg;
}
inline void SearchMatrixOffsetsResponse::set_allocated_usage(::qdrant::Usage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.usage_ = reinterpret_cast<::qdrant::Usage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SearchMatrixOffsetsResponse.usage)
}

// -------------------------------------------------------------------

// Filter

// repeated .qdrant.Condition should = 1;
inline int Filter::_internal_should_size() const {
  return _internal_should().size();
}
inline int Filter::should_size() const {
  return _internal_should_size();
}
inline void Filter::clear_should() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.should_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::Condition* PROTOBUF_NONNULL Filter::mutable_should(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.Filter.should)
  return _internal_mutable_should()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Condition>* PROTOBUF_NONNULL Filter::mutable_should()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.Filter.should)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_should();
}
inline const ::qdrant::Condition& Filter::should(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Filter.should)
  return _internal_should().Get(index);
}
inline ::qdrant::Condition* PROTOBUF_NONNULL Filter::add_should()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::Condition* _add =
      _internal_mutable_should()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.Filter.should)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Condition>& Filter::should() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.Filter.should)
  return _internal_should();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Condition>&
Filter::_internal_should() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.should_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Condition>* PROTOBUF_NONNULL
Filter::_internal_mutable_should() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.should_;
}

// repeated .qdrant.Condition must = 2;
inline int Filter::_internal_must_size() const {
  return _internal_must().size();
}
inline int Filter::must_size() const {
  return _internal_must_size();
}
inline void Filter::clear_must() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.must_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::qdrant::Condition* PROTOBUF_NONNULL Filter::mutable_must(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.Filter.must)
  return _internal_mutable_must()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Condition>* PROTOBUF_NONNULL Filter::mutable_must()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.Filter.must)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_must();
}
inline const ::qdrant::Condition& Filter::must(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Filter.must)
  return _internal_must().Get(index);
}
inline ::qdrant::Condition* PROTOBUF_NONNULL Filter::add_must()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::Condition* _add =
      _internal_mutable_must()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:qdrant.Filter.must)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Condition>& Filter::must() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.Filter.must)
  return _internal_must();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Condition>&
Filter::_internal_must() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.must_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Condition>* PROTOBUF_NONNULL
Filter::_internal_mutable_must() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.must_;
}

// repeated .qdrant.Condition must_not = 3;
inline int Filter::_internal_must_not_size() const {
  return _internal_must_not().size();
}
inline int Filter::must_not_size() const {
  return _internal_must_not_size();
}
inline void Filter::clear_must_not() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.must_not_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::qdrant::Condition* PROTOBUF_NONNULL Filter::mutable_must_not(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.Filter.must_not)
  return _internal_mutable_must_not()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Condition>* PROTOBUF_NONNULL Filter::mutable_must_not()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.Filter.must_not)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_must_not();
}
inline const ::qdrant::Condition& Filter::must_not(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Filter.must_not)
  return _internal_must_not().Get(index);
}
inline ::qdrant::Condition* PROTOBUF_NONNULL Filter::add_must_not()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::Condition* _add =
      _internal_mutable_must_not()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:qdrant.Filter.must_not)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Condition>& Filter::must_not() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.Filter.must_not)
  return _internal_must_not();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Condition>&
Filter::_internal_must_not() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.must_not_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Condition>* PROTOBUF_NONNULL
Filter::_internal_mutable_must_not() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.must_not_;
}

// optional .qdrant.MinShould min_should = 4;
inline bool Filter::has_min_should() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.min_should_ != nullptr);
  return value;
}
inline void Filter::clear_min_should() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.min_should_ != nullptr) _impl_.min_should_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::MinShould& Filter::_internal_min_should() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::MinShould* p = _impl_.min_should_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::MinShould&>(::qdrant::_MinShould_default_instance_);
}
inline const ::qdrant::MinShould& Filter::min_should() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Filter.min_should)
  return _internal_min_should();
}
inline void Filter::unsafe_arena_set_allocated_min_should(
    ::qdrant::MinShould* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_should_);
  }
  _impl_.min_should_ = reinterpret_cast<::qdrant::MinShould*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Filter.min_should)
}
inline ::qdrant::MinShould* PROTOBUF_NULLABLE Filter::release_min_should() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::MinShould* released = _impl_.min_should_;
  _impl_.min_should_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::MinShould* PROTOBUF_NULLABLE Filter::unsafe_arena_release_min_should() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.Filter.min_should)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::MinShould* temp = _impl_.min_should_;
  _impl_.min_should_ = nullptr;
  return temp;
}
inline ::qdrant::MinShould* PROTOBUF_NONNULL Filter::_internal_mutable_min_should() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.min_should_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::MinShould>(GetArena());
    _impl_.min_should_ = reinterpret_cast<::qdrant::MinShould*>(p);
  }
  return _impl_.min_should_;
}
inline ::qdrant::MinShould* PROTOBUF_NONNULL Filter::mutable_min_should()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::MinShould* _msg = _internal_mutable_min_should();
  // @@protoc_insertion_point(field_mutable:qdrant.Filter.min_should)
  return _msg;
}
inline void Filter::set_allocated_min_should(::qdrant::MinShould* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_should_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.min_should_ = reinterpret_cast<::qdrant::MinShould*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.Filter.min_should)
}

// -------------------------------------------------------------------

// MinShould

// repeated .qdrant.Condition conditions = 1;
inline int MinShould::_internal_conditions_size() const {
  return _internal_conditions().size();
}
inline int MinShould::conditions_size() const {
  return _internal_conditions_size();
}
inline void MinShould::clear_conditions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conditions_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::Condition* PROTOBUF_NONNULL MinShould::mutable_conditions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.MinShould.conditions)
  return _internal_mutable_conditions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Condition>* PROTOBUF_NONNULL MinShould::mutable_conditions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.MinShould.conditions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_conditions();
}
inline const ::qdrant::Condition& MinShould::conditions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.MinShould.conditions)
  return _internal_conditions().Get(index);
}
inline ::qdrant::Condition* PROTOBUF_NONNULL MinShould::add_conditions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::Condition* _add =
      _internal_mutable_conditions()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.MinShould.conditions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Condition>& MinShould::conditions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.MinShould.conditions)
  return _internal_conditions();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::Condition>&
MinShould::_internal_conditions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.conditions_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::Condition>* PROTOBUF_NONNULL
MinShould::_internal_mutable_conditions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.conditions_;
}

// uint64 min_count = 2;
inline void MinShould::clear_min_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_count_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint64_t MinShould::min_count() const {
  // @@protoc_insertion_point(field_get:qdrant.MinShould.min_count)
  return _internal_min_count();
}
inline void MinShould::set_min_count(::uint64_t value) {
  _internal_set_min_count(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.MinShould.min_count)
}
inline ::uint64_t MinShould::_internal_min_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_count_;
}
inline void MinShould::_internal_set_min_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_count_ = value;
}

// -------------------------------------------------------------------

// Condition

// .qdrant.FieldCondition field = 1;
inline bool Condition::has_field() const {
  return condition_one_of_case() == kField;
}
inline bool Condition::_internal_has_field() const {
  return condition_one_of_case() == kField;
}
inline void Condition::set_has_field() {
  _impl_._oneof_case_[0] = kField;
}
inline void Condition::clear_field() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (condition_one_of_case() == kField) {
    if (GetArena() == nullptr) {
      delete _impl_.condition_one_of_.field_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.condition_one_of_.field_);
    }
    clear_has_condition_one_of();
  }
}
inline ::qdrant::FieldCondition* PROTOBUF_NULLABLE Condition::release_field() {
  // @@protoc_insertion_point(field_release:qdrant.Condition.field)
  if (condition_one_of_case() == kField) {
    clear_has_condition_one_of();
    auto* temp = reinterpret_cast<::qdrant::FieldCondition*>(_impl_.condition_one_of_.field_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.condition_one_of_.field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::FieldCondition& Condition::_internal_field() const {
  return condition_one_of_case() == kField ? static_cast<const ::qdrant::FieldCondition&>(*reinterpret_cast<::qdrant::FieldCondition*>(_impl_.condition_one_of_.field_))
                     : reinterpret_cast<const ::qdrant::FieldCondition&>(::qdrant::_FieldCondition_default_instance_);
}
inline const ::qdrant::FieldCondition& Condition::field() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Condition.field)
  return _internal_field();
}
inline ::qdrant::FieldCondition* PROTOBUF_NULLABLE Condition::unsafe_arena_release_field() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Condition.field)
  if (condition_one_of_case() == kField) {
    clear_has_condition_one_of();
    auto* temp = reinterpret_cast<::qdrant::FieldCondition*>(_impl_.condition_one_of_.field_);
    _impl_.condition_one_of_.field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_field(
    ::qdrant::FieldCondition* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_condition_one_of();
  if (value) {
    set_has_field();
    _impl_.condition_one_of_.field_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Condition.field)
}
inline ::qdrant::FieldCondition* PROTOBUF_NONNULL Condition::_internal_mutable_field() {
  if (condition_one_of_case() != kField) {
    clear_condition_one_of();
    set_has_field();
    _impl_.condition_one_of_.field_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::FieldCondition>(GetArena()));
  }
  return reinterpret_cast<::qdrant::FieldCondition*>(_impl_.condition_one_of_.field_);
}
inline ::qdrant::FieldCondition* PROTOBUF_NONNULL Condition::mutable_field()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::FieldCondition* _msg = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:qdrant.Condition.field)
  return _msg;
}

// .qdrant.IsEmptyCondition is_empty = 2;
inline bool Condition::has_is_empty() const {
  return condition_one_of_case() == kIsEmpty;
}
inline bool Condition::_internal_has_is_empty() const {
  return condition_one_of_case() == kIsEmpty;
}
inline void Condition::set_has_is_empty() {
  _impl_._oneof_case_[0] = kIsEmpty;
}
inline void Condition::clear_is_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (condition_one_of_case() == kIsEmpty) {
    if (GetArena() == nullptr) {
      delete _impl_.condition_one_of_.is_empty_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.condition_one_of_.is_empty_);
    }
    clear_has_condition_one_of();
  }
}
inline ::qdrant::IsEmptyCondition* PROTOBUF_NULLABLE Condition::release_is_empty() {
  // @@protoc_insertion_point(field_release:qdrant.Condition.is_empty)
  if (condition_one_of_case() == kIsEmpty) {
    clear_has_condition_one_of();
    auto* temp = reinterpret_cast<::qdrant::IsEmptyCondition*>(_impl_.condition_one_of_.is_empty_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.condition_one_of_.is_empty_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::IsEmptyCondition& Condition::_internal_is_empty() const {
  return condition_one_of_case() == kIsEmpty ? static_cast<const ::qdrant::IsEmptyCondition&>(*reinterpret_cast<::qdrant::IsEmptyCondition*>(_impl_.condition_one_of_.is_empty_))
                     : reinterpret_cast<const ::qdrant::IsEmptyCondition&>(::qdrant::_IsEmptyCondition_default_instance_);
}
inline const ::qdrant::IsEmptyCondition& Condition::is_empty() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Condition.is_empty)
  return _internal_is_empty();
}
inline ::qdrant::IsEmptyCondition* PROTOBUF_NULLABLE Condition::unsafe_arena_release_is_empty() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Condition.is_empty)
  if (condition_one_of_case() == kIsEmpty) {
    clear_has_condition_one_of();
    auto* temp = reinterpret_cast<::qdrant::IsEmptyCondition*>(_impl_.condition_one_of_.is_empty_);
    _impl_.condition_one_of_.is_empty_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_is_empty(
    ::qdrant::IsEmptyCondition* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_condition_one_of();
  if (value) {
    set_has_is_empty();
    _impl_.condition_one_of_.is_empty_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Condition.is_empty)
}
inline ::qdrant::IsEmptyCondition* PROTOBUF_NONNULL Condition::_internal_mutable_is_empty() {
  if (condition_one_of_case() != kIsEmpty) {
    clear_condition_one_of();
    set_has_is_empty();
    _impl_.condition_one_of_.is_empty_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::IsEmptyCondition>(GetArena()));
  }
  return reinterpret_cast<::qdrant::IsEmptyCondition*>(_impl_.condition_one_of_.is_empty_);
}
inline ::qdrant::IsEmptyCondition* PROTOBUF_NONNULL Condition::mutable_is_empty()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::IsEmptyCondition* _msg = _internal_mutable_is_empty();
  // @@protoc_insertion_point(field_mutable:qdrant.Condition.is_empty)
  return _msg;
}

// .qdrant.HasIdCondition has_id = 3;
inline bool Condition::has_has_id() const {
  return condition_one_of_case() == kHasId;
}
inline bool Condition::_internal_has_has_id() const {
  return condition_one_of_case() == kHasId;
}
inline void Condition::set_has_has_id() {
  _impl_._oneof_case_[0] = kHasId;
}
inline void Condition::clear_has_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (condition_one_of_case() == kHasId) {
    if (GetArena() == nullptr) {
      delete _impl_.condition_one_of_.has_id_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.condition_one_of_.has_id_);
    }
    clear_has_condition_one_of();
  }
}
inline ::qdrant::HasIdCondition* PROTOBUF_NULLABLE Condition::release_has_id() {
  // @@protoc_insertion_point(field_release:qdrant.Condition.has_id)
  if (condition_one_of_case() == kHasId) {
    clear_has_condition_one_of();
    auto* temp = reinterpret_cast<::qdrant::HasIdCondition*>(_impl_.condition_one_of_.has_id_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.condition_one_of_.has_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::HasIdCondition& Condition::_internal_has_id() const {
  return condition_one_of_case() == kHasId ? static_cast<const ::qdrant::HasIdCondition&>(*reinterpret_cast<::qdrant::HasIdCondition*>(_impl_.condition_one_of_.has_id_))
                     : reinterpret_cast<const ::qdrant::HasIdCondition&>(::qdrant::_HasIdCondition_default_instance_);
}
inline const ::qdrant::HasIdCondition& Condition::has_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Condition.has_id)
  return _internal_has_id();
}
inline ::qdrant::HasIdCondition* PROTOBUF_NULLABLE Condition::unsafe_arena_release_has_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Condition.has_id)
  if (condition_one_of_case() == kHasId) {
    clear_has_condition_one_of();
    auto* temp = reinterpret_cast<::qdrant::HasIdCondition*>(_impl_.condition_one_of_.has_id_);
    _impl_.condition_one_of_.has_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_has_id(
    ::qdrant::HasIdCondition* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_condition_one_of();
  if (value) {
    set_has_has_id();
    _impl_.condition_one_of_.has_id_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Condition.has_id)
}
inline ::qdrant::HasIdCondition* PROTOBUF_NONNULL Condition::_internal_mutable_has_id() {
  if (condition_one_of_case() != kHasId) {
    clear_condition_one_of();
    set_has_has_id();
    _impl_.condition_one_of_.has_id_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::HasIdCondition>(GetArena()));
  }
  return reinterpret_cast<::qdrant::HasIdCondition*>(_impl_.condition_one_of_.has_id_);
}
inline ::qdrant::HasIdCondition* PROTOBUF_NONNULL Condition::mutable_has_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::HasIdCondition* _msg = _internal_mutable_has_id();
  // @@protoc_insertion_point(field_mutable:qdrant.Condition.has_id)
  return _msg;
}

// .qdrant.Filter filter = 4;
inline bool Condition::has_filter() const {
  return condition_one_of_case() == kFilter;
}
inline bool Condition::_internal_has_filter() const {
  return condition_one_of_case() == kFilter;
}
inline void Condition::set_has_filter() {
  _impl_._oneof_case_[0] = kFilter;
}
inline void Condition::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (condition_one_of_case() == kFilter) {
    if (GetArena() == nullptr) {
      delete _impl_.condition_one_of_.filter_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.condition_one_of_.filter_);
    }
    clear_has_condition_one_of();
  }
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE Condition::release_filter() {
  // @@protoc_insertion_point(field_release:qdrant.Condition.filter)
  if (condition_one_of_case() == kFilter) {
    clear_has_condition_one_of();
    auto* temp = reinterpret_cast<::qdrant::Filter*>(_impl_.condition_one_of_.filter_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.condition_one_of_.filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Filter& Condition::_internal_filter() const {
  return condition_one_of_case() == kFilter ? static_cast<const ::qdrant::Filter&>(*reinterpret_cast<::qdrant::Filter*>(_impl_.condition_one_of_.filter_))
                     : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& Condition::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Condition.filter)
  return _internal_filter();
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE Condition::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Condition.filter)
  if (condition_one_of_case() == kFilter) {
    clear_has_condition_one_of();
    auto* temp = reinterpret_cast<::qdrant::Filter*>(_impl_.condition_one_of_.filter_);
    _impl_.condition_one_of_.filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_condition_one_of();
  if (value) {
    set_has_filter();
    _impl_.condition_one_of_.filter_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Condition.filter)
}
inline ::qdrant::Filter* PROTOBUF_NONNULL Condition::_internal_mutable_filter() {
  if (condition_one_of_case() != kFilter) {
    clear_condition_one_of();
    set_has_filter();
    _impl_.condition_one_of_.filter_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena()));
  }
  return reinterpret_cast<::qdrant::Filter*>(_impl_.condition_one_of_.filter_);
}
inline ::qdrant::Filter* PROTOBUF_NONNULL Condition::mutable_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.Condition.filter)
  return _msg;
}

// .qdrant.IsNullCondition is_null = 5;
inline bool Condition::has_is_null() const {
  return condition_one_of_case() == kIsNull;
}
inline bool Condition::_internal_has_is_null() const {
  return condition_one_of_case() == kIsNull;
}
inline void Condition::set_has_is_null() {
  _impl_._oneof_case_[0] = kIsNull;
}
inline void Condition::clear_is_null() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (condition_one_of_case() == kIsNull) {
    if (GetArena() == nullptr) {
      delete _impl_.condition_one_of_.is_null_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.condition_one_of_.is_null_);
    }
    clear_has_condition_one_of();
  }
}
inline ::qdrant::IsNullCondition* PROTOBUF_NULLABLE Condition::release_is_null() {
  // @@protoc_insertion_point(field_release:qdrant.Condition.is_null)
  if (condition_one_of_case() == kIsNull) {
    clear_has_condition_one_of();
    auto* temp = reinterpret_cast<::qdrant::IsNullCondition*>(_impl_.condition_one_of_.is_null_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.condition_one_of_.is_null_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::IsNullCondition& Condition::_internal_is_null() const {
  return condition_one_of_case() == kIsNull ? static_cast<const ::qdrant::IsNullCondition&>(*reinterpret_cast<::qdrant::IsNullCondition*>(_impl_.condition_one_of_.is_null_))
                     : reinterpret_cast<const ::qdrant::IsNullCondition&>(::qdrant::_IsNullCondition_default_instance_);
}
inline const ::qdrant::IsNullCondition& Condition::is_null() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Condition.is_null)
  return _internal_is_null();
}
inline ::qdrant::IsNullCondition* PROTOBUF_NULLABLE Condition::unsafe_arena_release_is_null() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Condition.is_null)
  if (condition_one_of_case() == kIsNull) {
    clear_has_condition_one_of();
    auto* temp = reinterpret_cast<::qdrant::IsNullCondition*>(_impl_.condition_one_of_.is_null_);
    _impl_.condition_one_of_.is_null_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_is_null(
    ::qdrant::IsNullCondition* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_condition_one_of();
  if (value) {
    set_has_is_null();
    _impl_.condition_one_of_.is_null_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Condition.is_null)
}
inline ::qdrant::IsNullCondition* PROTOBUF_NONNULL Condition::_internal_mutable_is_null() {
  if (condition_one_of_case() != kIsNull) {
    clear_condition_one_of();
    set_has_is_null();
    _impl_.condition_one_of_.is_null_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::IsNullCondition>(GetArena()));
  }
  return reinterpret_cast<::qdrant::IsNullCondition*>(_impl_.condition_one_of_.is_null_);
}
inline ::qdrant::IsNullCondition* PROTOBUF_NONNULL Condition::mutable_is_null()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::IsNullCondition* _msg = _internal_mutable_is_null();
  // @@protoc_insertion_point(field_mutable:qdrant.Condition.is_null)
  return _msg;
}

// .qdrant.NestedCondition nested = 6;
inline bool Condition::has_nested() const {
  return condition_one_of_case() == kNested;
}
inline bool Condition::_internal_has_nested() const {
  return condition_one_of_case() == kNested;
}
inline void Condition::set_has_nested() {
  _impl_._oneof_case_[0] = kNested;
}
inline void Condition::clear_nested() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (condition_one_of_case() == kNested) {
    if (GetArena() == nullptr) {
      delete _impl_.condition_one_of_.nested_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.condition_one_of_.nested_);
    }
    clear_has_condition_one_of();
  }
}
inline ::qdrant::NestedCondition* PROTOBUF_NULLABLE Condition::release_nested() {
  // @@protoc_insertion_point(field_release:qdrant.Condition.nested)
  if (condition_one_of_case() == kNested) {
    clear_has_condition_one_of();
    auto* temp = reinterpret_cast<::qdrant::NestedCondition*>(_impl_.condition_one_of_.nested_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.condition_one_of_.nested_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::NestedCondition& Condition::_internal_nested() const {
  return condition_one_of_case() == kNested ? static_cast<const ::qdrant::NestedCondition&>(*reinterpret_cast<::qdrant::NestedCondition*>(_impl_.condition_one_of_.nested_))
                     : reinterpret_cast<const ::qdrant::NestedCondition&>(::qdrant::_NestedCondition_default_instance_);
}
inline const ::qdrant::NestedCondition& Condition::nested() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Condition.nested)
  return _internal_nested();
}
inline ::qdrant::NestedCondition* PROTOBUF_NULLABLE Condition::unsafe_arena_release_nested() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Condition.nested)
  if (condition_one_of_case() == kNested) {
    clear_has_condition_one_of();
    auto* temp = reinterpret_cast<::qdrant::NestedCondition*>(_impl_.condition_one_of_.nested_);
    _impl_.condition_one_of_.nested_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_nested(
    ::qdrant::NestedCondition* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_condition_one_of();
  if (value) {
    set_has_nested();
    _impl_.condition_one_of_.nested_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Condition.nested)
}
inline ::qdrant::NestedCondition* PROTOBUF_NONNULL Condition::_internal_mutable_nested() {
  if (condition_one_of_case() != kNested) {
    clear_condition_one_of();
    set_has_nested();
    _impl_.condition_one_of_.nested_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::NestedCondition>(GetArena()));
  }
  return reinterpret_cast<::qdrant::NestedCondition*>(_impl_.condition_one_of_.nested_);
}
inline ::qdrant::NestedCondition* PROTOBUF_NONNULL Condition::mutable_nested()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::NestedCondition* _msg = _internal_mutable_nested();
  // @@protoc_insertion_point(field_mutable:qdrant.Condition.nested)
  return _msg;
}

// .qdrant.HasVectorCondition has_vector = 7;
inline bool Condition::has_has_vector() const {
  return condition_one_of_case() == kHasVector;
}
inline bool Condition::_internal_has_has_vector() const {
  return condition_one_of_case() == kHasVector;
}
inline void Condition::set_has_has_vector() {
  _impl_._oneof_case_[0] = kHasVector;
}
inline void Condition::clear_has_vector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (condition_one_of_case() == kHasVector) {
    if (GetArena() == nullptr) {
      delete _impl_.condition_one_of_.has_vector_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.condition_one_of_.has_vector_);
    }
    clear_has_condition_one_of();
  }
}
inline ::qdrant::HasVectorCondition* PROTOBUF_NULLABLE Condition::release_has_vector() {
  // @@protoc_insertion_point(field_release:qdrant.Condition.has_vector)
  if (condition_one_of_case() == kHasVector) {
    clear_has_condition_one_of();
    auto* temp = reinterpret_cast<::qdrant::HasVectorCondition*>(_impl_.condition_one_of_.has_vector_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.condition_one_of_.has_vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::HasVectorCondition& Condition::_internal_has_vector() const {
  return condition_one_of_case() == kHasVector ? static_cast<const ::qdrant::HasVectorCondition&>(*reinterpret_cast<::qdrant::HasVectorCondition*>(_impl_.condition_one_of_.has_vector_))
                     : reinterpret_cast<const ::qdrant::HasVectorCondition&>(::qdrant::_HasVectorCondition_default_instance_);
}
inline const ::qdrant::HasVectorCondition& Condition::has_vector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Condition.has_vector)
  return _internal_has_vector();
}
inline ::qdrant::HasVectorCondition* PROTOBUF_NULLABLE Condition::unsafe_arena_release_has_vector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Condition.has_vector)
  if (condition_one_of_case() == kHasVector) {
    clear_has_condition_one_of();
    auto* temp = reinterpret_cast<::qdrant::HasVectorCondition*>(_impl_.condition_one_of_.has_vector_);
    _impl_.condition_one_of_.has_vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_has_vector(
    ::qdrant::HasVectorCondition* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_condition_one_of();
  if (value) {
    set_has_has_vector();
    _impl_.condition_one_of_.has_vector_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Condition.has_vector)
}
inline ::qdrant::HasVectorCondition* PROTOBUF_NONNULL Condition::_internal_mutable_has_vector() {
  if (condition_one_of_case() != kHasVector) {
    clear_condition_one_of();
    set_has_has_vector();
    _impl_.condition_one_of_.has_vector_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::HasVectorCondition>(GetArena()));
  }
  return reinterpret_cast<::qdrant::HasVectorCondition*>(_impl_.condition_one_of_.has_vector_);
}
inline ::qdrant::HasVectorCondition* PROTOBUF_NONNULL Condition::mutable_has_vector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::HasVectorCondition* _msg = _internal_mutable_has_vector();
  // @@protoc_insertion_point(field_mutable:qdrant.Condition.has_vector)
  return _msg;
}

inline bool Condition::has_condition_one_of() const {
  return condition_one_of_case() != CONDITION_ONE_OF_NOT_SET;
}
inline void Condition::clear_has_condition_one_of() {
  _impl_._oneof_case_[0] = CONDITION_ONE_OF_NOT_SET;
}
inline Condition::ConditionOneOfCase Condition::condition_one_of_case() const {
  return Condition::ConditionOneOfCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// IsEmptyCondition

// string key = 1;
inline void IsEmptyCondition::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& IsEmptyCondition::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.IsEmptyCondition.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void IsEmptyCondition::set_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.IsEmptyCondition.key)
}
inline ::std::string* PROTOBUF_NONNULL IsEmptyCondition::mutable_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:qdrant.IsEmptyCondition.key)
  return _s;
}
inline const ::std::string& IsEmptyCondition::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void IsEmptyCondition::_internal_set_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL IsEmptyCondition::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE IsEmptyCondition::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.IsEmptyCondition.key)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.key_.Set("", GetArena());
  }
  return released;
}
inline void IsEmptyCondition::set_allocated_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.IsEmptyCondition.key)
}

// -------------------------------------------------------------------

// IsNullCondition

// string key = 1;
inline void IsNullCondition::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& IsNullCondition::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.IsNullCondition.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void IsNullCondition::set_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.IsNullCondition.key)
}
inline ::std::string* PROTOBUF_NONNULL IsNullCondition::mutable_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:qdrant.IsNullCondition.key)
  return _s;
}
inline const ::std::string& IsNullCondition::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void IsNullCondition::_internal_set_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL IsNullCondition::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE IsNullCondition::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.IsNullCondition.key)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.key_.Set("", GetArena());
  }
  return released;
}
inline void IsNullCondition::set_allocated_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.IsNullCondition.key)
}

// -------------------------------------------------------------------

// HasIdCondition

// repeated .qdrant.PointId has_id = 1;
inline int HasIdCondition::_internal_has_id_size() const {
  return _internal_has_id().size();
}
inline int HasIdCondition::has_id_size() const {
  return _internal_has_id_size();
}
inline void HasIdCondition::clear_has_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_id_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::PointId* PROTOBUF_NONNULL HasIdCondition::mutable_has_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.HasIdCondition.has_id)
  return _internal_mutable_has_id()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL HasIdCondition::mutable_has_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.HasIdCondition.has_id)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_has_id();
}
inline const ::qdrant::PointId& HasIdCondition::has_id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.HasIdCondition.has_id)
  return _internal_has_id().Get(index);
}
inline ::qdrant::PointId* PROTOBUF_NONNULL HasIdCondition::add_has_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::PointId* _add =
      _internal_mutable_has_id()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.HasIdCondition.has_id)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& HasIdCondition::has_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.HasIdCondition.has_id)
  return _internal_has_id();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>&
HasIdCondition::_internal_has_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_id_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL
HasIdCondition::_internal_mutable_has_id() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.has_id_;
}

// -------------------------------------------------------------------

// HasVectorCondition

// string has_vector = 1;
inline void HasVectorCondition::clear_has_vector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_vector_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& HasVectorCondition::has_vector() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.HasVectorCondition.has_vector)
  return _internal_has_vector();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void HasVectorCondition::set_has_vector(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.has_vector_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.HasVectorCondition.has_vector)
}
inline ::std::string* PROTOBUF_NONNULL HasVectorCondition::mutable_has_vector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_has_vector();
  // @@protoc_insertion_point(field_mutable:qdrant.HasVectorCondition.has_vector)
  return _s;
}
inline const ::std::string& HasVectorCondition::_internal_has_vector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_vector_.Get();
}
inline void HasVectorCondition::_internal_set_has_vector(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_vector_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL HasVectorCondition::_internal_mutable_has_vector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.has_vector_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE HasVectorCondition::release_has_vector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.HasVectorCondition.has_vector)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.has_vector_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.has_vector_.Set("", GetArena());
  }
  return released;
}
inline void HasVectorCondition::set_allocated_has_vector(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.has_vector_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.has_vector_.IsDefault()) {
    _impl_.has_vector_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.HasVectorCondition.has_vector)
}

// -------------------------------------------------------------------

// NestedCondition

// string key = 1;
inline void NestedCondition::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& NestedCondition::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.NestedCondition.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void NestedCondition::set_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.NestedCondition.key)
}
inline ::std::string* PROTOBUF_NONNULL NestedCondition::mutable_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:qdrant.NestedCondition.key)
  return _s;
}
inline const ::std::string& NestedCondition::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void NestedCondition::_internal_set_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL NestedCondition::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE NestedCondition::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.NestedCondition.key)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.key_.Set("", GetArena());
  }
  return released;
}
inline void NestedCondition::set_allocated_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.NestedCondition.key)
}

// .qdrant.Filter filter = 2;
inline bool NestedCondition::has_filter() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void NestedCondition::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Filter& NestedCondition::_internal_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Filter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& NestedCondition::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.NestedCondition.filter)
  return _internal_filter();
}
inline void NestedCondition::unsafe_arena_set_allocated_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.NestedCondition.filter)
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE NestedCondition::release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Filter* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE NestedCondition::unsafe_arena_release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.NestedCondition.filter)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL NestedCondition::_internal_mutable_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
    _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(p);
  }
  return _impl_.filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL NestedCondition::mutable_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.NestedCondition.filter)
  return _msg;
}
inline void NestedCondition::set_allocated_filter(::qdrant::Filter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.filter_ = reinterpret_cast<::qdrant::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.NestedCondition.filter)
}

// -------------------------------------------------------------------

// FieldCondition

// string key = 1;
inline void FieldCondition::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& FieldCondition::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.FieldCondition.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FieldCondition::set_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.FieldCondition.key)
}
inline ::std::string* PROTOBUF_NONNULL FieldCondition::mutable_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:qdrant.FieldCondition.key)
  return _s;
}
inline const ::std::string& FieldCondition::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void FieldCondition::_internal_set_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FieldCondition::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FieldCondition::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.FieldCondition.key)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.key_.Set("", GetArena());
  }
  return released;
}
inline void FieldCondition::set_allocated_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.FieldCondition.key)
}

// .qdrant.Match match = 2;
inline bool FieldCondition::has_match() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.match_ != nullptr);
  return value;
}
inline void FieldCondition::clear_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.match_ != nullptr) _impl_.match_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Match& FieldCondition::_internal_match() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Match* p = _impl_.match_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Match&>(::qdrant::_Match_default_instance_);
}
inline const ::qdrant::Match& FieldCondition::match() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.FieldCondition.match)
  return _internal_match();
}
inline void FieldCondition::unsafe_arena_set_allocated_match(
    ::qdrant::Match* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.match_);
  }
  _impl_.match_ = reinterpret_cast<::qdrant::Match*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.FieldCondition.match)
}
inline ::qdrant::Match* PROTOBUF_NULLABLE FieldCondition::release_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Match* released = _impl_.match_;
  _impl_.match_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Match* PROTOBUF_NULLABLE FieldCondition::unsafe_arena_release_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.FieldCondition.match)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Match* temp = _impl_.match_;
  _impl_.match_ = nullptr;
  return temp;
}
inline ::qdrant::Match* PROTOBUF_NONNULL FieldCondition::_internal_mutable_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.match_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Match>(GetArena());
    _impl_.match_ = reinterpret_cast<::qdrant::Match*>(p);
  }
  return _impl_.match_;
}
inline ::qdrant::Match* PROTOBUF_NONNULL FieldCondition::mutable_match()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Match* _msg = _internal_mutable_match();
  // @@protoc_insertion_point(field_mutable:qdrant.FieldCondition.match)
  return _msg;
}
inline void FieldCondition::set_allocated_match(::qdrant::Match* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.match_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.match_ = reinterpret_cast<::qdrant::Match*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.FieldCondition.match)
}

// .qdrant.Range range = 3;
inline bool FieldCondition::has_range() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.range_ != nullptr);
  return value;
}
inline void FieldCondition::clear_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.range_ != nullptr) _impl_.range_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::Range& FieldCondition::_internal_range() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Range* p = _impl_.range_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Range&>(::qdrant::_Range_default_instance_);
}
inline const ::qdrant::Range& FieldCondition::range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.FieldCondition.range)
  return _internal_range();
}
inline void FieldCondition::unsafe_arena_set_allocated_range(
    ::qdrant::Range* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.range_);
  }
  _impl_.range_ = reinterpret_cast<::qdrant::Range*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.FieldCondition.range)
}
inline ::qdrant::Range* PROTOBUF_NULLABLE FieldCondition::release_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Range* released = _impl_.range_;
  _impl_.range_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Range* PROTOBUF_NULLABLE FieldCondition::unsafe_arena_release_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.FieldCondition.range)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Range* temp = _impl_.range_;
  _impl_.range_ = nullptr;
  return temp;
}
inline ::qdrant::Range* PROTOBUF_NONNULL FieldCondition::_internal_mutable_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.range_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Range>(GetArena());
    _impl_.range_ = reinterpret_cast<::qdrant::Range*>(p);
  }
  return _impl_.range_;
}
inline ::qdrant::Range* PROTOBUF_NONNULL FieldCondition::mutable_range()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::Range* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:qdrant.FieldCondition.range)
  return _msg;
}
inline void FieldCondition::set_allocated_range(::qdrant::Range* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.range_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.range_ = reinterpret_cast<::qdrant::Range*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.FieldCondition.range)
}

// .qdrant.GeoBoundingBox geo_bounding_box = 4;
inline bool FieldCondition::has_geo_bounding_box() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.geo_bounding_box_ != nullptr);
  return value;
}
inline void FieldCondition::clear_geo_bounding_box() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.geo_bounding_box_ != nullptr) _impl_.geo_bounding_box_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::GeoBoundingBox& FieldCondition::_internal_geo_bounding_box() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::GeoBoundingBox* p = _impl_.geo_bounding_box_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::GeoBoundingBox&>(::qdrant::_GeoBoundingBox_default_instance_);
}
inline const ::qdrant::GeoBoundingBox& FieldCondition::geo_bounding_box() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.FieldCondition.geo_bounding_box)
  return _internal_geo_bounding_box();
}
inline void FieldCondition::unsafe_arena_set_allocated_geo_bounding_box(
    ::qdrant::GeoBoundingBox* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geo_bounding_box_);
  }
  _impl_.geo_bounding_box_ = reinterpret_cast<::qdrant::GeoBoundingBox*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.FieldCondition.geo_bounding_box)
}
inline ::qdrant::GeoBoundingBox* PROTOBUF_NULLABLE FieldCondition::release_geo_bounding_box() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::GeoBoundingBox* released = _impl_.geo_bounding_box_;
  _impl_.geo_bounding_box_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::GeoBoundingBox* PROTOBUF_NULLABLE FieldCondition::unsafe_arena_release_geo_bounding_box() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.FieldCondition.geo_bounding_box)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::GeoBoundingBox* temp = _impl_.geo_bounding_box_;
  _impl_.geo_bounding_box_ = nullptr;
  return temp;
}
inline ::qdrant::GeoBoundingBox* PROTOBUF_NONNULL FieldCondition::_internal_mutable_geo_bounding_box() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.geo_bounding_box_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::GeoBoundingBox>(GetArena());
    _impl_.geo_bounding_box_ = reinterpret_cast<::qdrant::GeoBoundingBox*>(p);
  }
  return _impl_.geo_bounding_box_;
}
inline ::qdrant::GeoBoundingBox* PROTOBUF_NONNULL FieldCondition::mutable_geo_bounding_box()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::GeoBoundingBox* _msg = _internal_mutable_geo_bounding_box();
  // @@protoc_insertion_point(field_mutable:qdrant.FieldCondition.geo_bounding_box)
  return _msg;
}
inline void FieldCondition::set_allocated_geo_bounding_box(::qdrant::GeoBoundingBox* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geo_bounding_box_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.geo_bounding_box_ = reinterpret_cast<::qdrant::GeoBoundingBox*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.FieldCondition.geo_bounding_box)
}

// .qdrant.GeoRadius geo_radius = 5;
inline bool FieldCondition::has_geo_radius() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.geo_radius_ != nullptr);
  return value;
}
inline void FieldCondition::clear_geo_radius() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.geo_radius_ != nullptr) _impl_.geo_radius_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::GeoRadius& FieldCondition::_internal_geo_radius() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::GeoRadius* p = _impl_.geo_radius_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::GeoRadius&>(::qdrant::_GeoRadius_default_instance_);
}
inline const ::qdrant::GeoRadius& FieldCondition::geo_radius() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.FieldCondition.geo_radius)
  return _internal_geo_radius();
}
inline void FieldCondition::unsafe_arena_set_allocated_geo_radius(
    ::qdrant::GeoRadius* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geo_radius_);
  }
  _impl_.geo_radius_ = reinterpret_cast<::qdrant::GeoRadius*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.FieldCondition.geo_radius)
}
inline ::qdrant::GeoRadius* PROTOBUF_NULLABLE FieldCondition::release_geo_radius() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::GeoRadius* released = _impl_.geo_radius_;
  _impl_.geo_radius_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::GeoRadius* PROTOBUF_NULLABLE FieldCondition::unsafe_arena_release_geo_radius() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.FieldCondition.geo_radius)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::GeoRadius* temp = _impl_.geo_radius_;
  _impl_.geo_radius_ = nullptr;
  return temp;
}
inline ::qdrant::GeoRadius* PROTOBUF_NONNULL FieldCondition::_internal_mutable_geo_radius() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.geo_radius_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::GeoRadius>(GetArena());
    _impl_.geo_radius_ = reinterpret_cast<::qdrant::GeoRadius*>(p);
  }
  return _impl_.geo_radius_;
}
inline ::qdrant::GeoRadius* PROTOBUF_NONNULL FieldCondition::mutable_geo_radius()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::GeoRadius* _msg = _internal_mutable_geo_radius();
  // @@protoc_insertion_point(field_mutable:qdrant.FieldCondition.geo_radius)
  return _msg;
}
inline void FieldCondition::set_allocated_geo_radius(::qdrant::GeoRadius* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geo_radius_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.geo_radius_ = reinterpret_cast<::qdrant::GeoRadius*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.FieldCondition.geo_radius)
}

// .qdrant.ValuesCount values_count = 6;
inline bool FieldCondition::has_values_count() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.values_count_ != nullptr);
  return value;
}
inline void FieldCondition::clear_values_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.values_count_ != nullptr) _impl_.values_count_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::qdrant::ValuesCount& FieldCondition::_internal_values_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ValuesCount* p = _impl_.values_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ValuesCount&>(::qdrant::_ValuesCount_default_instance_);
}
inline const ::qdrant::ValuesCount& FieldCondition::values_count() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.FieldCondition.values_count)
  return _internal_values_count();
}
inline void FieldCondition::unsafe_arena_set_allocated_values_count(
    ::qdrant::ValuesCount* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.values_count_);
  }
  _impl_.values_count_ = reinterpret_cast<::qdrant::ValuesCount*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.FieldCondition.values_count)
}
inline ::qdrant::ValuesCount* PROTOBUF_NULLABLE FieldCondition::release_values_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::ValuesCount* released = _impl_.values_count_;
  _impl_.values_count_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ValuesCount* PROTOBUF_NULLABLE FieldCondition::unsafe_arena_release_values_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.FieldCondition.values_count)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::ValuesCount* temp = _impl_.values_count_;
  _impl_.values_count_ = nullptr;
  return temp;
}
inline ::qdrant::ValuesCount* PROTOBUF_NONNULL FieldCondition::_internal_mutable_values_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.values_count_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ValuesCount>(GetArena());
    _impl_.values_count_ = reinterpret_cast<::qdrant::ValuesCount*>(p);
  }
  return _impl_.values_count_;
}
inline ::qdrant::ValuesCount* PROTOBUF_NONNULL FieldCondition::mutable_values_count()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::ValuesCount* _msg = _internal_mutable_values_count();
  // @@protoc_insertion_point(field_mutable:qdrant.FieldCondition.values_count)
  return _msg;
}
inline void FieldCondition::set_allocated_values_count(::qdrant::ValuesCount* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.values_count_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.values_count_ = reinterpret_cast<::qdrant::ValuesCount*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.FieldCondition.values_count)
}

// .qdrant.GeoPolygon geo_polygon = 7;
inline bool FieldCondition::has_geo_polygon() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  PROTOBUF_ASSUME(!value || _impl_.geo_polygon_ != nullptr);
  return value;
}
inline void FieldCondition::clear_geo_polygon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.geo_polygon_ != nullptr) _impl_.geo_polygon_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::qdrant::GeoPolygon& FieldCondition::_internal_geo_polygon() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::GeoPolygon* p = _impl_.geo_polygon_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::GeoPolygon&>(::qdrant::_GeoPolygon_default_instance_);
}
inline const ::qdrant::GeoPolygon& FieldCondition::geo_polygon() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.FieldCondition.geo_polygon)
  return _internal_geo_polygon();
}
inline void FieldCondition::unsafe_arena_set_allocated_geo_polygon(
    ::qdrant::GeoPolygon* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geo_polygon_);
  }
  _impl_.geo_polygon_ = reinterpret_cast<::qdrant::GeoPolygon*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.FieldCondition.geo_polygon)
}
inline ::qdrant::GeoPolygon* PROTOBUF_NULLABLE FieldCondition::release_geo_polygon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::GeoPolygon* released = _impl_.geo_polygon_;
  _impl_.geo_polygon_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::GeoPolygon* PROTOBUF_NULLABLE FieldCondition::unsafe_arena_release_geo_polygon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.FieldCondition.geo_polygon)

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::GeoPolygon* temp = _impl_.geo_polygon_;
  _impl_.geo_polygon_ = nullptr;
  return temp;
}
inline ::qdrant::GeoPolygon* PROTOBUF_NONNULL FieldCondition::_internal_mutable_geo_polygon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.geo_polygon_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::GeoPolygon>(GetArena());
    _impl_.geo_polygon_ = reinterpret_cast<::qdrant::GeoPolygon*>(p);
  }
  return _impl_.geo_polygon_;
}
inline ::qdrant::GeoPolygon* PROTOBUF_NONNULL FieldCondition::mutable_geo_polygon()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::GeoPolygon* _msg = _internal_mutable_geo_polygon();
  // @@protoc_insertion_point(field_mutable:qdrant.FieldCondition.geo_polygon)
  return _msg;
}
inline void FieldCondition::set_allocated_geo_polygon(::qdrant::GeoPolygon* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geo_polygon_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }

  _impl_.geo_polygon_ = reinterpret_cast<::qdrant::GeoPolygon*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.FieldCondition.geo_polygon)
}

// .qdrant.DatetimeRange datetime_range = 8;
inline bool FieldCondition::has_datetime_range() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  PROTOBUF_ASSUME(!value || _impl_.datetime_range_ != nullptr);
  return value;
}
inline void FieldCondition::clear_datetime_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.datetime_range_ != nullptr) _impl_.datetime_range_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline const ::qdrant::DatetimeRange& FieldCondition::_internal_datetime_range() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::DatetimeRange* p = _impl_.datetime_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::DatetimeRange&>(::qdrant::_DatetimeRange_default_instance_);
}
inline const ::qdrant::DatetimeRange& FieldCondition::datetime_range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.FieldCondition.datetime_range)
  return _internal_datetime_range();
}
inline void FieldCondition::unsafe_arena_set_allocated_datetime_range(
    ::qdrant::DatetimeRange* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.datetime_range_);
  }
  _impl_.datetime_range_ = reinterpret_cast<::qdrant::DatetimeRange*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.FieldCondition.datetime_range)
}
inline ::qdrant::DatetimeRange* PROTOBUF_NULLABLE FieldCondition::release_datetime_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::DatetimeRange* released = _impl_.datetime_range_;
  _impl_.datetime_range_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::DatetimeRange* PROTOBUF_NULLABLE FieldCondition::unsafe_arena_release_datetime_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.FieldCondition.datetime_range)

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::DatetimeRange* temp = _impl_.datetime_range_;
  _impl_.datetime_range_ = nullptr;
  return temp;
}
inline ::qdrant::DatetimeRange* PROTOBUF_NONNULL FieldCondition::_internal_mutable_datetime_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.datetime_range_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::DatetimeRange>(GetArena());
    _impl_.datetime_range_ = reinterpret_cast<::qdrant::DatetimeRange*>(p);
  }
  return _impl_.datetime_range_;
}
inline ::qdrant::DatetimeRange* PROTOBUF_NONNULL FieldCondition::mutable_datetime_range()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::DatetimeRange* _msg = _internal_mutable_datetime_range();
  // @@protoc_insertion_point(field_mutable:qdrant.FieldCondition.datetime_range)
  return _msg;
}
inline void FieldCondition::set_allocated_datetime_range(::qdrant::DatetimeRange* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.datetime_range_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }

  _impl_.datetime_range_ = reinterpret_cast<::qdrant::DatetimeRange*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.FieldCondition.datetime_range)
}

// optional bool is_empty = 9;
inline bool FieldCondition::has_is_empty() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000100U);
  return value;
}
inline void FieldCondition::clear_is_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_empty_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline bool FieldCondition::is_empty() const {
  // @@protoc_insertion_point(field_get:qdrant.FieldCondition.is_empty)
  return _internal_is_empty();
}
inline void FieldCondition::set_is_empty(bool value) {
  _internal_set_is_empty(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  // @@protoc_insertion_point(field_set:qdrant.FieldCondition.is_empty)
}
inline bool FieldCondition::_internal_is_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_empty_;
}
inline void FieldCondition::_internal_set_is_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_empty_ = value;
}

// optional bool is_null = 10;
inline bool FieldCondition::has_is_null() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000200U);
  return value;
}
inline void FieldCondition::clear_is_null() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_null_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000200U);
}
inline bool FieldCondition::is_null() const {
  // @@protoc_insertion_point(field_get:qdrant.FieldCondition.is_null)
  return _internal_is_null();
}
inline void FieldCondition::set_is_null(bool value) {
  _internal_set_is_null(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  // @@protoc_insertion_point(field_set:qdrant.FieldCondition.is_null)
}
inline bool FieldCondition::_internal_is_null() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_null_;
}
inline void FieldCondition::_internal_set_is_null(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_null_ = value;
}

// -------------------------------------------------------------------

// Match

// string keyword = 1;
inline bool Match::has_keyword() const {
  return match_value_case() == kKeyword;
}
inline void Match::set_has_keyword() {
  _impl_._oneof_case_[0] = kKeyword;
}
inline void Match::clear_keyword() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (match_value_case() == kKeyword) {
    _impl_.match_value_.keyword_.Destroy();
    clear_has_match_value();
  }
}
inline const ::std::string& Match::keyword() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Match.keyword)
  return _internal_keyword();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Match::set_keyword(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (match_value_case() != kKeyword) {
    clear_match_value();

    set_has_keyword();
    _impl_.match_value_.keyword_.InitDefault();
  }
  _impl_.match_value_.keyword_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.Match.keyword)
}
inline ::std::string* PROTOBUF_NONNULL Match::mutable_keyword()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  if (match_value_case() != kKeyword) {
    clear_match_value();

    set_has_keyword();
    _impl_.match_value_.keyword_.InitDefault();
  }
  ::std::string* _s = _internal_mutable_keyword();
  // @@protoc_insertion_point(field_mutable:qdrant.Match.keyword)
  return _s;
}
inline const ::std::string& Match::_internal_keyword() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (match_value_case() != kKeyword) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.match_value_.keyword_.Get();
}
inline void Match::_internal_set_keyword(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.match_value_.keyword_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Match::_internal_mutable_keyword() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.match_value_.keyword_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Match::release_keyword() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.Match.keyword)
  if (match_value_case() != kKeyword) {
    return nullptr;
  }
  clear_has_match_value();
  return _impl_.match_value_.keyword_.Release();
}
inline void Match::set_allocated_keyword(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_match_value()) {
    clear_match_value();
  }
  if (value != nullptr) {
    set_has_keyword();
    _impl_.match_value_.keyword_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.Match.keyword)
}

// int64 integer = 2;
inline bool Match::has_integer() const {
  return match_value_case() == kInteger;
}
inline void Match::set_has_integer() {
  _impl_._oneof_case_[0] = kInteger;
}
inline void Match::clear_integer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (match_value_case() == kInteger) {
    _impl_.match_value_.integer_ = ::int64_t{0};
    clear_has_match_value();
  }
}
inline ::int64_t Match::integer() const {
  // @@protoc_insertion_point(field_get:qdrant.Match.integer)
  return _internal_integer();
}
inline void Match::set_integer(::int64_t value) {
  if (match_value_case() != kInteger) {
    clear_match_value();
    set_has_integer();
  }
  _impl_.match_value_.integer_ = value;
  // @@protoc_insertion_point(field_set:qdrant.Match.integer)
}
inline ::int64_t Match::_internal_integer() const {
  if (match_value_case() == kInteger) {
    return _impl_.match_value_.integer_;
  }
  return ::int64_t{0};
}

// bool boolean = 3;
inline bool Match::has_boolean() const {
  return match_value_case() == kBoolean;
}
inline void Match::set_has_boolean() {
  _impl_._oneof_case_[0] = kBoolean;
}
inline void Match::clear_boolean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (match_value_case() == kBoolean) {
    _impl_.match_value_.boolean_ = false;
    clear_has_match_value();
  }
}
inline bool Match::boolean() const {
  // @@protoc_insertion_point(field_get:qdrant.Match.boolean)
  return _internal_boolean();
}
inline void Match::set_boolean(bool value) {
  if (match_value_case() != kBoolean) {
    clear_match_value();
    set_has_boolean();
  }
  _impl_.match_value_.boolean_ = value;
  // @@protoc_insertion_point(field_set:qdrant.Match.boolean)
}
inline bool Match::_internal_boolean() const {
  if (match_value_case() == kBoolean) {
    return _impl_.match_value_.boolean_;
  }
  return false;
}

// string text = 4;
inline bool Match::has_text() const {
  return match_value_case() == kText;
}
inline void Match::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void Match::clear_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (match_value_case() == kText) {
    _impl_.match_value_.text_.Destroy();
    clear_has_match_value();
  }
}
inline const ::std::string& Match::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Match.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Match::set_text(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (match_value_case() != kText) {
    clear_match_value();

    set_has_text();
    _impl_.match_value_.text_.InitDefault();
  }
  _impl_.match_value_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.Match.text)
}
inline ::std::string* PROTOBUF_NONNULL Match::mutable_text()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  if (match_value_case() != kText) {
    clear_match_value();

    set_has_text();
    _impl_.match_value_.text_.InitDefault();
  }
  ::std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:qdrant.Match.text)
  return _s;
}
inline const ::std::string& Match::_internal_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (match_value_case() != kText) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.match_value_.text_.Get();
}
inline void Match::_internal_set_text(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.match_value_.text_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Match::_internal_mutable_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.match_value_.text_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Match::release_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.Match.text)
  if (match_value_case() != kText) {
    return nullptr;
  }
  clear_has_match_value();
  return _impl_.match_value_.text_.Release();
}
inline void Match::set_allocated_text(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_match_value()) {
    clear_match_value();
  }
  if (value != nullptr) {
    set_has_text();
    _impl_.match_value_.text_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.Match.text)
}

// .qdrant.RepeatedStrings keywords = 5;
inline bool Match::has_keywords() const {
  return match_value_case() == kKeywords;
}
inline bool Match::_internal_has_keywords() const {
  return match_value_case() == kKeywords;
}
inline void Match::set_has_keywords() {
  _impl_._oneof_case_[0] = kKeywords;
}
inline void Match::clear_keywords() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (match_value_case() == kKeywords) {
    if (GetArena() == nullptr) {
      delete _impl_.match_value_.keywords_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.match_value_.keywords_);
    }
    clear_has_match_value();
  }
}
inline ::qdrant::RepeatedStrings* PROTOBUF_NULLABLE Match::release_keywords() {
  // @@protoc_insertion_point(field_release:qdrant.Match.keywords)
  if (match_value_case() == kKeywords) {
    clear_has_match_value();
    auto* temp = reinterpret_cast<::qdrant::RepeatedStrings*>(_impl_.match_value_.keywords_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.match_value_.keywords_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::RepeatedStrings& Match::_internal_keywords() const {
  return match_value_case() == kKeywords ? static_cast<const ::qdrant::RepeatedStrings&>(*reinterpret_cast<::qdrant::RepeatedStrings*>(_impl_.match_value_.keywords_))
                     : reinterpret_cast<const ::qdrant::RepeatedStrings&>(::qdrant::_RepeatedStrings_default_instance_);
}
inline const ::qdrant::RepeatedStrings& Match::keywords() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Match.keywords)
  return _internal_keywords();
}
inline ::qdrant::RepeatedStrings* PROTOBUF_NULLABLE Match::unsafe_arena_release_keywords() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Match.keywords)
  if (match_value_case() == kKeywords) {
    clear_has_match_value();
    auto* temp = reinterpret_cast<::qdrant::RepeatedStrings*>(_impl_.match_value_.keywords_);
    _impl_.match_value_.keywords_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Match::unsafe_arena_set_allocated_keywords(
    ::qdrant::RepeatedStrings* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_match_value();
  if (value) {
    set_has_keywords();
    _impl_.match_value_.keywords_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Match.keywords)
}
inline ::qdrant::RepeatedStrings* PROTOBUF_NONNULL Match::_internal_mutable_keywords() {
  if (match_value_case() != kKeywords) {
    clear_match_value();
    set_has_keywords();
    _impl_.match_value_.keywords_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::RepeatedStrings>(GetArena()));
  }
  return reinterpret_cast<::qdrant::RepeatedStrings*>(_impl_.match_value_.keywords_);
}
inline ::qdrant::RepeatedStrings* PROTOBUF_NONNULL Match::mutable_keywords()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::RepeatedStrings* _msg = _internal_mutable_keywords();
  // @@protoc_insertion_point(field_mutable:qdrant.Match.keywords)
  return _msg;
}

// .qdrant.RepeatedIntegers integers = 6;
inline bool Match::has_integers() const {
  return match_value_case() == kIntegers;
}
inline bool Match::_internal_has_integers() const {
  return match_value_case() == kIntegers;
}
inline void Match::set_has_integers() {
  _impl_._oneof_case_[0] = kIntegers;
}
inline void Match::clear_integers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (match_value_case() == kIntegers) {
    if (GetArena() == nullptr) {
      delete _impl_.match_value_.integers_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.match_value_.integers_);
    }
    clear_has_match_value();
  }
}
inline ::qdrant::RepeatedIntegers* PROTOBUF_NULLABLE Match::release_integers() {
  // @@protoc_insertion_point(field_release:qdrant.Match.integers)
  if (match_value_case() == kIntegers) {
    clear_has_match_value();
    auto* temp = reinterpret_cast<::qdrant::RepeatedIntegers*>(_impl_.match_value_.integers_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.match_value_.integers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::RepeatedIntegers& Match::_internal_integers() const {
  return match_value_case() == kIntegers ? static_cast<const ::qdrant::RepeatedIntegers&>(*reinterpret_cast<::qdrant::RepeatedIntegers*>(_impl_.match_value_.integers_))
                     : reinterpret_cast<const ::qdrant::RepeatedIntegers&>(::qdrant::_RepeatedIntegers_default_instance_);
}
inline const ::qdrant::RepeatedIntegers& Match::integers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Match.integers)
  return _internal_integers();
}
inline ::qdrant::RepeatedIntegers* PROTOBUF_NULLABLE Match::unsafe_arena_release_integers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Match.integers)
  if (match_value_case() == kIntegers) {
    clear_has_match_value();
    auto* temp = reinterpret_cast<::qdrant::RepeatedIntegers*>(_impl_.match_value_.integers_);
    _impl_.match_value_.integers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Match::unsafe_arena_set_allocated_integers(
    ::qdrant::RepeatedIntegers* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_match_value();
  if (value) {
    set_has_integers();
    _impl_.match_value_.integers_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Match.integers)
}
inline ::qdrant::RepeatedIntegers* PROTOBUF_NONNULL Match::_internal_mutable_integers() {
  if (match_value_case() != kIntegers) {
    clear_match_value();
    set_has_integers();
    _impl_.match_value_.integers_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::RepeatedIntegers>(GetArena()));
  }
  return reinterpret_cast<::qdrant::RepeatedIntegers*>(_impl_.match_value_.integers_);
}
inline ::qdrant::RepeatedIntegers* PROTOBUF_NONNULL Match::mutable_integers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::RepeatedIntegers* _msg = _internal_mutable_integers();
  // @@protoc_insertion_point(field_mutable:qdrant.Match.integers)
  return _msg;
}

// .qdrant.RepeatedIntegers except_integers = 7;
inline bool Match::has_except_integers() const {
  return match_value_case() == kExceptIntegers;
}
inline bool Match::_internal_has_except_integers() const {
  return match_value_case() == kExceptIntegers;
}
inline void Match::set_has_except_integers() {
  _impl_._oneof_case_[0] = kExceptIntegers;
}
inline void Match::clear_except_integers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (match_value_case() == kExceptIntegers) {
    if (GetArena() == nullptr) {
      delete _impl_.match_value_.except_integers_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.match_value_.except_integers_);
    }
    clear_has_match_value();
  }
}
inline ::qdrant::RepeatedIntegers* PROTOBUF_NULLABLE Match::release_except_integers() {
  // @@protoc_insertion_point(field_release:qdrant.Match.except_integers)
  if (match_value_case() == kExceptIntegers) {
    clear_has_match_value();
    auto* temp = reinterpret_cast<::qdrant::RepeatedIntegers*>(_impl_.match_value_.except_integers_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.match_value_.except_integers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::RepeatedIntegers& Match::_internal_except_integers() const {
  return match_value_case() == kExceptIntegers ? static_cast<const ::qdrant::RepeatedIntegers&>(*reinterpret_cast<::qdrant::RepeatedIntegers*>(_impl_.match_value_.except_integers_))
                     : reinterpret_cast<const ::qdrant::RepeatedIntegers&>(::qdrant::_RepeatedIntegers_default_instance_);
}
inline const ::qdrant::RepeatedIntegers& Match::except_integers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Match.except_integers)
  return _internal_except_integers();
}
inline ::qdrant::RepeatedIntegers* PROTOBUF_NULLABLE Match::unsafe_arena_release_except_integers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Match.except_integers)
  if (match_value_case() == kExceptIntegers) {
    clear_has_match_value();
    auto* temp = reinterpret_cast<::qdrant::RepeatedIntegers*>(_impl_.match_value_.except_integers_);
    _impl_.match_value_.except_integers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Match::unsafe_arena_set_allocated_except_integers(
    ::qdrant::RepeatedIntegers* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_match_value();
  if (value) {
    set_has_except_integers();
    _impl_.match_value_.except_integers_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Match.except_integers)
}
inline ::qdrant::RepeatedIntegers* PROTOBUF_NONNULL Match::_internal_mutable_except_integers() {
  if (match_value_case() != kExceptIntegers) {
    clear_match_value();
    set_has_except_integers();
    _impl_.match_value_.except_integers_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::RepeatedIntegers>(GetArena()));
  }
  return reinterpret_cast<::qdrant::RepeatedIntegers*>(_impl_.match_value_.except_integers_);
}
inline ::qdrant::RepeatedIntegers* PROTOBUF_NONNULL Match::mutable_except_integers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::RepeatedIntegers* _msg = _internal_mutable_except_integers();
  // @@protoc_insertion_point(field_mutable:qdrant.Match.except_integers)
  return _msg;
}

// .qdrant.RepeatedStrings except_keywords = 8;
inline bool Match::has_except_keywords() const {
  return match_value_case() == kExceptKeywords;
}
inline bool Match::_internal_has_except_keywords() const {
  return match_value_case() == kExceptKeywords;
}
inline void Match::set_has_except_keywords() {
  _impl_._oneof_case_[0] = kExceptKeywords;
}
inline void Match::clear_except_keywords() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (match_value_case() == kExceptKeywords) {
    if (GetArena() == nullptr) {
      delete _impl_.match_value_.except_keywords_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.match_value_.except_keywords_);
    }
    clear_has_match_value();
  }
}
inline ::qdrant::RepeatedStrings* PROTOBUF_NULLABLE Match::release_except_keywords() {
  // @@protoc_insertion_point(field_release:qdrant.Match.except_keywords)
  if (match_value_case() == kExceptKeywords) {
    clear_has_match_value();
    auto* temp = reinterpret_cast<::qdrant::RepeatedStrings*>(_impl_.match_value_.except_keywords_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.match_value_.except_keywords_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::RepeatedStrings& Match::_internal_except_keywords() const {
  return match_value_case() == kExceptKeywords ? static_cast<const ::qdrant::RepeatedStrings&>(*reinterpret_cast<::qdrant::RepeatedStrings*>(_impl_.match_value_.except_keywords_))
                     : reinterpret_cast<const ::qdrant::RepeatedStrings&>(::qdrant::_RepeatedStrings_default_instance_);
}
inline const ::qdrant::RepeatedStrings& Match::except_keywords() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Match.except_keywords)
  return _internal_except_keywords();
}
inline ::qdrant::RepeatedStrings* PROTOBUF_NULLABLE Match::unsafe_arena_release_except_keywords() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.Match.except_keywords)
  if (match_value_case() == kExceptKeywords) {
    clear_has_match_value();
    auto* temp = reinterpret_cast<::qdrant::RepeatedStrings*>(_impl_.match_value_.except_keywords_);
    _impl_.match_value_.except_keywords_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Match::unsafe_arena_set_allocated_except_keywords(
    ::qdrant::RepeatedStrings* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_match_value();
  if (value) {
    set_has_except_keywords();
    _impl_.match_value_.except_keywords_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Match.except_keywords)
}
inline ::qdrant::RepeatedStrings* PROTOBUF_NONNULL Match::_internal_mutable_except_keywords() {
  if (match_value_case() != kExceptKeywords) {
    clear_match_value();
    set_has_except_keywords();
    _impl_.match_value_.except_keywords_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::RepeatedStrings>(GetArena()));
  }
  return reinterpret_cast<::qdrant::RepeatedStrings*>(_impl_.match_value_.except_keywords_);
}
inline ::qdrant::RepeatedStrings* PROTOBUF_NONNULL Match::mutable_except_keywords()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::RepeatedStrings* _msg = _internal_mutable_except_keywords();
  // @@protoc_insertion_point(field_mutable:qdrant.Match.except_keywords)
  return _msg;
}

// string phrase = 9;
inline bool Match::has_phrase() const {
  return match_value_case() == kPhrase;
}
inline void Match::set_has_phrase() {
  _impl_._oneof_case_[0] = kPhrase;
}
inline void Match::clear_phrase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (match_value_case() == kPhrase) {
    _impl_.match_value_.phrase_.Destroy();
    clear_has_match_value();
  }
}
inline const ::std::string& Match::phrase() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Match.phrase)
  return _internal_phrase();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Match::set_phrase(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (match_value_case() != kPhrase) {
    clear_match_value();

    set_has_phrase();
    _impl_.match_value_.phrase_.InitDefault();
  }
  _impl_.match_value_.phrase_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.Match.phrase)
}
inline ::std::string* PROTOBUF_NONNULL Match::mutable_phrase()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  if (match_value_case() != kPhrase) {
    clear_match_value();

    set_has_phrase();
    _impl_.match_value_.phrase_.InitDefault();
  }
  ::std::string* _s = _internal_mutable_phrase();
  // @@protoc_insertion_point(field_mutable:qdrant.Match.phrase)
  return _s;
}
inline const ::std::string& Match::_internal_phrase() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (match_value_case() != kPhrase) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.match_value_.phrase_.Get();
}
inline void Match::_internal_set_phrase(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.match_value_.phrase_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Match::_internal_mutable_phrase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.match_value_.phrase_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Match::release_phrase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.Match.phrase)
  if (match_value_case() != kPhrase) {
    return nullptr;
  }
  clear_has_match_value();
  return _impl_.match_value_.phrase_.Release();
}
inline void Match::set_allocated_phrase(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_match_value()) {
    clear_match_value();
  }
  if (value != nullptr) {
    set_has_phrase();
    _impl_.match_value_.phrase_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.Match.phrase)
}

// string text_any = 10;
inline bool Match::has_text_any() const {
  return match_value_case() == kTextAny;
}
inline void Match::set_has_text_any() {
  _impl_._oneof_case_[0] = kTextAny;
}
inline void Match::clear_text_any() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (match_value_case() == kTextAny) {
    _impl_.match_value_.text_any_.Destroy();
    clear_has_match_value();
  }
}
inline const ::std::string& Match::text_any() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Match.text_any)
  return _internal_text_any();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Match::set_text_any(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (match_value_case() != kTextAny) {
    clear_match_value();

    set_has_text_any();
    _impl_.match_value_.text_any_.InitDefault();
  }
  _impl_.match_value_.text_any_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.Match.text_any)
}
inline ::std::string* PROTOBUF_NONNULL Match::mutable_text_any()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  if (match_value_case() != kTextAny) {
    clear_match_value();

    set_has_text_any();
    _impl_.match_value_.text_any_.InitDefault();
  }
  ::std::string* _s = _internal_mutable_text_any();
  // @@protoc_insertion_point(field_mutable:qdrant.Match.text_any)
  return _s;
}
inline const ::std::string& Match::_internal_text_any() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (match_value_case() != kTextAny) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.match_value_.text_any_.Get();
}
inline void Match::_internal_set_text_any(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.match_value_.text_any_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Match::_internal_mutable_text_any() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.match_value_.text_any_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Match::release_text_any() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.Match.text_any)
  if (match_value_case() != kTextAny) {
    return nullptr;
  }
  clear_has_match_value();
  return _impl_.match_value_.text_any_.Release();
}
inline void Match::set_allocated_text_any(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_match_value()) {
    clear_match_value();
  }
  if (value != nullptr) {
    set_has_text_any();
    _impl_.match_value_.text_any_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.Match.text_any)
}

inline bool Match::has_match_value() const {
  return match_value_case() != MATCH_VALUE_NOT_SET;
}
inline void Match::clear_has_match_value() {
  _impl_._oneof_case_[0] = MATCH_VALUE_NOT_SET;
}
inline Match::MatchValueCase Match::match_value_case() const {
  return Match::MatchValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RepeatedStrings

// repeated string strings = 1;
inline int RepeatedStrings::_internal_strings_size() const {
  return _internal_strings().size();
}
inline int RepeatedStrings::strings_size() const {
  return _internal_strings_size();
}
inline void RepeatedStrings::clear_strings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strings_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL RepeatedStrings::add_strings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_strings()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:qdrant.RepeatedStrings.strings)
  return _s;
}
inline const ::std::string& RepeatedStrings::strings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RepeatedStrings.strings)
  return _internal_strings().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL RepeatedStrings::mutable_strings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.RepeatedStrings.strings)
  return _internal_mutable_strings()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void RepeatedStrings::set_strings(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_strings()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:qdrant.RepeatedStrings.strings)
}
template <typename Arg_, typename... Args_>
inline void RepeatedStrings::add_strings(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_strings(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.RepeatedStrings.strings)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& RepeatedStrings::strings()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.RepeatedStrings.strings)
  return _internal_strings();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
RepeatedStrings::mutable_strings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.RepeatedStrings.strings)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_strings();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
RepeatedStrings::_internal_strings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.strings_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
RepeatedStrings::_internal_mutable_strings() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.strings_;
}

// -------------------------------------------------------------------

// RepeatedIntegers

// repeated int64 integers = 1;
inline int RepeatedIntegers::_internal_integers_size() const {
  return _internal_integers().size();
}
inline int RepeatedIntegers::integers_size() const {
  return _internal_integers_size();
}
inline void RepeatedIntegers::clear_integers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.integers_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int64_t RepeatedIntegers::integers(int index) const {
  // @@protoc_insertion_point(field_get:qdrant.RepeatedIntegers.integers)
  return _internal_integers().Get(index);
}
inline void RepeatedIntegers::set_integers(int index, ::int64_t value) {
  _internal_mutable_integers()->Set(index, value);
  // @@protoc_insertion_point(field_set:qdrant.RepeatedIntegers.integers)
}
inline void RepeatedIntegers::add_integers(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_integers()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.RepeatedIntegers.integers)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& RepeatedIntegers::integers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.RepeatedIntegers.integers)
  return _internal_integers();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL RepeatedIntegers::mutable_integers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.RepeatedIntegers.integers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_integers();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
RepeatedIntegers::_internal_integers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.integers_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
RepeatedIntegers::_internal_mutable_integers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.integers_;
}

// -------------------------------------------------------------------

// Range

// optional double lt = 1;
inline bool Range::has_lt() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void Range::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline double Range::lt() const {
  // @@protoc_insertion_point(field_get:qdrant.Range.lt)
  return _internal_lt();
}
inline void Range::set_lt(double value) {
  _internal_set_lt(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.Range.lt)
}
inline double Range::_internal_lt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lt_;
}
inline void Range::_internal_set_lt(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = value;
}

// optional double gt = 2;
inline bool Range::has_gt() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void Range::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline double Range::gt() const {
  // @@protoc_insertion_point(field_get:qdrant.Range.gt)
  return _internal_gt();
}
inline void Range::set_gt(double value) {
  _internal_set_gt(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.Range.gt)
}
inline double Range::_internal_gt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gt_;
}
inline void Range::_internal_set_gt(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = value;
}

// optional double gte = 3;
inline bool Range::has_gte() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void Range::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double Range::gte() const {
  // @@protoc_insertion_point(field_get:qdrant.Range.gte)
  return _internal_gte();
}
inline void Range::set_gte(double value) {
  _internal_set_gte(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.Range.gte)
}
inline double Range::_internal_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gte_;
}
inline void Range::_internal_set_gte(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = value;
}

// optional double lte = 4;
inline bool Range::has_lte() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void Range::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline double Range::lte() const {
  // @@protoc_insertion_point(field_get:qdrant.Range.lte)
  return _internal_lte();
}
inline void Range::set_lte(double value) {
  _internal_set_lte(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.Range.lte)
}
inline double Range::_internal_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lte_;
}
inline void Range::_internal_set_lte(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = value;
}

// -------------------------------------------------------------------

// DatetimeRange

// optional .google.protobuf.Timestamp lt = 1;
inline bool DatetimeRange::has_lt() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.lt_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& DatetimeRange::_internal_lt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.lt_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& DatetimeRange::lt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DatetimeRange.lt)
  return _internal_lt();
}
inline void DatetimeRange::unsafe_arena_set_allocated_lt(
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lt_);
  }
  _impl_.lt_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DatetimeRange.lt)
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE DatetimeRange::release_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::google::protobuf::Timestamp* released = _impl_.lt_;
  _impl_.lt_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE DatetimeRange::unsafe_arena_release_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DatetimeRange.lt)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::google::protobuf::Timestamp* temp = _impl_.lt_;
  _impl_.lt_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL DatetimeRange::_internal_mutable_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lt_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.lt_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.lt_;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL DatetimeRange::mutable_lt()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::google::protobuf::Timestamp* _msg = _internal_mutable_lt();
  // @@protoc_insertion_point(field_mutable:qdrant.DatetimeRange.lt)
  return _msg;
}
inline void DatetimeRange::set_allocated_lt(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lt_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.lt_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DatetimeRange.lt)
}

// optional .google.protobuf.Timestamp gt = 2;
inline bool DatetimeRange::has_gt() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.gt_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& DatetimeRange::_internal_gt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.gt_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& DatetimeRange::gt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DatetimeRange.gt)
  return _internal_gt();
}
inline void DatetimeRange::unsafe_arena_set_allocated_gt(
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gt_);
  }
  _impl_.gt_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DatetimeRange.gt)
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE DatetimeRange::release_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::google::protobuf::Timestamp* released = _impl_.gt_;
  _impl_.gt_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE DatetimeRange::unsafe_arena_release_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DatetimeRange.gt)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::google::protobuf::Timestamp* temp = _impl_.gt_;
  _impl_.gt_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL DatetimeRange::_internal_mutable_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gt_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.gt_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.gt_;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL DatetimeRange::mutable_gt()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::google::protobuf::Timestamp* _msg = _internal_mutable_gt();
  // @@protoc_insertion_point(field_mutable:qdrant.DatetimeRange.gt)
  return _msg;
}
inline void DatetimeRange::set_allocated_gt(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gt_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.gt_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DatetimeRange.gt)
}

// optional .google.protobuf.Timestamp gte = 3;
inline bool DatetimeRange::has_gte() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.gte_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& DatetimeRange::_internal_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.gte_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& DatetimeRange::gte() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DatetimeRange.gte)
  return _internal_gte();
}
inline void DatetimeRange::unsafe_arena_set_allocated_gte(
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gte_);
  }
  _impl_.gte_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DatetimeRange.gte)
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE DatetimeRange::release_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::google::protobuf::Timestamp* released = _impl_.gte_;
  _impl_.gte_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE DatetimeRange::unsafe_arena_release_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DatetimeRange.gte)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::google::protobuf::Timestamp* temp = _impl_.gte_;
  _impl_.gte_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL DatetimeRange::_internal_mutable_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gte_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.gte_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.gte_;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL DatetimeRange::mutable_gte()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::google::protobuf::Timestamp* _msg = _internal_mutable_gte();
  // @@protoc_insertion_point(field_mutable:qdrant.DatetimeRange.gte)
  return _msg;
}
inline void DatetimeRange::set_allocated_gte(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gte_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.gte_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DatetimeRange.gte)
}

// optional .google.protobuf.Timestamp lte = 4;
inline bool DatetimeRange::has_lte() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.lte_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& DatetimeRange::_internal_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.lte_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& DatetimeRange::lte() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DatetimeRange.lte)
  return _internal_lte();
}
inline void DatetimeRange::unsafe_arena_set_allocated_lte(
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lte_);
  }
  _impl_.lte_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DatetimeRange.lte)
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE DatetimeRange::release_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::google::protobuf::Timestamp* released = _impl_.lte_;
  _impl_.lte_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE DatetimeRange::unsafe_arena_release_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DatetimeRange.lte)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::google::protobuf::Timestamp* temp = _impl_.lte_;
  _impl_.lte_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL DatetimeRange::_internal_mutable_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lte_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.lte_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.lte_;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL DatetimeRange::mutable_lte()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::google::protobuf::Timestamp* _msg = _internal_mutable_lte();
  // @@protoc_insertion_point(field_mutable:qdrant.DatetimeRange.lte)
  return _msg;
}
inline void DatetimeRange::set_allocated_lte(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lte_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.lte_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DatetimeRange.lte)
}

// -------------------------------------------------------------------

// GeoBoundingBox

// .qdrant.GeoPoint top_left = 1;
inline bool GeoBoundingBox::has_top_left() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.top_left_ != nullptr);
  return value;
}
inline void GeoBoundingBox::clear_top_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.top_left_ != nullptr) _impl_.top_left_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::GeoPoint& GeoBoundingBox::_internal_top_left() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::GeoPoint* p = _impl_.top_left_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::GeoPoint&>(::qdrant::_GeoPoint_default_instance_);
}
inline const ::qdrant::GeoPoint& GeoBoundingBox::top_left() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GeoBoundingBox.top_left)
  return _internal_top_left();
}
inline void GeoBoundingBox::unsafe_arena_set_allocated_top_left(
    ::qdrant::GeoPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.top_left_);
  }
  _impl_.top_left_ = reinterpret_cast<::qdrant::GeoPoint*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.GeoBoundingBox.top_left)
}
inline ::qdrant::GeoPoint* PROTOBUF_NULLABLE GeoBoundingBox::release_top_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::GeoPoint* released = _impl_.top_left_;
  _impl_.top_left_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::GeoPoint* PROTOBUF_NULLABLE GeoBoundingBox::unsafe_arena_release_top_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.GeoBoundingBox.top_left)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::GeoPoint* temp = _impl_.top_left_;
  _impl_.top_left_ = nullptr;
  return temp;
}
inline ::qdrant::GeoPoint* PROTOBUF_NONNULL GeoBoundingBox::_internal_mutable_top_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.top_left_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::GeoPoint>(GetArena());
    _impl_.top_left_ = reinterpret_cast<::qdrant::GeoPoint*>(p);
  }
  return _impl_.top_left_;
}
inline ::qdrant::GeoPoint* PROTOBUF_NONNULL GeoBoundingBox::mutable_top_left()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::GeoPoint* _msg = _internal_mutable_top_left();
  // @@protoc_insertion_point(field_mutable:qdrant.GeoBoundingBox.top_left)
  return _msg;
}
inline void GeoBoundingBox::set_allocated_top_left(::qdrant::GeoPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.top_left_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.top_left_ = reinterpret_cast<::qdrant::GeoPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.GeoBoundingBox.top_left)
}

// .qdrant.GeoPoint bottom_right = 2;
inline bool GeoBoundingBox::has_bottom_right() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.bottom_right_ != nullptr);
  return value;
}
inline void GeoBoundingBox::clear_bottom_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bottom_right_ != nullptr) _impl_.bottom_right_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::GeoPoint& GeoBoundingBox::_internal_bottom_right() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::GeoPoint* p = _impl_.bottom_right_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::GeoPoint&>(::qdrant::_GeoPoint_default_instance_);
}
inline const ::qdrant::GeoPoint& GeoBoundingBox::bottom_right() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GeoBoundingBox.bottom_right)
  return _internal_bottom_right();
}
inline void GeoBoundingBox::unsafe_arena_set_allocated_bottom_right(
    ::qdrant::GeoPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bottom_right_);
  }
  _impl_.bottom_right_ = reinterpret_cast<::qdrant::GeoPoint*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.GeoBoundingBox.bottom_right)
}
inline ::qdrant::GeoPoint* PROTOBUF_NULLABLE GeoBoundingBox::release_bottom_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::GeoPoint* released = _impl_.bottom_right_;
  _impl_.bottom_right_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::GeoPoint* PROTOBUF_NULLABLE GeoBoundingBox::unsafe_arena_release_bottom_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.GeoBoundingBox.bottom_right)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::GeoPoint* temp = _impl_.bottom_right_;
  _impl_.bottom_right_ = nullptr;
  return temp;
}
inline ::qdrant::GeoPoint* PROTOBUF_NONNULL GeoBoundingBox::_internal_mutable_bottom_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bottom_right_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::GeoPoint>(GetArena());
    _impl_.bottom_right_ = reinterpret_cast<::qdrant::GeoPoint*>(p);
  }
  return _impl_.bottom_right_;
}
inline ::qdrant::GeoPoint* PROTOBUF_NONNULL GeoBoundingBox::mutable_bottom_right()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::GeoPoint* _msg = _internal_mutable_bottom_right();
  // @@protoc_insertion_point(field_mutable:qdrant.GeoBoundingBox.bottom_right)
  return _msg;
}
inline void GeoBoundingBox::set_allocated_bottom_right(::qdrant::GeoPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bottom_right_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.bottom_right_ = reinterpret_cast<::qdrant::GeoPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.GeoBoundingBox.bottom_right)
}

// -------------------------------------------------------------------

// GeoRadius

// .qdrant.GeoPoint center = 1;
inline bool GeoRadius::has_center() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline void GeoRadius::clear_center() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.center_ != nullptr) _impl_.center_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::GeoPoint& GeoRadius::_internal_center() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::GeoPoint* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::GeoPoint&>(::qdrant::_GeoPoint_default_instance_);
}
inline const ::qdrant::GeoPoint& GeoRadius::center() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GeoRadius.center)
  return _internal_center();
}
inline void GeoRadius::unsafe_arena_set_allocated_center(
    ::qdrant::GeoPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = reinterpret_cast<::qdrant::GeoPoint*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.GeoRadius.center)
}
inline ::qdrant::GeoPoint* PROTOBUF_NULLABLE GeoRadius::release_center() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::GeoPoint* released = _impl_.center_;
  _impl_.center_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::GeoPoint* PROTOBUF_NULLABLE GeoRadius::unsafe_arena_release_center() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.GeoRadius.center)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::GeoPoint* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::qdrant::GeoPoint* PROTOBUF_NONNULL GeoRadius::_internal_mutable_center() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.center_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::GeoPoint>(GetArena());
    _impl_.center_ = reinterpret_cast<::qdrant::GeoPoint*>(p);
  }
  return _impl_.center_;
}
inline ::qdrant::GeoPoint* PROTOBUF_NONNULL GeoRadius::mutable_center()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::GeoPoint* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:qdrant.GeoRadius.center)
  return _msg;
}
inline void GeoRadius::set_allocated_center(::qdrant::GeoPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.center_ = reinterpret_cast<::qdrant::GeoPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.GeoRadius.center)
}

// float radius = 2;
inline void GeoRadius::clear_radius() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.radius_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline float GeoRadius::radius() const {
  // @@protoc_insertion_point(field_get:qdrant.GeoRadius.radius)
  return _internal_radius();
}
inline void GeoRadius::set_radius(float value) {
  _internal_set_radius(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.GeoRadius.radius)
}
inline float GeoRadius::_internal_radius() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.radius_;
}
inline void GeoRadius::_internal_set_radius(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.radius_ = value;
}

// -------------------------------------------------------------------

// GeoLineString

// repeated .qdrant.GeoPoint points = 1;
inline int GeoLineString::_internal_points_size() const {
  return _internal_points().size();
}
inline int GeoLineString::points_size() const {
  return _internal_points_size();
}
inline void GeoLineString::clear_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.points_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::GeoPoint* PROTOBUF_NONNULL GeoLineString::mutable_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.GeoLineString.points)
  return _internal_mutable_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::GeoPoint>* PROTOBUF_NONNULL GeoLineString::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.GeoLineString.points)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_points();
}
inline const ::qdrant::GeoPoint& GeoLineString::points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GeoLineString.points)
  return _internal_points().Get(index);
}
inline ::qdrant::GeoPoint* PROTOBUF_NONNULL GeoLineString::add_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::GeoPoint* _add =
      _internal_mutable_points()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.GeoLineString.points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::GeoPoint>& GeoLineString::points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.GeoLineString.points)
  return _internal_points();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::GeoPoint>&
GeoLineString::_internal_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.points_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::GeoPoint>* PROTOBUF_NONNULL
GeoLineString::_internal_mutable_points() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.points_;
}

// -------------------------------------------------------------------

// GeoPolygon

// .qdrant.GeoLineString exterior = 1;
inline bool GeoPolygon::has_exterior() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.exterior_ != nullptr);
  return value;
}
inline void GeoPolygon::clear_exterior() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.exterior_ != nullptr) _impl_.exterior_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::GeoLineString& GeoPolygon::_internal_exterior() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::GeoLineString* p = _impl_.exterior_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::GeoLineString&>(::qdrant::_GeoLineString_default_instance_);
}
inline const ::qdrant::GeoLineString& GeoPolygon::exterior() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GeoPolygon.exterior)
  return _internal_exterior();
}
inline void GeoPolygon::unsafe_arena_set_allocated_exterior(
    ::qdrant::GeoLineString* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.exterior_);
  }
  _impl_.exterior_ = reinterpret_cast<::qdrant::GeoLineString*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.GeoPolygon.exterior)
}
inline ::qdrant::GeoLineString* PROTOBUF_NULLABLE GeoPolygon::release_exterior() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::GeoLineString* released = _impl_.exterior_;
  _impl_.exterior_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::GeoLineString* PROTOBUF_NULLABLE GeoPolygon::unsafe_arena_release_exterior() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.GeoPolygon.exterior)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::GeoLineString* temp = _impl_.exterior_;
  _impl_.exterior_ = nullptr;
  return temp;
}
inline ::qdrant::GeoLineString* PROTOBUF_NONNULL GeoPolygon::_internal_mutable_exterior() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.exterior_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::GeoLineString>(GetArena());
    _impl_.exterior_ = reinterpret_cast<::qdrant::GeoLineString*>(p);
  }
  return _impl_.exterior_;
}
inline ::qdrant::GeoLineString* PROTOBUF_NONNULL GeoPolygon::mutable_exterior()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::GeoLineString* _msg = _internal_mutable_exterior();
  // @@protoc_insertion_point(field_mutable:qdrant.GeoPolygon.exterior)
  return _msg;
}
inline void GeoPolygon::set_allocated_exterior(::qdrant::GeoLineString* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.exterior_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.exterior_ = reinterpret_cast<::qdrant::GeoLineString*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.GeoPolygon.exterior)
}

// repeated .qdrant.GeoLineString interiors = 2;
inline int GeoPolygon::_internal_interiors_size() const {
  return _internal_interiors().size();
}
inline int GeoPolygon::interiors_size() const {
  return _internal_interiors_size();
}
inline void GeoPolygon::clear_interiors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.interiors_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::GeoLineString* PROTOBUF_NONNULL GeoPolygon::mutable_interiors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.GeoPolygon.interiors)
  return _internal_mutable_interiors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::GeoLineString>* PROTOBUF_NONNULL GeoPolygon::mutable_interiors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.GeoPolygon.interiors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_interiors();
}
inline const ::qdrant::GeoLineString& GeoPolygon::interiors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GeoPolygon.interiors)
  return _internal_interiors().Get(index);
}
inline ::qdrant::GeoLineString* PROTOBUF_NONNULL GeoPolygon::add_interiors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::GeoLineString* _add =
      _internal_mutable_interiors()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.GeoPolygon.interiors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::GeoLineString>& GeoPolygon::interiors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.GeoPolygon.interiors)
  return _internal_interiors();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::GeoLineString>&
GeoPolygon::_internal_interiors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.interiors_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::GeoLineString>* PROTOBUF_NONNULL
GeoPolygon::_internal_mutable_interiors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.interiors_;
}

// -------------------------------------------------------------------

// ValuesCount

// optional uint64 lt = 1;
inline bool ValuesCount::has_lt() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void ValuesCount::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t ValuesCount::lt() const {
  // @@protoc_insertion_point(field_get:qdrant.ValuesCount.lt)
  return _internal_lt();
}
inline void ValuesCount::set_lt(::uint64_t value) {
  _internal_set_lt(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.ValuesCount.lt)
}
inline ::uint64_t ValuesCount::_internal_lt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lt_;
}
inline void ValuesCount::_internal_set_lt(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = value;
}

// optional uint64 gt = 2;
inline bool ValuesCount::has_gt() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void ValuesCount::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint64_t ValuesCount::gt() const {
  // @@protoc_insertion_point(field_get:qdrant.ValuesCount.gt)
  return _internal_gt();
}
inline void ValuesCount::set_gt(::uint64_t value) {
  _internal_set_gt(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.ValuesCount.gt)
}
inline ::uint64_t ValuesCount::_internal_gt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gt_;
}
inline void ValuesCount::_internal_set_gt(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = value;
}

// optional uint64 gte = 3;
inline bool ValuesCount::has_gte() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void ValuesCount::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint64_t ValuesCount::gte() const {
  // @@protoc_insertion_point(field_get:qdrant.ValuesCount.gte)
  return _internal_gte();
}
inline void ValuesCount::set_gte(::uint64_t value) {
  _internal_set_gte(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.ValuesCount.gte)
}
inline ::uint64_t ValuesCount::_internal_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gte_;
}
inline void ValuesCount::_internal_set_gte(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = value;
}

// optional uint64 lte = 4;
inline bool ValuesCount::has_lte() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void ValuesCount::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint64_t ValuesCount::lte() const {
  // @@protoc_insertion_point(field_get:qdrant.ValuesCount.lte)
  return _internal_lte();
}
inline void ValuesCount::set_lte(::uint64_t value) {
  _internal_set_lte(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.ValuesCount.lte)
}
inline ::uint64_t ValuesCount::_internal_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lte_;
}
inline void ValuesCount::_internal_set_lte(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = value;
}

// -------------------------------------------------------------------

// PointsSelector

// .qdrant.PointsIdsList points = 1;
inline bool PointsSelector::has_points() const {
  return points_selector_one_of_case() == kPoints;
}
inline bool PointsSelector::_internal_has_points() const {
  return points_selector_one_of_case() == kPoints;
}
inline void PointsSelector::set_has_points() {
  _impl_._oneof_case_[0] = kPoints;
}
inline void PointsSelector::clear_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (points_selector_one_of_case() == kPoints) {
    if (GetArena() == nullptr) {
      delete _impl_.points_selector_one_of_.points_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.points_selector_one_of_.points_);
    }
    clear_has_points_selector_one_of();
  }
}
inline ::qdrant::PointsIdsList* PROTOBUF_NULLABLE PointsSelector::release_points() {
  // @@protoc_insertion_point(field_release:qdrant.PointsSelector.points)
  if (points_selector_one_of_case() == kPoints) {
    clear_has_points_selector_one_of();
    auto* temp = _impl_.points_selector_one_of_.points_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.points_selector_one_of_.points_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::PointsIdsList& PointsSelector::_internal_points() const {
  return points_selector_one_of_case() == kPoints ? static_cast<const ::qdrant::PointsIdsList&>(*_impl_.points_selector_one_of_.points_)
                     : reinterpret_cast<const ::qdrant::PointsIdsList&>(::qdrant::_PointsIdsList_default_instance_);
}
inline const ::qdrant::PointsIdsList& PointsSelector::points() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsSelector.points)
  return _internal_points();
}
inline ::qdrant::PointsIdsList* PROTOBUF_NULLABLE PointsSelector::unsafe_arena_release_points() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PointsSelector.points)
  if (points_selector_one_of_case() == kPoints) {
    clear_has_points_selector_one_of();
    auto* temp = _impl_.points_selector_one_of_.points_;
    _impl_.points_selector_one_of_.points_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PointsSelector::unsafe_arena_set_allocated_points(
    ::qdrant::PointsIdsList* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_points_selector_one_of();
  if (value) {
    set_has_points();
    _impl_.points_selector_one_of_.points_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsSelector.points)
}
inline ::qdrant::PointsIdsList* PROTOBUF_NONNULL PointsSelector::_internal_mutable_points() {
  if (points_selector_one_of_case() != kPoints) {
    clear_points_selector_one_of();
    set_has_points();
    _impl_.points_selector_one_of_.points_ = 
        ::google::protobuf::Message::DefaultConstruct<::qdrant::PointsIdsList>(GetArena());
  }
  return _impl_.points_selector_one_of_.points_;
}
inline ::qdrant::PointsIdsList* PROTOBUF_NONNULL PointsSelector::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::PointsIdsList* _msg = _internal_mutable_points();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsSelector.points)
  return _msg;
}

// .qdrant.Filter filter = 2;
inline bool PointsSelector::has_filter() const {
  return points_selector_one_of_case() == kFilter;
}
inline bool PointsSelector::_internal_has_filter() const {
  return points_selector_one_of_case() == kFilter;
}
inline void PointsSelector::set_has_filter() {
  _impl_._oneof_case_[0] = kFilter;
}
inline void PointsSelector::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (points_selector_one_of_case() == kFilter) {
    if (GetArena() == nullptr) {
      delete _impl_.points_selector_one_of_.filter_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.points_selector_one_of_.filter_);
    }
    clear_has_points_selector_one_of();
  }
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE PointsSelector::release_filter() {
  // @@protoc_insertion_point(field_release:qdrant.PointsSelector.filter)
  if (points_selector_one_of_case() == kFilter) {
    clear_has_points_selector_one_of();
    auto* temp = _impl_.points_selector_one_of_.filter_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.points_selector_one_of_.filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Filter& PointsSelector::_internal_filter() const {
  return points_selector_one_of_case() == kFilter ? static_cast<const ::qdrant::Filter&>(*_impl_.points_selector_one_of_.filter_)
                     : reinterpret_cast<const ::qdrant::Filter&>(::qdrant::_Filter_default_instance_);
}
inline const ::qdrant::Filter& PointsSelector::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsSelector.filter)
  return _internal_filter();
}
inline ::qdrant::Filter* PROTOBUF_NULLABLE PointsSelector::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PointsSelector.filter)
  if (points_selector_one_of_case() == kFilter) {
    clear_has_points_selector_one_of();
    auto* temp = _impl_.points_selector_one_of_.filter_;
    _impl_.points_selector_one_of_.filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PointsSelector::unsafe_arena_set_allocated_filter(
    ::qdrant::Filter* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_points_selector_one_of();
  if (value) {
    set_has_filter();
    _impl_.points_selector_one_of_.filter_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointsSelector.filter)
}
inline ::qdrant::Filter* PROTOBUF_NONNULL PointsSelector::_internal_mutable_filter() {
  if (points_selector_one_of_case() != kFilter) {
    clear_points_selector_one_of();
    set_has_filter();
    _impl_.points_selector_one_of_.filter_ = 
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Filter>(GetArena());
  }
  return _impl_.points_selector_one_of_.filter_;
}
inline ::qdrant::Filter* PROTOBUF_NONNULL PointsSelector::mutable_filter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:qdrant.PointsSelector.filter)
  return _msg;
}

inline bool PointsSelector::has_points_selector_one_of() const {
  return points_selector_one_of_case() != POINTS_SELECTOR_ONE_OF_NOT_SET;
}
inline void PointsSelector::clear_has_points_selector_one_of() {
  _impl_._oneof_case_[0] = POINTS_SELECTOR_ONE_OF_NOT_SET;
}
inline PointsSelector::PointsSelectorOneOfCase PointsSelector::points_selector_one_of_case() const {
  return PointsSelector::PointsSelectorOneOfCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PointsIdsList

// repeated .qdrant.PointId ids = 1;
inline int PointsIdsList::_internal_ids_size() const {
  return _internal_ids().size();
}
inline int PointsIdsList::ids_size() const {
  return _internal_ids_size();
}
inline void PointsIdsList::clear_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ids_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::PointId* PROTOBUF_NONNULL PointsIdsList::mutable_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.PointsIdsList.ids)
  return _internal_mutable_ids()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL PointsIdsList::mutable_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.PointsIdsList.ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ids();
}
inline const ::qdrant::PointId& PointsIdsList::ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointsIdsList.ids)
  return _internal_ids().Get(index);
}
inline ::qdrant::PointId* PROTOBUF_NONNULL PointsIdsList::add_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::PointId* _add =
      _internal_mutable_ids()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.PointsIdsList.ids)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>& PointsIdsList::ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.PointsIdsList.ids)
  return _internal_ids();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::PointId>&
PointsIdsList::_internal_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ids_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::PointId>* PROTOBUF_NONNULL
PointsIdsList::_internal_mutable_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ids_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PointStruct

// .qdrant.PointId id = 1;
inline bool PointStruct::has_id() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline void PointStruct::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::PointId& PointStruct::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PointId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PointId&>(::qdrant::_PointId_default_instance_);
}
inline const ::qdrant::PointId& PointStruct::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointStruct.id)
  return _internal_id();
}
inline void PointStruct::unsafe_arena_set_allocated_id(
    ::qdrant::PointId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::qdrant::PointId*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointStruct.id)
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE PointStruct::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointId* released = _impl_.id_;
  _impl_.id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PointId* PROTOBUF_NULLABLE PointStruct::unsafe_arena_release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointStruct.id)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::qdrant::PointId* PROTOBUF_NONNULL PointStruct::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PointId>(GetArena());
    _impl_.id_ = reinterpret_cast<::qdrant::PointId*>(p);
  }
  return _impl_.id_;
}
inline ::qdrant::PointId* PROTOBUF_NONNULL PointStruct::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PointId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:qdrant.PointStruct.id)
  return _msg;
}
inline void PointStruct::set_allocated_id(::qdrant::PointId* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.id_ = reinterpret_cast<::qdrant::PointId*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointStruct.id)
}

// map<string, .qdrant.Value> payload = 3;
inline int PointStruct::_internal_payload_size() const {
  return _internal_payload().size();
}
inline int PointStruct::payload_size() const {
  return _internal_payload_size();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& PointStruct::_internal_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& PointStruct::payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.PointStruct.payload)
  return _internal_payload();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL PointStruct::_internal_mutable_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.payload_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL PointStruct::mutable_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.PointStruct.payload)
  return _internal_mutable_payload();
}

// optional .qdrant.Vectors vectors = 4;
inline bool PointStruct::has_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.vectors_ != nullptr);
  return value;
}
inline void PointStruct::clear_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_ != nullptr) _impl_.vectors_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::Vectors& PointStruct::_internal_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::Vectors* p = _impl_.vectors_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::Vectors&>(::qdrant::_Vectors_default_instance_);
}
inline const ::qdrant::Vectors& PointStruct::vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PointStruct.vectors)
  return _internal_vectors();
}
inline void PointStruct::unsafe_arena_set_allocated_vectors(
    ::qdrant::Vectors* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_);
  }
  _impl_.vectors_ = reinterpret_cast<::qdrant::Vectors*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PointStruct.vectors)
}
inline ::qdrant::Vectors* PROTOBUF_NULLABLE PointStruct::release_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Vectors* released = _impl_.vectors_;
  _impl_.vectors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::Vectors* PROTOBUF_NULLABLE PointStruct::unsafe_arena_release_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PointStruct.vectors)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Vectors* temp = _impl_.vectors_;
  _impl_.vectors_ = nullptr;
  return temp;
}
inline ::qdrant::Vectors* PROTOBUF_NONNULL PointStruct::_internal_mutable_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::Vectors>(GetArena());
    _impl_.vectors_ = reinterpret_cast<::qdrant::Vectors*>(p);
  }
  return _impl_.vectors_;
}
inline ::qdrant::Vectors* PROTOBUF_NONNULL PointStruct::mutable_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::Vectors* _msg = _internal_mutable_vectors();
  // @@protoc_insertion_point(field_mutable:qdrant.PointStruct.vectors)
  return _msg;
}
inline void PointStruct::set_allocated_vectors(::qdrant::Vectors* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.vectors_ = reinterpret_cast<::qdrant::Vectors*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PointStruct.vectors)
}

// -------------------------------------------------------------------

// GeoPoint

// double lon = 1;
inline void GeoPoint::clear_lon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lon_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline double GeoPoint::lon() const {
  // @@protoc_insertion_point(field_get:qdrant.GeoPoint.lon)
  return _internal_lon();
}
inline void GeoPoint::set_lon(double value) {
  _internal_set_lon(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.GeoPoint.lon)
}
inline double GeoPoint::_internal_lon() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lon_;
}
inline void GeoPoint::_internal_set_lon(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lon_ = value;
}

// double lat = 2;
inline void GeoPoint::clear_lat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lat_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline double GeoPoint::lat() const {
  // @@protoc_insertion_point(field_get:qdrant.GeoPoint.lat)
  return _internal_lat();
}
inline void GeoPoint::set_lat(double value) {
  _internal_set_lat(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.GeoPoint.lat)
}
inline double GeoPoint::_internal_lat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lat_;
}
inline void GeoPoint::_internal_set_lat(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lat_ = value;
}

// -------------------------------------------------------------------

// Usage

// optional .qdrant.HardwareUsage hardware = 1;
inline bool Usage::has_hardware() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.hardware_ != nullptr);
  return value;
}
inline void Usage::clear_hardware() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hardware_ != nullptr) _impl_.hardware_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::HardwareUsage& Usage::_internal_hardware() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::HardwareUsage* p = _impl_.hardware_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::HardwareUsage&>(::qdrant::_HardwareUsage_default_instance_);
}
inline const ::qdrant::HardwareUsage& Usage::hardware() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Usage.hardware)
  return _internal_hardware();
}
inline void Usage::unsafe_arena_set_allocated_hardware(
    ::qdrant::HardwareUsage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hardware_);
  }
  _impl_.hardware_ = reinterpret_cast<::qdrant::HardwareUsage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Usage.hardware)
}
inline ::qdrant::HardwareUsage* PROTOBUF_NULLABLE Usage::release_hardware() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::HardwareUsage* released = _impl_.hardware_;
  _impl_.hardware_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::HardwareUsage* PROTOBUF_NULLABLE Usage::unsafe_arena_release_hardware() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.Usage.hardware)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::HardwareUsage* temp = _impl_.hardware_;
  _impl_.hardware_ = nullptr;
  return temp;
}
inline ::qdrant::HardwareUsage* PROTOBUF_NONNULL Usage::_internal_mutable_hardware() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hardware_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::HardwareUsage>(GetArena());
    _impl_.hardware_ = reinterpret_cast<::qdrant::HardwareUsage*>(p);
  }
  return _impl_.hardware_;
}
inline ::qdrant::HardwareUsage* PROTOBUF_NONNULL Usage::mutable_hardware()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::HardwareUsage* _msg = _internal_mutable_hardware();
  // @@protoc_insertion_point(field_mutable:qdrant.Usage.hardware)
  return _msg;
}
inline void Usage::set_allocated_hardware(::qdrant::HardwareUsage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hardware_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.hardware_ = reinterpret_cast<::qdrant::HardwareUsage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.Usage.hardware)
}

// optional .qdrant.InferenceUsage inference = 2;
inline bool Usage::has_inference() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.inference_ != nullptr);
  return value;
}
inline void Usage::clear_inference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.inference_ != nullptr) _impl_.inference_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::InferenceUsage& Usage::_internal_inference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::InferenceUsage* p = _impl_.inference_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::InferenceUsage&>(::qdrant::_InferenceUsage_default_instance_);
}
inline const ::qdrant::InferenceUsage& Usage::inference() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.Usage.inference)
  return _internal_inference();
}
inline void Usage::unsafe_arena_set_allocated_inference(
    ::qdrant::InferenceUsage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inference_);
  }
  _impl_.inference_ = reinterpret_cast<::qdrant::InferenceUsage*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.Usage.inference)
}
inline ::qdrant::InferenceUsage* PROTOBUF_NULLABLE Usage::release_inference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::InferenceUsage* released = _impl_.inference_;
  _impl_.inference_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::InferenceUsage* PROTOBUF_NULLABLE Usage::unsafe_arena_release_inference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.Usage.inference)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::InferenceUsage* temp = _impl_.inference_;
  _impl_.inference_ = nullptr;
  return temp;
}
inline ::qdrant::InferenceUsage* PROTOBUF_NONNULL Usage::_internal_mutable_inference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.inference_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::InferenceUsage>(GetArena());
    _impl_.inference_ = reinterpret_cast<::qdrant::InferenceUsage*>(p);
  }
  return _impl_.inference_;
}
inline ::qdrant::InferenceUsage* PROTOBUF_NONNULL Usage::mutable_inference()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::InferenceUsage* _msg = _internal_mutable_inference();
  // @@protoc_insertion_point(field_mutable:qdrant.Usage.inference)
  return _msg;
}
inline void Usage::set_allocated_inference(::qdrant::InferenceUsage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inference_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.inference_ = reinterpret_cast<::qdrant::InferenceUsage*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.Usage.inference)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InferenceUsage

// map<string, .qdrant.ModelUsage> models = 1;
inline int InferenceUsage::_internal_models_size() const {
  return _internal_models().size();
}
inline int InferenceUsage::models_size() const {
  return _internal_models_size();
}
inline void InferenceUsage::clear_models() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.models_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::ModelUsage>& InferenceUsage::_internal_models() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.models_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::ModelUsage>& InferenceUsage::models() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.InferenceUsage.models)
  return _internal_models();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::ModelUsage>* PROTOBUF_NONNULL InferenceUsage::_internal_mutable_models() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.models_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::ModelUsage>* PROTOBUF_NONNULL InferenceUsage::mutable_models()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.InferenceUsage.models)
  return _internal_mutable_models();
}

// -------------------------------------------------------------------

// ModelUsage

// uint64 tokens = 1;
inline void ModelUsage::clear_tokens() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tokens_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t ModelUsage::tokens() const {
  // @@protoc_insertion_point(field_get:qdrant.ModelUsage.tokens)
  return _internal_tokens();
}
inline void ModelUsage::set_tokens(::uint64_t value) {
  _internal_set_tokens(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.ModelUsage.tokens)
}
inline ::uint64_t ModelUsage::_internal_tokens() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tokens_;
}
inline void ModelUsage::_internal_set_tokens(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tokens_ = value;
}

// -------------------------------------------------------------------

// HardwareUsage

// uint64 cpu = 1;
inline void HardwareUsage::clear_cpu() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpu_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t HardwareUsage::cpu() const {
  // @@protoc_insertion_point(field_get:qdrant.HardwareUsage.cpu)
  return _internal_cpu();
}
inline void HardwareUsage::set_cpu(::uint64_t value) {
  _internal_set_cpu(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.HardwareUsage.cpu)
}
inline ::uint64_t HardwareUsage::_internal_cpu() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cpu_;
}
inline void HardwareUsage::_internal_set_cpu(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpu_ = value;
}

// uint64 payload_io_read = 2;
inline void HardwareUsage::clear_payload_io_read() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_io_read_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint64_t HardwareUsage::payload_io_read() const {
  // @@protoc_insertion_point(field_get:qdrant.HardwareUsage.payload_io_read)
  return _internal_payload_io_read();
}
inline void HardwareUsage::set_payload_io_read(::uint64_t value) {
  _internal_set_payload_io_read(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.HardwareUsage.payload_io_read)
}
inline ::uint64_t HardwareUsage::_internal_payload_io_read() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_io_read_;
}
inline void HardwareUsage::_internal_set_payload_io_read(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_io_read_ = value;
}

// uint64 payload_io_write = 3;
inline void HardwareUsage::clear_payload_io_write() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_io_write_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint64_t HardwareUsage::payload_io_write() const {
  // @@protoc_insertion_point(field_get:qdrant.HardwareUsage.payload_io_write)
  return _internal_payload_io_write();
}
inline void HardwareUsage::set_payload_io_write(::uint64_t value) {
  _internal_set_payload_io_write(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.HardwareUsage.payload_io_write)
}
inline ::uint64_t HardwareUsage::_internal_payload_io_write() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_io_write_;
}
inline void HardwareUsage::_internal_set_payload_io_write(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_io_write_ = value;
}

// uint64 payload_index_io_read = 4;
inline void HardwareUsage::clear_payload_index_io_read() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_index_io_read_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint64_t HardwareUsage::payload_index_io_read() const {
  // @@protoc_insertion_point(field_get:qdrant.HardwareUsage.payload_index_io_read)
  return _internal_payload_index_io_read();
}
inline void HardwareUsage::set_payload_index_io_read(::uint64_t value) {
  _internal_set_payload_index_io_read(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.HardwareUsage.payload_index_io_read)
}
inline ::uint64_t HardwareUsage::_internal_payload_index_io_read() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_index_io_read_;
}
inline void HardwareUsage::_internal_set_payload_index_io_read(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_index_io_read_ = value;
}

// uint64 payload_index_io_write = 5;
inline void HardwareUsage::clear_payload_index_io_write() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_index_io_write_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::uint64_t HardwareUsage::payload_index_io_write() const {
  // @@protoc_insertion_point(field_get:qdrant.HardwareUsage.payload_index_io_write)
  return _internal_payload_index_io_write();
}
inline void HardwareUsage::set_payload_index_io_write(::uint64_t value) {
  _internal_set_payload_index_io_write(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.HardwareUsage.payload_index_io_write)
}
inline ::uint64_t HardwareUsage::_internal_payload_index_io_write() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_index_io_write_;
}
inline void HardwareUsage::_internal_set_payload_index_io_write(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_index_io_write_ = value;
}

// uint64 vector_io_read = 6;
inline void HardwareUsage::clear_vector_io_read() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vector_io_read_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::uint64_t HardwareUsage::vector_io_read() const {
  // @@protoc_insertion_point(field_get:qdrant.HardwareUsage.vector_io_read)
  return _internal_vector_io_read();
}
inline void HardwareUsage::set_vector_io_read(::uint64_t value) {
  _internal_set_vector_io_read(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.HardwareUsage.vector_io_read)
}
inline ::uint64_t HardwareUsage::_internal_vector_io_read() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vector_io_read_;
}
inline void HardwareUsage::_internal_set_vector_io_read(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vector_io_read_ = value;
}

// uint64 vector_io_write = 7;
inline void HardwareUsage::clear_vector_io_write() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vector_io_write_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline ::uint64_t HardwareUsage::vector_io_write() const {
  // @@protoc_insertion_point(field_get:qdrant.HardwareUsage.vector_io_write)
  return _internal_vector_io_write();
}
inline void HardwareUsage::set_vector_io_write(::uint64_t value) {
  _internal_set_vector_io_write(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:qdrant.HardwareUsage.vector_io_write)
}
inline ::uint64_t HardwareUsage::_internal_vector_io_write() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vector_io_write_;
}
inline void HardwareUsage::_internal_set_vector_io_write(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vector_io_write_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace qdrant


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::qdrant::WriteOrderingType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::WriteOrderingType>() {
  return ::qdrant::WriteOrderingType_descriptor();
}
template <>
struct is_proto_enum<::qdrant::ReadConsistencyType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::ReadConsistencyType>() {
  return ::qdrant::ReadConsistencyType_descriptor();
}
template <>
struct is_proto_enum<::qdrant::FieldType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::FieldType>() {
  return ::qdrant::FieldType_descriptor();
}
template <>
struct is_proto_enum<::qdrant::Direction> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::Direction>() {
  return ::qdrant::Direction_descriptor();
}
template <>
struct is_proto_enum<::qdrant::RecommendStrategy> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::RecommendStrategy>() {
  return ::qdrant::RecommendStrategy_descriptor();
}
template <>
struct is_proto_enum<::qdrant::Fusion> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::Fusion>() {
  return ::qdrant::Fusion_descriptor();
}
template <>
struct is_proto_enum<::qdrant::Sample> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::Sample>() {
  return ::qdrant::Sample_descriptor();
}
template <>
struct is_proto_enum<::qdrant::UpdateStatus> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::UpdateStatus>() {
  return ::qdrant::UpdateStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // points_2eproto_2epb_2eh
