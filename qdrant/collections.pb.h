// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: collections.proto
// Protobuf C++ Version: 6.33.0

#ifndef collections_2eproto_2epb_2eh
#define collections_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "json_with_int.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_collections_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_collections_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_collections_2eproto;
}  // extern "C"
namespace qdrant {
enum BinaryQuantizationEncoding : int;
extern const uint32_t BinaryQuantizationEncoding_internal_data_[];
enum BinaryQuantizationQueryEncoding_Setting : int;
extern const uint32_t BinaryQuantizationQueryEncoding_Setting_internal_data_[];
enum CollectionStatus : int;
extern const uint32_t CollectionStatus_internal_data_[];
enum CompressionRatio : int;
extern const uint32_t CompressionRatio_internal_data_[];
enum Datatype : int;
extern const uint32_t Datatype_internal_data_[];
enum Distance : int;
extern const uint32_t Distance_internal_data_[];
enum MaxOptimizationThreads_Setting : int;
extern const uint32_t MaxOptimizationThreads_Setting_internal_data_[];
enum Modifier : int;
extern const uint32_t Modifier_internal_data_[];
enum MultiVectorComparator : int;
extern const uint32_t MultiVectorComparator_internal_data_[];
enum PayloadSchemaType : int;
extern const uint32_t PayloadSchemaType_internal_data_[];
enum QuantizationType : int;
extern const uint32_t QuantizationType_internal_data_[];
enum ReplicaState : int;
extern const uint32_t ReplicaState_internal_data_[];
enum ReshardingDirection : int;
extern const uint32_t ReshardingDirection_internal_data_[];
enum ShardTransferMethod : int;
extern const uint32_t ShardTransferMethod_internal_data_[];
enum ShardingMethod : int;
extern const uint32_t ShardingMethod_internal_data_[];
enum TokenizerType : int;
extern const uint32_t TokenizerType_internal_data_[];
class AbortShardTransfer;
struct AbortShardTransferDefaultTypeInternal;
extern AbortShardTransferDefaultTypeInternal _AbortShardTransfer_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AbortShardTransfer_class_data_;
class AliasDescription;
struct AliasDescriptionDefaultTypeInternal;
extern AliasDescriptionDefaultTypeInternal _AliasDescription_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AliasDescription_class_data_;
class AliasOperations;
struct AliasOperationsDefaultTypeInternal;
extern AliasOperationsDefaultTypeInternal _AliasOperations_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AliasOperations_class_data_;
class BinaryQuantization;
struct BinaryQuantizationDefaultTypeInternal;
extern BinaryQuantizationDefaultTypeInternal _BinaryQuantization_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BinaryQuantization_class_data_;
class BinaryQuantizationQueryEncoding;
struct BinaryQuantizationQueryEncodingDefaultTypeInternal;
extern BinaryQuantizationQueryEncodingDefaultTypeInternal _BinaryQuantizationQueryEncoding_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BinaryQuantizationQueryEncoding_class_data_;
class BoolIndexParams;
struct BoolIndexParamsDefaultTypeInternal;
extern BoolIndexParamsDefaultTypeInternal _BoolIndexParams_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BoolIndexParams_class_data_;
class ChangeAliases;
struct ChangeAliasesDefaultTypeInternal;
extern ChangeAliasesDefaultTypeInternal _ChangeAliases_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ChangeAliases_class_data_;
class CollectionClusterInfoRequest;
struct CollectionClusterInfoRequestDefaultTypeInternal;
extern CollectionClusterInfoRequestDefaultTypeInternal _CollectionClusterInfoRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CollectionClusterInfoRequest_class_data_;
class CollectionClusterInfoResponse;
struct CollectionClusterInfoResponseDefaultTypeInternal;
extern CollectionClusterInfoResponseDefaultTypeInternal _CollectionClusterInfoResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CollectionClusterInfoResponse_class_data_;
class CollectionConfig;
struct CollectionConfigDefaultTypeInternal;
extern CollectionConfigDefaultTypeInternal _CollectionConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CollectionConfig_class_data_;
class CollectionConfig_MetadataEntry_DoNotUse;
struct CollectionConfig_MetadataEntry_DoNotUseDefaultTypeInternal;
extern CollectionConfig_MetadataEntry_DoNotUseDefaultTypeInternal _CollectionConfig_MetadataEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CollectionConfig_MetadataEntry_DoNotUse_class_data_;
class CollectionDescription;
struct CollectionDescriptionDefaultTypeInternal;
extern CollectionDescriptionDefaultTypeInternal _CollectionDescription_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CollectionDescription_class_data_;
class CollectionExists;
struct CollectionExistsDefaultTypeInternal;
extern CollectionExistsDefaultTypeInternal _CollectionExists_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CollectionExists_class_data_;
class CollectionExistsRequest;
struct CollectionExistsRequestDefaultTypeInternal;
extern CollectionExistsRequestDefaultTypeInternal _CollectionExistsRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CollectionExistsRequest_class_data_;
class CollectionExistsResponse;
struct CollectionExistsResponseDefaultTypeInternal;
extern CollectionExistsResponseDefaultTypeInternal _CollectionExistsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CollectionExistsResponse_class_data_;
class CollectionInfo;
struct CollectionInfoDefaultTypeInternal;
extern CollectionInfoDefaultTypeInternal _CollectionInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CollectionInfo_class_data_;
class CollectionInfo_PayloadSchemaEntry_DoNotUse;
struct CollectionInfo_PayloadSchemaEntry_DoNotUseDefaultTypeInternal;
extern CollectionInfo_PayloadSchemaEntry_DoNotUseDefaultTypeInternal _CollectionInfo_PayloadSchemaEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CollectionInfo_PayloadSchemaEntry_DoNotUse_class_data_;
class CollectionOperationResponse;
struct CollectionOperationResponseDefaultTypeInternal;
extern CollectionOperationResponseDefaultTypeInternal _CollectionOperationResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CollectionOperationResponse_class_data_;
class CollectionParams;
struct CollectionParamsDefaultTypeInternal;
extern CollectionParamsDefaultTypeInternal _CollectionParams_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CollectionParams_class_data_;
class CollectionParamsDiff;
struct CollectionParamsDiffDefaultTypeInternal;
extern CollectionParamsDiffDefaultTypeInternal _CollectionParamsDiff_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CollectionParamsDiff_class_data_;
class CreateAlias;
struct CreateAliasDefaultTypeInternal;
extern CreateAliasDefaultTypeInternal _CreateAlias_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CreateAlias_class_data_;
class CreateCollection;
struct CreateCollectionDefaultTypeInternal;
extern CreateCollectionDefaultTypeInternal _CreateCollection_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CreateCollection_class_data_;
class CreateCollection_MetadataEntry_DoNotUse;
struct CreateCollection_MetadataEntry_DoNotUseDefaultTypeInternal;
extern CreateCollection_MetadataEntry_DoNotUseDefaultTypeInternal _CreateCollection_MetadataEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CreateCollection_MetadataEntry_DoNotUse_class_data_;
class CreateShardKey;
struct CreateShardKeyDefaultTypeInternal;
extern CreateShardKeyDefaultTypeInternal _CreateShardKey_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CreateShardKey_class_data_;
class CreateShardKeyRequest;
struct CreateShardKeyRequestDefaultTypeInternal;
extern CreateShardKeyRequestDefaultTypeInternal _CreateShardKeyRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CreateShardKeyRequest_class_data_;
class CreateShardKeyResponse;
struct CreateShardKeyResponseDefaultTypeInternal;
extern CreateShardKeyResponseDefaultTypeInternal _CreateShardKeyResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CreateShardKeyResponse_class_data_;
class DatetimeIndexParams;
struct DatetimeIndexParamsDefaultTypeInternal;
extern DatetimeIndexParamsDefaultTypeInternal _DatetimeIndexParams_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DatetimeIndexParams_class_data_;
class DeleteAlias;
struct DeleteAliasDefaultTypeInternal;
extern DeleteAliasDefaultTypeInternal _DeleteAlias_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeleteAlias_class_data_;
class DeleteCollection;
struct DeleteCollectionDefaultTypeInternal;
extern DeleteCollectionDefaultTypeInternal _DeleteCollection_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeleteCollection_class_data_;
class DeleteShardKey;
struct DeleteShardKeyDefaultTypeInternal;
extern DeleteShardKeyDefaultTypeInternal _DeleteShardKey_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeleteShardKey_class_data_;
class DeleteShardKeyRequest;
struct DeleteShardKeyRequestDefaultTypeInternal;
extern DeleteShardKeyRequestDefaultTypeInternal _DeleteShardKeyRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeleteShardKeyRequest_class_data_;
class DeleteShardKeyResponse;
struct DeleteShardKeyResponseDefaultTypeInternal;
extern DeleteShardKeyResponseDefaultTypeInternal _DeleteShardKeyResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeleteShardKeyResponse_class_data_;
class Disabled;
struct DisabledDefaultTypeInternal;
extern DisabledDefaultTypeInternal _Disabled_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Disabled_class_data_;
class FloatIndexParams;
struct FloatIndexParamsDefaultTypeInternal;
extern FloatIndexParamsDefaultTypeInternal _FloatIndexParams_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FloatIndexParams_class_data_;
class GeoIndexParams;
struct GeoIndexParamsDefaultTypeInternal;
extern GeoIndexParamsDefaultTypeInternal _GeoIndexParams_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GeoIndexParams_class_data_;
class GetCollectionInfoRequest;
struct GetCollectionInfoRequestDefaultTypeInternal;
extern GetCollectionInfoRequestDefaultTypeInternal _GetCollectionInfoRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetCollectionInfoRequest_class_data_;
class GetCollectionInfoResponse;
struct GetCollectionInfoResponseDefaultTypeInternal;
extern GetCollectionInfoResponseDefaultTypeInternal _GetCollectionInfoResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetCollectionInfoResponse_class_data_;
class HnswConfigDiff;
struct HnswConfigDiffDefaultTypeInternal;
extern HnswConfigDiffDefaultTypeInternal _HnswConfigDiff_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull HnswConfigDiff_class_data_;
class IntegerIndexParams;
struct IntegerIndexParamsDefaultTypeInternal;
extern IntegerIndexParamsDefaultTypeInternal _IntegerIndexParams_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull IntegerIndexParams_class_data_;
class KeywordIndexParams;
struct KeywordIndexParamsDefaultTypeInternal;
extern KeywordIndexParamsDefaultTypeInternal _KeywordIndexParams_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull KeywordIndexParams_class_data_;
class ListAliasesRequest;
struct ListAliasesRequestDefaultTypeInternal;
extern ListAliasesRequestDefaultTypeInternal _ListAliasesRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListAliasesRequest_class_data_;
class ListAliasesResponse;
struct ListAliasesResponseDefaultTypeInternal;
extern ListAliasesResponseDefaultTypeInternal _ListAliasesResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListAliasesResponse_class_data_;
class ListCollectionAliasesRequest;
struct ListCollectionAliasesRequestDefaultTypeInternal;
extern ListCollectionAliasesRequestDefaultTypeInternal _ListCollectionAliasesRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListCollectionAliasesRequest_class_data_;
class ListCollectionsRequest;
struct ListCollectionsRequestDefaultTypeInternal;
extern ListCollectionsRequestDefaultTypeInternal _ListCollectionsRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListCollectionsRequest_class_data_;
class ListCollectionsResponse;
struct ListCollectionsResponseDefaultTypeInternal;
extern ListCollectionsResponseDefaultTypeInternal _ListCollectionsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListCollectionsResponse_class_data_;
class LocalShardInfo;
struct LocalShardInfoDefaultTypeInternal;
extern LocalShardInfoDefaultTypeInternal _LocalShardInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LocalShardInfo_class_data_;
class MaxOptimizationThreads;
struct MaxOptimizationThreadsDefaultTypeInternal;
extern MaxOptimizationThreadsDefaultTypeInternal _MaxOptimizationThreads_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MaxOptimizationThreads_class_data_;
class MoveShard;
struct MoveShardDefaultTypeInternal;
extern MoveShardDefaultTypeInternal _MoveShard_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MoveShard_class_data_;
class MultiVectorConfig;
struct MultiVectorConfigDefaultTypeInternal;
extern MultiVectorConfigDefaultTypeInternal _MultiVectorConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MultiVectorConfig_class_data_;
class OptimizerStatus;
struct OptimizerStatusDefaultTypeInternal;
extern OptimizerStatusDefaultTypeInternal _OptimizerStatus_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull OptimizerStatus_class_data_;
class OptimizersConfigDiff;
struct OptimizersConfigDiffDefaultTypeInternal;
extern OptimizersConfigDiffDefaultTypeInternal _OptimizersConfigDiff_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull OptimizersConfigDiff_class_data_;
class PayloadIndexParams;
struct PayloadIndexParamsDefaultTypeInternal;
extern PayloadIndexParamsDefaultTypeInternal _PayloadIndexParams_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PayloadIndexParams_class_data_;
class PayloadSchemaInfo;
struct PayloadSchemaInfoDefaultTypeInternal;
extern PayloadSchemaInfoDefaultTypeInternal _PayloadSchemaInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PayloadSchemaInfo_class_data_;
class ProductQuantization;
struct ProductQuantizationDefaultTypeInternal;
extern ProductQuantizationDefaultTypeInternal _ProductQuantization_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ProductQuantization_class_data_;
class QuantizationConfig;
struct QuantizationConfigDefaultTypeInternal;
extern QuantizationConfigDefaultTypeInternal _QuantizationConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QuantizationConfig_class_data_;
class QuantizationConfigDiff;
struct QuantizationConfigDiffDefaultTypeInternal;
extern QuantizationConfigDiffDefaultTypeInternal _QuantizationConfigDiff_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QuantizationConfigDiff_class_data_;
class RemoteShardInfo;
struct RemoteShardInfoDefaultTypeInternal;
extern RemoteShardInfoDefaultTypeInternal _RemoteShardInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RemoteShardInfo_class_data_;
class RenameAlias;
struct RenameAliasDefaultTypeInternal;
extern RenameAliasDefaultTypeInternal _RenameAlias_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RenameAlias_class_data_;
class Replica;
struct ReplicaDefaultTypeInternal;
extern ReplicaDefaultTypeInternal _Replica_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Replica_class_data_;
class ReplicateShard;
struct ReplicateShardDefaultTypeInternal;
extern ReplicateShardDefaultTypeInternal _ReplicateShard_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReplicateShard_class_data_;
class ReshardingInfo;
struct ReshardingInfoDefaultTypeInternal;
extern ReshardingInfoDefaultTypeInternal _ReshardingInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReshardingInfo_class_data_;
class RestartTransfer;
struct RestartTransferDefaultTypeInternal;
extern RestartTransferDefaultTypeInternal _RestartTransfer_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RestartTransfer_class_data_;
class ScalarQuantization;
struct ScalarQuantizationDefaultTypeInternal;
extern ScalarQuantizationDefaultTypeInternal _ScalarQuantization_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ScalarQuantization_class_data_;
class ShardKey;
struct ShardKeyDefaultTypeInternal;
extern ShardKeyDefaultTypeInternal _ShardKey_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ShardKey_class_data_;
class ShardTransferInfo;
struct ShardTransferInfoDefaultTypeInternal;
extern ShardTransferInfoDefaultTypeInternal _ShardTransferInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ShardTransferInfo_class_data_;
class SnowballParams;
struct SnowballParamsDefaultTypeInternal;
extern SnowballParamsDefaultTypeInternal _SnowballParams_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SnowballParams_class_data_;
class SparseIndexConfig;
struct SparseIndexConfigDefaultTypeInternal;
extern SparseIndexConfigDefaultTypeInternal _SparseIndexConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SparseIndexConfig_class_data_;
class SparseVectorConfig;
struct SparseVectorConfigDefaultTypeInternal;
extern SparseVectorConfigDefaultTypeInternal _SparseVectorConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SparseVectorConfig_class_data_;
class SparseVectorConfig_MapEntry_DoNotUse;
struct SparseVectorConfig_MapEntry_DoNotUseDefaultTypeInternal;
extern SparseVectorConfig_MapEntry_DoNotUseDefaultTypeInternal _SparseVectorConfig_MapEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SparseVectorConfig_MapEntry_DoNotUse_class_data_;
class SparseVectorParams;
struct SparseVectorParamsDefaultTypeInternal;
extern SparseVectorParamsDefaultTypeInternal _SparseVectorParams_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SparseVectorParams_class_data_;
class StemmingAlgorithm;
struct StemmingAlgorithmDefaultTypeInternal;
extern StemmingAlgorithmDefaultTypeInternal _StemmingAlgorithm_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StemmingAlgorithm_class_data_;
class StopwordsSet;
struct StopwordsSetDefaultTypeInternal;
extern StopwordsSetDefaultTypeInternal _StopwordsSet_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StopwordsSet_class_data_;
class StrictModeConfig;
struct StrictModeConfigDefaultTypeInternal;
extern StrictModeConfigDefaultTypeInternal _StrictModeConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StrictModeConfig_class_data_;
class StrictModeMultivector;
struct StrictModeMultivectorDefaultTypeInternal;
extern StrictModeMultivectorDefaultTypeInternal _StrictModeMultivector_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StrictModeMultivector_class_data_;
class StrictModeMultivectorConfig;
struct StrictModeMultivectorConfigDefaultTypeInternal;
extern StrictModeMultivectorConfigDefaultTypeInternal _StrictModeMultivectorConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StrictModeMultivectorConfig_class_data_;
class StrictModeMultivectorConfig_MultivectorConfigEntry_DoNotUse;
struct StrictModeMultivectorConfig_MultivectorConfigEntry_DoNotUseDefaultTypeInternal;
extern StrictModeMultivectorConfig_MultivectorConfigEntry_DoNotUseDefaultTypeInternal _StrictModeMultivectorConfig_MultivectorConfigEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StrictModeMultivectorConfig_MultivectorConfigEntry_DoNotUse_class_data_;
class StrictModeSparse;
struct StrictModeSparseDefaultTypeInternal;
extern StrictModeSparseDefaultTypeInternal _StrictModeSparse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StrictModeSparse_class_data_;
class StrictModeSparseConfig;
struct StrictModeSparseConfigDefaultTypeInternal;
extern StrictModeSparseConfigDefaultTypeInternal _StrictModeSparseConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StrictModeSparseConfig_class_data_;
class StrictModeSparseConfig_SparseConfigEntry_DoNotUse;
struct StrictModeSparseConfig_SparseConfigEntry_DoNotUseDefaultTypeInternal;
extern StrictModeSparseConfig_SparseConfigEntry_DoNotUseDefaultTypeInternal _StrictModeSparseConfig_SparseConfigEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StrictModeSparseConfig_SparseConfigEntry_DoNotUse_class_data_;
class TextIndexParams;
struct TextIndexParamsDefaultTypeInternal;
extern TextIndexParamsDefaultTypeInternal _TextIndexParams_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TextIndexParams_class_data_;
class UpdateCollection;
struct UpdateCollectionDefaultTypeInternal;
extern UpdateCollectionDefaultTypeInternal _UpdateCollection_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateCollection_class_data_;
class UpdateCollectionClusterSetupRequest;
struct UpdateCollectionClusterSetupRequestDefaultTypeInternal;
extern UpdateCollectionClusterSetupRequestDefaultTypeInternal _UpdateCollectionClusterSetupRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateCollectionClusterSetupRequest_class_data_;
class UpdateCollectionClusterSetupResponse;
struct UpdateCollectionClusterSetupResponseDefaultTypeInternal;
extern UpdateCollectionClusterSetupResponseDefaultTypeInternal _UpdateCollectionClusterSetupResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateCollectionClusterSetupResponse_class_data_;
class UpdateCollection_MetadataEntry_DoNotUse;
struct UpdateCollection_MetadataEntry_DoNotUseDefaultTypeInternal;
extern UpdateCollection_MetadataEntry_DoNotUseDefaultTypeInternal _UpdateCollection_MetadataEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateCollection_MetadataEntry_DoNotUse_class_data_;
class UuidIndexParams;
struct UuidIndexParamsDefaultTypeInternal;
extern UuidIndexParamsDefaultTypeInternal _UuidIndexParams_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UuidIndexParams_class_data_;
class VectorParams;
struct VectorParamsDefaultTypeInternal;
extern VectorParamsDefaultTypeInternal _VectorParams_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VectorParams_class_data_;
class VectorParamsDiff;
struct VectorParamsDiffDefaultTypeInternal;
extern VectorParamsDiffDefaultTypeInternal _VectorParamsDiff_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VectorParamsDiff_class_data_;
class VectorParamsDiffMap;
struct VectorParamsDiffMapDefaultTypeInternal;
extern VectorParamsDiffMapDefaultTypeInternal _VectorParamsDiffMap_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VectorParamsDiffMap_class_data_;
class VectorParamsDiffMap_MapEntry_DoNotUse;
struct VectorParamsDiffMap_MapEntry_DoNotUseDefaultTypeInternal;
extern VectorParamsDiffMap_MapEntry_DoNotUseDefaultTypeInternal _VectorParamsDiffMap_MapEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VectorParamsDiffMap_MapEntry_DoNotUse_class_data_;
class VectorParamsMap;
struct VectorParamsMapDefaultTypeInternal;
extern VectorParamsMapDefaultTypeInternal _VectorParamsMap_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VectorParamsMap_class_data_;
class VectorParamsMap_MapEntry_DoNotUse;
struct VectorParamsMap_MapEntry_DoNotUseDefaultTypeInternal;
extern VectorParamsMap_MapEntry_DoNotUseDefaultTypeInternal _VectorParamsMap_MapEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VectorParamsMap_MapEntry_DoNotUse_class_data_;
class VectorsConfig;
struct VectorsConfigDefaultTypeInternal;
extern VectorsConfigDefaultTypeInternal _VectorsConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VectorsConfig_class_data_;
class VectorsConfigDiff;
struct VectorsConfigDiffDefaultTypeInternal;
extern VectorsConfigDiffDefaultTypeInternal _VectorsConfigDiff_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VectorsConfigDiff_class_data_;
class WalConfigDiff;
struct WalConfigDiffDefaultTypeInternal;
extern WalConfigDiffDefaultTypeInternal _WalConfigDiff_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull WalConfigDiff_class_data_;
}  // namespace qdrant
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::qdrant::BinaryQuantizationEncoding_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::BinaryQuantizationEncoding>;
template <>
internal::EnumTraitsT<::qdrant::BinaryQuantizationQueryEncoding_Setting_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::BinaryQuantizationQueryEncoding_Setting>;
template <>
internal::EnumTraitsT<::qdrant::CollectionStatus_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::CollectionStatus>;
template <>
internal::EnumTraitsT<::qdrant::CompressionRatio_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::CompressionRatio>;
template <>
internal::EnumTraitsT<::qdrant::Datatype_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::Datatype>;
template <>
internal::EnumTraitsT<::qdrant::Distance_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::Distance>;
template <>
internal::EnumTraitsT<::qdrant::MaxOptimizationThreads_Setting_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::MaxOptimizationThreads_Setting>;
template <>
internal::EnumTraitsT<::qdrant::Modifier_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::Modifier>;
template <>
internal::EnumTraitsT<::qdrant::MultiVectorComparator_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::MultiVectorComparator>;
template <>
internal::EnumTraitsT<::qdrant::PayloadSchemaType_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::PayloadSchemaType>;
template <>
internal::EnumTraitsT<::qdrant::QuantizationType_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::QuantizationType>;
template <>
internal::EnumTraitsT<::qdrant::ReplicaState_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::ReplicaState>;
template <>
internal::EnumTraitsT<::qdrant::ReshardingDirection_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::ReshardingDirection>;
template <>
internal::EnumTraitsT<::qdrant::ShardTransferMethod_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::ShardTransferMethod>;
template <>
internal::EnumTraitsT<::qdrant::ShardingMethod_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::ShardingMethod>;
template <>
internal::EnumTraitsT<::qdrant::TokenizerType_internal_data_>
    internal::EnumTraitsImpl::value<::qdrant::TokenizerType>;
}  // namespace protobuf
}  // namespace google

namespace qdrant {
enum MaxOptimizationThreads_Setting : int {
  MaxOptimizationThreads_Setting_Auto = 0,
  MaxOptimizationThreads_Setting_MaxOptimizationThreads_Setting_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  MaxOptimizationThreads_Setting_MaxOptimizationThreads_Setting_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t MaxOptimizationThreads_Setting_internal_data_[];
inline constexpr MaxOptimizationThreads_Setting MaxOptimizationThreads_Setting_Setting_MIN =
    static_cast<MaxOptimizationThreads_Setting>(0);
inline constexpr MaxOptimizationThreads_Setting MaxOptimizationThreads_Setting_Setting_MAX =
    static_cast<MaxOptimizationThreads_Setting>(0);
inline bool MaxOptimizationThreads_Setting_IsValid(int value) {
  return 0 <= value && value <= 0;
}
inline constexpr int MaxOptimizationThreads_Setting_Setting_ARRAYSIZE = 0 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MaxOptimizationThreads_Setting_descriptor();
template <typename T>
const ::std::string& MaxOptimizationThreads_Setting_Name(T value) {
  static_assert(::std::is_same<T, MaxOptimizationThreads_Setting>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Setting_Name().");
  return MaxOptimizationThreads_Setting_Name(static_cast<MaxOptimizationThreads_Setting>(value));
}
template <>
inline const ::std::string& MaxOptimizationThreads_Setting_Name(MaxOptimizationThreads_Setting value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MaxOptimizationThreads_Setting_descriptor, 0, 0>(
      static_cast<int>(value));
}
inline bool MaxOptimizationThreads_Setting_Parse(
    ::absl::string_view name, MaxOptimizationThreads_Setting* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<MaxOptimizationThreads_Setting>(MaxOptimizationThreads_Setting_descriptor(), name,
                                           value);
}
enum BinaryQuantizationQueryEncoding_Setting : int {
  BinaryQuantizationQueryEncoding_Setting_Default = 0,
  BinaryQuantizationQueryEncoding_Setting_Binary = 1,
  BinaryQuantizationQueryEncoding_Setting_Scalar4Bits = 2,
  BinaryQuantizationQueryEncoding_Setting_Scalar8Bits = 3,
  BinaryQuantizationQueryEncoding_Setting_BinaryQuantizationQueryEncoding_Setting_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  BinaryQuantizationQueryEncoding_Setting_BinaryQuantizationQueryEncoding_Setting_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t BinaryQuantizationQueryEncoding_Setting_internal_data_[];
inline constexpr BinaryQuantizationQueryEncoding_Setting BinaryQuantizationQueryEncoding_Setting_Setting_MIN =
    static_cast<BinaryQuantizationQueryEncoding_Setting>(0);
inline constexpr BinaryQuantizationQueryEncoding_Setting BinaryQuantizationQueryEncoding_Setting_Setting_MAX =
    static_cast<BinaryQuantizationQueryEncoding_Setting>(3);
inline bool BinaryQuantizationQueryEncoding_Setting_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int BinaryQuantizationQueryEncoding_Setting_Setting_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL BinaryQuantizationQueryEncoding_Setting_descriptor();
template <typename T>
const ::std::string& BinaryQuantizationQueryEncoding_Setting_Name(T value) {
  static_assert(::std::is_same<T, BinaryQuantizationQueryEncoding_Setting>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Setting_Name().");
  return BinaryQuantizationQueryEncoding_Setting_Name(static_cast<BinaryQuantizationQueryEncoding_Setting>(value));
}
template <>
inline const ::std::string& BinaryQuantizationQueryEncoding_Setting_Name(BinaryQuantizationQueryEncoding_Setting value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BinaryQuantizationQueryEncoding_Setting_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool BinaryQuantizationQueryEncoding_Setting_Parse(
    ::absl::string_view name, BinaryQuantizationQueryEncoding_Setting* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<BinaryQuantizationQueryEncoding_Setting>(BinaryQuantizationQueryEncoding_Setting_descriptor(), name,
                                           value);
}
enum Datatype : int {
  Default = 0,
  Float32 = 1,
  Uint8 = 2,
  Float16 = 3,
  Datatype_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Datatype_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Datatype_internal_data_[];
inline constexpr Datatype Datatype_MIN =
    static_cast<Datatype>(0);
inline constexpr Datatype Datatype_MAX =
    static_cast<Datatype>(3);
inline bool Datatype_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int Datatype_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Datatype_descriptor();
template <typename T>
const ::std::string& Datatype_Name(T value) {
  static_assert(::std::is_same<T, Datatype>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Datatype_Name().");
  return Datatype_Name(static_cast<Datatype>(value));
}
template <>
inline const ::std::string& Datatype_Name(Datatype value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Datatype_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool Datatype_Parse(
    ::absl::string_view name, Datatype* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Datatype>(Datatype_descriptor(), name,
                                           value);
}
enum Modifier : int {
  None = 0,
  Idf = 1,
  Modifier_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Modifier_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Modifier_internal_data_[];
inline constexpr Modifier Modifier_MIN =
    static_cast<Modifier>(0);
inline constexpr Modifier Modifier_MAX =
    static_cast<Modifier>(1);
inline bool Modifier_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int Modifier_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Modifier_descriptor();
template <typename T>
const ::std::string& Modifier_Name(T value) {
  static_assert(::std::is_same<T, Modifier>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Modifier_Name().");
  return Modifier_Name(static_cast<Modifier>(value));
}
template <>
inline const ::std::string& Modifier_Name(Modifier value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Modifier_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool Modifier_Parse(
    ::absl::string_view name, Modifier* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Modifier>(Modifier_descriptor(), name,
                                           value);
}
enum MultiVectorComparator : int {
  MaxSim = 0,
  MultiVectorComparator_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  MultiVectorComparator_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t MultiVectorComparator_internal_data_[];
inline constexpr MultiVectorComparator MultiVectorComparator_MIN =
    static_cast<MultiVectorComparator>(0);
inline constexpr MultiVectorComparator MultiVectorComparator_MAX =
    static_cast<MultiVectorComparator>(0);
inline bool MultiVectorComparator_IsValid(int value) {
  return 0 <= value && value <= 0;
}
inline constexpr int MultiVectorComparator_ARRAYSIZE = 0 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MultiVectorComparator_descriptor();
template <typename T>
const ::std::string& MultiVectorComparator_Name(T value) {
  static_assert(::std::is_same<T, MultiVectorComparator>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to MultiVectorComparator_Name().");
  return MultiVectorComparator_Name(static_cast<MultiVectorComparator>(value));
}
template <>
inline const ::std::string& MultiVectorComparator_Name(MultiVectorComparator value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MultiVectorComparator_descriptor, 0, 0>(
      static_cast<int>(value));
}
inline bool MultiVectorComparator_Parse(
    ::absl::string_view name, MultiVectorComparator* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<MultiVectorComparator>(MultiVectorComparator_descriptor(), name,
                                           value);
}
enum Distance : int {
  UnknownDistance = 0,
  Cosine = 1,
  Euclid = 2,
  Dot = 3,
  Manhattan = 4,
  Distance_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Distance_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Distance_internal_data_[];
inline constexpr Distance Distance_MIN =
    static_cast<Distance>(0);
inline constexpr Distance Distance_MAX =
    static_cast<Distance>(4);
inline bool Distance_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int Distance_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Distance_descriptor();
template <typename T>
const ::std::string& Distance_Name(T value) {
  static_assert(::std::is_same<T, Distance>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Distance_Name().");
  return Distance_Name(static_cast<Distance>(value));
}
template <>
inline const ::std::string& Distance_Name(Distance value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Distance_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool Distance_Parse(
    ::absl::string_view name, Distance* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Distance>(Distance_descriptor(), name,
                                           value);
}
enum CollectionStatus : int {
  UnknownCollectionStatus = 0,
  Green = 1,
  Yellow = 2,
  Red = 3,
  Grey = 4,
  CollectionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  CollectionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t CollectionStatus_internal_data_[];
inline constexpr CollectionStatus CollectionStatus_MIN =
    static_cast<CollectionStatus>(0);
inline constexpr CollectionStatus CollectionStatus_MAX =
    static_cast<CollectionStatus>(4);
inline bool CollectionStatus_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int CollectionStatus_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CollectionStatus_descriptor();
template <typename T>
const ::std::string& CollectionStatus_Name(T value) {
  static_assert(::std::is_same<T, CollectionStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CollectionStatus_Name().");
  return CollectionStatus_Name(static_cast<CollectionStatus>(value));
}
template <>
inline const ::std::string& CollectionStatus_Name(CollectionStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CollectionStatus_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool CollectionStatus_Parse(
    ::absl::string_view name, CollectionStatus* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CollectionStatus>(CollectionStatus_descriptor(), name,
                                           value);
}
enum PayloadSchemaType : int {
  UnknownType = 0,
  Keyword = 1,
  Integer = 2,
  Float = 3,
  Geo = 4,
  Text = 5,
  Bool = 6,
  Datetime = 7,
  Uuid = 8,
  PayloadSchemaType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  PayloadSchemaType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t PayloadSchemaType_internal_data_[];
inline constexpr PayloadSchemaType PayloadSchemaType_MIN =
    static_cast<PayloadSchemaType>(0);
inline constexpr PayloadSchemaType PayloadSchemaType_MAX =
    static_cast<PayloadSchemaType>(8);
inline bool PayloadSchemaType_IsValid(int value) {
  return 0 <= value && value <= 8;
}
inline constexpr int PayloadSchemaType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL PayloadSchemaType_descriptor();
template <typename T>
const ::std::string& PayloadSchemaType_Name(T value) {
  static_assert(::std::is_same<T, PayloadSchemaType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PayloadSchemaType_Name().");
  return PayloadSchemaType_Name(static_cast<PayloadSchemaType>(value));
}
template <>
inline const ::std::string& PayloadSchemaType_Name(PayloadSchemaType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PayloadSchemaType_descriptor, 0, 8>(
      static_cast<int>(value));
}
inline bool PayloadSchemaType_Parse(
    ::absl::string_view name, PayloadSchemaType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<PayloadSchemaType>(PayloadSchemaType_descriptor(), name,
                                           value);
}
enum QuantizationType : int {
  UnknownQuantization = 0,
  Int8 = 1,
  QuantizationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  QuantizationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t QuantizationType_internal_data_[];
inline constexpr QuantizationType QuantizationType_MIN =
    static_cast<QuantizationType>(0);
inline constexpr QuantizationType QuantizationType_MAX =
    static_cast<QuantizationType>(1);
inline bool QuantizationType_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int QuantizationType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL QuantizationType_descriptor();
template <typename T>
const ::std::string& QuantizationType_Name(T value) {
  static_assert(::std::is_same<T, QuantizationType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to QuantizationType_Name().");
  return QuantizationType_Name(static_cast<QuantizationType>(value));
}
template <>
inline const ::std::string& QuantizationType_Name(QuantizationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<QuantizationType_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool QuantizationType_Parse(
    ::absl::string_view name, QuantizationType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<QuantizationType>(QuantizationType_descriptor(), name,
                                           value);
}
enum CompressionRatio : int {
  x4 = 0,
  x8 = 1,
  x16 = 2,
  x32 = 3,
  x64 = 4,
  CompressionRatio_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  CompressionRatio_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t CompressionRatio_internal_data_[];
inline constexpr CompressionRatio CompressionRatio_MIN =
    static_cast<CompressionRatio>(0);
inline constexpr CompressionRatio CompressionRatio_MAX =
    static_cast<CompressionRatio>(4);
inline bool CompressionRatio_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int CompressionRatio_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CompressionRatio_descriptor();
template <typename T>
const ::std::string& CompressionRatio_Name(T value) {
  static_assert(::std::is_same<T, CompressionRatio>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CompressionRatio_Name().");
  return CompressionRatio_Name(static_cast<CompressionRatio>(value));
}
template <>
inline const ::std::string& CompressionRatio_Name(CompressionRatio value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CompressionRatio_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool CompressionRatio_Parse(
    ::absl::string_view name, CompressionRatio* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CompressionRatio>(CompressionRatio_descriptor(), name,
                                           value);
}
enum BinaryQuantizationEncoding : int {
  OneBit = 0,
  TwoBits = 1,
  OneAndHalfBits = 2,
  BinaryQuantizationEncoding_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  BinaryQuantizationEncoding_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t BinaryQuantizationEncoding_internal_data_[];
inline constexpr BinaryQuantizationEncoding BinaryQuantizationEncoding_MIN =
    static_cast<BinaryQuantizationEncoding>(0);
inline constexpr BinaryQuantizationEncoding BinaryQuantizationEncoding_MAX =
    static_cast<BinaryQuantizationEncoding>(2);
inline bool BinaryQuantizationEncoding_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int BinaryQuantizationEncoding_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL BinaryQuantizationEncoding_descriptor();
template <typename T>
const ::std::string& BinaryQuantizationEncoding_Name(T value) {
  static_assert(::std::is_same<T, BinaryQuantizationEncoding>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BinaryQuantizationEncoding_Name().");
  return BinaryQuantizationEncoding_Name(static_cast<BinaryQuantizationEncoding>(value));
}
template <>
inline const ::std::string& BinaryQuantizationEncoding_Name(BinaryQuantizationEncoding value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BinaryQuantizationEncoding_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool BinaryQuantizationEncoding_Parse(
    ::absl::string_view name, BinaryQuantizationEncoding* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<BinaryQuantizationEncoding>(BinaryQuantizationEncoding_descriptor(), name,
                                           value);
}
enum ShardingMethod : int {
  Auto = 0,
  Custom = 1,
  ShardingMethod_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ShardingMethod_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ShardingMethod_internal_data_[];
inline constexpr ShardingMethod ShardingMethod_MIN =
    static_cast<ShardingMethod>(0);
inline constexpr ShardingMethod ShardingMethod_MAX =
    static_cast<ShardingMethod>(1);
inline bool ShardingMethod_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int ShardingMethod_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ShardingMethod_descriptor();
template <typename T>
const ::std::string& ShardingMethod_Name(T value) {
  static_assert(::std::is_same<T, ShardingMethod>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ShardingMethod_Name().");
  return ShardingMethod_Name(static_cast<ShardingMethod>(value));
}
template <>
inline const ::std::string& ShardingMethod_Name(ShardingMethod value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ShardingMethod_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool ShardingMethod_Parse(
    ::absl::string_view name, ShardingMethod* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShardingMethod>(ShardingMethod_descriptor(), name,
                                           value);
}
enum TokenizerType : int {
  Unknown = 0,
  Prefix = 1,
  Whitespace = 2,
  Word = 3,
  Multilingual = 4,
  TokenizerType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TokenizerType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TokenizerType_internal_data_[];
inline constexpr TokenizerType TokenizerType_MIN =
    static_cast<TokenizerType>(0);
inline constexpr TokenizerType TokenizerType_MAX =
    static_cast<TokenizerType>(4);
inline bool TokenizerType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int TokenizerType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TokenizerType_descriptor();
template <typename T>
const ::std::string& TokenizerType_Name(T value) {
  static_assert(::std::is_same<T, TokenizerType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TokenizerType_Name().");
  return TokenizerType_Name(static_cast<TokenizerType>(value));
}
template <>
inline const ::std::string& TokenizerType_Name(TokenizerType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TokenizerType_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool TokenizerType_Parse(
    ::absl::string_view name, TokenizerType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TokenizerType>(TokenizerType_descriptor(), name,
                                           value);
}
enum ReplicaState : int {
  Active = 0,
  Dead = 1,
  Partial = 2,
  Initializing = 3,
  Listener = 4,
  PartialSnapshot = 5,
  Recovery = 6,
  Resharding = 7,
  ReshardingScaleDown = 8,
  ReplicaState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ReplicaState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ReplicaState_internal_data_[];
inline constexpr ReplicaState ReplicaState_MIN =
    static_cast<ReplicaState>(0);
inline constexpr ReplicaState ReplicaState_MAX =
    static_cast<ReplicaState>(8);
inline bool ReplicaState_IsValid(int value) {
  return 0 <= value && value <= 8;
}
inline constexpr int ReplicaState_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ReplicaState_descriptor();
template <typename T>
const ::std::string& ReplicaState_Name(T value) {
  static_assert(::std::is_same<T, ReplicaState>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ReplicaState_Name().");
  return ReplicaState_Name(static_cast<ReplicaState>(value));
}
template <>
inline const ::std::string& ReplicaState_Name(ReplicaState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ReplicaState_descriptor, 0, 8>(
      static_cast<int>(value));
}
inline bool ReplicaState_Parse(
    ::absl::string_view name, ReplicaState* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReplicaState>(ReplicaState_descriptor(), name,
                                           value);
}
enum ReshardingDirection : int {
  Up = 0,
  Down = 1,
  ReshardingDirection_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ReshardingDirection_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ReshardingDirection_internal_data_[];
inline constexpr ReshardingDirection ReshardingDirection_MIN =
    static_cast<ReshardingDirection>(0);
inline constexpr ReshardingDirection ReshardingDirection_MAX =
    static_cast<ReshardingDirection>(1);
inline bool ReshardingDirection_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int ReshardingDirection_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ReshardingDirection_descriptor();
template <typename T>
const ::std::string& ReshardingDirection_Name(T value) {
  static_assert(::std::is_same<T, ReshardingDirection>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ReshardingDirection_Name().");
  return ReshardingDirection_Name(static_cast<ReshardingDirection>(value));
}
template <>
inline const ::std::string& ReshardingDirection_Name(ReshardingDirection value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ReshardingDirection_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool ReshardingDirection_Parse(
    ::absl::string_view name, ReshardingDirection* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReshardingDirection>(ReshardingDirection_descriptor(), name,
                                           value);
}
enum ShardTransferMethod : int {
  StreamRecords = 0,
  Snapshot = 1,
  WalDelta = 2,
  ReshardingStreamRecords = 3,
  ShardTransferMethod_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ShardTransferMethod_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ShardTransferMethod_internal_data_[];
inline constexpr ShardTransferMethod ShardTransferMethod_MIN =
    static_cast<ShardTransferMethod>(0);
inline constexpr ShardTransferMethod ShardTransferMethod_MAX =
    static_cast<ShardTransferMethod>(3);
inline bool ShardTransferMethod_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ShardTransferMethod_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ShardTransferMethod_descriptor();
template <typename T>
const ::std::string& ShardTransferMethod_Name(T value) {
  static_assert(::std::is_same<T, ShardTransferMethod>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ShardTransferMethod_Name().");
  return ShardTransferMethod_Name(static_cast<ShardTransferMethod>(value));
}
template <>
inline const ::std::string& ShardTransferMethod_Name(ShardTransferMethod value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ShardTransferMethod_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool ShardTransferMethod_Parse(
    ::absl::string_view name, ShardTransferMethod* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShardTransferMethod>(ShardTransferMethod_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class WalConfigDiff final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.WalConfigDiff) */ {
 public:
  inline WalConfigDiff() : WalConfigDiff(nullptr) {}
  ~WalConfigDiff() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WalConfigDiff* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WalConfigDiff));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WalConfigDiff(::google::protobuf::internal::ConstantInitialized);

  inline WalConfigDiff(const WalConfigDiff& from) : WalConfigDiff(nullptr, from) {}
  inline WalConfigDiff(WalConfigDiff&& from) noexcept
      : WalConfigDiff(nullptr, ::std::move(from)) {}
  inline WalConfigDiff& operator=(const WalConfigDiff& from) {
    CopyFrom(from);
    return *this;
  }
  inline WalConfigDiff& operator=(WalConfigDiff&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WalConfigDiff& default_instance() {
    return *reinterpret_cast<const WalConfigDiff*>(
        &_WalConfigDiff_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(WalConfigDiff& a, WalConfigDiff& b) { a.Swap(&b); }
  inline void Swap(WalConfigDiff* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WalConfigDiff* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WalConfigDiff* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WalConfigDiff>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WalConfigDiff& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WalConfigDiff& from) { WalConfigDiff::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WalConfigDiff* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.WalConfigDiff"; }

  explicit WalConfigDiff(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  WalConfigDiff(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const WalConfigDiff& from);
  WalConfigDiff(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, WalConfigDiff&& from) noexcept
      : WalConfigDiff(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWalCapacityMbFieldNumber = 1,
    kWalSegmentsAheadFieldNumber = 2,
    kWalRetainClosedFieldNumber = 3,
  };
  // optional uint64 wal_capacity_mb = 1;
  bool has_wal_capacity_mb() const;
  void clear_wal_capacity_mb() ;
  ::uint64_t wal_capacity_mb() const;
  void set_wal_capacity_mb(::uint64_t value);

  private:
  ::uint64_t _internal_wal_capacity_mb() const;
  void _internal_set_wal_capacity_mb(::uint64_t value);

  public:
  // optional uint64 wal_segments_ahead = 2;
  bool has_wal_segments_ahead() const;
  void clear_wal_segments_ahead() ;
  ::uint64_t wal_segments_ahead() const;
  void set_wal_segments_ahead(::uint64_t value);

  private:
  ::uint64_t _internal_wal_segments_ahead() const;
  void _internal_set_wal_segments_ahead(::uint64_t value);

  public:
  // optional uint64 wal_retain_closed = 3;
  bool has_wal_retain_closed() const;
  void clear_wal_retain_closed() ;
  ::uint64_t wal_retain_closed() const;
  void set_wal_retain_closed(::uint64_t value);

  private:
  ::uint64_t _internal_wal_retain_closed() const;
  void _internal_set_wal_retain_closed(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.WalConfigDiff)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const WalConfigDiff& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t wal_capacity_mb_;
    ::uint64_t wal_segments_ahead_;
    ::uint64_t wal_retain_closed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull WalConfigDiff_class_data_;
// -------------------------------------------------------------------

class UuidIndexParams final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.UuidIndexParams) */ {
 public:
  inline UuidIndexParams() : UuidIndexParams(nullptr) {}
  ~UuidIndexParams() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UuidIndexParams* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UuidIndexParams));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UuidIndexParams(::google::protobuf::internal::ConstantInitialized);

  inline UuidIndexParams(const UuidIndexParams& from) : UuidIndexParams(nullptr, from) {}
  inline UuidIndexParams(UuidIndexParams&& from) noexcept
      : UuidIndexParams(nullptr, ::std::move(from)) {}
  inline UuidIndexParams& operator=(const UuidIndexParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline UuidIndexParams& operator=(UuidIndexParams&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UuidIndexParams& default_instance() {
    return *reinterpret_cast<const UuidIndexParams*>(
        &_UuidIndexParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 60;
  friend void swap(UuidIndexParams& a, UuidIndexParams& b) { a.Swap(&b); }
  inline void Swap(UuidIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UuidIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UuidIndexParams* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UuidIndexParams>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UuidIndexParams& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UuidIndexParams& from) { UuidIndexParams::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UuidIndexParams* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.UuidIndexParams"; }

  explicit UuidIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UuidIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UuidIndexParams& from);
  UuidIndexParams(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UuidIndexParams&& from) noexcept
      : UuidIndexParams(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIsTenantFieldNumber = 1,
    kOnDiskFieldNumber = 2,
  };
  // optional bool is_tenant = 1;
  bool has_is_tenant() const;
  void clear_is_tenant() ;
  bool is_tenant() const;
  void set_is_tenant(bool value);

  private:
  bool _internal_is_tenant() const;
  void _internal_set_is_tenant(bool value);

  public:
  // optional bool on_disk = 2;
  bool has_on_disk() const;
  void clear_on_disk() ;
  bool on_disk() const;
  void set_on_disk(bool value);

  private:
  bool _internal_on_disk() const;
  void _internal_set_on_disk(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.UuidIndexParams)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UuidIndexParams& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool is_tenant_;
    bool on_disk_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UuidIndexParams_class_data_;
// -------------------------------------------------------------------

class UpdateCollectionClusterSetupResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.UpdateCollectionClusterSetupResponse) */ {
 public:
  inline UpdateCollectionClusterSetupResponse() : UpdateCollectionClusterSetupResponse(nullptr) {}
  ~UpdateCollectionClusterSetupResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateCollectionClusterSetupResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateCollectionClusterSetupResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateCollectionClusterSetupResponse(::google::protobuf::internal::ConstantInitialized);

  inline UpdateCollectionClusterSetupResponse(const UpdateCollectionClusterSetupResponse& from) : UpdateCollectionClusterSetupResponse(nullptr, from) {}
  inline UpdateCollectionClusterSetupResponse(UpdateCollectionClusterSetupResponse&& from) noexcept
      : UpdateCollectionClusterSetupResponse(nullptr, ::std::move(from)) {}
  inline UpdateCollectionClusterSetupResponse& operator=(const UpdateCollectionClusterSetupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCollectionClusterSetupResponse& operator=(UpdateCollectionClusterSetupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCollectionClusterSetupResponse& default_instance() {
    return *reinterpret_cast<const UpdateCollectionClusterSetupResponse*>(
        &_UpdateCollectionClusterSetupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 89;
  friend void swap(UpdateCollectionClusterSetupResponse& a, UpdateCollectionClusterSetupResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateCollectionClusterSetupResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCollectionClusterSetupResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCollectionClusterSetupResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateCollectionClusterSetupResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateCollectionClusterSetupResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateCollectionClusterSetupResponse& from) { UpdateCollectionClusterSetupResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateCollectionClusterSetupResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.UpdateCollectionClusterSetupResponse"; }

  explicit UpdateCollectionClusterSetupResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateCollectionClusterSetupResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateCollectionClusterSetupResponse& from);
  UpdateCollectionClusterSetupResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateCollectionClusterSetupResponse&& from) noexcept
      : UpdateCollectionClusterSetupResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
  };
  // bool result = 1;
  void clear_result() ;
  bool result() const;
  void set_result(bool value);

  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.UpdateCollectionClusterSetupResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateCollectionClusterSetupResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool result_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateCollectionClusterSetupResponse_class_data_;
// -------------------------------------------------------------------

class StrictModeSparse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.StrictModeSparse) */ {
 public:
  inline StrictModeSparse() : StrictModeSparse(nullptr) {}
  ~StrictModeSparse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StrictModeSparse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StrictModeSparse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StrictModeSparse(::google::protobuf::internal::ConstantInitialized);

  inline StrictModeSparse(const StrictModeSparse& from) : StrictModeSparse(nullptr, from) {}
  inline StrictModeSparse(StrictModeSparse&& from) noexcept
      : StrictModeSparse(nullptr, ::std::move(from)) {}
  inline StrictModeSparse& operator=(const StrictModeSparse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrictModeSparse& operator=(StrictModeSparse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrictModeSparse& default_instance() {
    return *reinterpret_cast<const StrictModeSparse*>(
        &_StrictModeSparse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(StrictModeSparse& a, StrictModeSparse& b) { a.Swap(&b); }
  inline void Swap(StrictModeSparse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrictModeSparse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrictModeSparse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StrictModeSparse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StrictModeSparse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StrictModeSparse& from) { StrictModeSparse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StrictModeSparse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.StrictModeSparse"; }

  explicit StrictModeSparse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StrictModeSparse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StrictModeSparse& from);
  StrictModeSparse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StrictModeSparse&& from) noexcept
      : StrictModeSparse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMaxLengthFieldNumber = 10,
  };
  // optional uint64 max_length = 10;
  bool has_max_length() const;
  void clear_max_length() ;
  ::uint64_t max_length() const;
  void set_max_length(::uint64_t value);

  private:
  ::uint64_t _internal_max_length() const;
  void _internal_set_max_length(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.StrictModeSparse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StrictModeSparse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t max_length_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StrictModeSparse_class_data_;
// -------------------------------------------------------------------

class StrictModeMultivector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.StrictModeMultivector) */ {
 public:
  inline StrictModeMultivector() : StrictModeMultivector(nullptr) {}
  ~StrictModeMultivector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StrictModeMultivector* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StrictModeMultivector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StrictModeMultivector(::google::protobuf::internal::ConstantInitialized);

  inline StrictModeMultivector(const StrictModeMultivector& from) : StrictModeMultivector(nullptr, from) {}
  inline StrictModeMultivector(StrictModeMultivector&& from) noexcept
      : StrictModeMultivector(nullptr, ::std::move(from)) {}
  inline StrictModeMultivector& operator=(const StrictModeMultivector& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrictModeMultivector& operator=(StrictModeMultivector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrictModeMultivector& default_instance() {
    return *reinterpret_cast<const StrictModeMultivector*>(
        &_StrictModeMultivector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(StrictModeMultivector& a, StrictModeMultivector& b) { a.Swap(&b); }
  inline void Swap(StrictModeMultivector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrictModeMultivector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrictModeMultivector* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StrictModeMultivector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StrictModeMultivector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StrictModeMultivector& from) { StrictModeMultivector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StrictModeMultivector* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.StrictModeMultivector"; }

  explicit StrictModeMultivector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StrictModeMultivector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StrictModeMultivector& from);
  StrictModeMultivector(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StrictModeMultivector&& from) noexcept
      : StrictModeMultivector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMaxVectorsFieldNumber = 1,
  };
  // optional uint64 max_vectors = 1;
  bool has_max_vectors() const;
  void clear_max_vectors() ;
  ::uint64_t max_vectors() const;
  void set_max_vectors(::uint64_t value);

  private:
  ::uint64_t _internal_max_vectors() const;
  void _internal_set_max_vectors(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.StrictModeMultivector)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StrictModeMultivector& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t max_vectors_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StrictModeMultivector_class_data_;
// -------------------------------------------------------------------

class StopwordsSet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.StopwordsSet) */ {
 public:
  inline StopwordsSet() : StopwordsSet(nullptr) {}
  ~StopwordsSet() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StopwordsSet* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StopwordsSet));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StopwordsSet(::google::protobuf::internal::ConstantInitialized);

  inline StopwordsSet(const StopwordsSet& from) : StopwordsSet(nullptr, from) {}
  inline StopwordsSet(StopwordsSet&& from) noexcept
      : StopwordsSet(nullptr, ::std::move(from)) {}
  inline StopwordsSet& operator=(const StopwordsSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopwordsSet& operator=(StopwordsSet&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopwordsSet& default_instance() {
    return *reinterpret_cast<const StopwordsSet*>(
        &_StopwordsSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 54;
  friend void swap(StopwordsSet& a, StopwordsSet& b) { a.Swap(&b); }
  inline void Swap(StopwordsSet* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopwordsSet* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopwordsSet* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StopwordsSet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StopwordsSet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StopwordsSet& from) { StopwordsSet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StopwordsSet* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.StopwordsSet"; }

  explicit StopwordsSet(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StopwordsSet(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StopwordsSet& from);
  StopwordsSet(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StopwordsSet&& from) noexcept
      : StopwordsSet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLanguagesFieldNumber = 1,
    kCustomFieldNumber = 2,
  };
  // repeated string languages = 1;
  int languages_size() const;
  private:
  int _internal_languages_size() const;

  public:
  void clear_languages() ;
  const ::std::string& languages(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_languages(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_languages(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_languages();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_languages(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& languages() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_languages();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_languages() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_languages();

  public:
  // repeated string custom = 2;
  int custom_size() const;
  private:
  int _internal_custom_size() const;

  public:
  void clear_custom() ;
  const ::std::string& custom(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_custom(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_custom(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_custom();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_custom(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& custom() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_custom();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_custom() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_custom();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.StopwordsSet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 43,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StopwordsSet& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> languages_;
    ::google::protobuf::RepeatedPtrField<::std::string> custom_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StopwordsSet_class_data_;
// -------------------------------------------------------------------

class SparseIndexConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SparseIndexConfig) */ {
 public:
  inline SparseIndexConfig() : SparseIndexConfig(nullptr) {}
  ~SparseIndexConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SparseIndexConfig* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SparseIndexConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SparseIndexConfig(::google::protobuf::internal::ConstantInitialized);

  inline SparseIndexConfig(const SparseIndexConfig& from) : SparseIndexConfig(nullptr, from) {}
  inline SparseIndexConfig(SparseIndexConfig&& from) noexcept
      : SparseIndexConfig(nullptr, ::std::move(from)) {}
  inline SparseIndexConfig& operator=(const SparseIndexConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SparseIndexConfig& operator=(SparseIndexConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SparseIndexConfig& default_instance() {
    return *reinterpret_cast<const SparseIndexConfig*>(
        &_SparseIndexConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(SparseIndexConfig& a, SparseIndexConfig& b) { a.Swap(&b); }
  inline void Swap(SparseIndexConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SparseIndexConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SparseIndexConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SparseIndexConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SparseIndexConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SparseIndexConfig& from) { SparseIndexConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SparseIndexConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SparseIndexConfig"; }

  explicit SparseIndexConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SparseIndexConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SparseIndexConfig& from);
  SparseIndexConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SparseIndexConfig&& from) noexcept
      : SparseIndexConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFullScanThresholdFieldNumber = 1,
    kOnDiskFieldNumber = 2,
    kDatatypeFieldNumber = 3,
  };
  // optional uint64 full_scan_threshold = 1;
  bool has_full_scan_threshold() const;
  void clear_full_scan_threshold() ;
  ::uint64_t full_scan_threshold() const;
  void set_full_scan_threshold(::uint64_t value);

  private:
  ::uint64_t _internal_full_scan_threshold() const;
  void _internal_set_full_scan_threshold(::uint64_t value);

  public:
  // optional bool on_disk = 2;
  bool has_on_disk() const;
  void clear_on_disk() ;
  bool on_disk() const;
  void set_on_disk(bool value);

  private:
  bool _internal_on_disk() const;
  void _internal_set_on_disk(bool value);

  public:
  // optional .qdrant.Datatype datatype = 3;
  bool has_datatype() const;
  void clear_datatype() ;
  ::qdrant::Datatype datatype() const;
  void set_datatype(::qdrant::Datatype value);

  private:
  ::qdrant::Datatype _internal_datatype() const;
  void _internal_set_datatype(::qdrant::Datatype value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SparseIndexConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SparseIndexConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t full_scan_threshold_;
    bool on_disk_;
    int datatype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SparseIndexConfig_class_data_;
// -------------------------------------------------------------------

class SnowballParams final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SnowballParams) */ {
 public:
  inline SnowballParams() : SnowballParams(nullptr) {}
  ~SnowballParams() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SnowballParams* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SnowballParams));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SnowballParams(::google::protobuf::internal::ConstantInitialized);

  inline SnowballParams(const SnowballParams& from) : SnowballParams(nullptr, from) {}
  inline SnowballParams(SnowballParams&& from) noexcept
      : SnowballParams(nullptr, ::std::move(from)) {}
  inline SnowballParams& operator=(const SnowballParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnowballParams& operator=(SnowballParams&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnowballParams& default_instance() {
    return *reinterpret_cast<const SnowballParams*>(
        &_SnowballParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 57;
  friend void swap(SnowballParams& a, SnowballParams& b) { a.Swap(&b); }
  inline void Swap(SnowballParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnowballParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnowballParams* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SnowballParams>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SnowballParams& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SnowballParams& from) { SnowballParams::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SnowballParams* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SnowballParams"; }

  explicit SnowballParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SnowballParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SnowballParams& from);
  SnowballParams(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SnowballParams&& from) noexcept
      : SnowballParams(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLanguageFieldNumber = 1,
  };
  // string language = 1;
  void clear_language() ;
  const ::std::string& language() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_language(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_language();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_language();
  void set_allocated_language(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_language() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_language(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_language();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SnowballParams)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 38,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SnowballParams& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr language_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SnowballParams_class_data_;
// -------------------------------------------------------------------

class ShardTransferInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ShardTransferInfo) */ {
 public:
  inline ShardTransferInfo() : ShardTransferInfo(nullptr) {}
  ~ShardTransferInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ShardTransferInfo* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ShardTransferInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ShardTransferInfo(::google::protobuf::internal::ConstantInitialized);

  inline ShardTransferInfo(const ShardTransferInfo& from) : ShardTransferInfo(nullptr, from) {}
  inline ShardTransferInfo(ShardTransferInfo&& from) noexcept
      : ShardTransferInfo(nullptr, ::std::move(from)) {}
  inline ShardTransferInfo& operator=(const ShardTransferInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardTransferInfo& operator=(ShardTransferInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardTransferInfo& default_instance() {
    return *reinterpret_cast<const ShardTransferInfo*>(
        &_ShardTransferInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 78;
  friend void swap(ShardTransferInfo& a, ShardTransferInfo& b) { a.Swap(&b); }
  inline void Swap(ShardTransferInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardTransferInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardTransferInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ShardTransferInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ShardTransferInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ShardTransferInfo& from) { ShardTransferInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ShardTransferInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ShardTransferInfo"; }

  explicit ShardTransferInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ShardTransferInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ShardTransferInfo& from);
  ShardTransferInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ShardTransferInfo&& from) noexcept
      : ShardTransferInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFromFieldNumber = 2,
    kShardIdFieldNumber = 1,
    kSyncFieldNumber = 4,
    kToFieldNumber = 3,
    kToShardIdFieldNumber = 5,
  };
  // uint64 from = 2;
  void clear_from() ;
  ::uint64_t from() const;
  void set_from(::uint64_t value);

  private:
  ::uint64_t _internal_from() const;
  void _internal_set_from(::uint64_t value);

  public:
  // uint32 shard_id = 1;
  void clear_shard_id() ;
  ::uint32_t shard_id() const;
  void set_shard_id(::uint32_t value);

  private:
  ::uint32_t _internal_shard_id() const;
  void _internal_set_shard_id(::uint32_t value);

  public:
  // bool sync = 4;
  void clear_sync() ;
  bool sync() const;
  void set_sync(bool value);

  private:
  bool _internal_sync() const;
  void _internal_set_sync(bool value);

  public:
  // uint64 to = 3;
  void clear_to() ;
  ::uint64_t to() const;
  void set_to(::uint64_t value);

  private:
  ::uint64_t _internal_to() const;
  void _internal_set_to(::uint64_t value);

  public:
  // optional uint32 to_shard_id = 5;
  bool has_to_shard_id() const;
  void clear_to_shard_id() ;
  ::uint32_t to_shard_id() const;
  void set_to_shard_id(::uint32_t value);

  private:
  ::uint32_t _internal_to_shard_id() const;
  void _internal_set_to_shard_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.ShardTransferInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ShardTransferInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t from_;
    ::uint32_t shard_id_;
    bool sync_;
    ::uint64_t to_;
    ::uint32_t to_shard_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ShardTransferInfo_class_data_;
// -------------------------------------------------------------------

class ShardKey final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ShardKey) */ {
 public:
  inline ShardKey() : ShardKey(nullptr) {}
  ~ShardKey() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ShardKey* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ShardKey));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ShardKey(::google::protobuf::internal::ConstantInitialized);

  inline ShardKey(const ShardKey& from) : ShardKey(nullptr, from) {}
  inline ShardKey(ShardKey&& from) noexcept
      : ShardKey(nullptr, ::std::move(from)) {}
  inline ShardKey& operator=(const ShardKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardKey& operator=(ShardKey&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardKey& default_instance() {
    return *reinterpret_cast<const ShardKey*>(
        &_ShardKey_default_instance_);
  }
  enum KeyCase {
    kKeyword = 1,
    kNumber = 2,
    KEY_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 75;
  friend void swap(ShardKey& a, ShardKey& b) { a.Swap(&b); }
  inline void Swap(ShardKey* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardKey* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardKey* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ShardKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ShardKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ShardKey& from) { ShardKey::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ShardKey* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ShardKey"; }

  explicit ShardKey(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ShardKey(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ShardKey& from);
  ShardKey(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ShardKey&& from) noexcept
      : ShardKey(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeywordFieldNumber = 1,
    kNumberFieldNumber = 2,
  };
  // string keyword = 1;
  bool has_keyword() const;
  void clear_keyword() ;
  const ::std::string& keyword() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_keyword(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_keyword();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_keyword();
  void set_allocated_keyword(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_keyword() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_keyword(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_keyword();

  public:
  // uint64 number = 2;
  bool has_number() const;
  void clear_number() ;
  ::uint64_t number() const;
  void set_number(::uint64_t value);

  private:
  ::uint64_t _internal_number() const;
  void _internal_set_number(::uint64_t value);

  public:
  void clear_key();
  KeyCase key_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.ShardKey)
 private:
  class _Internal;
  void set_has_keyword();
  void set_has_number();
  inline bool has_key() const;
  inline void clear_has_key();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   0, 31,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ShardKey& from_msg);
    union KeyUnion {
      constexpr KeyUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr keyword_;
      ::uint64_t number_;
    } key_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ShardKey_class_data_;
// -------------------------------------------------------------------

class ScalarQuantization final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ScalarQuantization) */ {
 public:
  inline ScalarQuantization() : ScalarQuantization(nullptr) {}
  ~ScalarQuantization() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ScalarQuantization* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ScalarQuantization));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ScalarQuantization(::google::protobuf::internal::ConstantInitialized);

  inline ScalarQuantization(const ScalarQuantization& from) : ScalarQuantization(nullptr, from) {}
  inline ScalarQuantization(ScalarQuantization&& from) noexcept
      : ScalarQuantization(nullptr, ::std::move(from)) {}
  inline ScalarQuantization& operator=(const ScalarQuantization& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScalarQuantization& operator=(ScalarQuantization&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScalarQuantization& default_instance() {
    return *reinterpret_cast<const ScalarQuantization*>(
        &_ScalarQuantization_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(ScalarQuantization& a, ScalarQuantization& b) { a.Swap(&b); }
  inline void Swap(ScalarQuantization* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScalarQuantization* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScalarQuantization* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ScalarQuantization>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ScalarQuantization& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ScalarQuantization& from) { ScalarQuantization::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ScalarQuantization* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ScalarQuantization"; }

  explicit ScalarQuantization(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ScalarQuantization(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ScalarQuantization& from);
  ScalarQuantization(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ScalarQuantization&& from) noexcept
      : ScalarQuantization(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kQuantileFieldNumber = 2,
    kAlwaysRamFieldNumber = 3,
  };
  // .qdrant.QuantizationType type = 1;
  void clear_type() ;
  ::qdrant::QuantizationType type() const;
  void set_type(::qdrant::QuantizationType value);

  private:
  ::qdrant::QuantizationType _internal_type() const;
  void _internal_set_type(::qdrant::QuantizationType value);

  public:
  // optional float quantile = 2;
  bool has_quantile() const;
  void clear_quantile() ;
  float quantile() const;
  void set_quantile(float value);

  private:
  float _internal_quantile() const;
  void _internal_set_quantile(float value);

  public:
  // optional bool always_ram = 3;
  bool has_always_ram() const;
  void clear_always_ram() ;
  bool always_ram() const;
  void set_always_ram(bool value);

  private:
  bool _internal_always_ram() const;
  void _internal_set_always_ram(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.ScalarQuantization)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ScalarQuantization& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int type_;
    float quantile_;
    bool always_ram_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ScalarQuantization_class_data_;
// -------------------------------------------------------------------

class RestartTransfer final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.RestartTransfer) */ {
 public:
  inline RestartTransfer() : RestartTransfer(nullptr) {}
  ~RestartTransfer() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RestartTransfer* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RestartTransfer));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RestartTransfer(::google::protobuf::internal::ConstantInitialized);

  inline RestartTransfer(const RestartTransfer& from) : RestartTransfer(nullptr, from) {}
  inline RestartTransfer(RestartTransfer&& from) noexcept
      : RestartTransfer(nullptr, ::std::move(from)) {}
  inline RestartTransfer& operator=(const RestartTransfer& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestartTransfer& operator=(RestartTransfer&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestartTransfer& default_instance() {
    return *reinterpret_cast<const RestartTransfer*>(
        &_RestartTransfer_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 84;
  friend void swap(RestartTransfer& a, RestartTransfer& b) { a.Swap(&b); }
  inline void Swap(RestartTransfer* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestartTransfer* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestartTransfer* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RestartTransfer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RestartTransfer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RestartTransfer& from) { RestartTransfer::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RestartTransfer* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.RestartTransfer"; }

  explicit RestartTransfer(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RestartTransfer(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RestartTransfer& from);
  RestartTransfer(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RestartTransfer&& from) noexcept
      : RestartTransfer(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFromPeerIdFieldNumber = 2,
    kShardIdFieldNumber = 1,
    kMethodFieldNumber = 4,
    kToPeerIdFieldNumber = 3,
    kToShardIdFieldNumber = 5,
  };
  // uint64 from_peer_id = 2;
  void clear_from_peer_id() ;
  ::uint64_t from_peer_id() const;
  void set_from_peer_id(::uint64_t value);

  private:
  ::uint64_t _internal_from_peer_id() const;
  void _internal_set_from_peer_id(::uint64_t value);

  public:
  // uint32 shard_id = 1;
  void clear_shard_id() ;
  ::uint32_t shard_id() const;
  void set_shard_id(::uint32_t value);

  private:
  ::uint32_t _internal_shard_id() const;
  void _internal_set_shard_id(::uint32_t value);

  public:
  // .qdrant.ShardTransferMethod method = 4;
  void clear_method() ;
  ::qdrant::ShardTransferMethod method() const;
  void set_method(::qdrant::ShardTransferMethod value);

  private:
  ::qdrant::ShardTransferMethod _internal_method() const;
  void _internal_set_method(::qdrant::ShardTransferMethod value);

  public:
  // uint64 to_peer_id = 3;
  void clear_to_peer_id() ;
  ::uint64_t to_peer_id() const;
  void set_to_peer_id(::uint64_t value);

  private:
  ::uint64_t _internal_to_peer_id() const;
  void _internal_set_to_peer_id(::uint64_t value);

  public:
  // optional uint32 to_shard_id = 5;
  bool has_to_shard_id() const;
  void clear_to_shard_id() ;
  ::uint32_t to_shard_id() const;
  void set_to_shard_id(::uint32_t value);

  private:
  ::uint32_t _internal_to_shard_id() const;
  void _internal_set_to_shard_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.RestartTransfer)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RestartTransfer& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t from_peer_id_;
    ::uint32_t shard_id_;
    int method_;
    ::uint64_t to_peer_id_;
    ::uint32_t to_shard_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RestartTransfer_class_data_;
// -------------------------------------------------------------------

class ReplicateShard final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ReplicateShard) */ {
 public:
  inline ReplicateShard() : ReplicateShard(nullptr) {}
  ~ReplicateShard() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReplicateShard* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReplicateShard));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplicateShard(::google::protobuf::internal::ConstantInitialized);

  inline ReplicateShard(const ReplicateShard& from) : ReplicateShard(nullptr, from) {}
  inline ReplicateShard(ReplicateShard&& from) noexcept
      : ReplicateShard(nullptr, ::std::move(from)) {}
  inline ReplicateShard& operator=(const ReplicateShard& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicateShard& operator=(ReplicateShard&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplicateShard& default_instance() {
    return *reinterpret_cast<const ReplicateShard*>(
        &_ReplicateShard_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 82;
  friend void swap(ReplicateShard& a, ReplicateShard& b) { a.Swap(&b); }
  inline void Swap(ReplicateShard* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplicateShard* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplicateShard* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReplicateShard>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReplicateShard& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReplicateShard& from) { ReplicateShard::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReplicateShard* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ReplicateShard"; }

  explicit ReplicateShard(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReplicateShard(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReplicateShard& from);
  ReplicateShard(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReplicateShard&& from) noexcept
      : ReplicateShard(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFromPeerIdFieldNumber = 2,
    kShardIdFieldNumber = 1,
    kMethodFieldNumber = 4,
    kToPeerIdFieldNumber = 3,
    kToShardIdFieldNumber = 5,
  };
  // uint64 from_peer_id = 2;
  void clear_from_peer_id() ;
  ::uint64_t from_peer_id() const;
  void set_from_peer_id(::uint64_t value);

  private:
  ::uint64_t _internal_from_peer_id() const;
  void _internal_set_from_peer_id(::uint64_t value);

  public:
  // uint32 shard_id = 1;
  void clear_shard_id() ;
  ::uint32_t shard_id() const;
  void set_shard_id(::uint32_t value);

  private:
  ::uint32_t _internal_shard_id() const;
  void _internal_set_shard_id(::uint32_t value);

  public:
  // optional .qdrant.ShardTransferMethod method = 4;
  bool has_method() const;
  void clear_method() ;
  ::qdrant::ShardTransferMethod method() const;
  void set_method(::qdrant::ShardTransferMethod value);

  private:
  ::qdrant::ShardTransferMethod _internal_method() const;
  void _internal_set_method(::qdrant::ShardTransferMethod value);

  public:
  // uint64 to_peer_id = 3;
  void clear_to_peer_id() ;
  ::uint64_t to_peer_id() const;
  void set_to_peer_id(::uint64_t value);

  private:
  ::uint64_t _internal_to_peer_id() const;
  void _internal_set_to_peer_id(::uint64_t value);

  public:
  // optional uint32 to_shard_id = 5;
  bool has_to_shard_id() const;
  void clear_to_shard_id() ;
  ::uint32_t to_shard_id() const;
  void set_to_shard_id(::uint32_t value);

  private:
  ::uint32_t _internal_to_shard_id() const;
  void _internal_set_to_shard_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.ReplicateShard)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReplicateShard& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t from_peer_id_;
    ::uint32_t shard_id_;
    int method_;
    ::uint64_t to_peer_id_;
    ::uint32_t to_shard_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReplicateShard_class_data_;
// -------------------------------------------------------------------

class Replica final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.Replica) */ {
 public:
  inline Replica() : Replica(nullptr) {}
  ~Replica() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Replica* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Replica));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Replica(::google::protobuf::internal::ConstantInitialized);

  inline Replica(const Replica& from) : Replica(nullptr, from) {}
  inline Replica(Replica&& from) noexcept
      : Replica(nullptr, ::std::move(from)) {}
  inline Replica& operator=(const Replica& from) {
    CopyFrom(from);
    return *this;
  }
  inline Replica& operator=(Replica&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Replica& default_instance() {
    return *reinterpret_cast<const Replica*>(
        &_Replica_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 85;
  friend void swap(Replica& a, Replica& b) { a.Swap(&b); }
  inline void Swap(Replica* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Replica* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Replica* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Replica>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Replica& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Replica& from) { Replica::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Replica* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.Replica"; }

  explicit Replica(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Replica(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Replica& from);
  Replica(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Replica&& from) noexcept
      : Replica(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPeerIdFieldNumber = 2,
    kShardIdFieldNumber = 1,
  };
  // uint64 peer_id = 2;
  void clear_peer_id() ;
  ::uint64_t peer_id() const;
  void set_peer_id(::uint64_t value);

  private:
  ::uint64_t _internal_peer_id() const;
  void _internal_set_peer_id(::uint64_t value);

  public:
  // uint32 shard_id = 1;
  void clear_shard_id() ;
  ::uint32_t shard_id() const;
  void set_shard_id(::uint32_t value);

  private:
  ::uint32_t _internal_shard_id() const;
  void _internal_set_shard_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.Replica)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Replica& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t peer_id_;
    ::uint32_t shard_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Replica_class_data_;
// -------------------------------------------------------------------

class RenameAlias final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.RenameAlias) */ {
 public:
  inline RenameAlias() : RenameAlias(nullptr) {}
  ~RenameAlias() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RenameAlias* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RenameAlias));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RenameAlias(::google::protobuf::internal::ConstantInitialized);

  inline RenameAlias(const RenameAlias& from) : RenameAlias(nullptr, from) {}
  inline RenameAlias(RenameAlias&& from) noexcept
      : RenameAlias(nullptr, ::std::move(from)) {}
  inline RenameAlias& operator=(const RenameAlias& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameAlias& operator=(RenameAlias&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameAlias& default_instance() {
    return *reinterpret_cast<const RenameAlias*>(
        &_RenameAlias_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 68;
  friend void swap(RenameAlias& a, RenameAlias& b) { a.Swap(&b); }
  inline void Swap(RenameAlias* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameAlias* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameAlias* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RenameAlias>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RenameAlias& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RenameAlias& from) { RenameAlias::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RenameAlias* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.RenameAlias"; }

  explicit RenameAlias(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RenameAlias(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RenameAlias& from);
  RenameAlias(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RenameAlias&& from) noexcept
      : RenameAlias(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOldAliasNameFieldNumber = 1,
    kNewAliasNameFieldNumber = 2,
  };
  // string old_alias_name = 1;
  void clear_old_alias_name() ;
  const ::std::string& old_alias_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_old_alias_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_old_alias_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_old_alias_name();
  void set_allocated_old_alias_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_old_alias_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_old_alias_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_old_alias_name();

  public:
  // string new_alias_name = 2;
  void clear_new_alias_name() ;
  const ::std::string& new_alias_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_new_alias_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_new_alias_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_new_alias_name();
  void set_allocated_new_alias_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_new_alias_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_new_alias_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_new_alias_name();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.RenameAlias)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 55,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RenameAlias& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr old_alias_name_;
    ::google::protobuf::internal::ArenaStringPtr new_alias_name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RenameAlias_class_data_;
// -------------------------------------------------------------------

class ProductQuantization final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ProductQuantization) */ {
 public:
  inline ProductQuantization() : ProductQuantization(nullptr) {}
  ~ProductQuantization() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ProductQuantization* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ProductQuantization));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProductQuantization(::google::protobuf::internal::ConstantInitialized);

  inline ProductQuantization(const ProductQuantization& from) : ProductQuantization(nullptr, from) {}
  inline ProductQuantization(ProductQuantization&& from) noexcept
      : ProductQuantization(nullptr, ::std::move(from)) {}
  inline ProductQuantization& operator=(const ProductQuantization& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProductQuantization& operator=(ProductQuantization&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProductQuantization& default_instance() {
    return *reinterpret_cast<const ProductQuantization*>(
        &_ProductQuantization_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(ProductQuantization& a, ProductQuantization& b) { a.Swap(&b); }
  inline void Swap(ProductQuantization* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProductQuantization* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProductQuantization* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ProductQuantization>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProductQuantization& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ProductQuantization& from) { ProductQuantization::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ProductQuantization* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ProductQuantization"; }

  explicit ProductQuantization(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ProductQuantization(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ProductQuantization& from);
  ProductQuantization(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ProductQuantization&& from) noexcept
      : ProductQuantization(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCompressionFieldNumber = 1,
    kAlwaysRamFieldNumber = 2,
  };
  // .qdrant.CompressionRatio compression = 1;
  void clear_compression() ;
  ::qdrant::CompressionRatio compression() const;
  void set_compression(::qdrant::CompressionRatio value);

  private:
  ::qdrant::CompressionRatio _internal_compression() const;
  void _internal_set_compression(::qdrant::CompressionRatio value);

  public:
  // optional bool always_ram = 2;
  bool has_always_ram() const;
  void clear_always_ram() ;
  bool always_ram() const;
  void set_always_ram(bool value);

  private:
  bool _internal_always_ram() const;
  void _internal_set_always_ram(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.ProductQuantization)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ProductQuantization& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int compression_;
    bool always_ram_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ProductQuantization_class_data_;
// -------------------------------------------------------------------

class OptimizerStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.OptimizerStatus) */ {
 public:
  inline OptimizerStatus() : OptimizerStatus(nullptr) {}
  ~OptimizerStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OptimizerStatus* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OptimizerStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OptimizerStatus(::google::protobuf::internal::ConstantInitialized);

  inline OptimizerStatus(const OptimizerStatus& from) : OptimizerStatus(nullptr, from) {}
  inline OptimizerStatus(OptimizerStatus&& from) noexcept
      : OptimizerStatus(nullptr, ::std::move(from)) {}
  inline OptimizerStatus& operator=(const OptimizerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptimizerStatus& operator=(OptimizerStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptimizerStatus& default_instance() {
    return *reinterpret_cast<const OptimizerStatus*>(
        &_OptimizerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(OptimizerStatus& a, OptimizerStatus& b) { a.Swap(&b); }
  inline void Swap(OptimizerStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptimizerStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptimizerStatus* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OptimizerStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OptimizerStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OptimizerStatus& from) { OptimizerStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OptimizerStatus* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.OptimizerStatus"; }

  explicit OptimizerStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  OptimizerStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const OptimizerStatus& from);
  OptimizerStatus(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, OptimizerStatus&& from) noexcept
      : OptimizerStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // string error = 2;
  void clear_error() ;
  const ::std::string& error() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_error();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_error();
  void set_allocated_error(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_error() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_error(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // bool ok = 1;
  void clear_ok() ;
  bool ok() const;
  void set_ok(bool value);

  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.OptimizerStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 36,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const OptimizerStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    bool ok_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull OptimizerStatus_class_data_;
// -------------------------------------------------------------------

class MultiVectorConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.MultiVectorConfig) */ {
 public:
  inline MultiVectorConfig() : MultiVectorConfig(nullptr) {}
  ~MultiVectorConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MultiVectorConfig* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MultiVectorConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MultiVectorConfig(::google::protobuf::internal::ConstantInitialized);

  inline MultiVectorConfig(const MultiVectorConfig& from) : MultiVectorConfig(nullptr, from) {}
  inline MultiVectorConfig(MultiVectorConfig&& from) noexcept
      : MultiVectorConfig(nullptr, ::std::move(from)) {}
  inline MultiVectorConfig& operator=(const MultiVectorConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiVectorConfig& operator=(MultiVectorConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiVectorConfig& default_instance() {
    return *reinterpret_cast<const MultiVectorConfig*>(
        &_MultiVectorConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(MultiVectorConfig& a, MultiVectorConfig& b) { a.Swap(&b); }
  inline void Swap(MultiVectorConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiVectorConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiVectorConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MultiVectorConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MultiVectorConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MultiVectorConfig& from) { MultiVectorConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MultiVectorConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.MultiVectorConfig"; }

  explicit MultiVectorConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MultiVectorConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MultiVectorConfig& from);
  MultiVectorConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MultiVectorConfig&& from) noexcept
      : MultiVectorConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComparatorFieldNumber = 1,
  };
  // .qdrant.MultiVectorComparator comparator = 1;
  void clear_comparator() ;
  ::qdrant::MultiVectorComparator comparator() const;
  void set_comparator(::qdrant::MultiVectorComparator value);

  private:
  ::qdrant::MultiVectorComparator _internal_comparator() const;
  void _internal_set_comparator(::qdrant::MultiVectorComparator value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.MultiVectorConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MultiVectorConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int comparator_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MultiVectorConfig_class_data_;
// -------------------------------------------------------------------

class MoveShard final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.MoveShard) */ {
 public:
  inline MoveShard() : MoveShard(nullptr) {}
  ~MoveShard() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MoveShard* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MoveShard));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MoveShard(::google::protobuf::internal::ConstantInitialized);

  inline MoveShard(const MoveShard& from) : MoveShard(nullptr, from) {}
  inline MoveShard(MoveShard&& from) noexcept
      : MoveShard(nullptr, ::std::move(from)) {}
  inline MoveShard& operator=(const MoveShard& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveShard& operator=(MoveShard&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveShard& default_instance() {
    return *reinterpret_cast<const MoveShard*>(
        &_MoveShard_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 81;
  friend void swap(MoveShard& a, MoveShard& b) { a.Swap(&b); }
  inline void Swap(MoveShard* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveShard* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveShard* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MoveShard>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveShard& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MoveShard& from) { MoveShard::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MoveShard* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.MoveShard"; }

  explicit MoveShard(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MoveShard(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MoveShard& from);
  MoveShard(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MoveShard&& from) noexcept
      : MoveShard(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFromPeerIdFieldNumber = 2,
    kShardIdFieldNumber = 1,
    kMethodFieldNumber = 4,
    kToPeerIdFieldNumber = 3,
    kToShardIdFieldNumber = 5,
  };
  // uint64 from_peer_id = 2;
  void clear_from_peer_id() ;
  ::uint64_t from_peer_id() const;
  void set_from_peer_id(::uint64_t value);

  private:
  ::uint64_t _internal_from_peer_id() const;
  void _internal_set_from_peer_id(::uint64_t value);

  public:
  // uint32 shard_id = 1;
  void clear_shard_id() ;
  ::uint32_t shard_id() const;
  void set_shard_id(::uint32_t value);

  private:
  ::uint32_t _internal_shard_id() const;
  void _internal_set_shard_id(::uint32_t value);

  public:
  // optional .qdrant.ShardTransferMethod method = 4;
  bool has_method() const;
  void clear_method() ;
  ::qdrant::ShardTransferMethod method() const;
  void set_method(::qdrant::ShardTransferMethod value);

  private:
  ::qdrant::ShardTransferMethod _internal_method() const;
  void _internal_set_method(::qdrant::ShardTransferMethod value);

  public:
  // uint64 to_peer_id = 3;
  void clear_to_peer_id() ;
  ::uint64_t to_peer_id() const;
  void set_to_peer_id(::uint64_t value);

  private:
  ::uint64_t _internal_to_peer_id() const;
  void _internal_set_to_peer_id(::uint64_t value);

  public:
  // optional uint32 to_shard_id = 5;
  bool has_to_shard_id() const;
  void clear_to_shard_id() ;
  ::uint32_t to_shard_id() const;
  void set_to_shard_id(::uint32_t value);

  private:
  ::uint32_t _internal_to_shard_id() const;
  void _internal_set_to_shard_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.MoveShard)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MoveShard& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t from_peer_id_;
    ::uint32_t shard_id_;
    int method_;
    ::uint64_t to_peer_id_;
    ::uint32_t to_shard_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MoveShard_class_data_;
// -------------------------------------------------------------------

class MaxOptimizationThreads final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.MaxOptimizationThreads) */ {
 public:
  inline MaxOptimizationThreads() : MaxOptimizationThreads(nullptr) {}
  ~MaxOptimizationThreads() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MaxOptimizationThreads* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MaxOptimizationThreads));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MaxOptimizationThreads(::google::protobuf::internal::ConstantInitialized);

  inline MaxOptimizationThreads(const MaxOptimizationThreads& from) : MaxOptimizationThreads(nullptr, from) {}
  inline MaxOptimizationThreads(MaxOptimizationThreads&& from) noexcept
      : MaxOptimizationThreads(nullptr, ::std::move(from)) {}
  inline MaxOptimizationThreads& operator=(const MaxOptimizationThreads& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaxOptimizationThreads& operator=(MaxOptimizationThreads&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaxOptimizationThreads& default_instance() {
    return *reinterpret_cast<const MaxOptimizationThreads*>(
        &_MaxOptimizationThreads_default_instance_);
  }
  enum VariantCase {
    kValue = 1,
    kSetting = 2,
    VARIANT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(MaxOptimizationThreads& a, MaxOptimizationThreads& b) { a.Swap(&b); }
  inline void Swap(MaxOptimizationThreads* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaxOptimizationThreads* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MaxOptimizationThreads* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MaxOptimizationThreads>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MaxOptimizationThreads& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MaxOptimizationThreads& from) { MaxOptimizationThreads::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MaxOptimizationThreads* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.MaxOptimizationThreads"; }

  explicit MaxOptimizationThreads(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MaxOptimizationThreads(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MaxOptimizationThreads& from);
  MaxOptimizationThreads(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MaxOptimizationThreads&& from) noexcept
      : MaxOptimizationThreads(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Setting = MaxOptimizationThreads_Setting;
  static constexpr Setting Auto = MaxOptimizationThreads_Setting_Auto;
  static inline bool Setting_IsValid(int value) {
    return MaxOptimizationThreads_Setting_IsValid(value);
  }
  static constexpr Setting Setting_MIN = MaxOptimizationThreads_Setting_Setting_MIN;
  static constexpr Setting Setting_MAX = MaxOptimizationThreads_Setting_Setting_MAX;
  static constexpr int Setting_ARRAYSIZE = MaxOptimizationThreads_Setting_Setting_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Setting_descriptor() {
    return MaxOptimizationThreads_Setting_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Setting_Name(T value) {
    return MaxOptimizationThreads_Setting_Name(value);
  }
  static inline bool Setting_Parse(
      ::absl::string_view name, Setting* PROTOBUF_NONNULL value) {
    return MaxOptimizationThreads_Setting_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
    kSettingFieldNumber = 2,
  };
  // uint64 value = 1;
  bool has_value() const;
  void clear_value() ;
  ::uint64_t value() const;
  void set_value(::uint64_t value);

  private:
  ::uint64_t _internal_value() const;
  void _internal_set_value(::uint64_t value);

  public:
  // .qdrant.MaxOptimizationThreads.Setting setting = 2;
  bool has_setting() const;
  void clear_setting() ;
  ::qdrant::MaxOptimizationThreads_Setting setting() const;
  void set_setting(::qdrant::MaxOptimizationThreads_Setting value);

  private:
  ::qdrant::MaxOptimizationThreads_Setting _internal_setting() const;
  void _internal_set_setting(::qdrant::MaxOptimizationThreads_Setting value);

  public:
  void clear_variant();
  VariantCase variant_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.MaxOptimizationThreads)
 private:
  class _Internal;
  void set_has_value();
  void set_has_setting();
  inline bool has_variant() const;
  inline void clear_has_variant();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MaxOptimizationThreads& from_msg);
    union VariantUnion {
      constexpr VariantUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint64_t value_;
      int setting_;
    } variant_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MaxOptimizationThreads_class_data_;
// -------------------------------------------------------------------

class ListCollectionsRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:qdrant.ListCollectionsRequest) */ {
 public:
  inline ListCollectionsRequest() : ListCollectionsRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListCollectionsRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListCollectionsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListCollectionsRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListCollectionsRequest(const ListCollectionsRequest& from) : ListCollectionsRequest(nullptr, from) {}
  inline ListCollectionsRequest(ListCollectionsRequest&& from) noexcept
      : ListCollectionsRequest(nullptr, ::std::move(from)) {}
  inline ListCollectionsRequest& operator=(const ListCollectionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListCollectionsRequest& operator=(ListCollectionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListCollectionsRequest& default_instance() {
    return *reinterpret_cast<const ListCollectionsRequest*>(
        &_ListCollectionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ListCollectionsRequest& a, ListCollectionsRequest& b) { a.Swap(&b); }
  inline void Swap(ListCollectionsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListCollectionsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListCollectionsRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ListCollectionsRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListCollectionsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListCollectionsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ListCollectionsRequest"; }

  explicit ListCollectionsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListCollectionsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListCollectionsRequest& from);
  ListCollectionsRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListCollectionsRequest&& from) noexcept
      : ListCollectionsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:qdrant.ListCollectionsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListCollectionsRequest_class_data_;
// -------------------------------------------------------------------

class ListCollectionAliasesRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ListCollectionAliasesRequest) */ {
 public:
  inline ListCollectionAliasesRequest() : ListCollectionAliasesRequest(nullptr) {}
  ~ListCollectionAliasesRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListCollectionAliasesRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListCollectionAliasesRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListCollectionAliasesRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListCollectionAliasesRequest(const ListCollectionAliasesRequest& from) : ListCollectionAliasesRequest(nullptr, from) {}
  inline ListCollectionAliasesRequest(ListCollectionAliasesRequest&& from) noexcept
      : ListCollectionAliasesRequest(nullptr, ::std::move(from)) {}
  inline ListCollectionAliasesRequest& operator=(const ListCollectionAliasesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListCollectionAliasesRequest& operator=(ListCollectionAliasesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListCollectionAliasesRequest& default_instance() {
    return *reinterpret_cast<const ListCollectionAliasesRequest*>(
        &_ListCollectionAliasesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 71;
  friend void swap(ListCollectionAliasesRequest& a, ListCollectionAliasesRequest& b) { a.Swap(&b); }
  inline void Swap(ListCollectionAliasesRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListCollectionAliasesRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListCollectionAliasesRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListCollectionAliasesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListCollectionAliasesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListCollectionAliasesRequest& from) { ListCollectionAliasesRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListCollectionAliasesRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ListCollectionAliasesRequest"; }

  explicit ListCollectionAliasesRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListCollectionAliasesRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListCollectionAliasesRequest& from);
  ListCollectionAliasesRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListCollectionAliasesRequest&& from) noexcept
      : ListCollectionAliasesRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.ListCollectionAliasesRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 59,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListCollectionAliasesRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListCollectionAliasesRequest_class_data_;
// -------------------------------------------------------------------

class ListAliasesRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:qdrant.ListAliasesRequest) */ {
 public:
  inline ListAliasesRequest() : ListAliasesRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListAliasesRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListAliasesRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListAliasesRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListAliasesRequest(const ListAliasesRequest& from) : ListAliasesRequest(nullptr, from) {}
  inline ListAliasesRequest(ListAliasesRequest&& from) noexcept
      : ListAliasesRequest(nullptr, ::std::move(from)) {}
  inline ListAliasesRequest& operator=(const ListAliasesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAliasesRequest& operator=(ListAliasesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAliasesRequest& default_instance() {
    return *reinterpret_cast<const ListAliasesRequest*>(
        &_ListAliasesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 70;
  friend void swap(ListAliasesRequest& a, ListAliasesRequest& b) { a.Swap(&b); }
  inline void Swap(ListAliasesRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAliasesRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAliasesRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ListAliasesRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListAliasesRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListAliasesRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ListAliasesRequest"; }

  explicit ListAliasesRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListAliasesRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListAliasesRequest& from);
  ListAliasesRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListAliasesRequest&& from) noexcept
      : ListAliasesRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:qdrant.ListAliasesRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListAliasesRequest_class_data_;
// -------------------------------------------------------------------

class KeywordIndexParams final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.KeywordIndexParams) */ {
 public:
  inline KeywordIndexParams() : KeywordIndexParams(nullptr) {}
  ~KeywordIndexParams() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(KeywordIndexParams* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(KeywordIndexParams));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeywordIndexParams(::google::protobuf::internal::ConstantInitialized);

  inline KeywordIndexParams(const KeywordIndexParams& from) : KeywordIndexParams(nullptr, from) {}
  inline KeywordIndexParams(KeywordIndexParams&& from) noexcept
      : KeywordIndexParams(nullptr, ::std::move(from)) {}
  inline KeywordIndexParams& operator=(const KeywordIndexParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeywordIndexParams& operator=(KeywordIndexParams&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeywordIndexParams& default_instance() {
    return *reinterpret_cast<const KeywordIndexParams*>(
        &_KeywordIndexParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 50;
  friend void swap(KeywordIndexParams& a, KeywordIndexParams& b) { a.Swap(&b); }
  inline void Swap(KeywordIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeywordIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeywordIndexParams* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<KeywordIndexParams>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeywordIndexParams& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeywordIndexParams& from) { KeywordIndexParams::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(KeywordIndexParams* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.KeywordIndexParams"; }

  explicit KeywordIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  KeywordIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const KeywordIndexParams& from);
  KeywordIndexParams(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, KeywordIndexParams&& from) noexcept
      : KeywordIndexParams(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIsTenantFieldNumber = 1,
    kOnDiskFieldNumber = 2,
  };
  // optional bool is_tenant = 1;
  bool has_is_tenant() const;
  void clear_is_tenant() ;
  bool is_tenant() const;
  void set_is_tenant(bool value);

  private:
  bool _internal_is_tenant() const;
  void _internal_set_is_tenant(bool value);

  public:
  // optional bool on_disk = 2;
  bool has_on_disk() const;
  void clear_on_disk() ;
  bool on_disk() const;
  void set_on_disk(bool value);

  private:
  bool _internal_on_disk() const;
  void _internal_set_on_disk(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.KeywordIndexParams)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const KeywordIndexParams& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool is_tenant_;
    bool on_disk_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull KeywordIndexParams_class_data_;
// -------------------------------------------------------------------

class IntegerIndexParams final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.IntegerIndexParams) */ {
 public:
  inline IntegerIndexParams() : IntegerIndexParams(nullptr) {}
  ~IntegerIndexParams() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IntegerIndexParams* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IntegerIndexParams));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IntegerIndexParams(::google::protobuf::internal::ConstantInitialized);

  inline IntegerIndexParams(const IntegerIndexParams& from) : IntegerIndexParams(nullptr, from) {}
  inline IntegerIndexParams(IntegerIndexParams&& from) noexcept
      : IntegerIndexParams(nullptr, ::std::move(from)) {}
  inline IntegerIndexParams& operator=(const IntegerIndexParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntegerIndexParams& operator=(IntegerIndexParams&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntegerIndexParams& default_instance() {
    return *reinterpret_cast<const IntegerIndexParams*>(
        &_IntegerIndexParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 51;
  friend void swap(IntegerIndexParams& a, IntegerIndexParams& b) { a.Swap(&b); }
  inline void Swap(IntegerIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntegerIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntegerIndexParams* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IntegerIndexParams>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IntegerIndexParams& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IntegerIndexParams& from) { IntegerIndexParams::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IntegerIndexParams* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.IntegerIndexParams"; }

  explicit IntegerIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  IntegerIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const IntegerIndexParams& from);
  IntegerIndexParams(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, IntegerIndexParams&& from) noexcept
      : IntegerIndexParams(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLookupFieldNumber = 1,
    kRangeFieldNumber = 2,
    kIsPrincipalFieldNumber = 3,
    kOnDiskFieldNumber = 4,
  };
  // optional bool lookup = 1;
  bool has_lookup() const;
  void clear_lookup() ;
  bool lookup() const;
  void set_lookup(bool value);

  private:
  bool _internal_lookup() const;
  void _internal_set_lookup(bool value);

  public:
  // optional bool range = 2;
  bool has_range() const;
  void clear_range() ;
  bool range() const;
  void set_range(bool value);

  private:
  bool _internal_range() const;
  void _internal_set_range(bool value);

  public:
  // optional bool is_principal = 3;
  bool has_is_principal() const;
  void clear_is_principal() ;
  bool is_principal() const;
  void set_is_principal(bool value);

  private:
  bool _internal_is_principal() const;
  void _internal_set_is_principal(bool value);

  public:
  // optional bool on_disk = 4;
  bool has_on_disk() const;
  void clear_on_disk() ;
  bool on_disk() const;
  void set_on_disk(bool value);

  private:
  bool _internal_on_disk() const;
  void _internal_set_on_disk(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.IntegerIndexParams)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const IntegerIndexParams& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool lookup_;
    bool range_;
    bool is_principal_;
    bool on_disk_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull IntegerIndexParams_class_data_;
// -------------------------------------------------------------------

class HnswConfigDiff final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.HnswConfigDiff) */ {
 public:
  inline HnswConfigDiff() : HnswConfigDiff(nullptr) {}
  ~HnswConfigDiff() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HnswConfigDiff* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HnswConfigDiff));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HnswConfigDiff(::google::protobuf::internal::ConstantInitialized);

  inline HnswConfigDiff(const HnswConfigDiff& from) : HnswConfigDiff(nullptr, from) {}
  inline HnswConfigDiff(HnswConfigDiff&& from) noexcept
      : HnswConfigDiff(nullptr, ::std::move(from)) {}
  inline HnswConfigDiff& operator=(const HnswConfigDiff& from) {
    CopyFrom(from);
    return *this;
  }
  inline HnswConfigDiff& operator=(HnswConfigDiff&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HnswConfigDiff& default_instance() {
    return *reinterpret_cast<const HnswConfigDiff*>(
        &_HnswConfigDiff_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(HnswConfigDiff& a, HnswConfigDiff& b) { a.Swap(&b); }
  inline void Swap(HnswConfigDiff* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HnswConfigDiff* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HnswConfigDiff* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HnswConfigDiff>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HnswConfigDiff& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HnswConfigDiff& from) { HnswConfigDiff::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HnswConfigDiff* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.HnswConfigDiff"; }

  explicit HnswConfigDiff(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  HnswConfigDiff(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HnswConfigDiff& from);
  HnswConfigDiff(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, HnswConfigDiff&& from) noexcept
      : HnswConfigDiff(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMFieldNumber = 1,
    kEfConstructFieldNumber = 2,
    kFullScanThresholdFieldNumber = 3,
    kMaxIndexingThreadsFieldNumber = 4,
    kPayloadMFieldNumber = 6,
    kOnDiskFieldNumber = 5,
    kCopyVectorsFieldNumber = 7,
  };
  // optional uint64 m = 1;
  bool has_m() const;
  void clear_m() ;
  ::uint64_t m() const;
  void set_m(::uint64_t value);

  private:
  ::uint64_t _internal_m() const;
  void _internal_set_m(::uint64_t value);

  public:
  // optional uint64 ef_construct = 2;
  bool has_ef_construct() const;
  void clear_ef_construct() ;
  ::uint64_t ef_construct() const;
  void set_ef_construct(::uint64_t value);

  private:
  ::uint64_t _internal_ef_construct() const;
  void _internal_set_ef_construct(::uint64_t value);

  public:
  // optional uint64 full_scan_threshold = 3;
  bool has_full_scan_threshold() const;
  void clear_full_scan_threshold() ;
  ::uint64_t full_scan_threshold() const;
  void set_full_scan_threshold(::uint64_t value);

  private:
  ::uint64_t _internal_full_scan_threshold() const;
  void _internal_set_full_scan_threshold(::uint64_t value);

  public:
  // optional uint64 max_indexing_threads = 4;
  bool has_max_indexing_threads() const;
  void clear_max_indexing_threads() ;
  ::uint64_t max_indexing_threads() const;
  void set_max_indexing_threads(::uint64_t value);

  private:
  ::uint64_t _internal_max_indexing_threads() const;
  void _internal_set_max_indexing_threads(::uint64_t value);

  public:
  // optional uint64 payload_m = 6;
  bool has_payload_m() const;
  void clear_payload_m() ;
  ::uint64_t payload_m() const;
  void set_payload_m(::uint64_t value);

  private:
  ::uint64_t _internal_payload_m() const;
  void _internal_set_payload_m(::uint64_t value);

  public:
  // optional bool on_disk = 5;
  bool has_on_disk() const;
  void clear_on_disk() ;
  bool on_disk() const;
  void set_on_disk(bool value);

  private:
  bool _internal_on_disk() const;
  void _internal_set_on_disk(bool value);

  public:
  // optional bool copy_vectors = 7;
  bool has_copy_vectors() const;
  void clear_copy_vectors() ;
  bool copy_vectors() const;
  void set_copy_vectors(bool value);

  private:
  bool _internal_copy_vectors() const;
  void _internal_set_copy_vectors(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.HnswConfigDiff)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const HnswConfigDiff& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t m_;
    ::uint64_t ef_construct_;
    ::uint64_t full_scan_threshold_;
    ::uint64_t max_indexing_threads_;
    ::uint64_t payload_m_;
    bool on_disk_;
    bool copy_vectors_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull HnswConfigDiff_class_data_;
// -------------------------------------------------------------------

class GetCollectionInfoRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.GetCollectionInfoRequest) */ {
 public:
  inline GetCollectionInfoRequest() : GetCollectionInfoRequest(nullptr) {}
  ~GetCollectionInfoRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetCollectionInfoRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetCollectionInfoRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetCollectionInfoRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetCollectionInfoRequest(const GetCollectionInfoRequest& from) : GetCollectionInfoRequest(nullptr, from) {}
  inline GetCollectionInfoRequest(GetCollectionInfoRequest&& from) noexcept
      : GetCollectionInfoRequest(nullptr, ::std::move(from)) {}
  inline GetCollectionInfoRequest& operator=(const GetCollectionInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCollectionInfoRequest& operator=(GetCollectionInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCollectionInfoRequest& default_instance() {
    return *reinterpret_cast<const GetCollectionInfoRequest*>(
        &_GetCollectionInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(GetCollectionInfoRequest& a, GetCollectionInfoRequest& b) { a.Swap(&b); }
  inline void Swap(GetCollectionInfoRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCollectionInfoRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCollectionInfoRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetCollectionInfoRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetCollectionInfoRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetCollectionInfoRequest& from) { GetCollectionInfoRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetCollectionInfoRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.GetCollectionInfoRequest"; }

  explicit GetCollectionInfoRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetCollectionInfoRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetCollectionInfoRequest& from);
  GetCollectionInfoRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetCollectionInfoRequest&& from) noexcept
      : GetCollectionInfoRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.GetCollectionInfoRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 55,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetCollectionInfoRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetCollectionInfoRequest_class_data_;
// -------------------------------------------------------------------

class GeoIndexParams final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.GeoIndexParams) */ {
 public:
  inline GeoIndexParams() : GeoIndexParams(nullptr) {}
  ~GeoIndexParams() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GeoIndexParams* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GeoIndexParams));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoIndexParams(::google::protobuf::internal::ConstantInitialized);

  inline GeoIndexParams(const GeoIndexParams& from) : GeoIndexParams(nullptr, from) {}
  inline GeoIndexParams(GeoIndexParams&& from) noexcept
      : GeoIndexParams(nullptr, ::std::move(from)) {}
  inline GeoIndexParams& operator=(const GeoIndexParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoIndexParams& operator=(GeoIndexParams&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoIndexParams& default_instance() {
    return *reinterpret_cast<const GeoIndexParams*>(
        &_GeoIndexParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 53;
  friend void swap(GeoIndexParams& a, GeoIndexParams& b) { a.Swap(&b); }
  inline void Swap(GeoIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoIndexParams* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GeoIndexParams>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoIndexParams& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoIndexParams& from) { GeoIndexParams::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GeoIndexParams* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.GeoIndexParams"; }

  explicit GeoIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GeoIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GeoIndexParams& from);
  GeoIndexParams(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GeoIndexParams&& from) noexcept
      : GeoIndexParams(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOnDiskFieldNumber = 1,
  };
  // optional bool on_disk = 1;
  bool has_on_disk() const;
  void clear_on_disk() ;
  bool on_disk() const;
  void set_on_disk(bool value);

  private:
  bool _internal_on_disk() const;
  void _internal_set_on_disk(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.GeoIndexParams)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GeoIndexParams& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool on_disk_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GeoIndexParams_class_data_;
// -------------------------------------------------------------------

class FloatIndexParams final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.FloatIndexParams) */ {
 public:
  inline FloatIndexParams() : FloatIndexParams(nullptr) {}
  ~FloatIndexParams() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FloatIndexParams* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FloatIndexParams));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FloatIndexParams(::google::protobuf::internal::ConstantInitialized);

  inline FloatIndexParams(const FloatIndexParams& from) : FloatIndexParams(nullptr, from) {}
  inline FloatIndexParams(FloatIndexParams&& from) noexcept
      : FloatIndexParams(nullptr, ::std::move(from)) {}
  inline FloatIndexParams& operator=(const FloatIndexParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatIndexParams& operator=(FloatIndexParams&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatIndexParams& default_instance() {
    return *reinterpret_cast<const FloatIndexParams*>(
        &_FloatIndexParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 52;
  friend void swap(FloatIndexParams& a, FloatIndexParams& b) { a.Swap(&b); }
  inline void Swap(FloatIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloatIndexParams* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FloatIndexParams>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FloatIndexParams& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FloatIndexParams& from) { FloatIndexParams::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FloatIndexParams* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.FloatIndexParams"; }

  explicit FloatIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FloatIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FloatIndexParams& from);
  FloatIndexParams(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FloatIndexParams&& from) noexcept
      : FloatIndexParams(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOnDiskFieldNumber = 1,
    kIsPrincipalFieldNumber = 2,
  };
  // optional bool on_disk = 1;
  bool has_on_disk() const;
  void clear_on_disk() ;
  bool on_disk() const;
  void set_on_disk(bool value);

  private:
  bool _internal_on_disk() const;
  void _internal_set_on_disk(bool value);

  public:
  // optional bool is_principal = 2;
  bool has_is_principal() const;
  void clear_is_principal() ;
  bool is_principal() const;
  void set_is_principal(bool value);

  private:
  bool _internal_is_principal() const;
  void _internal_set_is_principal(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.FloatIndexParams)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FloatIndexParams& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool on_disk_;
    bool is_principal_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FloatIndexParams_class_data_;
// -------------------------------------------------------------------

class Disabled final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:qdrant.Disabled) */ {
 public:
  inline Disabled() : Disabled(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Disabled* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Disabled));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Disabled(::google::protobuf::internal::ConstantInitialized);

  inline Disabled(const Disabled& from) : Disabled(nullptr, from) {}
  inline Disabled(Disabled&& from) noexcept
      : Disabled(nullptr, ::std::move(from)) {}
  inline Disabled& operator=(const Disabled& from) {
    CopyFrom(from);
    return *this;
  }
  inline Disabled& operator=(Disabled&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Disabled& default_instance() {
    return *reinterpret_cast<const Disabled*>(
        &_Disabled_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(Disabled& a, Disabled& b) { a.Swap(&b); }
  inline void Swap(Disabled* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Disabled* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Disabled* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Disabled>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Disabled& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Disabled& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.Disabled"; }

  explicit Disabled(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Disabled(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Disabled& from);
  Disabled(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Disabled&& from) noexcept
      : Disabled(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:qdrant.Disabled)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Disabled_class_data_;
// -------------------------------------------------------------------

class DeleteShardKeyResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DeleteShardKeyResponse) */ {
 public:
  inline DeleteShardKeyResponse() : DeleteShardKeyResponse(nullptr) {}
  ~DeleteShardKeyResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteShardKeyResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteShardKeyResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteShardKeyResponse(::google::protobuf::internal::ConstantInitialized);

  inline DeleteShardKeyResponse(const DeleteShardKeyResponse& from) : DeleteShardKeyResponse(nullptr, from) {}
  inline DeleteShardKeyResponse(DeleteShardKeyResponse&& from) noexcept
      : DeleteShardKeyResponse(nullptr, ::std::move(from)) {}
  inline DeleteShardKeyResponse& operator=(const DeleteShardKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteShardKeyResponse& operator=(DeleteShardKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteShardKeyResponse& default_instance() {
    return *reinterpret_cast<const DeleteShardKeyResponse*>(
        &_DeleteShardKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 93;
  friend void swap(DeleteShardKeyResponse& a, DeleteShardKeyResponse& b) { a.Swap(&b); }
  inline void Swap(DeleteShardKeyResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteShardKeyResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteShardKeyResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteShardKeyResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteShardKeyResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteShardKeyResponse& from) { DeleteShardKeyResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteShardKeyResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DeleteShardKeyResponse"; }

  explicit DeleteShardKeyResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeleteShardKeyResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeleteShardKeyResponse& from);
  DeleteShardKeyResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeleteShardKeyResponse&& from) noexcept
      : DeleteShardKeyResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
  };
  // bool result = 1;
  void clear_result() ;
  bool result() const;
  void set_result(bool value);

  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DeleteShardKeyResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeleteShardKeyResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool result_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeleteShardKeyResponse_class_data_;
// -------------------------------------------------------------------

class DeleteCollection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DeleteCollection) */ {
 public:
  inline DeleteCollection() : DeleteCollection(nullptr) {}
  ~DeleteCollection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteCollection* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteCollection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteCollection(::google::protobuf::internal::ConstantInitialized);

  inline DeleteCollection(const DeleteCollection& from) : DeleteCollection(nullptr, from) {}
  inline DeleteCollection(DeleteCollection&& from) noexcept
      : DeleteCollection(nullptr, ::std::move(from)) {}
  inline DeleteCollection& operator=(const DeleteCollection& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteCollection& operator=(DeleteCollection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteCollection& default_instance() {
    return *reinterpret_cast<const DeleteCollection*>(
        &_DeleteCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 44;
  friend void swap(DeleteCollection& a, DeleteCollection& b) { a.Swap(&b); }
  inline void Swap(DeleteCollection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteCollection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteCollection* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteCollection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteCollection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteCollection& from) { DeleteCollection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteCollection* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DeleteCollection"; }

  explicit DeleteCollection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeleteCollection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeleteCollection& from);
  DeleteCollection(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeleteCollection&& from) noexcept
      : DeleteCollection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kTimeoutFieldNumber = 2,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional uint64 timeout = 2;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DeleteCollection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeleteCollection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::uint64_t timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeleteCollection_class_data_;
// -------------------------------------------------------------------

class DeleteAlias final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DeleteAlias) */ {
 public:
  inline DeleteAlias() : DeleteAlias(nullptr) {}
  ~DeleteAlias() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteAlias* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteAlias));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteAlias(::google::protobuf::internal::ConstantInitialized);

  inline DeleteAlias(const DeleteAlias& from) : DeleteAlias(nullptr, from) {}
  inline DeleteAlias(DeleteAlias&& from) noexcept
      : DeleteAlias(nullptr, ::std::move(from)) {}
  inline DeleteAlias& operator=(const DeleteAlias& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAlias& operator=(DeleteAlias&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteAlias& default_instance() {
    return *reinterpret_cast<const DeleteAlias*>(
        &_DeleteAlias_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 69;
  friend void swap(DeleteAlias& a, DeleteAlias& b) { a.Swap(&b); }
  inline void Swap(DeleteAlias* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAlias* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteAlias* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteAlias>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteAlias& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteAlias& from) { DeleteAlias::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteAlias* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DeleteAlias"; }

  explicit DeleteAlias(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeleteAlias(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeleteAlias& from);
  DeleteAlias(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeleteAlias&& from) noexcept
      : DeleteAlias(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAliasNameFieldNumber = 1,
  };
  // string alias_name = 1;
  void clear_alias_name() ;
  const ::std::string& alias_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_alias_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_alias_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_alias_name();
  void set_allocated_alias_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_alias_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_alias_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_alias_name();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DeleteAlias)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 37,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeleteAlias& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr alias_name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeleteAlias_class_data_;
// -------------------------------------------------------------------

class DatetimeIndexParams final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DatetimeIndexParams) */ {
 public:
  inline DatetimeIndexParams() : DatetimeIndexParams(nullptr) {}
  ~DatetimeIndexParams() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DatetimeIndexParams* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DatetimeIndexParams));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DatetimeIndexParams(::google::protobuf::internal::ConstantInitialized);

  inline DatetimeIndexParams(const DatetimeIndexParams& from) : DatetimeIndexParams(nullptr, from) {}
  inline DatetimeIndexParams(DatetimeIndexParams&& from) noexcept
      : DatetimeIndexParams(nullptr, ::std::move(from)) {}
  inline DatetimeIndexParams& operator=(const DatetimeIndexParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatetimeIndexParams& operator=(DatetimeIndexParams&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatetimeIndexParams& default_instance() {
    return *reinterpret_cast<const DatetimeIndexParams*>(
        &_DatetimeIndexParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 59;
  friend void swap(DatetimeIndexParams& a, DatetimeIndexParams& b) { a.Swap(&b); }
  inline void Swap(DatetimeIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatetimeIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatetimeIndexParams* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DatetimeIndexParams>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DatetimeIndexParams& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DatetimeIndexParams& from) { DatetimeIndexParams::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DatetimeIndexParams* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DatetimeIndexParams"; }

  explicit DatetimeIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DatetimeIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DatetimeIndexParams& from);
  DatetimeIndexParams(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DatetimeIndexParams&& from) noexcept
      : DatetimeIndexParams(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOnDiskFieldNumber = 1,
    kIsPrincipalFieldNumber = 2,
  };
  // optional bool on_disk = 1;
  bool has_on_disk() const;
  void clear_on_disk() ;
  bool on_disk() const;
  void set_on_disk(bool value);

  private:
  bool _internal_on_disk() const;
  void _internal_set_on_disk(bool value);

  public:
  // optional bool is_principal = 2;
  bool has_is_principal() const;
  void clear_is_principal() ;
  bool is_principal() const;
  void set_is_principal(bool value);

  private:
  bool _internal_is_principal() const;
  void _internal_set_is_principal(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DatetimeIndexParams)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DatetimeIndexParams& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool on_disk_;
    bool is_principal_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DatetimeIndexParams_class_data_;
// -------------------------------------------------------------------

class CreateShardKeyResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CreateShardKeyResponse) */ {
 public:
  inline CreateShardKeyResponse() : CreateShardKeyResponse(nullptr) {}
  ~CreateShardKeyResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateShardKeyResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateShardKeyResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateShardKeyResponse(::google::protobuf::internal::ConstantInitialized);

  inline CreateShardKeyResponse(const CreateShardKeyResponse& from) : CreateShardKeyResponse(nullptr, from) {}
  inline CreateShardKeyResponse(CreateShardKeyResponse&& from) noexcept
      : CreateShardKeyResponse(nullptr, ::std::move(from)) {}
  inline CreateShardKeyResponse& operator=(const CreateShardKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateShardKeyResponse& operator=(CreateShardKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateShardKeyResponse& default_instance() {
    return *reinterpret_cast<const CreateShardKeyResponse*>(
        &_CreateShardKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 92;
  friend void swap(CreateShardKeyResponse& a, CreateShardKeyResponse& b) { a.Swap(&b); }
  inline void Swap(CreateShardKeyResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateShardKeyResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateShardKeyResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateShardKeyResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateShardKeyResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateShardKeyResponse& from) { CreateShardKeyResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateShardKeyResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CreateShardKeyResponse"; }

  explicit CreateShardKeyResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CreateShardKeyResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CreateShardKeyResponse& from);
  CreateShardKeyResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CreateShardKeyResponse&& from) noexcept
      : CreateShardKeyResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
  };
  // bool result = 1;
  void clear_result() ;
  bool result() const;
  void set_result(bool value);

  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CreateShardKeyResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CreateShardKeyResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool result_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CreateShardKeyResponse_class_data_;
// -------------------------------------------------------------------

class CreateAlias final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CreateAlias) */ {
 public:
  inline CreateAlias() : CreateAlias(nullptr) {}
  ~CreateAlias() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateAlias* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateAlias));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateAlias(::google::protobuf::internal::ConstantInitialized);

  inline CreateAlias(const CreateAlias& from) : CreateAlias(nullptr, from) {}
  inline CreateAlias(CreateAlias&& from) noexcept
      : CreateAlias(nullptr, ::std::move(from)) {}
  inline CreateAlias& operator=(const CreateAlias& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAlias& operator=(CreateAlias&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAlias& default_instance() {
    return *reinterpret_cast<const CreateAlias*>(
        &_CreateAlias_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 67;
  friend void swap(CreateAlias& a, CreateAlias& b) { a.Swap(&b); }
  inline void Swap(CreateAlias* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAlias* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAlias* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateAlias>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateAlias& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateAlias& from) { CreateAlias::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateAlias* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CreateAlias"; }

  explicit CreateAlias(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CreateAlias(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CreateAlias& from);
  CreateAlias(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CreateAlias&& from) noexcept
      : CreateAlias(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kAliasNameFieldNumber = 2,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // string alias_name = 2;
  void clear_alias_name() ;
  const ::std::string& alias_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_alias_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_alias_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_alias_name();
  void set_allocated_alias_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_alias_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_alias_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_alias_name();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CreateAlias)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 52,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CreateAlias& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::google::protobuf::internal::ArenaStringPtr alias_name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CreateAlias_class_data_;
// -------------------------------------------------------------------

class CollectionParamsDiff final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CollectionParamsDiff) */ {
 public:
  inline CollectionParamsDiff() : CollectionParamsDiff(nullptr) {}
  ~CollectionParamsDiff() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CollectionParamsDiff* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CollectionParamsDiff));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionParamsDiff(::google::protobuf::internal::ConstantInitialized);

  inline CollectionParamsDiff(const CollectionParamsDiff& from) : CollectionParamsDiff(nullptr, from) {}
  inline CollectionParamsDiff(CollectionParamsDiff&& from) noexcept
      : CollectionParamsDiff(nullptr, ::std::move(from)) {}
  inline CollectionParamsDiff& operator=(const CollectionParamsDiff& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionParamsDiff& operator=(CollectionParamsDiff&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionParamsDiff& default_instance() {
    return *reinterpret_cast<const CollectionParamsDiff*>(
        &_CollectionParamsDiff_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 47;
  friend void swap(CollectionParamsDiff& a, CollectionParamsDiff& b) { a.Swap(&b); }
  inline void Swap(CollectionParamsDiff* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionParamsDiff* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionParamsDiff* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CollectionParamsDiff>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionParamsDiff& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectionParamsDiff& from) { CollectionParamsDiff::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CollectionParamsDiff* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CollectionParamsDiff"; }

  explicit CollectionParamsDiff(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CollectionParamsDiff(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CollectionParamsDiff& from);
  CollectionParamsDiff(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CollectionParamsDiff&& from) noexcept
      : CollectionParamsDiff(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReplicationFactorFieldNumber = 1,
    kWriteConsistencyFactorFieldNumber = 2,
    kOnDiskPayloadFieldNumber = 3,
    kReadFanOutFactorFieldNumber = 4,
  };
  // optional uint32 replication_factor = 1;
  bool has_replication_factor() const;
  void clear_replication_factor() ;
  ::uint32_t replication_factor() const;
  void set_replication_factor(::uint32_t value);

  private:
  ::uint32_t _internal_replication_factor() const;
  void _internal_set_replication_factor(::uint32_t value);

  public:
  // optional uint32 write_consistency_factor = 2;
  bool has_write_consistency_factor() const;
  void clear_write_consistency_factor() ;
  ::uint32_t write_consistency_factor() const;
  void set_write_consistency_factor(::uint32_t value);

  private:
  ::uint32_t _internal_write_consistency_factor() const;
  void _internal_set_write_consistency_factor(::uint32_t value);

  public:
  // optional bool on_disk_payload = 3;
  bool has_on_disk_payload() const;
  void clear_on_disk_payload() ;
  bool on_disk_payload() const;
  void set_on_disk_payload(bool value);

  private:
  bool _internal_on_disk_payload() const;
  void _internal_set_on_disk_payload(bool value);

  public:
  // optional uint32 read_fan_out_factor = 4;
  bool has_read_fan_out_factor() const;
  void clear_read_fan_out_factor() ;
  ::uint32_t read_fan_out_factor() const;
  void set_read_fan_out_factor(::uint32_t value);

  private:
  ::uint32_t _internal_read_fan_out_factor() const;
  void _internal_set_read_fan_out_factor(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CollectionParamsDiff)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CollectionParamsDiff& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t replication_factor_;
    ::uint32_t write_consistency_factor_;
    bool on_disk_payload_;
    ::uint32_t read_fan_out_factor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CollectionParamsDiff_class_data_;
// -------------------------------------------------------------------

class CollectionOperationResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CollectionOperationResponse) */ {
 public:
  inline CollectionOperationResponse() : CollectionOperationResponse(nullptr) {}
  ~CollectionOperationResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CollectionOperationResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CollectionOperationResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionOperationResponse(::google::protobuf::internal::ConstantInitialized);

  inline CollectionOperationResponse(const CollectionOperationResponse& from) : CollectionOperationResponse(nullptr, from) {}
  inline CollectionOperationResponse(CollectionOperationResponse&& from) noexcept
      : CollectionOperationResponse(nullptr, ::std::move(from)) {}
  inline CollectionOperationResponse& operator=(const CollectionOperationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionOperationResponse& operator=(CollectionOperationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionOperationResponse& default_instance() {
    return *reinterpret_cast<const CollectionOperationResponse*>(
        &_CollectionOperationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 45;
  friend void swap(CollectionOperationResponse& a, CollectionOperationResponse& b) { a.Swap(&b); }
  inline void Swap(CollectionOperationResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionOperationResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionOperationResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CollectionOperationResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionOperationResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectionOperationResponse& from) { CollectionOperationResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CollectionOperationResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CollectionOperationResponse"; }

  explicit CollectionOperationResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CollectionOperationResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CollectionOperationResponse& from);
  CollectionOperationResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CollectionOperationResponse&& from) noexcept
      : CollectionOperationResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimeFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // bool result = 1;
  void clear_result() ;
  bool result() const;
  void set_result(bool value);

  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CollectionOperationResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CollectionOperationResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double time_;
    bool result_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CollectionOperationResponse_class_data_;
// -------------------------------------------------------------------

class CollectionExistsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CollectionExistsRequest) */ {
 public:
  inline CollectionExistsRequest() : CollectionExistsRequest(nullptr) {}
  ~CollectionExistsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CollectionExistsRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CollectionExistsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionExistsRequest(::google::protobuf::internal::ConstantInitialized);

  inline CollectionExistsRequest(const CollectionExistsRequest& from) : CollectionExistsRequest(nullptr, from) {}
  inline CollectionExistsRequest(CollectionExistsRequest&& from) noexcept
      : CollectionExistsRequest(nullptr, ::std::move(from)) {}
  inline CollectionExistsRequest& operator=(const CollectionExistsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionExistsRequest& operator=(CollectionExistsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionExistsRequest& default_instance() {
    return *reinterpret_cast<const CollectionExistsRequest*>(
        &_CollectionExistsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(CollectionExistsRequest& a, CollectionExistsRequest& b) { a.Swap(&b); }
  inline void Swap(CollectionExistsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionExistsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionExistsRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CollectionExistsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionExistsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectionExistsRequest& from) { CollectionExistsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CollectionExistsRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CollectionExistsRequest"; }

  explicit CollectionExistsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CollectionExistsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CollectionExistsRequest& from);
  CollectionExistsRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CollectionExistsRequest&& from) noexcept
      : CollectionExistsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CollectionExistsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 54,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CollectionExistsRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CollectionExistsRequest_class_data_;
// -------------------------------------------------------------------

class CollectionExists final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CollectionExists) */ {
 public:
  inline CollectionExists() : CollectionExists(nullptr) {}
  ~CollectionExists() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CollectionExists* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CollectionExists));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionExists(::google::protobuf::internal::ConstantInitialized);

  inline CollectionExists(const CollectionExists& from) : CollectionExists(nullptr, from) {}
  inline CollectionExists(CollectionExists&& from) noexcept
      : CollectionExists(nullptr, ::std::move(from)) {}
  inline CollectionExists& operator=(const CollectionExists& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionExists& operator=(CollectionExists&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionExists& default_instance() {
    return *reinterpret_cast<const CollectionExists*>(
        &_CollectionExists_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(CollectionExists& a, CollectionExists& b) { a.Swap(&b); }
  inline void Swap(CollectionExists* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionExists* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionExists* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CollectionExists>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionExists& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectionExists& from) { CollectionExists::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CollectionExists* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CollectionExists"; }

  explicit CollectionExists(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CollectionExists(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CollectionExists& from);
  CollectionExists(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CollectionExists&& from) noexcept
      : CollectionExists(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExistsFieldNumber = 1,
  };
  // bool exists = 1;
  void clear_exists() ;
  bool exists() const;
  void set_exists(bool value);

  private:
  bool _internal_exists() const;
  void _internal_set_exists(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CollectionExists)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CollectionExists& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool exists_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CollectionExists_class_data_;
// -------------------------------------------------------------------

class CollectionDescription final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CollectionDescription) */ {
 public:
  inline CollectionDescription() : CollectionDescription(nullptr) {}
  ~CollectionDescription() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CollectionDescription* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CollectionDescription));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionDescription(::google::protobuf::internal::ConstantInitialized);

  inline CollectionDescription(const CollectionDescription& from) : CollectionDescription(nullptr, from) {}
  inline CollectionDescription(CollectionDescription&& from) noexcept
      : CollectionDescription(nullptr, ::std::move(from)) {}
  inline CollectionDescription& operator=(const CollectionDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionDescription& operator=(CollectionDescription&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionDescription& default_instance() {
    return *reinterpret_cast<const CollectionDescription*>(
        &_CollectionDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(CollectionDescription& a, CollectionDescription& b) { a.Swap(&b); }
  inline void Swap(CollectionDescription* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionDescription* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionDescription* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CollectionDescription>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionDescription& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectionDescription& from) { CollectionDescription::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CollectionDescription* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CollectionDescription"; }

  explicit CollectionDescription(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CollectionDescription(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CollectionDescription& from);
  CollectionDescription(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CollectionDescription&& from) noexcept
      : CollectionDescription(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CollectionDescription)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 41,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CollectionDescription& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CollectionDescription_class_data_;
// -------------------------------------------------------------------

class CollectionClusterInfoRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CollectionClusterInfoRequest) */ {
 public:
  inline CollectionClusterInfoRequest() : CollectionClusterInfoRequest(nullptr) {}
  ~CollectionClusterInfoRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CollectionClusterInfoRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CollectionClusterInfoRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionClusterInfoRequest(::google::protobuf::internal::ConstantInitialized);

  inline CollectionClusterInfoRequest(const CollectionClusterInfoRequest& from) : CollectionClusterInfoRequest(nullptr, from) {}
  inline CollectionClusterInfoRequest(CollectionClusterInfoRequest&& from) noexcept
      : CollectionClusterInfoRequest(nullptr, ::std::move(from)) {}
  inline CollectionClusterInfoRequest& operator=(const CollectionClusterInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionClusterInfoRequest& operator=(CollectionClusterInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionClusterInfoRequest& default_instance() {
    return *reinterpret_cast<const CollectionClusterInfoRequest*>(
        &_CollectionClusterInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 74;
  friend void swap(CollectionClusterInfoRequest& a, CollectionClusterInfoRequest& b) { a.Swap(&b); }
  inline void Swap(CollectionClusterInfoRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionClusterInfoRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionClusterInfoRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CollectionClusterInfoRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionClusterInfoRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectionClusterInfoRequest& from) { CollectionClusterInfoRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CollectionClusterInfoRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CollectionClusterInfoRequest"; }

  explicit CollectionClusterInfoRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CollectionClusterInfoRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CollectionClusterInfoRequest& from);
  CollectionClusterInfoRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CollectionClusterInfoRequest&& from) noexcept
      : CollectionClusterInfoRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CollectionClusterInfoRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 59,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CollectionClusterInfoRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CollectionClusterInfoRequest_class_data_;
// -------------------------------------------------------------------

class BoolIndexParams final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.BoolIndexParams) */ {
 public:
  inline BoolIndexParams() : BoolIndexParams(nullptr) {}
  ~BoolIndexParams() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BoolIndexParams* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BoolIndexParams));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BoolIndexParams(::google::protobuf::internal::ConstantInitialized);

  inline BoolIndexParams(const BoolIndexParams& from) : BoolIndexParams(nullptr, from) {}
  inline BoolIndexParams(BoolIndexParams&& from) noexcept
      : BoolIndexParams(nullptr, ::std::move(from)) {}
  inline BoolIndexParams& operator=(const BoolIndexParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolIndexParams& operator=(BoolIndexParams&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolIndexParams& default_instance() {
    return *reinterpret_cast<const BoolIndexParams*>(
        &_BoolIndexParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 58;
  friend void swap(BoolIndexParams& a, BoolIndexParams& b) { a.Swap(&b); }
  inline void Swap(BoolIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolIndexParams* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BoolIndexParams>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BoolIndexParams& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BoolIndexParams& from) { BoolIndexParams::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BoolIndexParams* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.BoolIndexParams"; }

  explicit BoolIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BoolIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BoolIndexParams& from);
  BoolIndexParams(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BoolIndexParams&& from) noexcept
      : BoolIndexParams(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOnDiskFieldNumber = 1,
  };
  // optional bool on_disk = 1;
  bool has_on_disk() const;
  void clear_on_disk() ;
  bool on_disk() const;
  void set_on_disk(bool value);

  private:
  bool _internal_on_disk() const;
  void _internal_set_on_disk(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.BoolIndexParams)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BoolIndexParams& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool on_disk_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BoolIndexParams_class_data_;
// -------------------------------------------------------------------

class BinaryQuantizationQueryEncoding final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.BinaryQuantizationQueryEncoding) */ {
 public:
  inline BinaryQuantizationQueryEncoding() : BinaryQuantizationQueryEncoding(nullptr) {}
  ~BinaryQuantizationQueryEncoding() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BinaryQuantizationQueryEncoding* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BinaryQuantizationQueryEncoding));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BinaryQuantizationQueryEncoding(::google::protobuf::internal::ConstantInitialized);

  inline BinaryQuantizationQueryEncoding(const BinaryQuantizationQueryEncoding& from) : BinaryQuantizationQueryEncoding(nullptr, from) {}
  inline BinaryQuantizationQueryEncoding(BinaryQuantizationQueryEncoding&& from) noexcept
      : BinaryQuantizationQueryEncoding(nullptr, ::std::move(from)) {}
  inline BinaryQuantizationQueryEncoding& operator=(const BinaryQuantizationQueryEncoding& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryQuantizationQueryEncoding& operator=(BinaryQuantizationQueryEncoding&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryQuantizationQueryEncoding& default_instance() {
    return *reinterpret_cast<const BinaryQuantizationQueryEncoding*>(
        &_BinaryQuantizationQueryEncoding_default_instance_);
  }
  enum VariantCase {
    kSetting = 4,
    VARIANT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(BinaryQuantizationQueryEncoding& a, BinaryQuantizationQueryEncoding& b) { a.Swap(&b); }
  inline void Swap(BinaryQuantizationQueryEncoding* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryQuantizationQueryEncoding* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryQuantizationQueryEncoding* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BinaryQuantizationQueryEncoding>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BinaryQuantizationQueryEncoding& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BinaryQuantizationQueryEncoding& from) { BinaryQuantizationQueryEncoding::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BinaryQuantizationQueryEncoding* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.BinaryQuantizationQueryEncoding"; }

  explicit BinaryQuantizationQueryEncoding(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BinaryQuantizationQueryEncoding(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BinaryQuantizationQueryEncoding& from);
  BinaryQuantizationQueryEncoding(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BinaryQuantizationQueryEncoding&& from) noexcept
      : BinaryQuantizationQueryEncoding(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Setting = BinaryQuantizationQueryEncoding_Setting;
  static constexpr Setting Default = BinaryQuantizationQueryEncoding_Setting_Default;
  static constexpr Setting Binary = BinaryQuantizationQueryEncoding_Setting_Binary;
  static constexpr Setting Scalar4Bits = BinaryQuantizationQueryEncoding_Setting_Scalar4Bits;
  static constexpr Setting Scalar8Bits = BinaryQuantizationQueryEncoding_Setting_Scalar8Bits;
  static inline bool Setting_IsValid(int value) {
    return BinaryQuantizationQueryEncoding_Setting_IsValid(value);
  }
  static constexpr Setting Setting_MIN = BinaryQuantizationQueryEncoding_Setting_Setting_MIN;
  static constexpr Setting Setting_MAX = BinaryQuantizationQueryEncoding_Setting_Setting_MAX;
  static constexpr int Setting_ARRAYSIZE = BinaryQuantizationQueryEncoding_Setting_Setting_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Setting_descriptor() {
    return BinaryQuantizationQueryEncoding_Setting_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Setting_Name(T value) {
    return BinaryQuantizationQueryEncoding_Setting_Name(value);
  }
  static inline bool Setting_Parse(
      ::absl::string_view name, Setting* PROTOBUF_NONNULL value) {
    return BinaryQuantizationQueryEncoding_Setting_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kSettingFieldNumber = 4,
  };
  // .qdrant.BinaryQuantizationQueryEncoding.Setting setting = 4;
  bool has_setting() const;
  void clear_setting() ;
  ::qdrant::BinaryQuantizationQueryEncoding_Setting setting() const;
  void set_setting(::qdrant::BinaryQuantizationQueryEncoding_Setting value);

  private:
  ::qdrant::BinaryQuantizationQueryEncoding_Setting _internal_setting() const;
  void _internal_set_setting(::qdrant::BinaryQuantizationQueryEncoding_Setting value);

  public:
  void clear_variant();
  VariantCase variant_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.BinaryQuantizationQueryEncoding)
 private:
  class _Internal;
  void set_has_setting();
  inline bool has_variant() const;
  inline void clear_has_variant();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BinaryQuantizationQueryEncoding& from_msg);
    union VariantUnion {
      constexpr VariantUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int setting_;
    } variant_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BinaryQuantizationQueryEncoding_class_data_;
// -------------------------------------------------------------------

class AliasDescription final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.AliasDescription) */ {
 public:
  inline AliasDescription() : AliasDescription(nullptr) {}
  ~AliasDescription() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AliasDescription* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AliasDescription));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AliasDescription(::google::protobuf::internal::ConstantInitialized);

  inline AliasDescription(const AliasDescription& from) : AliasDescription(nullptr, from) {}
  inline AliasDescription(AliasDescription&& from) noexcept
      : AliasDescription(nullptr, ::std::move(from)) {}
  inline AliasDescription& operator=(const AliasDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline AliasDescription& operator=(AliasDescription&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AliasDescription& default_instance() {
    return *reinterpret_cast<const AliasDescription*>(
        &_AliasDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 72;
  friend void swap(AliasDescription& a, AliasDescription& b) { a.Swap(&b); }
  inline void Swap(AliasDescription* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AliasDescription* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AliasDescription* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AliasDescription>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AliasDescription& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AliasDescription& from) { AliasDescription::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AliasDescription* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.AliasDescription"; }

  explicit AliasDescription(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AliasDescription(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AliasDescription& from);
  AliasDescription(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AliasDescription&& from) noexcept
      : AliasDescription(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAliasNameFieldNumber = 1,
    kCollectionNameFieldNumber = 2,
  };
  // string alias_name = 1;
  void clear_alias_name() ;
  const ::std::string& alias_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_alias_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_alias_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_alias_name();
  void set_allocated_alias_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_alias_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_alias_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_alias_name();

  public:
  // string collection_name = 2;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.AliasDescription)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 57,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AliasDescription& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr alias_name_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AliasDescription_class_data_;
// -------------------------------------------------------------------

class AbortShardTransfer final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.AbortShardTransfer) */ {
 public:
  inline AbortShardTransfer() : AbortShardTransfer(nullptr) {}
  ~AbortShardTransfer() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AbortShardTransfer* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AbortShardTransfer));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AbortShardTransfer(::google::protobuf::internal::ConstantInitialized);

  inline AbortShardTransfer(const AbortShardTransfer& from) : AbortShardTransfer(nullptr, from) {}
  inline AbortShardTransfer(AbortShardTransfer&& from) noexcept
      : AbortShardTransfer(nullptr, ::std::move(from)) {}
  inline AbortShardTransfer& operator=(const AbortShardTransfer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbortShardTransfer& operator=(AbortShardTransfer&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbortShardTransfer& default_instance() {
    return *reinterpret_cast<const AbortShardTransfer*>(
        &_AbortShardTransfer_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 83;
  friend void swap(AbortShardTransfer& a, AbortShardTransfer& b) { a.Swap(&b); }
  inline void Swap(AbortShardTransfer* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbortShardTransfer* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbortShardTransfer* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AbortShardTransfer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AbortShardTransfer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AbortShardTransfer& from) { AbortShardTransfer::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AbortShardTransfer* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.AbortShardTransfer"; }

  explicit AbortShardTransfer(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AbortShardTransfer(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AbortShardTransfer& from);
  AbortShardTransfer(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AbortShardTransfer&& from) noexcept
      : AbortShardTransfer(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFromPeerIdFieldNumber = 2,
    kShardIdFieldNumber = 1,
    kToShardIdFieldNumber = 4,
    kToPeerIdFieldNumber = 3,
  };
  // uint64 from_peer_id = 2;
  void clear_from_peer_id() ;
  ::uint64_t from_peer_id() const;
  void set_from_peer_id(::uint64_t value);

  private:
  ::uint64_t _internal_from_peer_id() const;
  void _internal_set_from_peer_id(::uint64_t value);

  public:
  // uint32 shard_id = 1;
  void clear_shard_id() ;
  ::uint32_t shard_id() const;
  void set_shard_id(::uint32_t value);

  private:
  ::uint32_t _internal_shard_id() const;
  void _internal_set_shard_id(::uint32_t value);

  public:
  // optional uint32 to_shard_id = 4;
  bool has_to_shard_id() const;
  void clear_to_shard_id() ;
  ::uint32_t to_shard_id() const;
  void set_to_shard_id(::uint32_t value);

  private:
  ::uint32_t _internal_to_shard_id() const;
  void _internal_set_to_shard_id(::uint32_t value);

  public:
  // uint64 to_peer_id = 3;
  void clear_to_peer_id() ;
  ::uint64_t to_peer_id() const;
  void set_to_peer_id(::uint64_t value);

  private:
  ::uint64_t _internal_to_peer_id() const;
  void _internal_set_to_peer_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.AbortShardTransfer)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AbortShardTransfer& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t from_peer_id_;
    ::uint32_t shard_id_;
    ::uint32_t to_shard_id_;
    ::uint64_t to_peer_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AbortShardTransfer_class_data_;
// -------------------------------------------------------------------

class UpdateCollection_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  UpdateCollection_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateCollection_MetadataEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit UpdateCollection_MetadataEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_UpdateCollection_MetadataEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_collections_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 49,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull UpdateCollection_MetadataEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class StrictModeSparseConfig_SparseConfigEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  StrictModeSparseConfig_SparseConfigEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StrictModeSparseConfig_SparseConfigEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit StrictModeSparseConfig_SparseConfigEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_StrictModeSparseConfig_SparseConfigEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_collections_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 59,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull StrictModeSparseConfig_SparseConfigEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class StrictModeMultivectorConfig_MultivectorConfigEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  StrictModeMultivectorConfig_MultivectorConfigEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StrictModeMultivectorConfig_MultivectorConfigEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit StrictModeMultivectorConfig_MultivectorConfigEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_StrictModeMultivectorConfig_MultivectorConfigEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_collections_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 69,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull StrictModeMultivectorConfig_MultivectorConfigEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class StemmingAlgorithm final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.StemmingAlgorithm) */ {
 public:
  inline StemmingAlgorithm() : StemmingAlgorithm(nullptr) {}
  ~StemmingAlgorithm() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StemmingAlgorithm* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StemmingAlgorithm));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StemmingAlgorithm(::google::protobuf::internal::ConstantInitialized);

  inline StemmingAlgorithm(const StemmingAlgorithm& from) : StemmingAlgorithm(nullptr, from) {}
  inline StemmingAlgorithm(StemmingAlgorithm&& from) noexcept
      : StemmingAlgorithm(nullptr, ::std::move(from)) {}
  inline StemmingAlgorithm& operator=(const StemmingAlgorithm& from) {
    CopyFrom(from);
    return *this;
  }
  inline StemmingAlgorithm& operator=(StemmingAlgorithm&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StemmingAlgorithm& default_instance() {
    return *reinterpret_cast<const StemmingAlgorithm*>(
        &_StemmingAlgorithm_default_instance_);
  }
  enum StemmingParamsCase {
    kSnowball = 1,
    STEMMING_PARAMS_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 56;
  friend void swap(StemmingAlgorithm& a, StemmingAlgorithm& b) { a.Swap(&b); }
  inline void Swap(StemmingAlgorithm* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StemmingAlgorithm* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StemmingAlgorithm* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StemmingAlgorithm>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StemmingAlgorithm& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StemmingAlgorithm& from) { StemmingAlgorithm::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StemmingAlgorithm* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.StemmingAlgorithm"; }

  explicit StemmingAlgorithm(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StemmingAlgorithm(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StemmingAlgorithm& from);
  StemmingAlgorithm(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StemmingAlgorithm&& from) noexcept
      : StemmingAlgorithm(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSnowballFieldNumber = 1,
  };
  // .qdrant.SnowballParams snowball = 1;
  bool has_snowball() const;
  private:
  bool _internal_has_snowball() const;

  public:
  void clear_snowball() ;
  const ::qdrant::SnowballParams& snowball() const;
  [[nodiscard]] ::qdrant::SnowballParams* PROTOBUF_NULLABLE release_snowball();
  ::qdrant::SnowballParams* PROTOBUF_NONNULL mutable_snowball();
  void set_allocated_snowball(::qdrant::SnowballParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_snowball(::qdrant::SnowballParams* PROTOBUF_NULLABLE value);
  ::qdrant::SnowballParams* PROTOBUF_NULLABLE unsafe_arena_release_snowball();

  private:
  const ::qdrant::SnowballParams& _internal_snowball() const;
  ::qdrant::SnowballParams* PROTOBUF_NONNULL _internal_mutable_snowball();

  public:
  void clear_stemming_params();
  StemmingParamsCase stemming_params_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.StemmingAlgorithm)
 private:
  class _Internal;
  void set_has_snowball();
  inline bool has_stemming_params() const;
  inline void clear_has_stemming_params();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StemmingAlgorithm& from_msg);
    union StemmingParamsUnion {
      constexpr StemmingParamsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::qdrant::SnowballParams* PROTOBUF_NULLABLE snowball_;
    } stemming_params_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StemmingAlgorithm_class_data_;
// -------------------------------------------------------------------

class SparseVectorParams final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SparseVectorParams) */ {
 public:
  inline SparseVectorParams() : SparseVectorParams(nullptr) {}
  ~SparseVectorParams() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SparseVectorParams* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SparseVectorParams));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SparseVectorParams(::google::protobuf::internal::ConstantInitialized);

  inline SparseVectorParams(const SparseVectorParams& from) : SparseVectorParams(nullptr, from) {}
  inline SparseVectorParams(SparseVectorParams&& from) noexcept
      : SparseVectorParams(nullptr, ::std::move(from)) {}
  inline SparseVectorParams& operator=(const SparseVectorParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline SparseVectorParams& operator=(SparseVectorParams&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SparseVectorParams& default_instance() {
    return *reinterpret_cast<const SparseVectorParams*>(
        &_SparseVectorParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(SparseVectorParams& a, SparseVectorParams& b) { a.Swap(&b); }
  inline void Swap(SparseVectorParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SparseVectorParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SparseVectorParams* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SparseVectorParams>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SparseVectorParams& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SparseVectorParams& from) { SparseVectorParams::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SparseVectorParams* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SparseVectorParams"; }

  explicit SparseVectorParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SparseVectorParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SparseVectorParams& from);
  SparseVectorParams(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SparseVectorParams&& from) noexcept
      : SparseVectorParams(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIndexFieldNumber = 1,
    kModifierFieldNumber = 2,
  };
  // optional .qdrant.SparseIndexConfig index = 1;
  bool has_index() const;
  void clear_index() ;
  const ::qdrant::SparseIndexConfig& index() const;
  [[nodiscard]] ::qdrant::SparseIndexConfig* PROTOBUF_NULLABLE release_index();
  ::qdrant::SparseIndexConfig* PROTOBUF_NONNULL mutable_index();
  void set_allocated_index(::qdrant::SparseIndexConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_index(::qdrant::SparseIndexConfig* PROTOBUF_NULLABLE value);
  ::qdrant::SparseIndexConfig* PROTOBUF_NULLABLE unsafe_arena_release_index();

  private:
  const ::qdrant::SparseIndexConfig& _internal_index() const;
  ::qdrant::SparseIndexConfig* PROTOBUF_NONNULL _internal_mutable_index();

  public:
  // optional .qdrant.Modifier modifier = 2;
  bool has_modifier() const;
  void clear_modifier() ;
  ::qdrant::Modifier modifier() const;
  void set_modifier(::qdrant::Modifier value);

  private:
  ::qdrant::Modifier _internal_modifier() const;
  void _internal_set_modifier(::qdrant::Modifier value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SparseVectorParams)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SparseVectorParams& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::SparseIndexConfig* PROTOBUF_NULLABLE index_;
    int modifier_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SparseVectorParams_class_data_;
// -------------------------------------------------------------------

class ReshardingInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ReshardingInfo) */ {
 public:
  inline ReshardingInfo() : ReshardingInfo(nullptr) {}
  ~ReshardingInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReshardingInfo* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReshardingInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReshardingInfo(::google::protobuf::internal::ConstantInitialized);

  inline ReshardingInfo(const ReshardingInfo& from) : ReshardingInfo(nullptr, from) {}
  inline ReshardingInfo(ReshardingInfo&& from) noexcept
      : ReshardingInfo(nullptr, ::std::move(from)) {}
  inline ReshardingInfo& operator=(const ReshardingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReshardingInfo& operator=(ReshardingInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReshardingInfo& default_instance() {
    return *reinterpret_cast<const ReshardingInfo*>(
        &_ReshardingInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 79;
  friend void swap(ReshardingInfo& a, ReshardingInfo& b) { a.Swap(&b); }
  inline void Swap(ReshardingInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReshardingInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReshardingInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReshardingInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReshardingInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReshardingInfo& from) { ReshardingInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReshardingInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ReshardingInfo"; }

  explicit ReshardingInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReshardingInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReshardingInfo& from);
  ReshardingInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReshardingInfo&& from) noexcept
      : ReshardingInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kShardKeyFieldNumber = 3,
    kPeerIdFieldNumber = 2,
    kShardIdFieldNumber = 1,
    kDirectionFieldNumber = 4,
  };
  // optional .qdrant.ShardKey shard_key = 3;
  bool has_shard_key() const;
  void clear_shard_key() ;
  const ::qdrant::ShardKey& shard_key() const;
  [[nodiscard]] ::qdrant::ShardKey* PROTOBUF_NULLABLE release_shard_key();
  ::qdrant::ShardKey* PROTOBUF_NONNULL mutable_shard_key();
  void set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKey* PROTOBUF_NULLABLE unsafe_arena_release_shard_key();

  private:
  const ::qdrant::ShardKey& _internal_shard_key() const;
  ::qdrant::ShardKey* PROTOBUF_NONNULL _internal_mutable_shard_key();

  public:
  // uint64 peer_id = 2;
  void clear_peer_id() ;
  ::uint64_t peer_id() const;
  void set_peer_id(::uint64_t value);

  private:
  ::uint64_t _internal_peer_id() const;
  void _internal_set_peer_id(::uint64_t value);

  public:
  // uint32 shard_id = 1;
  void clear_shard_id() ;
  ::uint32_t shard_id() const;
  void set_shard_id(::uint32_t value);

  private:
  ::uint32_t _internal_shard_id() const;
  void _internal_set_shard_id(::uint32_t value);

  public:
  // .qdrant.ReshardingDirection direction = 4;
  void clear_direction() ;
  ::qdrant::ReshardingDirection direction() const;
  void set_direction(::qdrant::ReshardingDirection value);

  private:
  ::qdrant::ReshardingDirection _internal_direction() const;
  void _internal_set_direction(::qdrant::ReshardingDirection value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.ReshardingInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReshardingInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::ShardKey* PROTOBUF_NULLABLE shard_key_;
    ::uint64_t peer_id_;
    ::uint32_t shard_id_;
    int direction_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReshardingInfo_class_data_;
// -------------------------------------------------------------------

class RemoteShardInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.RemoteShardInfo) */ {
 public:
  inline RemoteShardInfo() : RemoteShardInfo(nullptr) {}
  ~RemoteShardInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RemoteShardInfo* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RemoteShardInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RemoteShardInfo(::google::protobuf::internal::ConstantInitialized);

  inline RemoteShardInfo(const RemoteShardInfo& from) : RemoteShardInfo(nullptr, from) {}
  inline RemoteShardInfo(RemoteShardInfo&& from) noexcept
      : RemoteShardInfo(nullptr, ::std::move(from)) {}
  inline RemoteShardInfo& operator=(const RemoteShardInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteShardInfo& operator=(RemoteShardInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteShardInfo& default_instance() {
    return *reinterpret_cast<const RemoteShardInfo*>(
        &_RemoteShardInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 77;
  friend void swap(RemoteShardInfo& a, RemoteShardInfo& b) { a.Swap(&b); }
  inline void Swap(RemoteShardInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteShardInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteShardInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RemoteShardInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemoteShardInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RemoteShardInfo& from) { RemoteShardInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RemoteShardInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.RemoteShardInfo"; }

  explicit RemoteShardInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RemoteShardInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RemoteShardInfo& from);
  RemoteShardInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RemoteShardInfo&& from) noexcept
      : RemoteShardInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kShardKeyFieldNumber = 4,
    kPeerIdFieldNumber = 2,
    kShardIdFieldNumber = 1,
    kStateFieldNumber = 3,
  };
  // optional .qdrant.ShardKey shard_key = 4;
  bool has_shard_key() const;
  void clear_shard_key() ;
  const ::qdrant::ShardKey& shard_key() const;
  [[nodiscard]] ::qdrant::ShardKey* PROTOBUF_NULLABLE release_shard_key();
  ::qdrant::ShardKey* PROTOBUF_NONNULL mutable_shard_key();
  void set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKey* PROTOBUF_NULLABLE unsafe_arena_release_shard_key();

  private:
  const ::qdrant::ShardKey& _internal_shard_key() const;
  ::qdrant::ShardKey* PROTOBUF_NONNULL _internal_mutable_shard_key();

  public:
  // uint64 peer_id = 2;
  void clear_peer_id() ;
  ::uint64_t peer_id() const;
  void set_peer_id(::uint64_t value);

  private:
  ::uint64_t _internal_peer_id() const;
  void _internal_set_peer_id(::uint64_t value);

  public:
  // uint32 shard_id = 1;
  void clear_shard_id() ;
  ::uint32_t shard_id() const;
  void set_shard_id(::uint32_t value);

  private:
  ::uint32_t _internal_shard_id() const;
  void _internal_set_shard_id(::uint32_t value);

  public:
  // .qdrant.ReplicaState state = 3;
  void clear_state() ;
  ::qdrant::ReplicaState state() const;
  void set_state(::qdrant::ReplicaState value);

  private:
  ::qdrant::ReplicaState _internal_state() const;
  void _internal_set_state(::qdrant::ReplicaState value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.RemoteShardInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RemoteShardInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::ShardKey* PROTOBUF_NULLABLE shard_key_;
    ::uint64_t peer_id_;
    ::uint32_t shard_id_;
    int state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RemoteShardInfo_class_data_;
// -------------------------------------------------------------------

class OptimizersConfigDiff final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.OptimizersConfigDiff) */ {
 public:
  inline OptimizersConfigDiff() : OptimizersConfigDiff(nullptr) {}
  ~OptimizersConfigDiff() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OptimizersConfigDiff* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OptimizersConfigDiff));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OptimizersConfigDiff(::google::protobuf::internal::ConstantInitialized);

  inline OptimizersConfigDiff(const OptimizersConfigDiff& from) : OptimizersConfigDiff(nullptr, from) {}
  inline OptimizersConfigDiff(OptimizersConfigDiff&& from) noexcept
      : OptimizersConfigDiff(nullptr, ::std::move(from)) {}
  inline OptimizersConfigDiff& operator=(const OptimizersConfigDiff& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptimizersConfigDiff& operator=(OptimizersConfigDiff&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptimizersConfigDiff& default_instance() {
    return *reinterpret_cast<const OptimizersConfigDiff*>(
        &_OptimizersConfigDiff_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(OptimizersConfigDiff& a, OptimizersConfigDiff& b) { a.Swap(&b); }
  inline void Swap(OptimizersConfigDiff* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptimizersConfigDiff* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptimizersConfigDiff* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OptimizersConfigDiff>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OptimizersConfigDiff& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OptimizersConfigDiff& from) { OptimizersConfigDiff::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OptimizersConfigDiff* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.OptimizersConfigDiff"; }

  explicit OptimizersConfigDiff(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  OptimizersConfigDiff(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const OptimizersConfigDiff& from);
  OptimizersConfigDiff(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, OptimizersConfigDiff&& from) noexcept
      : OptimizersConfigDiff(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMaxOptimizationThreadsFieldNumber = 9,
    kDeletedThresholdFieldNumber = 1,
    kVacuumMinVectorNumberFieldNumber = 2,
    kDefaultSegmentNumberFieldNumber = 3,
    kMaxSegmentSizeFieldNumber = 4,
    kMemmapThresholdFieldNumber = 5,
    kIndexingThresholdFieldNumber = 6,
    kFlushIntervalSecFieldNumber = 7,
    kDeprecatedMaxOptimizationThreadsFieldNumber = 8,
  };
  // optional .qdrant.MaxOptimizationThreads max_optimization_threads = 9;
  bool has_max_optimization_threads() const;
  void clear_max_optimization_threads() ;
  const ::qdrant::MaxOptimizationThreads& max_optimization_threads() const;
  [[nodiscard]] ::qdrant::MaxOptimizationThreads* PROTOBUF_NULLABLE release_max_optimization_threads();
  ::qdrant::MaxOptimizationThreads* PROTOBUF_NONNULL mutable_max_optimization_threads();
  void set_allocated_max_optimization_threads(::qdrant::MaxOptimizationThreads* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_max_optimization_threads(::qdrant::MaxOptimizationThreads* PROTOBUF_NULLABLE value);
  ::qdrant::MaxOptimizationThreads* PROTOBUF_NULLABLE unsafe_arena_release_max_optimization_threads();

  private:
  const ::qdrant::MaxOptimizationThreads& _internal_max_optimization_threads() const;
  ::qdrant::MaxOptimizationThreads* PROTOBUF_NONNULL _internal_mutable_max_optimization_threads();

  public:
  // optional double deleted_threshold = 1;
  bool has_deleted_threshold() const;
  void clear_deleted_threshold() ;
  double deleted_threshold() const;
  void set_deleted_threshold(double value);

  private:
  double _internal_deleted_threshold() const;
  void _internal_set_deleted_threshold(double value);

  public:
  // optional uint64 vacuum_min_vector_number = 2;
  bool has_vacuum_min_vector_number() const;
  void clear_vacuum_min_vector_number() ;
  ::uint64_t vacuum_min_vector_number() const;
  void set_vacuum_min_vector_number(::uint64_t value);

  private:
  ::uint64_t _internal_vacuum_min_vector_number() const;
  void _internal_set_vacuum_min_vector_number(::uint64_t value);

  public:
  // optional uint64 default_segment_number = 3;
  bool has_default_segment_number() const;
  void clear_default_segment_number() ;
  ::uint64_t default_segment_number() const;
  void set_default_segment_number(::uint64_t value);

  private:
  ::uint64_t _internal_default_segment_number() const;
  void _internal_set_default_segment_number(::uint64_t value);

  public:
  // optional uint64 max_segment_size = 4;
  bool has_max_segment_size() const;
  void clear_max_segment_size() ;
  ::uint64_t max_segment_size() const;
  void set_max_segment_size(::uint64_t value);

  private:
  ::uint64_t _internal_max_segment_size() const;
  void _internal_set_max_segment_size(::uint64_t value);

  public:
  // optional uint64 memmap_threshold = 5;
  bool has_memmap_threshold() const;
  void clear_memmap_threshold() ;
  ::uint64_t memmap_threshold() const;
  void set_memmap_threshold(::uint64_t value);

  private:
  ::uint64_t _internal_memmap_threshold() const;
  void _internal_set_memmap_threshold(::uint64_t value);

  public:
  // optional uint64 indexing_threshold = 6;
  bool has_indexing_threshold() const;
  void clear_indexing_threshold() ;
  ::uint64_t indexing_threshold() const;
  void set_indexing_threshold(::uint64_t value);

  private:
  ::uint64_t _internal_indexing_threshold() const;
  void _internal_set_indexing_threshold(::uint64_t value);

  public:
  // optional uint64 flush_interval_sec = 7;
  bool has_flush_interval_sec() const;
  void clear_flush_interval_sec() ;
  ::uint64_t flush_interval_sec() const;
  void set_flush_interval_sec(::uint64_t value);

  private:
  ::uint64_t _internal_flush_interval_sec() const;
  void _internal_set_flush_interval_sec(::uint64_t value);

  public:
  // optional uint64 deprecated_max_optimization_threads = 8;
  bool has_deprecated_max_optimization_threads() const;
  void clear_deprecated_max_optimization_threads() ;
  ::uint64_t deprecated_max_optimization_threads() const;
  void set_deprecated_max_optimization_threads(::uint64_t value);

  private:
  ::uint64_t _internal_deprecated_max_optimization_threads() const;
  void _internal_set_deprecated_max_optimization_threads(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.OptimizersConfigDiff)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const OptimizersConfigDiff& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::MaxOptimizationThreads* PROTOBUF_NULLABLE max_optimization_threads_;
    double deleted_threshold_;
    ::uint64_t vacuum_min_vector_number_;
    ::uint64_t default_segment_number_;
    ::uint64_t max_segment_size_;
    ::uint64_t memmap_threshold_;
    ::uint64_t indexing_threshold_;
    ::uint64_t flush_interval_sec_;
    ::uint64_t deprecated_max_optimization_threads_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull OptimizersConfigDiff_class_data_;
// -------------------------------------------------------------------

class LocalShardInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.LocalShardInfo) */ {
 public:
  inline LocalShardInfo() : LocalShardInfo(nullptr) {}
  ~LocalShardInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LocalShardInfo* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LocalShardInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LocalShardInfo(::google::protobuf::internal::ConstantInitialized);

  inline LocalShardInfo(const LocalShardInfo& from) : LocalShardInfo(nullptr, from) {}
  inline LocalShardInfo(LocalShardInfo&& from) noexcept
      : LocalShardInfo(nullptr, ::std::move(from)) {}
  inline LocalShardInfo& operator=(const LocalShardInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalShardInfo& operator=(LocalShardInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalShardInfo& default_instance() {
    return *reinterpret_cast<const LocalShardInfo*>(
        &_LocalShardInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 76;
  friend void swap(LocalShardInfo& a, LocalShardInfo& b) { a.Swap(&b); }
  inline void Swap(LocalShardInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalShardInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalShardInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LocalShardInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LocalShardInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LocalShardInfo& from) { LocalShardInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LocalShardInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.LocalShardInfo"; }

  explicit LocalShardInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LocalShardInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LocalShardInfo& from);
  LocalShardInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LocalShardInfo&& from) noexcept
      : LocalShardInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kShardKeyFieldNumber = 4,
    kPointsCountFieldNumber = 2,
    kShardIdFieldNumber = 1,
    kStateFieldNumber = 3,
  };
  // optional .qdrant.ShardKey shard_key = 4;
  bool has_shard_key() const;
  void clear_shard_key() ;
  const ::qdrant::ShardKey& shard_key() const;
  [[nodiscard]] ::qdrant::ShardKey* PROTOBUF_NULLABLE release_shard_key();
  ::qdrant::ShardKey* PROTOBUF_NONNULL mutable_shard_key();
  void set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKey* PROTOBUF_NULLABLE unsafe_arena_release_shard_key();

  private:
  const ::qdrant::ShardKey& _internal_shard_key() const;
  ::qdrant::ShardKey* PROTOBUF_NONNULL _internal_mutable_shard_key();

  public:
  // uint64 points_count = 2;
  void clear_points_count() ;
  ::uint64_t points_count() const;
  void set_points_count(::uint64_t value);

  private:
  ::uint64_t _internal_points_count() const;
  void _internal_set_points_count(::uint64_t value);

  public:
  // uint32 shard_id = 1;
  void clear_shard_id() ;
  ::uint32_t shard_id() const;
  void set_shard_id(::uint32_t value);

  private:
  ::uint32_t _internal_shard_id() const;
  void _internal_set_shard_id(::uint32_t value);

  public:
  // .qdrant.ReplicaState state = 3;
  void clear_state() ;
  ::qdrant::ReplicaState state() const;
  void set_state(::qdrant::ReplicaState value);

  private:
  ::qdrant::ReplicaState _internal_state() const;
  void _internal_set_state(::qdrant::ReplicaState value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.LocalShardInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LocalShardInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::ShardKey* PROTOBUF_NULLABLE shard_key_;
    ::uint64_t points_count_;
    ::uint32_t shard_id_;
    int state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LocalShardInfo_class_data_;
// -------------------------------------------------------------------

class ListCollectionsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ListCollectionsResponse) */ {
 public:
  inline ListCollectionsResponse() : ListCollectionsResponse(nullptr) {}
  ~ListCollectionsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListCollectionsResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListCollectionsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListCollectionsResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListCollectionsResponse(const ListCollectionsResponse& from) : ListCollectionsResponse(nullptr, from) {}
  inline ListCollectionsResponse(ListCollectionsResponse&& from) noexcept
      : ListCollectionsResponse(nullptr, ::std::move(from)) {}
  inline ListCollectionsResponse& operator=(const ListCollectionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListCollectionsResponse& operator=(ListCollectionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListCollectionsResponse& default_instance() {
    return *reinterpret_cast<const ListCollectionsResponse*>(
        &_ListCollectionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(ListCollectionsResponse& a, ListCollectionsResponse& b) { a.Swap(&b); }
  inline void Swap(ListCollectionsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListCollectionsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListCollectionsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListCollectionsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListCollectionsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListCollectionsResponse& from) { ListCollectionsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListCollectionsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ListCollectionsResponse"; }

  explicit ListCollectionsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListCollectionsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListCollectionsResponse& from);
  ListCollectionsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListCollectionsResponse&& from) noexcept
      : ListCollectionsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionsFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // repeated .qdrant.CollectionDescription collections = 1;
  int collections_size() const;
  private:
  int _internal_collections_size() const;

  public:
  void clear_collections() ;
  ::qdrant::CollectionDescription* PROTOBUF_NONNULL mutable_collections(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::CollectionDescription>* PROTOBUF_NONNULL mutable_collections();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::CollectionDescription>& _internal_collections() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::CollectionDescription>* PROTOBUF_NONNULL _internal_mutable_collections();
  public:
  const ::qdrant::CollectionDescription& collections(int index) const;
  ::qdrant::CollectionDescription* PROTOBUF_NONNULL add_collections();
  const ::google::protobuf::RepeatedPtrField<::qdrant::CollectionDescription>& collections() const;
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.ListCollectionsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListCollectionsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::CollectionDescription > collections_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListCollectionsResponse_class_data_;
// -------------------------------------------------------------------

class ListAliasesResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ListAliasesResponse) */ {
 public:
  inline ListAliasesResponse() : ListAliasesResponse(nullptr) {}
  ~ListAliasesResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListAliasesResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListAliasesResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListAliasesResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListAliasesResponse(const ListAliasesResponse& from) : ListAliasesResponse(nullptr, from) {}
  inline ListAliasesResponse(ListAliasesResponse&& from) noexcept
      : ListAliasesResponse(nullptr, ::std::move(from)) {}
  inline ListAliasesResponse& operator=(const ListAliasesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAliasesResponse& operator=(ListAliasesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAliasesResponse& default_instance() {
    return *reinterpret_cast<const ListAliasesResponse*>(
        &_ListAliasesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 73;
  friend void swap(ListAliasesResponse& a, ListAliasesResponse& b) { a.Swap(&b); }
  inline void Swap(ListAliasesResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAliasesResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAliasesResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListAliasesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListAliasesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListAliasesResponse& from) { ListAliasesResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListAliasesResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ListAliasesResponse"; }

  explicit ListAliasesResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListAliasesResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListAliasesResponse& from);
  ListAliasesResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListAliasesResponse&& from) noexcept
      : ListAliasesResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAliasesFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // repeated .qdrant.AliasDescription aliases = 1;
  int aliases_size() const;
  private:
  int _internal_aliases_size() const;

  public:
  void clear_aliases() ;
  ::qdrant::AliasDescription* PROTOBUF_NONNULL mutable_aliases(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::AliasDescription>* PROTOBUF_NONNULL mutable_aliases();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::AliasDescription>& _internal_aliases() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::AliasDescription>* PROTOBUF_NONNULL _internal_mutable_aliases();
  public:
  const ::qdrant::AliasDescription& aliases(int index) const;
  ::qdrant::AliasDescription* PROTOBUF_NONNULL add_aliases();
  const ::google::protobuf::RepeatedPtrField<::qdrant::AliasDescription>& aliases() const;
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.ListAliasesResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListAliasesResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::AliasDescription > aliases_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListAliasesResponse_class_data_;
// -------------------------------------------------------------------

class DeleteShardKey final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DeleteShardKey) */ {
 public:
  inline DeleteShardKey() : DeleteShardKey(nullptr) {}
  ~DeleteShardKey() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteShardKey* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteShardKey));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteShardKey(::google::protobuf::internal::ConstantInitialized);

  inline DeleteShardKey(const DeleteShardKey& from) : DeleteShardKey(nullptr, from) {}
  inline DeleteShardKey(DeleteShardKey&& from) noexcept
      : DeleteShardKey(nullptr, ::std::move(from)) {}
  inline DeleteShardKey& operator=(const DeleteShardKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteShardKey& operator=(DeleteShardKey&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteShardKey& default_instance() {
    return *reinterpret_cast<const DeleteShardKey*>(
        &_DeleteShardKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 87;
  friend void swap(DeleteShardKey& a, DeleteShardKey& b) { a.Swap(&b); }
  inline void Swap(DeleteShardKey* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteShardKey* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteShardKey* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteShardKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteShardKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteShardKey& from) { DeleteShardKey::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteShardKey* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DeleteShardKey"; }

  explicit DeleteShardKey(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeleteShardKey(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeleteShardKey& from);
  DeleteShardKey(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeleteShardKey&& from) noexcept
      : DeleteShardKey(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kShardKeyFieldNumber = 1,
  };
  // .qdrant.ShardKey shard_key = 1;
  bool has_shard_key() const;
  void clear_shard_key() ;
  const ::qdrant::ShardKey& shard_key() const;
  [[nodiscard]] ::qdrant::ShardKey* PROTOBUF_NULLABLE release_shard_key();
  ::qdrant::ShardKey* PROTOBUF_NONNULL mutable_shard_key();
  void set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKey* PROTOBUF_NULLABLE unsafe_arena_release_shard_key();

  private:
  const ::qdrant::ShardKey& _internal_shard_key() const;
  ::qdrant::ShardKey* PROTOBUF_NONNULL _internal_mutable_shard_key();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DeleteShardKey)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeleteShardKey& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::ShardKey* PROTOBUF_NULLABLE shard_key_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeleteShardKey_class_data_;
// -------------------------------------------------------------------

class CreateShardKey final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CreateShardKey) */ {
 public:
  inline CreateShardKey() : CreateShardKey(nullptr) {}
  ~CreateShardKey() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateShardKey* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateShardKey));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateShardKey(::google::protobuf::internal::ConstantInitialized);

  inline CreateShardKey(const CreateShardKey& from) : CreateShardKey(nullptr, from) {}
  inline CreateShardKey(CreateShardKey&& from) noexcept
      : CreateShardKey(nullptr, ::std::move(from)) {}
  inline CreateShardKey& operator=(const CreateShardKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateShardKey& operator=(CreateShardKey&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateShardKey& default_instance() {
    return *reinterpret_cast<const CreateShardKey*>(
        &_CreateShardKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 86;
  friend void swap(CreateShardKey& a, CreateShardKey& b) { a.Swap(&b); }
  inline void Swap(CreateShardKey* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateShardKey* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateShardKey* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateShardKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateShardKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateShardKey& from) { CreateShardKey::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateShardKey* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CreateShardKey"; }

  explicit CreateShardKey(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CreateShardKey(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CreateShardKey& from);
  CreateShardKey(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CreateShardKey&& from) noexcept
      : CreateShardKey(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlacementFieldNumber = 4,
    kShardKeyFieldNumber = 1,
    kShardsNumberFieldNumber = 2,
    kReplicationFactorFieldNumber = 3,
  };
  // repeated uint64 placement = 4;
  int placement_size() const;
  private:
  int _internal_placement_size() const;

  public:
  void clear_placement() ;
  ::uint64_t placement(int index) const;
  void set_placement(int index, ::uint64_t value);
  void add_placement(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& placement() const;
  ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL mutable_placement();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_placement() const;
  ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL _internal_mutable_placement();

  public:
  // .qdrant.ShardKey shard_key = 1;
  bool has_shard_key() const;
  void clear_shard_key() ;
  const ::qdrant::ShardKey& shard_key() const;
  [[nodiscard]] ::qdrant::ShardKey* PROTOBUF_NULLABLE release_shard_key();
  ::qdrant::ShardKey* PROTOBUF_NONNULL mutable_shard_key();
  void set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value);
  ::qdrant::ShardKey* PROTOBUF_NULLABLE unsafe_arena_release_shard_key();

  private:
  const ::qdrant::ShardKey& _internal_shard_key() const;
  ::qdrant::ShardKey* PROTOBUF_NONNULL _internal_mutable_shard_key();

  public:
  // optional uint32 shards_number = 2;
  bool has_shards_number() const;
  void clear_shards_number() ;
  ::uint32_t shards_number() const;
  void set_shards_number(::uint32_t value);

  private:
  ::uint32_t _internal_shards_number() const;
  void _internal_set_shards_number(::uint32_t value);

  public:
  // optional uint32 replication_factor = 3;
  bool has_replication_factor() const;
  void clear_replication_factor() ;
  ::uint32_t replication_factor() const;
  void set_replication_factor(::uint32_t value);

  private:
  ::uint32_t _internal_replication_factor() const;
  void _internal_set_replication_factor(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CreateShardKey)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CreateShardKey& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint64_t> placement_;
    ::google::protobuf::internal::CachedSize _placement_cached_byte_size_;
    ::qdrant::ShardKey* PROTOBUF_NULLABLE shard_key_;
    ::uint32_t shards_number_;
    ::uint32_t replication_factor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CreateShardKey_class_data_;
// -------------------------------------------------------------------

class CreateCollection_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  CreateCollection_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateCollection_MetadataEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit CreateCollection_MetadataEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_CreateCollection_MetadataEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_collections_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 49,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull CreateCollection_MetadataEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class CollectionExistsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CollectionExistsResponse) */ {
 public:
  inline CollectionExistsResponse() : CollectionExistsResponse(nullptr) {}
  ~CollectionExistsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CollectionExistsResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CollectionExistsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionExistsResponse(::google::protobuf::internal::ConstantInitialized);

  inline CollectionExistsResponse(const CollectionExistsResponse& from) : CollectionExistsResponse(nullptr, from) {}
  inline CollectionExistsResponse(CollectionExistsResponse&& from) noexcept
      : CollectionExistsResponse(nullptr, ::std::move(from)) {}
  inline CollectionExistsResponse& operator=(const CollectionExistsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionExistsResponse& operator=(CollectionExistsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionExistsResponse& default_instance() {
    return *reinterpret_cast<const CollectionExistsResponse*>(
        &_CollectionExistsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(CollectionExistsResponse& a, CollectionExistsResponse& b) { a.Swap(&b); }
  inline void Swap(CollectionExistsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionExistsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionExistsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CollectionExistsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionExistsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectionExistsResponse& from) { CollectionExistsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CollectionExistsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CollectionExistsResponse"; }

  explicit CollectionExistsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CollectionExistsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CollectionExistsResponse& from);
  CollectionExistsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CollectionExistsResponse&& from) noexcept
      : CollectionExistsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // .qdrant.CollectionExists result = 1;
  bool has_result() const;
  void clear_result() ;
  const ::qdrant::CollectionExists& result() const;
  [[nodiscard]] ::qdrant::CollectionExists* PROTOBUF_NULLABLE release_result();
  ::qdrant::CollectionExists* PROTOBUF_NONNULL mutable_result();
  void set_allocated_result(::qdrant::CollectionExists* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_result(::qdrant::CollectionExists* PROTOBUF_NULLABLE value);
  ::qdrant::CollectionExists* PROTOBUF_NULLABLE unsafe_arena_release_result();

  private:
  const ::qdrant::CollectionExists& _internal_result() const;
  ::qdrant::CollectionExists* PROTOBUF_NONNULL _internal_mutable_result();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CollectionExistsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CollectionExistsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::CollectionExists* PROTOBUF_NULLABLE result_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CollectionExistsResponse_class_data_;
// -------------------------------------------------------------------

class CollectionConfig_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  CollectionConfig_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionConfig_MetadataEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit CollectionConfig_MetadataEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_CollectionConfig_MetadataEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_collections_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 49,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull CollectionConfig_MetadataEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class BinaryQuantization final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.BinaryQuantization) */ {
 public:
  inline BinaryQuantization() : BinaryQuantization(nullptr) {}
  ~BinaryQuantization() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BinaryQuantization* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BinaryQuantization));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BinaryQuantization(::google::protobuf::internal::ConstantInitialized);

  inline BinaryQuantization(const BinaryQuantization& from) : BinaryQuantization(nullptr, from) {}
  inline BinaryQuantization(BinaryQuantization&& from) noexcept
      : BinaryQuantization(nullptr, ::std::move(from)) {}
  inline BinaryQuantization& operator=(const BinaryQuantization& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryQuantization& operator=(BinaryQuantization&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryQuantization& default_instance() {
    return *reinterpret_cast<const BinaryQuantization*>(
        &_BinaryQuantization_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(BinaryQuantization& a, BinaryQuantization& b) { a.Swap(&b); }
  inline void Swap(BinaryQuantization* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryQuantization* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryQuantization* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BinaryQuantization>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BinaryQuantization& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BinaryQuantization& from) { BinaryQuantization::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BinaryQuantization* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.BinaryQuantization"; }

  explicit BinaryQuantization(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BinaryQuantization(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BinaryQuantization& from);
  BinaryQuantization(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BinaryQuantization&& from) noexcept
      : BinaryQuantization(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQueryEncodingFieldNumber = 3,
    kAlwaysRamFieldNumber = 1,
    kEncodingFieldNumber = 2,
  };
  // optional .qdrant.BinaryQuantizationQueryEncoding query_encoding = 3;
  bool has_query_encoding() const;
  void clear_query_encoding() ;
  const ::qdrant::BinaryQuantizationQueryEncoding& query_encoding() const;
  [[nodiscard]] ::qdrant::BinaryQuantizationQueryEncoding* PROTOBUF_NULLABLE release_query_encoding();
  ::qdrant::BinaryQuantizationQueryEncoding* PROTOBUF_NONNULL mutable_query_encoding();
  void set_allocated_query_encoding(::qdrant::BinaryQuantizationQueryEncoding* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_query_encoding(::qdrant::BinaryQuantizationQueryEncoding* PROTOBUF_NULLABLE value);
  ::qdrant::BinaryQuantizationQueryEncoding* PROTOBUF_NULLABLE unsafe_arena_release_query_encoding();

  private:
  const ::qdrant::BinaryQuantizationQueryEncoding& _internal_query_encoding() const;
  ::qdrant::BinaryQuantizationQueryEncoding* PROTOBUF_NONNULL _internal_mutable_query_encoding();

  public:
  // optional bool always_ram = 1;
  bool has_always_ram() const;
  void clear_always_ram() ;
  bool always_ram() const;
  void set_always_ram(bool value);

  private:
  bool _internal_always_ram() const;
  void _internal_set_always_ram(bool value);

  public:
  // optional .qdrant.BinaryQuantizationEncoding encoding = 2;
  bool has_encoding() const;
  void clear_encoding() ;
  ::qdrant::BinaryQuantizationEncoding encoding() const;
  void set_encoding(::qdrant::BinaryQuantizationEncoding value);

  private:
  ::qdrant::BinaryQuantizationEncoding _internal_encoding() const;
  void _internal_set_encoding(::qdrant::BinaryQuantizationEncoding value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.BinaryQuantization)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BinaryQuantization& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::BinaryQuantizationQueryEncoding* PROTOBUF_NULLABLE query_encoding_;
    bool always_ram_;
    int encoding_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BinaryQuantization_class_data_;
// -------------------------------------------------------------------

class AliasOperations final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.AliasOperations) */ {
 public:
  inline AliasOperations() : AliasOperations(nullptr) {}
  ~AliasOperations() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AliasOperations* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AliasOperations));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AliasOperations(::google::protobuf::internal::ConstantInitialized);

  inline AliasOperations(const AliasOperations& from) : AliasOperations(nullptr, from) {}
  inline AliasOperations(AliasOperations&& from) noexcept
      : AliasOperations(nullptr, ::std::move(from)) {}
  inline AliasOperations& operator=(const AliasOperations& from) {
    CopyFrom(from);
    return *this;
  }
  inline AliasOperations& operator=(AliasOperations&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AliasOperations& default_instance() {
    return *reinterpret_cast<const AliasOperations*>(
        &_AliasOperations_default_instance_);
  }
  enum ActionCase {
    kCreateAlias = 1,
    kRenameAlias = 2,
    kDeleteAlias = 3,
    ACTION_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 66;
  friend void swap(AliasOperations& a, AliasOperations& b) { a.Swap(&b); }
  inline void Swap(AliasOperations* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AliasOperations* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AliasOperations* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AliasOperations>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AliasOperations& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AliasOperations& from) { AliasOperations::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AliasOperations* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.AliasOperations"; }

  explicit AliasOperations(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AliasOperations(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AliasOperations& from);
  AliasOperations(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AliasOperations&& from) noexcept
      : AliasOperations(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCreateAliasFieldNumber = 1,
    kRenameAliasFieldNumber = 2,
    kDeleteAliasFieldNumber = 3,
  };
  // .qdrant.CreateAlias create_alias = 1;
  bool has_create_alias() const;
  private:
  bool _internal_has_create_alias() const;

  public:
  void clear_create_alias() ;
  const ::qdrant::CreateAlias& create_alias() const;
  [[nodiscard]] ::qdrant::CreateAlias* PROTOBUF_NULLABLE release_create_alias();
  ::qdrant::CreateAlias* PROTOBUF_NONNULL mutable_create_alias();
  void set_allocated_create_alias(::qdrant::CreateAlias* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_create_alias(::qdrant::CreateAlias* PROTOBUF_NULLABLE value);
  ::qdrant::CreateAlias* PROTOBUF_NULLABLE unsafe_arena_release_create_alias();

  private:
  const ::qdrant::CreateAlias& _internal_create_alias() const;
  ::qdrant::CreateAlias* PROTOBUF_NONNULL _internal_mutable_create_alias();

  public:
  // .qdrant.RenameAlias rename_alias = 2;
  bool has_rename_alias() const;
  private:
  bool _internal_has_rename_alias() const;

  public:
  void clear_rename_alias() ;
  const ::qdrant::RenameAlias& rename_alias() const;
  [[nodiscard]] ::qdrant::RenameAlias* PROTOBUF_NULLABLE release_rename_alias();
  ::qdrant::RenameAlias* PROTOBUF_NONNULL mutable_rename_alias();
  void set_allocated_rename_alias(::qdrant::RenameAlias* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_rename_alias(::qdrant::RenameAlias* PROTOBUF_NULLABLE value);
  ::qdrant::RenameAlias* PROTOBUF_NULLABLE unsafe_arena_release_rename_alias();

  private:
  const ::qdrant::RenameAlias& _internal_rename_alias() const;
  ::qdrant::RenameAlias* PROTOBUF_NONNULL _internal_mutable_rename_alias();

  public:
  // .qdrant.DeleteAlias delete_alias = 3;
  bool has_delete_alias() const;
  private:
  bool _internal_has_delete_alias() const;

  public:
  void clear_delete_alias() ;
  const ::qdrant::DeleteAlias& delete_alias() const;
  [[nodiscard]] ::qdrant::DeleteAlias* PROTOBUF_NULLABLE release_delete_alias();
  ::qdrant::DeleteAlias* PROTOBUF_NONNULL mutable_delete_alias();
  void set_allocated_delete_alias(::qdrant::DeleteAlias* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_delete_alias(::qdrant::DeleteAlias* PROTOBUF_NULLABLE value);
  ::qdrant::DeleteAlias* PROTOBUF_NULLABLE unsafe_arena_release_delete_alias();

  private:
  const ::qdrant::DeleteAlias& _internal_delete_alias() const;
  ::qdrant::DeleteAlias* PROTOBUF_NONNULL _internal_mutable_delete_alias();

  public:
  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.AliasOperations)
 private:
  class _Internal;
  void set_has_create_alias();
  void set_has_rename_alias();
  void set_has_delete_alias();
  inline bool has_action() const;
  inline void clear_has_action();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AliasOperations& from_msg);
    union ActionUnion {
      constexpr ActionUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE create_alias_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE rename_alias_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE delete_alias_;
    } action_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AliasOperations_class_data_;
// -------------------------------------------------------------------

class UpdateCollectionClusterSetupRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.UpdateCollectionClusterSetupRequest) */ {
 public:
  inline UpdateCollectionClusterSetupRequest() : UpdateCollectionClusterSetupRequest(nullptr) {}
  ~UpdateCollectionClusterSetupRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateCollectionClusterSetupRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateCollectionClusterSetupRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateCollectionClusterSetupRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateCollectionClusterSetupRequest(const UpdateCollectionClusterSetupRequest& from) : UpdateCollectionClusterSetupRequest(nullptr, from) {}
  inline UpdateCollectionClusterSetupRequest(UpdateCollectionClusterSetupRequest&& from) noexcept
      : UpdateCollectionClusterSetupRequest(nullptr, ::std::move(from)) {}
  inline UpdateCollectionClusterSetupRequest& operator=(const UpdateCollectionClusterSetupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCollectionClusterSetupRequest& operator=(UpdateCollectionClusterSetupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCollectionClusterSetupRequest& default_instance() {
    return *reinterpret_cast<const UpdateCollectionClusterSetupRequest*>(
        &_UpdateCollectionClusterSetupRequest_default_instance_);
  }
  enum OperationCase {
    kMoveShard = 2,
    kReplicateShard = 3,
    kAbortTransfer = 4,
    kDropReplica = 5,
    kCreateShardKey = 7,
    kDeleteShardKey = 8,
    kRestartTransfer = 9,
    OPERATION_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 88;
  friend void swap(UpdateCollectionClusterSetupRequest& a, UpdateCollectionClusterSetupRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateCollectionClusterSetupRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCollectionClusterSetupRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCollectionClusterSetupRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateCollectionClusterSetupRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateCollectionClusterSetupRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateCollectionClusterSetupRequest& from) { UpdateCollectionClusterSetupRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateCollectionClusterSetupRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.UpdateCollectionClusterSetupRequest"; }

  explicit UpdateCollectionClusterSetupRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateCollectionClusterSetupRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateCollectionClusterSetupRequest& from);
  UpdateCollectionClusterSetupRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateCollectionClusterSetupRequest&& from) noexcept
      : UpdateCollectionClusterSetupRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kTimeoutFieldNumber = 6,
    kMoveShardFieldNumber = 2,
    kReplicateShardFieldNumber = 3,
    kAbortTransferFieldNumber = 4,
    kDropReplicaFieldNumber = 5,
    kCreateShardKeyFieldNumber = 7,
    kDeleteShardKeyFieldNumber = 8,
    kRestartTransferFieldNumber = 9,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional uint64 timeout = 6;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // .qdrant.MoveShard move_shard = 2;
  bool has_move_shard() const;
  private:
  bool _internal_has_move_shard() const;

  public:
  void clear_move_shard() ;
  const ::qdrant::MoveShard& move_shard() const;
  [[nodiscard]] ::qdrant::MoveShard* PROTOBUF_NULLABLE release_move_shard();
  ::qdrant::MoveShard* PROTOBUF_NONNULL mutable_move_shard();
  void set_allocated_move_shard(::qdrant::MoveShard* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_move_shard(::qdrant::MoveShard* PROTOBUF_NULLABLE value);
  ::qdrant::MoveShard* PROTOBUF_NULLABLE unsafe_arena_release_move_shard();

  private:
  const ::qdrant::MoveShard& _internal_move_shard() const;
  ::qdrant::MoveShard* PROTOBUF_NONNULL _internal_mutable_move_shard();

  public:
  // .qdrant.ReplicateShard replicate_shard = 3;
  bool has_replicate_shard() const;
  private:
  bool _internal_has_replicate_shard() const;

  public:
  void clear_replicate_shard() ;
  const ::qdrant::ReplicateShard& replicate_shard() const;
  [[nodiscard]] ::qdrant::ReplicateShard* PROTOBUF_NULLABLE release_replicate_shard();
  ::qdrant::ReplicateShard* PROTOBUF_NONNULL mutable_replicate_shard();
  void set_allocated_replicate_shard(::qdrant::ReplicateShard* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_replicate_shard(::qdrant::ReplicateShard* PROTOBUF_NULLABLE value);
  ::qdrant::ReplicateShard* PROTOBUF_NULLABLE unsafe_arena_release_replicate_shard();

  private:
  const ::qdrant::ReplicateShard& _internal_replicate_shard() const;
  ::qdrant::ReplicateShard* PROTOBUF_NONNULL _internal_mutable_replicate_shard();

  public:
  // .qdrant.AbortShardTransfer abort_transfer = 4;
  bool has_abort_transfer() const;
  private:
  bool _internal_has_abort_transfer() const;

  public:
  void clear_abort_transfer() ;
  const ::qdrant::AbortShardTransfer& abort_transfer() const;
  [[nodiscard]] ::qdrant::AbortShardTransfer* PROTOBUF_NULLABLE release_abort_transfer();
  ::qdrant::AbortShardTransfer* PROTOBUF_NONNULL mutable_abort_transfer();
  void set_allocated_abort_transfer(::qdrant::AbortShardTransfer* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_abort_transfer(::qdrant::AbortShardTransfer* PROTOBUF_NULLABLE value);
  ::qdrant::AbortShardTransfer* PROTOBUF_NULLABLE unsafe_arena_release_abort_transfer();

  private:
  const ::qdrant::AbortShardTransfer& _internal_abort_transfer() const;
  ::qdrant::AbortShardTransfer* PROTOBUF_NONNULL _internal_mutable_abort_transfer();

  public:
  // .qdrant.Replica drop_replica = 5;
  bool has_drop_replica() const;
  private:
  bool _internal_has_drop_replica() const;

  public:
  void clear_drop_replica() ;
  const ::qdrant::Replica& drop_replica() const;
  [[nodiscard]] ::qdrant::Replica* PROTOBUF_NULLABLE release_drop_replica();
  ::qdrant::Replica* PROTOBUF_NONNULL mutable_drop_replica();
  void set_allocated_drop_replica(::qdrant::Replica* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_drop_replica(::qdrant::Replica* PROTOBUF_NULLABLE value);
  ::qdrant::Replica* PROTOBUF_NULLABLE unsafe_arena_release_drop_replica();

  private:
  const ::qdrant::Replica& _internal_drop_replica() const;
  ::qdrant::Replica* PROTOBUF_NONNULL _internal_mutable_drop_replica();

  public:
  // .qdrant.CreateShardKey create_shard_key = 7;
  bool has_create_shard_key() const;
  private:
  bool _internal_has_create_shard_key() const;

  public:
  void clear_create_shard_key() ;
  const ::qdrant::CreateShardKey& create_shard_key() const;
  [[nodiscard]] ::qdrant::CreateShardKey* PROTOBUF_NULLABLE release_create_shard_key();
  ::qdrant::CreateShardKey* PROTOBUF_NONNULL mutable_create_shard_key();
  void set_allocated_create_shard_key(::qdrant::CreateShardKey* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_create_shard_key(::qdrant::CreateShardKey* PROTOBUF_NULLABLE value);
  ::qdrant::CreateShardKey* PROTOBUF_NULLABLE unsafe_arena_release_create_shard_key();

  private:
  const ::qdrant::CreateShardKey& _internal_create_shard_key() const;
  ::qdrant::CreateShardKey* PROTOBUF_NONNULL _internal_mutable_create_shard_key();

  public:
  // .qdrant.DeleteShardKey delete_shard_key = 8;
  bool has_delete_shard_key() const;
  private:
  bool _internal_has_delete_shard_key() const;

  public:
  void clear_delete_shard_key() ;
  const ::qdrant::DeleteShardKey& delete_shard_key() const;
  [[nodiscard]] ::qdrant::DeleteShardKey* PROTOBUF_NULLABLE release_delete_shard_key();
  ::qdrant::DeleteShardKey* PROTOBUF_NONNULL mutable_delete_shard_key();
  void set_allocated_delete_shard_key(::qdrant::DeleteShardKey* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_delete_shard_key(::qdrant::DeleteShardKey* PROTOBUF_NULLABLE value);
  ::qdrant::DeleteShardKey* PROTOBUF_NULLABLE unsafe_arena_release_delete_shard_key();

  private:
  const ::qdrant::DeleteShardKey& _internal_delete_shard_key() const;
  ::qdrant::DeleteShardKey* PROTOBUF_NONNULL _internal_mutable_delete_shard_key();

  public:
  // .qdrant.RestartTransfer restart_transfer = 9;
  bool has_restart_transfer() const;
  private:
  bool _internal_has_restart_transfer() const;

  public:
  void clear_restart_transfer() ;
  const ::qdrant::RestartTransfer& restart_transfer() const;
  [[nodiscard]] ::qdrant::RestartTransfer* PROTOBUF_NULLABLE release_restart_transfer();
  ::qdrant::RestartTransfer* PROTOBUF_NONNULL mutable_restart_transfer();
  void set_allocated_restart_transfer(::qdrant::RestartTransfer* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_restart_transfer(::qdrant::RestartTransfer* PROTOBUF_NULLABLE value);
  ::qdrant::RestartTransfer* PROTOBUF_NULLABLE unsafe_arena_release_restart_transfer();

  private:
  const ::qdrant::RestartTransfer& _internal_restart_transfer() const;
  ::qdrant::RestartTransfer* PROTOBUF_NONNULL _internal_mutable_restart_transfer();

  public:
  void clear_operation();
  OperationCase operation_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.UpdateCollectionClusterSetupRequest)
 private:
  class _Internal;
  void set_has_move_shard();
  void set_has_replicate_shard();
  void set_has_abort_transfer();
  void set_has_drop_replica();
  void set_has_create_shard_key();
  void set_has_delete_shard_key();
  void set_has_restart_transfer();
  inline bool has_operation() const;
  inline void clear_has_operation();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 9,
                                   7, 74,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateCollectionClusterSetupRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::uint64_t timeout_;
    union OperationUnion {
      constexpr OperationUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE move_shard_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE replicate_shard_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE abort_transfer_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE drop_replica_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE create_shard_key_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE delete_shard_key_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE restart_transfer_;
    } operation_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateCollectionClusterSetupRequest_class_data_;
// -------------------------------------------------------------------

class TextIndexParams final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.TextIndexParams) */ {
 public:
  inline TextIndexParams() : TextIndexParams(nullptr) {}
  ~TextIndexParams() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TextIndexParams* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TextIndexParams));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TextIndexParams(::google::protobuf::internal::ConstantInitialized);

  inline TextIndexParams(const TextIndexParams& from) : TextIndexParams(nullptr, from) {}
  inline TextIndexParams(TextIndexParams&& from) noexcept
      : TextIndexParams(nullptr, ::std::move(from)) {}
  inline TextIndexParams& operator=(const TextIndexParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextIndexParams& operator=(TextIndexParams&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextIndexParams& default_instance() {
    return *reinterpret_cast<const TextIndexParams*>(
        &_TextIndexParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 55;
  friend void swap(TextIndexParams& a, TextIndexParams& b) { a.Swap(&b); }
  inline void Swap(TextIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextIndexParams* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TextIndexParams>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TextIndexParams& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TextIndexParams& from) { TextIndexParams::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TextIndexParams* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.TextIndexParams"; }

  explicit TextIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TextIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TextIndexParams& from);
  TextIndexParams(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TextIndexParams&& from) noexcept
      : TextIndexParams(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStopwordsFieldNumber = 6,
    kStemmerFieldNumber = 8,
    kMinTokenLenFieldNumber = 3,
    kTokenizerFieldNumber = 1,
    kLowercaseFieldNumber = 2,
    kOnDiskFieldNumber = 5,
    kPhraseMatchingFieldNumber = 7,
    kMaxTokenLenFieldNumber = 4,
  };
  // optional .qdrant.StopwordsSet stopwords = 6;
  bool has_stopwords() const;
  void clear_stopwords() ;
  const ::qdrant::StopwordsSet& stopwords() const;
  [[nodiscard]] ::qdrant::StopwordsSet* PROTOBUF_NULLABLE release_stopwords();
  ::qdrant::StopwordsSet* PROTOBUF_NONNULL mutable_stopwords();
  void set_allocated_stopwords(::qdrant::StopwordsSet* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_stopwords(::qdrant::StopwordsSet* PROTOBUF_NULLABLE value);
  ::qdrant::StopwordsSet* PROTOBUF_NULLABLE unsafe_arena_release_stopwords();

  private:
  const ::qdrant::StopwordsSet& _internal_stopwords() const;
  ::qdrant::StopwordsSet* PROTOBUF_NONNULL _internal_mutable_stopwords();

  public:
  // optional .qdrant.StemmingAlgorithm stemmer = 8;
  bool has_stemmer() const;
  void clear_stemmer() ;
  const ::qdrant::StemmingAlgorithm& stemmer() const;
  [[nodiscard]] ::qdrant::StemmingAlgorithm* PROTOBUF_NULLABLE release_stemmer();
  ::qdrant::StemmingAlgorithm* PROTOBUF_NONNULL mutable_stemmer();
  void set_allocated_stemmer(::qdrant::StemmingAlgorithm* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_stemmer(::qdrant::StemmingAlgorithm* PROTOBUF_NULLABLE value);
  ::qdrant::StemmingAlgorithm* PROTOBUF_NULLABLE unsafe_arena_release_stemmer();

  private:
  const ::qdrant::StemmingAlgorithm& _internal_stemmer() const;
  ::qdrant::StemmingAlgorithm* PROTOBUF_NONNULL _internal_mutable_stemmer();

  public:
  // optional uint64 min_token_len = 3;
  bool has_min_token_len() const;
  void clear_min_token_len() ;
  ::uint64_t min_token_len() const;
  void set_min_token_len(::uint64_t value);

  private:
  ::uint64_t _internal_min_token_len() const;
  void _internal_set_min_token_len(::uint64_t value);

  public:
  // .qdrant.TokenizerType tokenizer = 1;
  void clear_tokenizer() ;
  ::qdrant::TokenizerType tokenizer() const;
  void set_tokenizer(::qdrant::TokenizerType value);

  private:
  ::qdrant::TokenizerType _internal_tokenizer() const;
  void _internal_set_tokenizer(::qdrant::TokenizerType value);

  public:
  // optional bool lowercase = 2;
  bool has_lowercase() const;
  void clear_lowercase() ;
  bool lowercase() const;
  void set_lowercase(bool value);

  private:
  bool _internal_lowercase() const;
  void _internal_set_lowercase(bool value);

  public:
  // optional bool on_disk = 5;
  bool has_on_disk() const;
  void clear_on_disk() ;
  bool on_disk() const;
  void set_on_disk(bool value);

  private:
  bool _internal_on_disk() const;
  void _internal_set_on_disk(bool value);

  public:
  // optional bool phrase_matching = 7;
  bool has_phrase_matching() const;
  void clear_phrase_matching() ;
  bool phrase_matching() const;
  void set_phrase_matching(bool value);

  private:
  bool _internal_phrase_matching() const;
  void _internal_set_phrase_matching(bool value);

  public:
  // optional uint64 max_token_len = 4;
  bool has_max_token_len() const;
  void clear_max_token_len() ;
  ::uint64_t max_token_len() const;
  void set_max_token_len(::uint64_t value);

  private:
  ::uint64_t _internal_max_token_len() const;
  void _internal_set_max_token_len(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.TextIndexParams)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TextIndexParams& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::StopwordsSet* PROTOBUF_NULLABLE stopwords_;
    ::qdrant::StemmingAlgorithm* PROTOBUF_NULLABLE stemmer_;
    ::uint64_t min_token_len_;
    int tokenizer_;
    bool lowercase_;
    bool on_disk_;
    bool phrase_matching_;
    ::uint64_t max_token_len_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TextIndexParams_class_data_;
// -------------------------------------------------------------------

class StrictModeSparseConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.StrictModeSparseConfig) */ {
 public:
  inline StrictModeSparseConfig() : StrictModeSparseConfig(nullptr) {}
  ~StrictModeSparseConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StrictModeSparseConfig* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StrictModeSparseConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StrictModeSparseConfig(::google::protobuf::internal::ConstantInitialized);

  inline StrictModeSparseConfig(const StrictModeSparseConfig& from) : StrictModeSparseConfig(nullptr, from) {}
  inline StrictModeSparseConfig(StrictModeSparseConfig&& from) noexcept
      : StrictModeSparseConfig(nullptr, ::std::move(from)) {}
  inline StrictModeSparseConfig& operator=(const StrictModeSparseConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrictModeSparseConfig& operator=(StrictModeSparseConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrictModeSparseConfig& default_instance() {
    return *reinterpret_cast<const StrictModeSparseConfig*>(
        &_StrictModeSparseConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(StrictModeSparseConfig& a, StrictModeSparseConfig& b) { a.Swap(&b); }
  inline void Swap(StrictModeSparseConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrictModeSparseConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrictModeSparseConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StrictModeSparseConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StrictModeSparseConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StrictModeSparseConfig& from) { StrictModeSparseConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StrictModeSparseConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.StrictModeSparseConfig"; }

  explicit StrictModeSparseConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StrictModeSparseConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StrictModeSparseConfig& from);
  StrictModeSparseConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StrictModeSparseConfig&& from) noexcept
      : StrictModeSparseConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSparseConfigFieldNumber = 1,
  };
  // map<string, .qdrant.StrictModeSparse> sparse_config = 1;
  int sparse_config_size() const;
  private:
  int _internal_sparse_config_size() const;

  public:
  void clear_sparse_config() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::StrictModeSparse>& sparse_config() const;
  ::google::protobuf::Map<::std::string, ::qdrant::StrictModeSparse>* PROTOBUF_NONNULL mutable_sparse_config();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::StrictModeSparse>& _internal_sparse_config() const;
  ::google::protobuf::Map<::std::string, ::qdrant::StrictModeSparse>* PROTOBUF_NONNULL _internal_mutable_sparse_config();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.StrictModeSparseConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   2, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StrictModeSparseConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<StrictModeSparseConfig_SparseConfigEntry_DoNotUse, ::std::string, ::qdrant::StrictModeSparse,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        sparse_config_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StrictModeSparseConfig_class_data_;
// -------------------------------------------------------------------

class StrictModeMultivectorConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.StrictModeMultivectorConfig) */ {
 public:
  inline StrictModeMultivectorConfig() : StrictModeMultivectorConfig(nullptr) {}
  ~StrictModeMultivectorConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StrictModeMultivectorConfig* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StrictModeMultivectorConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StrictModeMultivectorConfig(::google::protobuf::internal::ConstantInitialized);

  inline StrictModeMultivectorConfig(const StrictModeMultivectorConfig& from) : StrictModeMultivectorConfig(nullptr, from) {}
  inline StrictModeMultivectorConfig(StrictModeMultivectorConfig&& from) noexcept
      : StrictModeMultivectorConfig(nullptr, ::std::move(from)) {}
  inline StrictModeMultivectorConfig& operator=(const StrictModeMultivectorConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrictModeMultivectorConfig& operator=(StrictModeMultivectorConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrictModeMultivectorConfig& default_instance() {
    return *reinterpret_cast<const StrictModeMultivectorConfig*>(
        &_StrictModeMultivectorConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(StrictModeMultivectorConfig& a, StrictModeMultivectorConfig& b) { a.Swap(&b); }
  inline void Swap(StrictModeMultivectorConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrictModeMultivectorConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrictModeMultivectorConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StrictModeMultivectorConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StrictModeMultivectorConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StrictModeMultivectorConfig& from) { StrictModeMultivectorConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StrictModeMultivectorConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.StrictModeMultivectorConfig"; }

  explicit StrictModeMultivectorConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StrictModeMultivectorConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StrictModeMultivectorConfig& from);
  StrictModeMultivectorConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StrictModeMultivectorConfig&& from) noexcept
      : StrictModeMultivectorConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMultivectorConfigFieldNumber = 1,
  };
  // map<string, .qdrant.StrictModeMultivector> multivector_config = 1;
  int multivector_config_size() const;
  private:
  int _internal_multivector_config_size() const;

  public:
  void clear_multivector_config() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::StrictModeMultivector>& multivector_config() const;
  ::google::protobuf::Map<::std::string, ::qdrant::StrictModeMultivector>* PROTOBUF_NONNULL mutable_multivector_config();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::StrictModeMultivector>& _internal_multivector_config() const;
  ::google::protobuf::Map<::std::string, ::qdrant::StrictModeMultivector>* PROTOBUF_NONNULL _internal_mutable_multivector_config();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.StrictModeMultivectorConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   2, 61,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StrictModeMultivectorConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<StrictModeMultivectorConfig_MultivectorConfigEntry_DoNotUse, ::std::string, ::qdrant::StrictModeMultivector,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        multivector_config_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StrictModeMultivectorConfig_class_data_;
// -------------------------------------------------------------------

class SparseVectorConfig_MapEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SparseVectorConfig_MapEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SparseVectorConfig_MapEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit SparseVectorConfig_MapEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_SparseVectorConfig_MapEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_collections_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 46,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull SparseVectorConfig_MapEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class QuantizationConfigDiff final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.QuantizationConfigDiff) */ {
 public:
  inline QuantizationConfigDiff() : QuantizationConfigDiff(nullptr) {}
  ~QuantizationConfigDiff() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QuantizationConfigDiff* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QuantizationConfigDiff));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QuantizationConfigDiff(::google::protobuf::internal::ConstantInitialized);

  inline QuantizationConfigDiff(const QuantizationConfigDiff& from) : QuantizationConfigDiff(nullptr, from) {}
  inline QuantizationConfigDiff(QuantizationConfigDiff&& from) noexcept
      : QuantizationConfigDiff(nullptr, ::std::move(from)) {}
  inline QuantizationConfigDiff& operator=(const QuantizationConfigDiff& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuantizationConfigDiff& operator=(QuantizationConfigDiff&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuantizationConfigDiff& default_instance() {
    return *reinterpret_cast<const QuantizationConfigDiff*>(
        &_QuantizationConfigDiff_default_instance_);
  }
  enum QuantizationCase {
    kScalar = 1,
    kProduct = 2,
    kDisabled = 3,
    kBinary = 4,
    QUANTIZATION_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(QuantizationConfigDiff& a, QuantizationConfigDiff& b) { a.Swap(&b); }
  inline void Swap(QuantizationConfigDiff* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuantizationConfigDiff* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuantizationConfigDiff* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QuantizationConfigDiff>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QuantizationConfigDiff& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QuantizationConfigDiff& from) { QuantizationConfigDiff::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QuantizationConfigDiff* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.QuantizationConfigDiff"; }

  explicit QuantizationConfigDiff(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QuantizationConfigDiff(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QuantizationConfigDiff& from);
  QuantizationConfigDiff(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QuantizationConfigDiff&& from) noexcept
      : QuantizationConfigDiff(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kScalarFieldNumber = 1,
    kProductFieldNumber = 2,
    kDisabledFieldNumber = 3,
    kBinaryFieldNumber = 4,
  };
  // .qdrant.ScalarQuantization scalar = 1;
  bool has_scalar() const;
  private:
  bool _internal_has_scalar() const;

  public:
  void clear_scalar() ;
  const ::qdrant::ScalarQuantization& scalar() const;
  [[nodiscard]] ::qdrant::ScalarQuantization* PROTOBUF_NULLABLE release_scalar();
  ::qdrant::ScalarQuantization* PROTOBUF_NONNULL mutable_scalar();
  void set_allocated_scalar(::qdrant::ScalarQuantization* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_scalar(::qdrant::ScalarQuantization* PROTOBUF_NULLABLE value);
  ::qdrant::ScalarQuantization* PROTOBUF_NULLABLE unsafe_arena_release_scalar();

  private:
  const ::qdrant::ScalarQuantization& _internal_scalar() const;
  ::qdrant::ScalarQuantization* PROTOBUF_NONNULL _internal_mutable_scalar();

  public:
  // .qdrant.ProductQuantization product = 2;
  bool has_product() const;
  private:
  bool _internal_has_product() const;

  public:
  void clear_product() ;
  const ::qdrant::ProductQuantization& product() const;
  [[nodiscard]] ::qdrant::ProductQuantization* PROTOBUF_NULLABLE release_product();
  ::qdrant::ProductQuantization* PROTOBUF_NONNULL mutable_product();
  void set_allocated_product(::qdrant::ProductQuantization* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_product(::qdrant::ProductQuantization* PROTOBUF_NULLABLE value);
  ::qdrant::ProductQuantization* PROTOBUF_NULLABLE unsafe_arena_release_product();

  private:
  const ::qdrant::ProductQuantization& _internal_product() const;
  ::qdrant::ProductQuantization* PROTOBUF_NONNULL _internal_mutable_product();

  public:
  // .qdrant.Disabled disabled = 3;
  bool has_disabled() const;
  private:
  bool _internal_has_disabled() const;

  public:
  void clear_disabled() ;
  const ::qdrant::Disabled& disabled() const;
  [[nodiscard]] ::qdrant::Disabled* PROTOBUF_NULLABLE release_disabled();
  ::qdrant::Disabled* PROTOBUF_NONNULL mutable_disabled();
  void set_allocated_disabled(::qdrant::Disabled* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_disabled(::qdrant::Disabled* PROTOBUF_NULLABLE value);
  ::qdrant::Disabled* PROTOBUF_NULLABLE unsafe_arena_release_disabled();

  private:
  const ::qdrant::Disabled& _internal_disabled() const;
  ::qdrant::Disabled* PROTOBUF_NONNULL _internal_mutable_disabled();

  public:
  // .qdrant.BinaryQuantization binary = 4;
  bool has_binary() const;
  private:
  bool _internal_has_binary() const;

  public:
  void clear_binary() ;
  const ::qdrant::BinaryQuantization& binary() const;
  [[nodiscard]] ::qdrant::BinaryQuantization* PROTOBUF_NULLABLE release_binary();
  ::qdrant::BinaryQuantization* PROTOBUF_NONNULL mutable_binary();
  void set_allocated_binary(::qdrant::BinaryQuantization* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_binary(::qdrant::BinaryQuantization* PROTOBUF_NULLABLE value);
  ::qdrant::BinaryQuantization* PROTOBUF_NULLABLE unsafe_arena_release_binary();

  private:
  const ::qdrant::BinaryQuantization& _internal_binary() const;
  ::qdrant::BinaryQuantization* PROTOBUF_NONNULL _internal_mutable_binary();

  public:
  void clear_quantization();
  QuantizationCase quantization_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.QuantizationConfigDiff)
 private:
  class _Internal;
  void set_has_scalar();
  void set_has_product();
  void set_has_disabled();
  void set_has_binary();
  inline bool has_quantization() const;
  inline void clear_has_quantization();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 4,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QuantizationConfigDiff& from_msg);
    union QuantizationUnion {
      constexpr QuantizationUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE scalar_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE product_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE disabled_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE binary_;
    } quantization_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QuantizationConfigDiff_class_data_;
// -------------------------------------------------------------------

class QuantizationConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.QuantizationConfig) */ {
 public:
  inline QuantizationConfig() : QuantizationConfig(nullptr) {}
  ~QuantizationConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QuantizationConfig* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QuantizationConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QuantizationConfig(::google::protobuf::internal::ConstantInitialized);

  inline QuantizationConfig(const QuantizationConfig& from) : QuantizationConfig(nullptr, from) {}
  inline QuantizationConfig(QuantizationConfig&& from) noexcept
      : QuantizationConfig(nullptr, ::std::move(from)) {}
  inline QuantizationConfig& operator=(const QuantizationConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuantizationConfig& operator=(QuantizationConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuantizationConfig& default_instance() {
    return *reinterpret_cast<const QuantizationConfig*>(
        &_QuantizationConfig_default_instance_);
  }
  enum QuantizationCase {
    kScalar = 1,
    kProduct = 2,
    kBinary = 3,
    QUANTIZATION_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(QuantizationConfig& a, QuantizationConfig& b) { a.Swap(&b); }
  inline void Swap(QuantizationConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuantizationConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuantizationConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QuantizationConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QuantizationConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QuantizationConfig& from) { QuantizationConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QuantizationConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.QuantizationConfig"; }

  explicit QuantizationConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QuantizationConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QuantizationConfig& from);
  QuantizationConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QuantizationConfig&& from) noexcept
      : QuantizationConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kScalarFieldNumber = 1,
    kProductFieldNumber = 2,
    kBinaryFieldNumber = 3,
  };
  // .qdrant.ScalarQuantization scalar = 1;
  bool has_scalar() const;
  private:
  bool _internal_has_scalar() const;

  public:
  void clear_scalar() ;
  const ::qdrant::ScalarQuantization& scalar() const;
  [[nodiscard]] ::qdrant::ScalarQuantization* PROTOBUF_NULLABLE release_scalar();
  ::qdrant::ScalarQuantization* PROTOBUF_NONNULL mutable_scalar();
  void set_allocated_scalar(::qdrant::ScalarQuantization* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_scalar(::qdrant::ScalarQuantization* PROTOBUF_NULLABLE value);
  ::qdrant::ScalarQuantization* PROTOBUF_NULLABLE unsafe_arena_release_scalar();

  private:
  const ::qdrant::ScalarQuantization& _internal_scalar() const;
  ::qdrant::ScalarQuantization* PROTOBUF_NONNULL _internal_mutable_scalar();

  public:
  // .qdrant.ProductQuantization product = 2;
  bool has_product() const;
  private:
  bool _internal_has_product() const;

  public:
  void clear_product() ;
  const ::qdrant::ProductQuantization& product() const;
  [[nodiscard]] ::qdrant::ProductQuantization* PROTOBUF_NULLABLE release_product();
  ::qdrant::ProductQuantization* PROTOBUF_NONNULL mutable_product();
  void set_allocated_product(::qdrant::ProductQuantization* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_product(::qdrant::ProductQuantization* PROTOBUF_NULLABLE value);
  ::qdrant::ProductQuantization* PROTOBUF_NULLABLE unsafe_arena_release_product();

  private:
  const ::qdrant::ProductQuantization& _internal_product() const;
  ::qdrant::ProductQuantization* PROTOBUF_NONNULL _internal_mutable_product();

  public:
  // .qdrant.BinaryQuantization binary = 3;
  bool has_binary() const;
  private:
  bool _internal_has_binary() const;

  public:
  void clear_binary() ;
  const ::qdrant::BinaryQuantization& binary() const;
  [[nodiscard]] ::qdrant::BinaryQuantization* PROTOBUF_NULLABLE release_binary();
  ::qdrant::BinaryQuantization* PROTOBUF_NONNULL mutable_binary();
  void set_allocated_binary(::qdrant::BinaryQuantization* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_binary(::qdrant::BinaryQuantization* PROTOBUF_NULLABLE value);
  ::qdrant::BinaryQuantization* PROTOBUF_NULLABLE unsafe_arena_release_binary();

  private:
  const ::qdrant::BinaryQuantization& _internal_binary() const;
  ::qdrant::BinaryQuantization* PROTOBUF_NONNULL _internal_mutable_binary();

  public:
  void clear_quantization();
  QuantizationCase quantization_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.QuantizationConfig)
 private:
  class _Internal;
  void set_has_scalar();
  void set_has_product();
  void set_has_binary();
  inline bool has_quantization() const;
  inline void clear_has_quantization();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QuantizationConfig& from_msg);
    union QuantizationUnion {
      constexpr QuantizationUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE scalar_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE product_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE binary_;
    } quantization_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QuantizationConfig_class_data_;
// -------------------------------------------------------------------

class DeleteShardKeyRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.DeleteShardKeyRequest) */ {
 public:
  inline DeleteShardKeyRequest() : DeleteShardKeyRequest(nullptr) {}
  ~DeleteShardKeyRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteShardKeyRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteShardKeyRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteShardKeyRequest(::google::protobuf::internal::ConstantInitialized);

  inline DeleteShardKeyRequest(const DeleteShardKeyRequest& from) : DeleteShardKeyRequest(nullptr, from) {}
  inline DeleteShardKeyRequest(DeleteShardKeyRequest&& from) noexcept
      : DeleteShardKeyRequest(nullptr, ::std::move(from)) {}
  inline DeleteShardKeyRequest& operator=(const DeleteShardKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteShardKeyRequest& operator=(DeleteShardKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteShardKeyRequest& default_instance() {
    return *reinterpret_cast<const DeleteShardKeyRequest*>(
        &_DeleteShardKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 91;
  friend void swap(DeleteShardKeyRequest& a, DeleteShardKeyRequest& b) { a.Swap(&b); }
  inline void Swap(DeleteShardKeyRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteShardKeyRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteShardKeyRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteShardKeyRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteShardKeyRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteShardKeyRequest& from) { DeleteShardKeyRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteShardKeyRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.DeleteShardKeyRequest"; }

  explicit DeleteShardKeyRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeleteShardKeyRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeleteShardKeyRequest& from);
  DeleteShardKeyRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeleteShardKeyRequest&& from) noexcept
      : DeleteShardKeyRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kRequestFieldNumber = 2,
    kTimeoutFieldNumber = 3,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // .qdrant.DeleteShardKey request = 2;
  bool has_request() const;
  void clear_request() ;
  const ::qdrant::DeleteShardKey& request() const;
  [[nodiscard]] ::qdrant::DeleteShardKey* PROTOBUF_NULLABLE release_request();
  ::qdrant::DeleteShardKey* PROTOBUF_NONNULL mutable_request();
  void set_allocated_request(::qdrant::DeleteShardKey* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_request(::qdrant::DeleteShardKey* PROTOBUF_NULLABLE value);
  ::qdrant::DeleteShardKey* PROTOBUF_NULLABLE unsafe_arena_release_request();

  private:
  const ::qdrant::DeleteShardKey& _internal_request() const;
  ::qdrant::DeleteShardKey* PROTOBUF_NONNULL _internal_mutable_request();

  public:
  // optional uint64 timeout = 3;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.DeleteShardKeyRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 52,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeleteShardKeyRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::qdrant::DeleteShardKey* PROTOBUF_NULLABLE request_;
    ::uint64_t timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeleteShardKeyRequest_class_data_;
// -------------------------------------------------------------------

class CreateShardKeyRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CreateShardKeyRequest) */ {
 public:
  inline CreateShardKeyRequest() : CreateShardKeyRequest(nullptr) {}
  ~CreateShardKeyRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateShardKeyRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateShardKeyRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateShardKeyRequest(::google::protobuf::internal::ConstantInitialized);

  inline CreateShardKeyRequest(const CreateShardKeyRequest& from) : CreateShardKeyRequest(nullptr, from) {}
  inline CreateShardKeyRequest(CreateShardKeyRequest&& from) noexcept
      : CreateShardKeyRequest(nullptr, ::std::move(from)) {}
  inline CreateShardKeyRequest& operator=(const CreateShardKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateShardKeyRequest& operator=(CreateShardKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateShardKeyRequest& default_instance() {
    return *reinterpret_cast<const CreateShardKeyRequest*>(
        &_CreateShardKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 90;
  friend void swap(CreateShardKeyRequest& a, CreateShardKeyRequest& b) { a.Swap(&b); }
  inline void Swap(CreateShardKeyRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateShardKeyRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateShardKeyRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateShardKeyRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateShardKeyRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateShardKeyRequest& from) { CreateShardKeyRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateShardKeyRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CreateShardKeyRequest"; }

  explicit CreateShardKeyRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CreateShardKeyRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CreateShardKeyRequest& from);
  CreateShardKeyRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CreateShardKeyRequest&& from) noexcept
      : CreateShardKeyRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kRequestFieldNumber = 2,
    kTimeoutFieldNumber = 3,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // .qdrant.CreateShardKey request = 2;
  bool has_request() const;
  void clear_request() ;
  const ::qdrant::CreateShardKey& request() const;
  [[nodiscard]] ::qdrant::CreateShardKey* PROTOBUF_NULLABLE release_request();
  ::qdrant::CreateShardKey* PROTOBUF_NONNULL mutable_request();
  void set_allocated_request(::qdrant::CreateShardKey* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_request(::qdrant::CreateShardKey* PROTOBUF_NULLABLE value);
  ::qdrant::CreateShardKey* PROTOBUF_NULLABLE unsafe_arena_release_request();

  private:
  const ::qdrant::CreateShardKey& _internal_request() const;
  ::qdrant::CreateShardKey* PROTOBUF_NONNULL _internal_mutable_request();

  public:
  // optional uint64 timeout = 3;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CreateShardKeyRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 52,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CreateShardKeyRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::qdrant::CreateShardKey* PROTOBUF_NULLABLE request_;
    ::uint64_t timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CreateShardKeyRequest_class_data_;
// -------------------------------------------------------------------

class CollectionClusterInfoResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CollectionClusterInfoResponse) */ {
 public:
  inline CollectionClusterInfoResponse() : CollectionClusterInfoResponse(nullptr) {}
  ~CollectionClusterInfoResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CollectionClusterInfoResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CollectionClusterInfoResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionClusterInfoResponse(::google::protobuf::internal::ConstantInitialized);

  inline CollectionClusterInfoResponse(const CollectionClusterInfoResponse& from) : CollectionClusterInfoResponse(nullptr, from) {}
  inline CollectionClusterInfoResponse(CollectionClusterInfoResponse&& from) noexcept
      : CollectionClusterInfoResponse(nullptr, ::std::move(from)) {}
  inline CollectionClusterInfoResponse& operator=(const CollectionClusterInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionClusterInfoResponse& operator=(CollectionClusterInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionClusterInfoResponse& default_instance() {
    return *reinterpret_cast<const CollectionClusterInfoResponse*>(
        &_CollectionClusterInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 80;
  friend void swap(CollectionClusterInfoResponse& a, CollectionClusterInfoResponse& b) { a.Swap(&b); }
  inline void Swap(CollectionClusterInfoResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionClusterInfoResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionClusterInfoResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CollectionClusterInfoResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionClusterInfoResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectionClusterInfoResponse& from) { CollectionClusterInfoResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CollectionClusterInfoResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CollectionClusterInfoResponse"; }

  explicit CollectionClusterInfoResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CollectionClusterInfoResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CollectionClusterInfoResponse& from);
  CollectionClusterInfoResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CollectionClusterInfoResponse&& from) noexcept
      : CollectionClusterInfoResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLocalShardsFieldNumber = 3,
    kRemoteShardsFieldNumber = 4,
    kShardTransfersFieldNumber = 5,
    kReshardingOperationsFieldNumber = 6,
    kPeerIdFieldNumber = 1,
    kShardCountFieldNumber = 2,
  };
  // repeated .qdrant.LocalShardInfo local_shards = 3;
  int local_shards_size() const;
  private:
  int _internal_local_shards_size() const;

  public:
  void clear_local_shards() ;
  ::qdrant::LocalShardInfo* PROTOBUF_NONNULL mutable_local_shards(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::LocalShardInfo>* PROTOBUF_NONNULL mutable_local_shards();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::LocalShardInfo>& _internal_local_shards() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::LocalShardInfo>* PROTOBUF_NONNULL _internal_mutable_local_shards();
  public:
  const ::qdrant::LocalShardInfo& local_shards(int index) const;
  ::qdrant::LocalShardInfo* PROTOBUF_NONNULL add_local_shards();
  const ::google::protobuf::RepeatedPtrField<::qdrant::LocalShardInfo>& local_shards() const;
  // repeated .qdrant.RemoteShardInfo remote_shards = 4;
  int remote_shards_size() const;
  private:
  int _internal_remote_shards_size() const;

  public:
  void clear_remote_shards() ;
  ::qdrant::RemoteShardInfo* PROTOBUF_NONNULL mutable_remote_shards(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::RemoteShardInfo>* PROTOBUF_NONNULL mutable_remote_shards();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::RemoteShardInfo>& _internal_remote_shards() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::RemoteShardInfo>* PROTOBUF_NONNULL _internal_mutable_remote_shards();
  public:
  const ::qdrant::RemoteShardInfo& remote_shards(int index) const;
  ::qdrant::RemoteShardInfo* PROTOBUF_NONNULL add_remote_shards();
  const ::google::protobuf::RepeatedPtrField<::qdrant::RemoteShardInfo>& remote_shards() const;
  // repeated .qdrant.ShardTransferInfo shard_transfers = 5;
  int shard_transfers_size() const;
  private:
  int _internal_shard_transfers_size() const;

  public:
  void clear_shard_transfers() ;
  ::qdrant::ShardTransferInfo* PROTOBUF_NONNULL mutable_shard_transfers(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::ShardTransferInfo>* PROTOBUF_NONNULL mutable_shard_transfers();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::ShardTransferInfo>& _internal_shard_transfers() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::ShardTransferInfo>* PROTOBUF_NONNULL _internal_mutable_shard_transfers();
  public:
  const ::qdrant::ShardTransferInfo& shard_transfers(int index) const;
  ::qdrant::ShardTransferInfo* PROTOBUF_NONNULL add_shard_transfers();
  const ::google::protobuf::RepeatedPtrField<::qdrant::ShardTransferInfo>& shard_transfers() const;
  // repeated .qdrant.ReshardingInfo resharding_operations = 6;
  int resharding_operations_size() const;
  private:
  int _internal_resharding_operations_size() const;

  public:
  void clear_resharding_operations() ;
  ::qdrant::ReshardingInfo* PROTOBUF_NONNULL mutable_resharding_operations(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::ReshardingInfo>* PROTOBUF_NONNULL mutable_resharding_operations();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::ReshardingInfo>& _internal_resharding_operations() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::ReshardingInfo>* PROTOBUF_NONNULL _internal_mutable_resharding_operations();
  public:
  const ::qdrant::ReshardingInfo& resharding_operations(int index) const;
  ::qdrant::ReshardingInfo* PROTOBUF_NONNULL add_resharding_operations();
  const ::google::protobuf::RepeatedPtrField<::qdrant::ReshardingInfo>& resharding_operations() const;
  // uint64 peer_id = 1;
  void clear_peer_id() ;
  ::uint64_t peer_id() const;
  void set_peer_id(::uint64_t value);

  private:
  ::uint64_t _internal_peer_id() const;
  void _internal_set_peer_id(::uint64_t value);

  public:
  // uint64 shard_count = 2;
  void clear_shard_count() ;
  ::uint64_t shard_count() const;
  void set_shard_count(::uint64_t value);

  private:
  ::uint64_t _internal_shard_count() const;
  void _internal_set_shard_count(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CollectionClusterInfoResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CollectionClusterInfoResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::LocalShardInfo > local_shards_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::RemoteShardInfo > remote_shards_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::ShardTransferInfo > shard_transfers_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::ReshardingInfo > resharding_operations_;
    ::uint64_t peer_id_;
    ::uint64_t shard_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CollectionClusterInfoResponse_class_data_;
// -------------------------------------------------------------------

class ChangeAliases final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.ChangeAliases) */ {
 public:
  inline ChangeAliases() : ChangeAliases(nullptr) {}
  ~ChangeAliases() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ChangeAliases* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ChangeAliases));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChangeAliases(::google::protobuf::internal::ConstantInitialized);

  inline ChangeAliases(const ChangeAliases& from) : ChangeAliases(nullptr, from) {}
  inline ChangeAliases(ChangeAliases&& from) noexcept
      : ChangeAliases(nullptr, ::std::move(from)) {}
  inline ChangeAliases& operator=(const ChangeAliases& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeAliases& operator=(ChangeAliases&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeAliases& default_instance() {
    return *reinterpret_cast<const ChangeAliases*>(
        &_ChangeAliases_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 65;
  friend void swap(ChangeAliases& a, ChangeAliases& b) { a.Swap(&b); }
  inline void Swap(ChangeAliases* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeAliases* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeAliases* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ChangeAliases>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChangeAliases& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChangeAliases& from) { ChangeAliases::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ChangeAliases* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.ChangeAliases"; }

  explicit ChangeAliases(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ChangeAliases(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ChangeAliases& from);
  ChangeAliases(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ChangeAliases&& from) noexcept
      : ChangeAliases(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kActionsFieldNumber = 1,
    kTimeoutFieldNumber = 2,
  };
  // repeated .qdrant.AliasOperations actions = 1;
  int actions_size() const;
  private:
  int _internal_actions_size() const;

  public:
  void clear_actions() ;
  ::qdrant::AliasOperations* PROTOBUF_NONNULL mutable_actions(int index);
  ::google::protobuf::RepeatedPtrField<::qdrant::AliasOperations>* PROTOBUF_NONNULL mutable_actions();

  private:
  const ::google::protobuf::RepeatedPtrField<::qdrant::AliasOperations>& _internal_actions() const;
  ::google::protobuf::RepeatedPtrField<::qdrant::AliasOperations>* PROTOBUF_NONNULL _internal_mutable_actions();
  public:
  const ::qdrant::AliasOperations& actions(int index) const;
  ::qdrant::AliasOperations* PROTOBUF_NONNULL add_actions();
  const ::google::protobuf::RepeatedPtrField<::qdrant::AliasOperations>& actions() const;
  // optional uint64 timeout = 2;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.ChangeAliases)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ChangeAliases& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::qdrant::AliasOperations > actions_;
    ::uint64_t timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ChangeAliases_class_data_;
// -------------------------------------------------------------------

class VectorParamsDiff final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.VectorParamsDiff) */ {
 public:
  inline VectorParamsDiff() : VectorParamsDiff(nullptr) {}
  ~VectorParamsDiff() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VectorParamsDiff* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VectorParamsDiff));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VectorParamsDiff(::google::protobuf::internal::ConstantInitialized);

  inline VectorParamsDiff(const VectorParamsDiff& from) : VectorParamsDiff(nullptr, from) {}
  inline VectorParamsDiff(VectorParamsDiff&& from) noexcept
      : VectorParamsDiff(nullptr, ::std::move(from)) {}
  inline VectorParamsDiff& operator=(const VectorParamsDiff& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorParamsDiff& operator=(VectorParamsDiff&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorParamsDiff& default_instance() {
    return *reinterpret_cast<const VectorParamsDiff*>(
        &_VectorParamsDiff_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(VectorParamsDiff& a, VectorParamsDiff& b) { a.Swap(&b); }
  inline void Swap(VectorParamsDiff* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorParamsDiff* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorParamsDiff* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VectorParamsDiff>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorParamsDiff& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VectorParamsDiff& from) { VectorParamsDiff::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VectorParamsDiff* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.VectorParamsDiff"; }

  explicit VectorParamsDiff(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  VectorParamsDiff(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const VectorParamsDiff& from);
  VectorParamsDiff(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, VectorParamsDiff&& from) noexcept
      : VectorParamsDiff(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHnswConfigFieldNumber = 1,
    kQuantizationConfigFieldNumber = 2,
    kOnDiskFieldNumber = 3,
  };
  // optional .qdrant.HnswConfigDiff hnsw_config = 1;
  bool has_hnsw_config() const;
  void clear_hnsw_config() ;
  const ::qdrant::HnswConfigDiff& hnsw_config() const;
  [[nodiscard]] ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE release_hnsw_config();
  ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL mutable_hnsw_config();
  void set_allocated_hnsw_config(::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_hnsw_config(::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value);
  ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE unsafe_arena_release_hnsw_config();

  private:
  const ::qdrant::HnswConfigDiff& _internal_hnsw_config() const;
  ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL _internal_mutable_hnsw_config();

  public:
  // optional .qdrant.QuantizationConfigDiff quantization_config = 2;
  bool has_quantization_config() const;
  void clear_quantization_config() ;
  const ::qdrant::QuantizationConfigDiff& quantization_config() const;
  [[nodiscard]] ::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE release_quantization_config();
  ::qdrant::QuantizationConfigDiff* PROTOBUF_NONNULL mutable_quantization_config();
  void set_allocated_quantization_config(::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_quantization_config(::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE value);
  ::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE unsafe_arena_release_quantization_config();

  private:
  const ::qdrant::QuantizationConfigDiff& _internal_quantization_config() const;
  ::qdrant::QuantizationConfigDiff* PROTOBUF_NONNULL _internal_mutable_quantization_config();

  public:
  // optional bool on_disk = 3;
  bool has_on_disk() const;
  void clear_on_disk() ;
  bool on_disk() const;
  void set_on_disk(bool value);

  private:
  bool _internal_on_disk() const;
  void _internal_set_on_disk(bool value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.VectorParamsDiff)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const VectorParamsDiff& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE hnsw_config_;
    ::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE quantization_config_;
    bool on_disk_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull VectorParamsDiff_class_data_;
// -------------------------------------------------------------------

class VectorParams final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.VectorParams) */ {
 public:
  inline VectorParams() : VectorParams(nullptr) {}
  ~VectorParams() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VectorParams* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VectorParams));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VectorParams(::google::protobuf::internal::ConstantInitialized);

  inline VectorParams(const VectorParams& from) : VectorParams(nullptr, from) {}
  inline VectorParams(VectorParams&& from) noexcept
      : VectorParams(nullptr, ::std::move(from)) {}
  inline VectorParams& operator=(const VectorParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorParams& operator=(VectorParams&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorParams& default_instance() {
    return *reinterpret_cast<const VectorParams*>(
        &_VectorParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(VectorParams& a, VectorParams& b) { a.Swap(&b); }
  inline void Swap(VectorParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorParams* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VectorParams>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorParams& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VectorParams& from) { VectorParams::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VectorParams* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.VectorParams"; }

  explicit VectorParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  VectorParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const VectorParams& from);
  VectorParams(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, VectorParams&& from) noexcept
      : VectorParams(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHnswConfigFieldNumber = 3,
    kQuantizationConfigFieldNumber = 4,
    kMultivectorConfigFieldNumber = 7,
    kSizeFieldNumber = 1,
    kDistanceFieldNumber = 2,
    kOnDiskFieldNumber = 5,
    kDatatypeFieldNumber = 6,
  };
  // optional .qdrant.HnswConfigDiff hnsw_config = 3;
  bool has_hnsw_config() const;
  void clear_hnsw_config() ;
  const ::qdrant::HnswConfigDiff& hnsw_config() const;
  [[nodiscard]] ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE release_hnsw_config();
  ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL mutable_hnsw_config();
  void set_allocated_hnsw_config(::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_hnsw_config(::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value);
  ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE unsafe_arena_release_hnsw_config();

  private:
  const ::qdrant::HnswConfigDiff& _internal_hnsw_config() const;
  ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL _internal_mutable_hnsw_config();

  public:
  // optional .qdrant.QuantizationConfig quantization_config = 4;
  bool has_quantization_config() const;
  void clear_quantization_config() ;
  const ::qdrant::QuantizationConfig& quantization_config() const;
  [[nodiscard]] ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE release_quantization_config();
  ::qdrant::QuantizationConfig* PROTOBUF_NONNULL mutable_quantization_config();
  void set_allocated_quantization_config(::qdrant::QuantizationConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_quantization_config(::qdrant::QuantizationConfig* PROTOBUF_NULLABLE value);
  ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE unsafe_arena_release_quantization_config();

  private:
  const ::qdrant::QuantizationConfig& _internal_quantization_config() const;
  ::qdrant::QuantizationConfig* PROTOBUF_NONNULL _internal_mutable_quantization_config();

  public:
  // optional .qdrant.MultiVectorConfig multivector_config = 7;
  bool has_multivector_config() const;
  void clear_multivector_config() ;
  const ::qdrant::MultiVectorConfig& multivector_config() const;
  [[nodiscard]] ::qdrant::MultiVectorConfig* PROTOBUF_NULLABLE release_multivector_config();
  ::qdrant::MultiVectorConfig* PROTOBUF_NONNULL mutable_multivector_config();
  void set_allocated_multivector_config(::qdrant::MultiVectorConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_multivector_config(::qdrant::MultiVectorConfig* PROTOBUF_NULLABLE value);
  ::qdrant::MultiVectorConfig* PROTOBUF_NULLABLE unsafe_arena_release_multivector_config();

  private:
  const ::qdrant::MultiVectorConfig& _internal_multivector_config() const;
  ::qdrant::MultiVectorConfig* PROTOBUF_NONNULL _internal_mutable_multivector_config();

  public:
  // uint64 size = 1;
  void clear_size() ;
  ::uint64_t size() const;
  void set_size(::uint64_t value);

  private:
  ::uint64_t _internal_size() const;
  void _internal_set_size(::uint64_t value);

  public:
  // .qdrant.Distance distance = 2;
  void clear_distance() ;
  ::qdrant::Distance distance() const;
  void set_distance(::qdrant::Distance value);

  private:
  ::qdrant::Distance _internal_distance() const;
  void _internal_set_distance(::qdrant::Distance value);

  public:
  // optional bool on_disk = 5;
  bool has_on_disk() const;
  void clear_on_disk() ;
  bool on_disk() const;
  void set_on_disk(bool value);

  private:
  bool _internal_on_disk() const;
  void _internal_set_on_disk(bool value);

  public:
  // optional .qdrant.Datatype datatype = 6;
  bool has_datatype() const;
  void clear_datatype() ;
  ::qdrant::Datatype datatype() const;
  void set_datatype(::qdrant::Datatype value);

  private:
  ::qdrant::Datatype _internal_datatype() const;
  void _internal_set_datatype(::qdrant::Datatype value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.VectorParams)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const VectorParams& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE hnsw_config_;
    ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE quantization_config_;
    ::qdrant::MultiVectorConfig* PROTOBUF_NULLABLE multivector_config_;
    ::uint64_t size_;
    int distance_;
    bool on_disk_;
    int datatype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull VectorParams_class_data_;
// -------------------------------------------------------------------

class StrictModeConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.StrictModeConfig) */ {
 public:
  inline StrictModeConfig() : StrictModeConfig(nullptr) {}
  ~StrictModeConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StrictModeConfig* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StrictModeConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StrictModeConfig(::google::protobuf::internal::ConstantInitialized);

  inline StrictModeConfig(const StrictModeConfig& from) : StrictModeConfig(nullptr, from) {}
  inline StrictModeConfig(StrictModeConfig&& from) noexcept
      : StrictModeConfig(nullptr, ::std::move(from)) {}
  inline StrictModeConfig& operator=(const StrictModeConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrictModeConfig& operator=(StrictModeConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrictModeConfig& default_instance() {
    return *reinterpret_cast<const StrictModeConfig*>(
        &_StrictModeConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(StrictModeConfig& a, StrictModeConfig& b) { a.Swap(&b); }
  inline void Swap(StrictModeConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrictModeConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrictModeConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StrictModeConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StrictModeConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StrictModeConfig& from) { StrictModeConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StrictModeConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.StrictModeConfig"; }

  explicit StrictModeConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StrictModeConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StrictModeConfig& from);
  StrictModeConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StrictModeConfig&& from) noexcept
      : StrictModeConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMultivectorConfigFieldNumber = 16,
    kSparseConfigFieldNumber = 17,
    kMaxQueryLimitFieldNumber = 2,
    kMaxTimeoutFieldNumber = 3,
    kEnabledFieldNumber = 1,
    kUnindexedFilteringRetrieveFieldNumber = 4,
    kUnindexedFilteringUpdateFieldNumber = 5,
    kSearchAllowExactFieldNumber = 7,
    kSearchMaxHnswEfFieldNumber = 6,
    kUpsertMaxBatchsizeFieldNumber = 9,
    kSearchMaxOversamplingFieldNumber = 8,
    kReadRateLimitFieldNumber = 11,
    kMaxCollectionVectorSizeBytesFieldNumber = 10,
    kMaxCollectionPayloadSizeBytesFieldNumber = 13,
    kFilterMaxConditionsFieldNumber = 14,
    kConditionMaxSizeFieldNumber = 15,
    kMaxPointsCountFieldNumber = 18,
    kMaxPayloadIndexCountFieldNumber = 19,
    kWriteRateLimitFieldNumber = 12,
  };
  // optional .qdrant.StrictModeMultivectorConfig multivector_config = 16;
  bool has_multivector_config() const;
  void clear_multivector_config() ;
  const ::qdrant::StrictModeMultivectorConfig& multivector_config() const;
  [[nodiscard]] ::qdrant::StrictModeMultivectorConfig* PROTOBUF_NULLABLE release_multivector_config();
  ::qdrant::StrictModeMultivectorConfig* PROTOBUF_NONNULL mutable_multivector_config();
  void set_allocated_multivector_config(::qdrant::StrictModeMultivectorConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_multivector_config(::qdrant::StrictModeMultivectorConfig* PROTOBUF_NULLABLE value);
  ::qdrant::StrictModeMultivectorConfig* PROTOBUF_NULLABLE unsafe_arena_release_multivector_config();

  private:
  const ::qdrant::StrictModeMultivectorConfig& _internal_multivector_config() const;
  ::qdrant::StrictModeMultivectorConfig* PROTOBUF_NONNULL _internal_mutable_multivector_config();

  public:
  // optional .qdrant.StrictModeSparseConfig sparse_config = 17;
  bool has_sparse_config() const;
  void clear_sparse_config() ;
  const ::qdrant::StrictModeSparseConfig& sparse_config() const;
  [[nodiscard]] ::qdrant::StrictModeSparseConfig* PROTOBUF_NULLABLE release_sparse_config();
  ::qdrant::StrictModeSparseConfig* PROTOBUF_NONNULL mutable_sparse_config();
  void set_allocated_sparse_config(::qdrant::StrictModeSparseConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sparse_config(::qdrant::StrictModeSparseConfig* PROTOBUF_NULLABLE value);
  ::qdrant::StrictModeSparseConfig* PROTOBUF_NULLABLE unsafe_arena_release_sparse_config();

  private:
  const ::qdrant::StrictModeSparseConfig& _internal_sparse_config() const;
  ::qdrant::StrictModeSparseConfig* PROTOBUF_NONNULL _internal_mutable_sparse_config();

  public:
  // optional uint32 max_query_limit = 2;
  bool has_max_query_limit() const;
  void clear_max_query_limit() ;
  ::uint32_t max_query_limit() const;
  void set_max_query_limit(::uint32_t value);

  private:
  ::uint32_t _internal_max_query_limit() const;
  void _internal_set_max_query_limit(::uint32_t value);

  public:
  // optional uint32 max_timeout = 3;
  bool has_max_timeout() const;
  void clear_max_timeout() ;
  ::uint32_t max_timeout() const;
  void set_max_timeout(::uint32_t value);

  private:
  ::uint32_t _internal_max_timeout() const;
  void _internal_set_max_timeout(::uint32_t value);

  public:
  // optional bool enabled = 1;
  bool has_enabled() const;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // optional bool unindexed_filtering_retrieve = 4;
  bool has_unindexed_filtering_retrieve() const;
  void clear_unindexed_filtering_retrieve() ;
  bool unindexed_filtering_retrieve() const;
  void set_unindexed_filtering_retrieve(bool value);

  private:
  bool _internal_unindexed_filtering_retrieve() const;
  void _internal_set_unindexed_filtering_retrieve(bool value);

  public:
  // optional bool unindexed_filtering_update = 5;
  bool has_unindexed_filtering_update() const;
  void clear_unindexed_filtering_update() ;
  bool unindexed_filtering_update() const;
  void set_unindexed_filtering_update(bool value);

  private:
  bool _internal_unindexed_filtering_update() const;
  void _internal_set_unindexed_filtering_update(bool value);

  public:
  // optional bool search_allow_exact = 7;
  bool has_search_allow_exact() const;
  void clear_search_allow_exact() ;
  bool search_allow_exact() const;
  void set_search_allow_exact(bool value);

  private:
  bool _internal_search_allow_exact() const;
  void _internal_set_search_allow_exact(bool value);

  public:
  // optional uint32 search_max_hnsw_ef = 6;
  bool has_search_max_hnsw_ef() const;
  void clear_search_max_hnsw_ef() ;
  ::uint32_t search_max_hnsw_ef() const;
  void set_search_max_hnsw_ef(::uint32_t value);

  private:
  ::uint32_t _internal_search_max_hnsw_ef() const;
  void _internal_set_search_max_hnsw_ef(::uint32_t value);

  public:
  // optional uint64 upsert_max_batchsize = 9;
  bool has_upsert_max_batchsize() const;
  void clear_upsert_max_batchsize() ;
  ::uint64_t upsert_max_batchsize() const;
  void set_upsert_max_batchsize(::uint64_t value);

  private:
  ::uint64_t _internal_upsert_max_batchsize() const;
  void _internal_set_upsert_max_batchsize(::uint64_t value);

  public:
  // optional float search_max_oversampling = 8;
  bool has_search_max_oversampling() const;
  void clear_search_max_oversampling() ;
  float search_max_oversampling() const;
  void set_search_max_oversampling(float value);

  private:
  float _internal_search_max_oversampling() const;
  void _internal_set_search_max_oversampling(float value);

  public:
  // optional uint32 read_rate_limit = 11;
  bool has_read_rate_limit() const;
  void clear_read_rate_limit() ;
  ::uint32_t read_rate_limit() const;
  void set_read_rate_limit(::uint32_t value);

  private:
  ::uint32_t _internal_read_rate_limit() const;
  void _internal_set_read_rate_limit(::uint32_t value);

  public:
  // optional uint64 max_collection_vector_size_bytes = 10;
  bool has_max_collection_vector_size_bytes() const;
  void clear_max_collection_vector_size_bytes() ;
  ::uint64_t max_collection_vector_size_bytes() const;
  void set_max_collection_vector_size_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_max_collection_vector_size_bytes() const;
  void _internal_set_max_collection_vector_size_bytes(::uint64_t value);

  public:
  // optional uint64 max_collection_payload_size_bytes = 13;
  bool has_max_collection_payload_size_bytes() const;
  void clear_max_collection_payload_size_bytes() ;
  ::uint64_t max_collection_payload_size_bytes() const;
  void set_max_collection_payload_size_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_max_collection_payload_size_bytes() const;
  void _internal_set_max_collection_payload_size_bytes(::uint64_t value);

  public:
  // optional uint64 filter_max_conditions = 14;
  bool has_filter_max_conditions() const;
  void clear_filter_max_conditions() ;
  ::uint64_t filter_max_conditions() const;
  void set_filter_max_conditions(::uint64_t value);

  private:
  ::uint64_t _internal_filter_max_conditions() const;
  void _internal_set_filter_max_conditions(::uint64_t value);

  public:
  // optional uint64 condition_max_size = 15;
  bool has_condition_max_size() const;
  void clear_condition_max_size() ;
  ::uint64_t condition_max_size() const;
  void set_condition_max_size(::uint64_t value);

  private:
  ::uint64_t _internal_condition_max_size() const;
  void _internal_set_condition_max_size(::uint64_t value);

  public:
  // optional uint64 max_points_count = 18;
  bool has_max_points_count() const;
  void clear_max_points_count() ;
  ::uint64_t max_points_count() const;
  void set_max_points_count(::uint64_t value);

  private:
  ::uint64_t _internal_max_points_count() const;
  void _internal_set_max_points_count(::uint64_t value);

  public:
  // optional uint64 max_payload_index_count = 19;
  bool has_max_payload_index_count() const;
  void clear_max_payload_index_count() ;
  ::uint64_t max_payload_index_count() const;
  void set_max_payload_index_count(::uint64_t value);

  private:
  ::uint64_t _internal_max_payload_index_count() const;
  void _internal_set_max_payload_index_count(::uint64_t value);

  public:
  // optional uint32 write_rate_limit = 12;
  bool has_write_rate_limit() const;
  void clear_write_rate_limit() ;
  ::uint32_t write_rate_limit() const;
  void set_write_rate_limit(::uint32_t value);

  private:
  ::uint32_t _internal_write_rate_limit() const;
  void _internal_set_write_rate_limit(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.StrictModeConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 19,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StrictModeConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::StrictModeMultivectorConfig* PROTOBUF_NULLABLE multivector_config_;
    ::qdrant::StrictModeSparseConfig* PROTOBUF_NULLABLE sparse_config_;
    ::uint32_t max_query_limit_;
    ::uint32_t max_timeout_;
    bool enabled_;
    bool unindexed_filtering_retrieve_;
    bool unindexed_filtering_update_;
    bool search_allow_exact_;
    ::uint32_t search_max_hnsw_ef_;
    ::uint64_t upsert_max_batchsize_;
    float search_max_oversampling_;
    ::uint32_t read_rate_limit_;
    ::uint64_t max_collection_vector_size_bytes_;
    ::uint64_t max_collection_payload_size_bytes_;
    ::uint64_t filter_max_conditions_;
    ::uint64_t condition_max_size_;
    ::uint64_t max_points_count_;
    ::uint64_t max_payload_index_count_;
    ::uint32_t write_rate_limit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StrictModeConfig_class_data_;
// -------------------------------------------------------------------

class SparseVectorConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.SparseVectorConfig) */ {
 public:
  inline SparseVectorConfig() : SparseVectorConfig(nullptr) {}
  ~SparseVectorConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SparseVectorConfig* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SparseVectorConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SparseVectorConfig(::google::protobuf::internal::ConstantInitialized);

  inline SparseVectorConfig(const SparseVectorConfig& from) : SparseVectorConfig(nullptr, from) {}
  inline SparseVectorConfig(SparseVectorConfig&& from) noexcept
      : SparseVectorConfig(nullptr, ::std::move(from)) {}
  inline SparseVectorConfig& operator=(const SparseVectorConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SparseVectorConfig& operator=(SparseVectorConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SparseVectorConfig& default_instance() {
    return *reinterpret_cast<const SparseVectorConfig*>(
        &_SparseVectorConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(SparseVectorConfig& a, SparseVectorConfig& b) { a.Swap(&b); }
  inline void Swap(SparseVectorConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SparseVectorConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SparseVectorConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SparseVectorConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SparseVectorConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SparseVectorConfig& from) { SparseVectorConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SparseVectorConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.SparseVectorConfig"; }

  explicit SparseVectorConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SparseVectorConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SparseVectorConfig& from);
  SparseVectorConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SparseVectorConfig&& from) noexcept
      : SparseVectorConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMapFieldNumber = 1,
  };
  // map<string, .qdrant.SparseVectorParams> map = 1;
  int map_size() const;
  private:
  int _internal_map_size() const;

  public:
  void clear_map() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::SparseVectorParams>& map() const;
  ::google::protobuf::Map<::std::string, ::qdrant::SparseVectorParams>* PROTOBUF_NONNULL mutable_map();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::SparseVectorParams>& _internal_map() const;
  ::google::protobuf::Map<::std::string, ::qdrant::SparseVectorParams>* PROTOBUF_NONNULL _internal_mutable_map();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.SparseVectorConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   2, 37,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SparseVectorConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<SparseVectorConfig_MapEntry_DoNotUse, ::std::string, ::qdrant::SparseVectorParams,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        map_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SparseVectorConfig_class_data_;
// -------------------------------------------------------------------

class PayloadIndexParams final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PayloadIndexParams) */ {
 public:
  inline PayloadIndexParams() : PayloadIndexParams(nullptr) {}
  ~PayloadIndexParams() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PayloadIndexParams* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PayloadIndexParams));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PayloadIndexParams(::google::protobuf::internal::ConstantInitialized);

  inline PayloadIndexParams(const PayloadIndexParams& from) : PayloadIndexParams(nullptr, from) {}
  inline PayloadIndexParams(PayloadIndexParams&& from) noexcept
      : PayloadIndexParams(nullptr, ::std::move(from)) {}
  inline PayloadIndexParams& operator=(const PayloadIndexParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadIndexParams& operator=(PayloadIndexParams&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PayloadIndexParams& default_instance() {
    return *reinterpret_cast<const PayloadIndexParams*>(
        &_PayloadIndexParams_default_instance_);
  }
  enum IndexParamsCase {
    kKeywordIndexParams = 3,
    kIntegerIndexParams = 2,
    kFloatIndexParams = 4,
    kGeoIndexParams = 5,
    kTextIndexParams = 1,
    kBoolIndexParams = 6,
    kDatetimeIndexParams = 7,
    kUuidIndexParams = 8,
    INDEX_PARAMS_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 61;
  friend void swap(PayloadIndexParams& a, PayloadIndexParams& b) { a.Swap(&b); }
  inline void Swap(PayloadIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadIndexParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadIndexParams* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PayloadIndexParams>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PayloadIndexParams& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PayloadIndexParams& from) { PayloadIndexParams::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PayloadIndexParams* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PayloadIndexParams"; }

  explicit PayloadIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PayloadIndexParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PayloadIndexParams& from);
  PayloadIndexParams(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PayloadIndexParams&& from) noexcept
      : PayloadIndexParams(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeywordIndexParamsFieldNumber = 3,
    kIntegerIndexParamsFieldNumber = 2,
    kFloatIndexParamsFieldNumber = 4,
    kGeoIndexParamsFieldNumber = 5,
    kTextIndexParamsFieldNumber = 1,
    kBoolIndexParamsFieldNumber = 6,
    kDatetimeIndexParamsFieldNumber = 7,
    kUuidIndexParamsFieldNumber = 8,
  };
  // .qdrant.KeywordIndexParams keyword_index_params = 3;
  bool has_keyword_index_params() const;
  private:
  bool _internal_has_keyword_index_params() const;

  public:
  void clear_keyword_index_params() ;
  const ::qdrant::KeywordIndexParams& keyword_index_params() const;
  [[nodiscard]] ::qdrant::KeywordIndexParams* PROTOBUF_NULLABLE release_keyword_index_params();
  ::qdrant::KeywordIndexParams* PROTOBUF_NONNULL mutable_keyword_index_params();
  void set_allocated_keyword_index_params(::qdrant::KeywordIndexParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_keyword_index_params(::qdrant::KeywordIndexParams* PROTOBUF_NULLABLE value);
  ::qdrant::KeywordIndexParams* PROTOBUF_NULLABLE unsafe_arena_release_keyword_index_params();

  private:
  const ::qdrant::KeywordIndexParams& _internal_keyword_index_params() const;
  ::qdrant::KeywordIndexParams* PROTOBUF_NONNULL _internal_mutable_keyword_index_params();

  public:
  // .qdrant.IntegerIndexParams integer_index_params = 2;
  bool has_integer_index_params() const;
  private:
  bool _internal_has_integer_index_params() const;

  public:
  void clear_integer_index_params() ;
  const ::qdrant::IntegerIndexParams& integer_index_params() const;
  [[nodiscard]] ::qdrant::IntegerIndexParams* PROTOBUF_NULLABLE release_integer_index_params();
  ::qdrant::IntegerIndexParams* PROTOBUF_NONNULL mutable_integer_index_params();
  void set_allocated_integer_index_params(::qdrant::IntegerIndexParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_integer_index_params(::qdrant::IntegerIndexParams* PROTOBUF_NULLABLE value);
  ::qdrant::IntegerIndexParams* PROTOBUF_NULLABLE unsafe_arena_release_integer_index_params();

  private:
  const ::qdrant::IntegerIndexParams& _internal_integer_index_params() const;
  ::qdrant::IntegerIndexParams* PROTOBUF_NONNULL _internal_mutable_integer_index_params();

  public:
  // .qdrant.FloatIndexParams float_index_params = 4;
  bool has_float_index_params() const;
  private:
  bool _internal_has_float_index_params() const;

  public:
  void clear_float_index_params() ;
  const ::qdrant::FloatIndexParams& float_index_params() const;
  [[nodiscard]] ::qdrant::FloatIndexParams* PROTOBUF_NULLABLE release_float_index_params();
  ::qdrant::FloatIndexParams* PROTOBUF_NONNULL mutable_float_index_params();
  void set_allocated_float_index_params(::qdrant::FloatIndexParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_float_index_params(::qdrant::FloatIndexParams* PROTOBUF_NULLABLE value);
  ::qdrant::FloatIndexParams* PROTOBUF_NULLABLE unsafe_arena_release_float_index_params();

  private:
  const ::qdrant::FloatIndexParams& _internal_float_index_params() const;
  ::qdrant::FloatIndexParams* PROTOBUF_NONNULL _internal_mutable_float_index_params();

  public:
  // .qdrant.GeoIndexParams geo_index_params = 5;
  bool has_geo_index_params() const;
  private:
  bool _internal_has_geo_index_params() const;

  public:
  void clear_geo_index_params() ;
  const ::qdrant::GeoIndexParams& geo_index_params() const;
  [[nodiscard]] ::qdrant::GeoIndexParams* PROTOBUF_NULLABLE release_geo_index_params();
  ::qdrant::GeoIndexParams* PROTOBUF_NONNULL mutable_geo_index_params();
  void set_allocated_geo_index_params(::qdrant::GeoIndexParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_geo_index_params(::qdrant::GeoIndexParams* PROTOBUF_NULLABLE value);
  ::qdrant::GeoIndexParams* PROTOBUF_NULLABLE unsafe_arena_release_geo_index_params();

  private:
  const ::qdrant::GeoIndexParams& _internal_geo_index_params() const;
  ::qdrant::GeoIndexParams* PROTOBUF_NONNULL _internal_mutable_geo_index_params();

  public:
  // .qdrant.TextIndexParams text_index_params = 1;
  bool has_text_index_params() const;
  private:
  bool _internal_has_text_index_params() const;

  public:
  void clear_text_index_params() ;
  const ::qdrant::TextIndexParams& text_index_params() const;
  [[nodiscard]] ::qdrant::TextIndexParams* PROTOBUF_NULLABLE release_text_index_params();
  ::qdrant::TextIndexParams* PROTOBUF_NONNULL mutable_text_index_params();
  void set_allocated_text_index_params(::qdrant::TextIndexParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_text_index_params(::qdrant::TextIndexParams* PROTOBUF_NULLABLE value);
  ::qdrant::TextIndexParams* PROTOBUF_NULLABLE unsafe_arena_release_text_index_params();

  private:
  const ::qdrant::TextIndexParams& _internal_text_index_params() const;
  ::qdrant::TextIndexParams* PROTOBUF_NONNULL _internal_mutable_text_index_params();

  public:
  // .qdrant.BoolIndexParams bool_index_params = 6;
  bool has_bool_index_params() const;
  private:
  bool _internal_has_bool_index_params() const;

  public:
  void clear_bool_index_params() ;
  const ::qdrant::BoolIndexParams& bool_index_params() const;
  [[nodiscard]] ::qdrant::BoolIndexParams* PROTOBUF_NULLABLE release_bool_index_params();
  ::qdrant::BoolIndexParams* PROTOBUF_NONNULL mutable_bool_index_params();
  void set_allocated_bool_index_params(::qdrant::BoolIndexParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bool_index_params(::qdrant::BoolIndexParams* PROTOBUF_NULLABLE value);
  ::qdrant::BoolIndexParams* PROTOBUF_NULLABLE unsafe_arena_release_bool_index_params();

  private:
  const ::qdrant::BoolIndexParams& _internal_bool_index_params() const;
  ::qdrant::BoolIndexParams* PROTOBUF_NONNULL _internal_mutable_bool_index_params();

  public:
  // .qdrant.DatetimeIndexParams datetime_index_params = 7;
  bool has_datetime_index_params() const;
  private:
  bool _internal_has_datetime_index_params() const;

  public:
  void clear_datetime_index_params() ;
  const ::qdrant::DatetimeIndexParams& datetime_index_params() const;
  [[nodiscard]] ::qdrant::DatetimeIndexParams* PROTOBUF_NULLABLE release_datetime_index_params();
  ::qdrant::DatetimeIndexParams* PROTOBUF_NONNULL mutable_datetime_index_params();
  void set_allocated_datetime_index_params(::qdrant::DatetimeIndexParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_datetime_index_params(::qdrant::DatetimeIndexParams* PROTOBUF_NULLABLE value);
  ::qdrant::DatetimeIndexParams* PROTOBUF_NULLABLE unsafe_arena_release_datetime_index_params();

  private:
  const ::qdrant::DatetimeIndexParams& _internal_datetime_index_params() const;
  ::qdrant::DatetimeIndexParams* PROTOBUF_NONNULL _internal_mutable_datetime_index_params();

  public:
  // .qdrant.UuidIndexParams uuid_index_params = 8;
  bool has_uuid_index_params() const;
  private:
  bool _internal_has_uuid_index_params() const;

  public:
  void clear_uuid_index_params() ;
  const ::qdrant::UuidIndexParams& uuid_index_params() const;
  [[nodiscard]] ::qdrant::UuidIndexParams* PROTOBUF_NULLABLE release_uuid_index_params();
  ::qdrant::UuidIndexParams* PROTOBUF_NONNULL mutable_uuid_index_params();
  void set_allocated_uuid_index_params(::qdrant::UuidIndexParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_uuid_index_params(::qdrant::UuidIndexParams* PROTOBUF_NULLABLE value);
  ::qdrant::UuidIndexParams* PROTOBUF_NULLABLE unsafe_arena_release_uuid_index_params();

  private:
  const ::qdrant::UuidIndexParams& _internal_uuid_index_params() const;
  ::qdrant::UuidIndexParams* PROTOBUF_NONNULL _internal_mutable_uuid_index_params();

  public:
  void clear_index_params();
  IndexParamsCase index_params_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.PayloadIndexParams)
 private:
  class _Internal;
  void set_has_keyword_index_params();
  void set_has_integer_index_params();
  void set_has_float_index_params();
  void set_has_geo_index_params();
  void set_has_text_index_params();
  void set_has_bool_index_params();
  void set_has_datetime_index_params();
  void set_has_uuid_index_params();
  inline bool has_index_params() const;
  inline void clear_has_index_params();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 8,
                                   8, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PayloadIndexParams& from_msg);
    union IndexParamsUnion {
      constexpr IndexParamsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE keyword_index_params_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE integer_index_params_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE float_index_params_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE geo_index_params_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE text_index_params_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE bool_index_params_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE datetime_index_params_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE uuid_index_params_;
    } index_params_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PayloadIndexParams_class_data_;
// -------------------------------------------------------------------

class VectorParamsMap_MapEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  VectorParamsMap_MapEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VectorParamsMap_MapEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit VectorParamsMap_MapEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_VectorParamsMap_MapEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_collections_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 43,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull VectorParamsMap_MapEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class VectorParamsDiffMap_MapEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  VectorParamsDiffMap_MapEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VectorParamsDiffMap_MapEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit VectorParamsDiffMap_MapEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_VectorParamsDiffMap_MapEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_collections_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 47,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull VectorParamsDiffMap_MapEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class PayloadSchemaInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.PayloadSchemaInfo) */ {
 public:
  inline PayloadSchemaInfo() : PayloadSchemaInfo(nullptr) {}
  ~PayloadSchemaInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PayloadSchemaInfo* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PayloadSchemaInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PayloadSchemaInfo(::google::protobuf::internal::ConstantInitialized);

  inline PayloadSchemaInfo(const PayloadSchemaInfo& from) : PayloadSchemaInfo(nullptr, from) {}
  inline PayloadSchemaInfo(PayloadSchemaInfo&& from) noexcept
      : PayloadSchemaInfo(nullptr, ::std::move(from)) {}
  inline PayloadSchemaInfo& operator=(const PayloadSchemaInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadSchemaInfo& operator=(PayloadSchemaInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PayloadSchemaInfo& default_instance() {
    return *reinterpret_cast<const PayloadSchemaInfo*>(
        &_PayloadSchemaInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 62;
  friend void swap(PayloadSchemaInfo& a, PayloadSchemaInfo& b) { a.Swap(&b); }
  inline void Swap(PayloadSchemaInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadSchemaInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadSchemaInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PayloadSchemaInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PayloadSchemaInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PayloadSchemaInfo& from) { PayloadSchemaInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PayloadSchemaInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.PayloadSchemaInfo"; }

  explicit PayloadSchemaInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PayloadSchemaInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PayloadSchemaInfo& from);
  PayloadSchemaInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PayloadSchemaInfo&& from) noexcept
      : PayloadSchemaInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kParamsFieldNumber = 2,
    kPointsFieldNumber = 3,
    kDataTypeFieldNumber = 1,
  };
  // optional .qdrant.PayloadIndexParams params = 2;
  bool has_params() const;
  void clear_params() ;
  const ::qdrant::PayloadIndexParams& params() const;
  [[nodiscard]] ::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE release_params();
  ::qdrant::PayloadIndexParams* PROTOBUF_NONNULL mutable_params();
  void set_allocated_params(::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_params(::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE value);
  ::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE unsafe_arena_release_params();

  private:
  const ::qdrant::PayloadIndexParams& _internal_params() const;
  ::qdrant::PayloadIndexParams* PROTOBUF_NONNULL _internal_mutable_params();

  public:
  // optional uint64 points = 3;
  bool has_points() const;
  void clear_points() ;
  ::uint64_t points() const;
  void set_points(::uint64_t value);

  private:
  ::uint64_t _internal_points() const;
  void _internal_set_points(::uint64_t value);

  public:
  // .qdrant.PayloadSchemaType data_type = 1;
  void clear_data_type() ;
  ::qdrant::PayloadSchemaType data_type() const;
  void set_data_type(::qdrant::PayloadSchemaType value);

  private:
  ::qdrant::PayloadSchemaType _internal_data_type() const;
  void _internal_set_data_type(::qdrant::PayloadSchemaType value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.PayloadSchemaInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PayloadSchemaInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE params_;
    ::uint64_t points_;
    int data_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PayloadSchemaInfo_class_data_;
// -------------------------------------------------------------------

class VectorParamsMap final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.VectorParamsMap) */ {
 public:
  inline VectorParamsMap() : VectorParamsMap(nullptr) {}
  ~VectorParamsMap() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VectorParamsMap* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VectorParamsMap));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VectorParamsMap(::google::protobuf::internal::ConstantInitialized);

  inline VectorParamsMap(const VectorParamsMap& from) : VectorParamsMap(nullptr, from) {}
  inline VectorParamsMap(VectorParamsMap&& from) noexcept
      : VectorParamsMap(nullptr, ::std::move(from)) {}
  inline VectorParamsMap& operator=(const VectorParamsMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorParamsMap& operator=(VectorParamsMap&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorParamsMap& default_instance() {
    return *reinterpret_cast<const VectorParamsMap*>(
        &_VectorParamsMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(VectorParamsMap& a, VectorParamsMap& b) { a.Swap(&b); }
  inline void Swap(VectorParamsMap* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorParamsMap* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorParamsMap* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VectorParamsMap>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorParamsMap& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VectorParamsMap& from) { VectorParamsMap::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VectorParamsMap* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.VectorParamsMap"; }

  explicit VectorParamsMap(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  VectorParamsMap(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const VectorParamsMap& from);
  VectorParamsMap(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, VectorParamsMap&& from) noexcept
      : VectorParamsMap(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMapFieldNumber = 1,
  };
  // map<string, .qdrant.VectorParams> map = 1;
  int map_size() const;
  private:
  int _internal_map_size() const;

  public:
  void clear_map() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::VectorParams>& map() const;
  ::google::protobuf::Map<::std::string, ::qdrant::VectorParams>* PROTOBUF_NONNULL mutable_map();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::VectorParams>& _internal_map() const;
  ::google::protobuf::Map<::std::string, ::qdrant::VectorParams>* PROTOBUF_NONNULL _internal_mutable_map();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.VectorParamsMap)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   2, 34,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const VectorParamsMap& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<VectorParamsMap_MapEntry_DoNotUse, ::std::string, ::qdrant::VectorParams,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        map_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull VectorParamsMap_class_data_;
// -------------------------------------------------------------------

class VectorParamsDiffMap final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.VectorParamsDiffMap) */ {
 public:
  inline VectorParamsDiffMap() : VectorParamsDiffMap(nullptr) {}
  ~VectorParamsDiffMap() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VectorParamsDiffMap* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VectorParamsDiffMap));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VectorParamsDiffMap(::google::protobuf::internal::ConstantInitialized);

  inline VectorParamsDiffMap(const VectorParamsDiffMap& from) : VectorParamsDiffMap(nullptr, from) {}
  inline VectorParamsDiffMap(VectorParamsDiffMap&& from) noexcept
      : VectorParamsDiffMap(nullptr, ::std::move(from)) {}
  inline VectorParamsDiffMap& operator=(const VectorParamsDiffMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorParamsDiffMap& operator=(VectorParamsDiffMap&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorParamsDiffMap& default_instance() {
    return *reinterpret_cast<const VectorParamsDiffMap*>(
        &_VectorParamsDiffMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(VectorParamsDiffMap& a, VectorParamsDiffMap& b) { a.Swap(&b); }
  inline void Swap(VectorParamsDiffMap* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorParamsDiffMap* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorParamsDiffMap* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VectorParamsDiffMap>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorParamsDiffMap& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VectorParamsDiffMap& from) { VectorParamsDiffMap::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VectorParamsDiffMap* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.VectorParamsDiffMap"; }

  explicit VectorParamsDiffMap(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  VectorParamsDiffMap(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const VectorParamsDiffMap& from);
  VectorParamsDiffMap(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, VectorParamsDiffMap&& from) noexcept
      : VectorParamsDiffMap(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMapFieldNumber = 1,
  };
  // map<string, .qdrant.VectorParamsDiff> map = 1;
  int map_size() const;
  private:
  int _internal_map_size() const;

  public:
  void clear_map() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::VectorParamsDiff>& map() const;
  ::google::protobuf::Map<::std::string, ::qdrant::VectorParamsDiff>* PROTOBUF_NONNULL mutable_map();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::VectorParamsDiff>& _internal_map() const;
  ::google::protobuf::Map<::std::string, ::qdrant::VectorParamsDiff>* PROTOBUF_NONNULL _internal_mutable_map();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.VectorParamsDiffMap)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   2, 38,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const VectorParamsDiffMap& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<VectorParamsDiffMap_MapEntry_DoNotUse, ::std::string, ::qdrant::VectorParamsDiff,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        map_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull VectorParamsDiffMap_class_data_;
// -------------------------------------------------------------------

class CollectionInfo_PayloadSchemaEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  CollectionInfo_PayloadSchemaEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionInfo_PayloadSchemaEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit CollectionInfo_PayloadSchemaEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_CollectionInfo_PayloadSchemaEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_collections_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 52,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull CollectionInfo_PayloadSchemaEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class VectorsConfigDiff final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.VectorsConfigDiff) */ {
 public:
  inline VectorsConfigDiff() : VectorsConfigDiff(nullptr) {}
  ~VectorsConfigDiff() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VectorsConfigDiff* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VectorsConfigDiff));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VectorsConfigDiff(::google::protobuf::internal::ConstantInitialized);

  inline VectorsConfigDiff(const VectorsConfigDiff& from) : VectorsConfigDiff(nullptr, from) {}
  inline VectorsConfigDiff(VectorsConfigDiff&& from) noexcept
      : VectorsConfigDiff(nullptr, ::std::move(from)) {}
  inline VectorsConfigDiff& operator=(const VectorsConfigDiff& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorsConfigDiff& operator=(VectorsConfigDiff&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorsConfigDiff& default_instance() {
    return *reinterpret_cast<const VectorsConfigDiff*>(
        &_VectorsConfigDiff_default_instance_);
  }
  enum ConfigCase {
    kParams = 1,
    kParamsMap = 2,
    CONFIG_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(VectorsConfigDiff& a, VectorsConfigDiff& b) { a.Swap(&b); }
  inline void Swap(VectorsConfigDiff* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorsConfigDiff* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorsConfigDiff* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VectorsConfigDiff>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorsConfigDiff& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VectorsConfigDiff& from) { VectorsConfigDiff::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VectorsConfigDiff* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.VectorsConfigDiff"; }

  explicit VectorsConfigDiff(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  VectorsConfigDiff(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const VectorsConfigDiff& from);
  VectorsConfigDiff(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, VectorsConfigDiff&& from) noexcept
      : VectorsConfigDiff(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kParamsFieldNumber = 1,
    kParamsMapFieldNumber = 2,
  };
  // .qdrant.VectorParamsDiff params = 1;
  bool has_params() const;
  private:
  bool _internal_has_params() const;

  public:
  void clear_params() ;
  const ::qdrant::VectorParamsDiff& params() const;
  [[nodiscard]] ::qdrant::VectorParamsDiff* PROTOBUF_NULLABLE release_params();
  ::qdrant::VectorParamsDiff* PROTOBUF_NONNULL mutable_params();
  void set_allocated_params(::qdrant::VectorParamsDiff* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_params(::qdrant::VectorParamsDiff* PROTOBUF_NULLABLE value);
  ::qdrant::VectorParamsDiff* PROTOBUF_NULLABLE unsafe_arena_release_params();

  private:
  const ::qdrant::VectorParamsDiff& _internal_params() const;
  ::qdrant::VectorParamsDiff* PROTOBUF_NONNULL _internal_mutable_params();

  public:
  // .qdrant.VectorParamsDiffMap params_map = 2;
  bool has_params_map() const;
  private:
  bool _internal_has_params_map() const;

  public:
  void clear_params_map() ;
  const ::qdrant::VectorParamsDiffMap& params_map() const;
  [[nodiscard]] ::qdrant::VectorParamsDiffMap* PROTOBUF_NULLABLE release_params_map();
  ::qdrant::VectorParamsDiffMap* PROTOBUF_NONNULL mutable_params_map();
  void set_allocated_params_map(::qdrant::VectorParamsDiffMap* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_params_map(::qdrant::VectorParamsDiffMap* PROTOBUF_NULLABLE value);
  ::qdrant::VectorParamsDiffMap* PROTOBUF_NULLABLE unsafe_arena_release_params_map();

  private:
  const ::qdrant::VectorParamsDiffMap& _internal_params_map() const;
  ::qdrant::VectorParamsDiffMap* PROTOBUF_NONNULL _internal_mutable_params_map();

  public:
  void clear_config();
  ConfigCase config_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.VectorsConfigDiff)
 private:
  class _Internal;
  void set_has_params();
  void set_has_params_map();
  inline bool has_config() const;
  inline void clear_has_config();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const VectorsConfigDiff& from_msg);
    union ConfigUnion {
      constexpr ConfigUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::qdrant::VectorParamsDiff* PROTOBUF_NULLABLE params_;
      ::qdrant::VectorParamsDiffMap* PROTOBUF_NULLABLE params_map_;
    } config_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull VectorsConfigDiff_class_data_;
// -------------------------------------------------------------------

class VectorsConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.VectorsConfig) */ {
 public:
  inline VectorsConfig() : VectorsConfig(nullptr) {}
  ~VectorsConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VectorsConfig* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VectorsConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VectorsConfig(::google::protobuf::internal::ConstantInitialized);

  inline VectorsConfig(const VectorsConfig& from) : VectorsConfig(nullptr, from) {}
  inline VectorsConfig(VectorsConfig&& from) noexcept
      : VectorsConfig(nullptr, ::std::move(from)) {}
  inline VectorsConfig& operator=(const VectorsConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorsConfig& operator=(VectorsConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorsConfig& default_instance() {
    return *reinterpret_cast<const VectorsConfig*>(
        &_VectorsConfig_default_instance_);
  }
  enum ConfigCase {
    kParams = 1,
    kParamsMap = 2,
    CONFIG_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(VectorsConfig& a, VectorsConfig& b) { a.Swap(&b); }
  inline void Swap(VectorsConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorsConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorsConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VectorsConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorsConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VectorsConfig& from) { VectorsConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VectorsConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.VectorsConfig"; }

  explicit VectorsConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  VectorsConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const VectorsConfig& from);
  VectorsConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, VectorsConfig&& from) noexcept
      : VectorsConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kParamsFieldNumber = 1,
    kParamsMapFieldNumber = 2,
  };
  // .qdrant.VectorParams params = 1;
  bool has_params() const;
  private:
  bool _internal_has_params() const;

  public:
  void clear_params() ;
  const ::qdrant::VectorParams& params() const;
  [[nodiscard]] ::qdrant::VectorParams* PROTOBUF_NULLABLE release_params();
  ::qdrant::VectorParams* PROTOBUF_NONNULL mutable_params();
  void set_allocated_params(::qdrant::VectorParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_params(::qdrant::VectorParams* PROTOBUF_NULLABLE value);
  ::qdrant::VectorParams* PROTOBUF_NULLABLE unsafe_arena_release_params();

  private:
  const ::qdrant::VectorParams& _internal_params() const;
  ::qdrant::VectorParams* PROTOBUF_NONNULL _internal_mutable_params();

  public:
  // .qdrant.VectorParamsMap params_map = 2;
  bool has_params_map() const;
  private:
  bool _internal_has_params_map() const;

  public:
  void clear_params_map() ;
  const ::qdrant::VectorParamsMap& params_map() const;
  [[nodiscard]] ::qdrant::VectorParamsMap* PROTOBUF_NULLABLE release_params_map();
  ::qdrant::VectorParamsMap* PROTOBUF_NONNULL mutable_params_map();
  void set_allocated_params_map(::qdrant::VectorParamsMap* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_params_map(::qdrant::VectorParamsMap* PROTOBUF_NULLABLE value);
  ::qdrant::VectorParamsMap* PROTOBUF_NULLABLE unsafe_arena_release_params_map();

  private:
  const ::qdrant::VectorParamsMap& _internal_params_map() const;
  ::qdrant::VectorParamsMap* PROTOBUF_NONNULL _internal_mutable_params_map();

  public:
  void clear_config();
  ConfigCase config_case() const;
  // @@protoc_insertion_point(class_scope:qdrant.VectorsConfig)
 private:
  class _Internal;
  void set_has_params();
  void set_has_params_map();
  inline bool has_config() const;
  inline void clear_has_config();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const VectorsConfig& from_msg);
    union ConfigUnion {
      constexpr ConfigUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::qdrant::VectorParams* PROTOBUF_NULLABLE params_;
      ::qdrant::VectorParamsMap* PROTOBUF_NULLABLE params_map_;
    } config_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull VectorsConfig_class_data_;
// -------------------------------------------------------------------

class UpdateCollection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.UpdateCollection) */ {
 public:
  inline UpdateCollection() : UpdateCollection(nullptr) {}
  ~UpdateCollection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateCollection* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateCollection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateCollection(::google::protobuf::internal::ConstantInitialized);

  inline UpdateCollection(const UpdateCollection& from) : UpdateCollection(nullptr, from) {}
  inline UpdateCollection(UpdateCollection&& from) noexcept
      : UpdateCollection(nullptr, ::std::move(from)) {}
  inline UpdateCollection& operator=(const UpdateCollection& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCollection& operator=(UpdateCollection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCollection& default_instance() {
    return *reinterpret_cast<const UpdateCollection*>(
        &_UpdateCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 43;
  friend void swap(UpdateCollection& a, UpdateCollection& b) { a.Swap(&b); }
  inline void Swap(UpdateCollection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCollection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCollection* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateCollection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateCollection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateCollection& from) { UpdateCollection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateCollection* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.UpdateCollection"; }

  explicit UpdateCollection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateCollection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateCollection& from);
  UpdateCollection(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateCollection&& from) noexcept
      : UpdateCollection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kOptimizersConfigFieldNumber = 2,
    kParamsFieldNumber = 4,
    kHnswConfigFieldNumber = 5,
    kVectorsConfigFieldNumber = 6,
    kQuantizationConfigFieldNumber = 7,
    kSparseVectorsConfigFieldNumber = 8,
    kStrictModeConfigFieldNumber = 9,
    kTimeoutFieldNumber = 3,
    kMetadataFieldNumber = 10,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional .qdrant.OptimizersConfigDiff optimizers_config = 2;
  bool has_optimizers_config() const;
  void clear_optimizers_config() ;
  const ::qdrant::OptimizersConfigDiff& optimizers_config() const;
  [[nodiscard]] ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE release_optimizers_config();
  ::qdrant::OptimizersConfigDiff* PROTOBUF_NONNULL mutable_optimizers_config();
  void set_allocated_optimizers_config(::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_optimizers_config(::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE value);
  ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE unsafe_arena_release_optimizers_config();

  private:
  const ::qdrant::OptimizersConfigDiff& _internal_optimizers_config() const;
  ::qdrant::OptimizersConfigDiff* PROTOBUF_NONNULL _internal_mutable_optimizers_config();

  public:
  // optional .qdrant.CollectionParamsDiff params = 4;
  bool has_params() const;
  void clear_params() ;
  const ::qdrant::CollectionParamsDiff& params() const;
  [[nodiscard]] ::qdrant::CollectionParamsDiff* PROTOBUF_NULLABLE release_params();
  ::qdrant::CollectionParamsDiff* PROTOBUF_NONNULL mutable_params();
  void set_allocated_params(::qdrant::CollectionParamsDiff* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_params(::qdrant::CollectionParamsDiff* PROTOBUF_NULLABLE value);
  ::qdrant::CollectionParamsDiff* PROTOBUF_NULLABLE unsafe_arena_release_params();

  private:
  const ::qdrant::CollectionParamsDiff& _internal_params() const;
  ::qdrant::CollectionParamsDiff* PROTOBUF_NONNULL _internal_mutable_params();

  public:
  // optional .qdrant.HnswConfigDiff hnsw_config = 5;
  bool has_hnsw_config() const;
  void clear_hnsw_config() ;
  const ::qdrant::HnswConfigDiff& hnsw_config() const;
  [[nodiscard]] ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE release_hnsw_config();
  ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL mutable_hnsw_config();
  void set_allocated_hnsw_config(::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_hnsw_config(::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value);
  ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE unsafe_arena_release_hnsw_config();

  private:
  const ::qdrant::HnswConfigDiff& _internal_hnsw_config() const;
  ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL _internal_mutable_hnsw_config();

  public:
  // optional .qdrant.VectorsConfigDiff vectors_config = 6;
  bool has_vectors_config() const;
  void clear_vectors_config() ;
  const ::qdrant::VectorsConfigDiff& vectors_config() const;
  [[nodiscard]] ::qdrant::VectorsConfigDiff* PROTOBUF_NULLABLE release_vectors_config();
  ::qdrant::VectorsConfigDiff* PROTOBUF_NONNULL mutable_vectors_config();
  void set_allocated_vectors_config(::qdrant::VectorsConfigDiff* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vectors_config(::qdrant::VectorsConfigDiff* PROTOBUF_NULLABLE value);
  ::qdrant::VectorsConfigDiff* PROTOBUF_NULLABLE unsafe_arena_release_vectors_config();

  private:
  const ::qdrant::VectorsConfigDiff& _internal_vectors_config() const;
  ::qdrant::VectorsConfigDiff* PROTOBUF_NONNULL _internal_mutable_vectors_config();

  public:
  // optional .qdrant.QuantizationConfigDiff quantization_config = 7;
  bool has_quantization_config() const;
  void clear_quantization_config() ;
  const ::qdrant::QuantizationConfigDiff& quantization_config() const;
  [[nodiscard]] ::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE release_quantization_config();
  ::qdrant::QuantizationConfigDiff* PROTOBUF_NONNULL mutable_quantization_config();
  void set_allocated_quantization_config(::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_quantization_config(::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE value);
  ::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE unsafe_arena_release_quantization_config();

  private:
  const ::qdrant::QuantizationConfigDiff& _internal_quantization_config() const;
  ::qdrant::QuantizationConfigDiff* PROTOBUF_NONNULL _internal_mutable_quantization_config();

  public:
  // optional .qdrant.SparseVectorConfig sparse_vectors_config = 8;
  bool has_sparse_vectors_config() const;
  void clear_sparse_vectors_config() ;
  const ::qdrant::SparseVectorConfig& sparse_vectors_config() const;
  [[nodiscard]] ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE release_sparse_vectors_config();
  ::qdrant::SparseVectorConfig* PROTOBUF_NONNULL mutable_sparse_vectors_config();
  void set_allocated_sparse_vectors_config(::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sparse_vectors_config(::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE value);
  ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE unsafe_arena_release_sparse_vectors_config();

  private:
  const ::qdrant::SparseVectorConfig& _internal_sparse_vectors_config() const;
  ::qdrant::SparseVectorConfig* PROTOBUF_NONNULL _internal_mutable_sparse_vectors_config();

  public:
  // optional .qdrant.StrictModeConfig strict_mode_config = 9;
  bool has_strict_mode_config() const;
  void clear_strict_mode_config() ;
  const ::qdrant::StrictModeConfig& strict_mode_config() const;
  [[nodiscard]] ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE release_strict_mode_config();
  ::qdrant::StrictModeConfig* PROTOBUF_NONNULL mutable_strict_mode_config();
  void set_allocated_strict_mode_config(::qdrant::StrictModeConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_strict_mode_config(::qdrant::StrictModeConfig* PROTOBUF_NULLABLE value);
  ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE unsafe_arena_release_strict_mode_config();

  private:
  const ::qdrant::StrictModeConfig& _internal_strict_mode_config() const;
  ::qdrant::StrictModeConfig* PROTOBUF_NONNULL _internal_mutable_strict_mode_config();

  public:
  // optional uint64 timeout = 3;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // map<string, .qdrant.Value> metadata = 10;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& metadata() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL mutable_metadata();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& _internal_metadata() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL _internal_mutable_metadata();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.UpdateCollection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 10,
                                   9, 63,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateCollection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE optimizers_config_;
    ::qdrant::CollectionParamsDiff* PROTOBUF_NULLABLE params_;
    ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE hnsw_config_;
    ::qdrant::VectorsConfigDiff* PROTOBUF_NULLABLE vectors_config_;
    ::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE quantization_config_;
    ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE sparse_vectors_config_;
    ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE strict_mode_config_;
    ::uint64_t timeout_;
    ::google::protobuf::internal::MapField<UpdateCollection_MetadataEntry_DoNotUse, ::std::string, ::qdrant::Value,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        metadata_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateCollection_class_data_;
// -------------------------------------------------------------------

class CreateCollection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CreateCollection) */ {
 public:
  inline CreateCollection() : CreateCollection(nullptr) {}
  ~CreateCollection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateCollection* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateCollection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateCollection(::google::protobuf::internal::ConstantInitialized);

  inline CreateCollection(const CreateCollection& from) : CreateCollection(nullptr, from) {}
  inline CreateCollection(CreateCollection&& from) noexcept
      : CreateCollection(nullptr, ::std::move(from)) {}
  inline CreateCollection& operator=(const CreateCollection& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCollection& operator=(CreateCollection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCollection& default_instance() {
    return *reinterpret_cast<const CreateCollection*>(
        &_CreateCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(CreateCollection& a, CreateCollection& b) { a.Swap(&b); }
  inline void Swap(CreateCollection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCollection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateCollection* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateCollection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateCollection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateCollection& from) { CreateCollection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateCollection* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CreateCollection"; }

  explicit CreateCollection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CreateCollection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CreateCollection& from);
  CreateCollection(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CreateCollection&& from) noexcept
      : CreateCollection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionNameFieldNumber = 1,
    kInitFromCollectionFieldNumber = 13,
    kHnswConfigFieldNumber = 4,
    kWalConfigFieldNumber = 5,
    kOptimizersConfigFieldNumber = 6,
    kVectorsConfigFieldNumber = 10,
    kQuantizationConfigFieldNumber = 14,
    kSparseVectorsConfigFieldNumber = 16,
    kStrictModeConfigFieldNumber = 17,
    kShardNumberFieldNumber = 7,
    kOnDiskPayloadFieldNumber = 8,
    kTimeoutFieldNumber = 9,
    kReplicationFactorFieldNumber = 11,
    kWriteConsistencyFactorFieldNumber = 12,
    kShardingMethodFieldNumber = 15,
    kMetadataFieldNumber = 18,
  };
  // string collection_name = 1;
  void clear_collection_name() ;
  const ::std::string& collection_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_collection_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_collection_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_collection_name();
  void set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_collection_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_collection_name();

  public:
  // optional string init_from_collection = 13;
  bool has_init_from_collection() const;
  void clear_init_from_collection() ;
  const ::std::string& init_from_collection() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_init_from_collection(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_init_from_collection();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_init_from_collection();
  void set_allocated_init_from_collection(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_init_from_collection() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_init_from_collection(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_init_from_collection();

  public:
  // optional .qdrant.HnswConfigDiff hnsw_config = 4;
  bool has_hnsw_config() const;
  void clear_hnsw_config() ;
  const ::qdrant::HnswConfigDiff& hnsw_config() const;
  [[nodiscard]] ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE release_hnsw_config();
  ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL mutable_hnsw_config();
  void set_allocated_hnsw_config(::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_hnsw_config(::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value);
  ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE unsafe_arena_release_hnsw_config();

  private:
  const ::qdrant::HnswConfigDiff& _internal_hnsw_config() const;
  ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL _internal_mutable_hnsw_config();

  public:
  // optional .qdrant.WalConfigDiff wal_config = 5;
  bool has_wal_config() const;
  void clear_wal_config() ;
  const ::qdrant::WalConfigDiff& wal_config() const;
  [[nodiscard]] ::qdrant::WalConfigDiff* PROTOBUF_NULLABLE release_wal_config();
  ::qdrant::WalConfigDiff* PROTOBUF_NONNULL mutable_wal_config();
  void set_allocated_wal_config(::qdrant::WalConfigDiff* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_wal_config(::qdrant::WalConfigDiff* PROTOBUF_NULLABLE value);
  ::qdrant::WalConfigDiff* PROTOBUF_NULLABLE unsafe_arena_release_wal_config();

  private:
  const ::qdrant::WalConfigDiff& _internal_wal_config() const;
  ::qdrant::WalConfigDiff* PROTOBUF_NONNULL _internal_mutable_wal_config();

  public:
  // optional .qdrant.OptimizersConfigDiff optimizers_config = 6;
  bool has_optimizers_config() const;
  void clear_optimizers_config() ;
  const ::qdrant::OptimizersConfigDiff& optimizers_config() const;
  [[nodiscard]] ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE release_optimizers_config();
  ::qdrant::OptimizersConfigDiff* PROTOBUF_NONNULL mutable_optimizers_config();
  void set_allocated_optimizers_config(::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_optimizers_config(::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE value);
  ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE unsafe_arena_release_optimizers_config();

  private:
  const ::qdrant::OptimizersConfigDiff& _internal_optimizers_config() const;
  ::qdrant::OptimizersConfigDiff* PROTOBUF_NONNULL _internal_mutable_optimizers_config();

  public:
  // optional .qdrant.VectorsConfig vectors_config = 10;
  bool has_vectors_config() const;
  void clear_vectors_config() ;
  const ::qdrant::VectorsConfig& vectors_config() const;
  [[nodiscard]] ::qdrant::VectorsConfig* PROTOBUF_NULLABLE release_vectors_config();
  ::qdrant::VectorsConfig* PROTOBUF_NONNULL mutable_vectors_config();
  void set_allocated_vectors_config(::qdrant::VectorsConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vectors_config(::qdrant::VectorsConfig* PROTOBUF_NULLABLE value);
  ::qdrant::VectorsConfig* PROTOBUF_NULLABLE unsafe_arena_release_vectors_config();

  private:
  const ::qdrant::VectorsConfig& _internal_vectors_config() const;
  ::qdrant::VectorsConfig* PROTOBUF_NONNULL _internal_mutable_vectors_config();

  public:
  // optional .qdrant.QuantizationConfig quantization_config = 14;
  bool has_quantization_config() const;
  void clear_quantization_config() ;
  const ::qdrant::QuantizationConfig& quantization_config() const;
  [[nodiscard]] ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE release_quantization_config();
  ::qdrant::QuantizationConfig* PROTOBUF_NONNULL mutable_quantization_config();
  void set_allocated_quantization_config(::qdrant::QuantizationConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_quantization_config(::qdrant::QuantizationConfig* PROTOBUF_NULLABLE value);
  ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE unsafe_arena_release_quantization_config();

  private:
  const ::qdrant::QuantizationConfig& _internal_quantization_config() const;
  ::qdrant::QuantizationConfig* PROTOBUF_NONNULL _internal_mutable_quantization_config();

  public:
  // optional .qdrant.SparseVectorConfig sparse_vectors_config = 16;
  bool has_sparse_vectors_config() const;
  void clear_sparse_vectors_config() ;
  const ::qdrant::SparseVectorConfig& sparse_vectors_config() const;
  [[nodiscard]] ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE release_sparse_vectors_config();
  ::qdrant::SparseVectorConfig* PROTOBUF_NONNULL mutable_sparse_vectors_config();
  void set_allocated_sparse_vectors_config(::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sparse_vectors_config(::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE value);
  ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE unsafe_arena_release_sparse_vectors_config();

  private:
  const ::qdrant::SparseVectorConfig& _internal_sparse_vectors_config() const;
  ::qdrant::SparseVectorConfig* PROTOBUF_NONNULL _internal_mutable_sparse_vectors_config();

  public:
  // optional .qdrant.StrictModeConfig strict_mode_config = 17;
  bool has_strict_mode_config() const;
  void clear_strict_mode_config() ;
  const ::qdrant::StrictModeConfig& strict_mode_config() const;
  [[nodiscard]] ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE release_strict_mode_config();
  ::qdrant::StrictModeConfig* PROTOBUF_NONNULL mutable_strict_mode_config();
  void set_allocated_strict_mode_config(::qdrant::StrictModeConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_strict_mode_config(::qdrant::StrictModeConfig* PROTOBUF_NULLABLE value);
  ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE unsafe_arena_release_strict_mode_config();

  private:
  const ::qdrant::StrictModeConfig& _internal_strict_mode_config() const;
  ::qdrant::StrictModeConfig* PROTOBUF_NONNULL _internal_mutable_strict_mode_config();

  public:
  // optional uint32 shard_number = 7;
  bool has_shard_number() const;
  void clear_shard_number() ;
  ::uint32_t shard_number() const;
  void set_shard_number(::uint32_t value);

  private:
  ::uint32_t _internal_shard_number() const;
  void _internal_set_shard_number(::uint32_t value);

  public:
  // optional bool on_disk_payload = 8;
  bool has_on_disk_payload() const;
  void clear_on_disk_payload() ;
  bool on_disk_payload() const;
  void set_on_disk_payload(bool value);

  private:
  bool _internal_on_disk_payload() const;
  void _internal_set_on_disk_payload(bool value);

  public:
  // optional uint64 timeout = 9;
  bool has_timeout() const;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // optional uint32 replication_factor = 11;
  bool has_replication_factor() const;
  void clear_replication_factor() ;
  ::uint32_t replication_factor() const;
  void set_replication_factor(::uint32_t value);

  private:
  ::uint32_t _internal_replication_factor() const;
  void _internal_set_replication_factor(::uint32_t value);

  public:
  // optional uint32 write_consistency_factor = 12;
  bool has_write_consistency_factor() const;
  void clear_write_consistency_factor() ;
  ::uint32_t write_consistency_factor() const;
  void set_write_consistency_factor(::uint32_t value);

  private:
  ::uint32_t _internal_write_consistency_factor() const;
  void _internal_set_write_consistency_factor(::uint32_t value);

  public:
  // optional .qdrant.ShardingMethod sharding_method = 15;
  bool has_sharding_method() const;
  void clear_sharding_method() ;
  ::qdrant::ShardingMethod sharding_method() const;
  void set_sharding_method(::qdrant::ShardingMethod value);

  private:
  ::qdrant::ShardingMethod _internal_sharding_method() const;
  void _internal_set_sharding_method(::qdrant::ShardingMethod value);

  public:
  // map<string, .qdrant.Value> metadata = 18;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& metadata() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL mutable_metadata();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& _internal_metadata() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL _internal_mutable_metadata();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CreateCollection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 16,
                                   9, 91,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CreateCollection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collection_name_;
    ::google::protobuf::internal::ArenaStringPtr init_from_collection_;
    ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE hnsw_config_;
    ::qdrant::WalConfigDiff* PROTOBUF_NULLABLE wal_config_;
    ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE optimizers_config_;
    ::qdrant::VectorsConfig* PROTOBUF_NULLABLE vectors_config_;
    ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE quantization_config_;
    ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE sparse_vectors_config_;
    ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE strict_mode_config_;
    ::uint32_t shard_number_;
    bool on_disk_payload_;
    ::uint64_t timeout_;
    ::uint32_t replication_factor_;
    ::uint32_t write_consistency_factor_;
    int sharding_method_;
    ::google::protobuf::internal::MapField<CreateCollection_MetadataEntry_DoNotUse, ::std::string, ::qdrant::Value,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        metadata_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CreateCollection_class_data_;
// -------------------------------------------------------------------

class CollectionParams final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CollectionParams) */ {
 public:
  inline CollectionParams() : CollectionParams(nullptr) {}
  ~CollectionParams() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CollectionParams* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CollectionParams));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionParams(::google::protobuf::internal::ConstantInitialized);

  inline CollectionParams(const CollectionParams& from) : CollectionParams(nullptr, from) {}
  inline CollectionParams(CollectionParams&& from) noexcept
      : CollectionParams(nullptr, ::std::move(from)) {}
  inline CollectionParams& operator=(const CollectionParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionParams& operator=(CollectionParams&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionParams& default_instance() {
    return *reinterpret_cast<const CollectionParams*>(
        &_CollectionParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 46;
  friend void swap(CollectionParams& a, CollectionParams& b) { a.Swap(&b); }
  inline void Swap(CollectionParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionParams* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CollectionParams>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionParams& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectionParams& from) { CollectionParams::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CollectionParams* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CollectionParams"; }

  explicit CollectionParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CollectionParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CollectionParams& from);
  CollectionParams(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CollectionParams&& from) noexcept
      : CollectionParams(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVectorsConfigFieldNumber = 5,
    kSparseVectorsConfigFieldNumber = 10,
    kShardNumberFieldNumber = 3,
    kOnDiskPayloadFieldNumber = 4,
    kReplicationFactorFieldNumber = 6,
    kWriteConsistencyFactorFieldNumber = 7,
    kReadFanOutFactorFieldNumber = 8,
    kShardingMethodFieldNumber = 9,
  };
  // optional .qdrant.VectorsConfig vectors_config = 5;
  bool has_vectors_config() const;
  void clear_vectors_config() ;
  const ::qdrant::VectorsConfig& vectors_config() const;
  [[nodiscard]] ::qdrant::VectorsConfig* PROTOBUF_NULLABLE release_vectors_config();
  ::qdrant::VectorsConfig* PROTOBUF_NONNULL mutable_vectors_config();
  void set_allocated_vectors_config(::qdrant::VectorsConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vectors_config(::qdrant::VectorsConfig* PROTOBUF_NULLABLE value);
  ::qdrant::VectorsConfig* PROTOBUF_NULLABLE unsafe_arena_release_vectors_config();

  private:
  const ::qdrant::VectorsConfig& _internal_vectors_config() const;
  ::qdrant::VectorsConfig* PROTOBUF_NONNULL _internal_mutable_vectors_config();

  public:
  // optional .qdrant.SparseVectorConfig sparse_vectors_config = 10;
  bool has_sparse_vectors_config() const;
  void clear_sparse_vectors_config() ;
  const ::qdrant::SparseVectorConfig& sparse_vectors_config() const;
  [[nodiscard]] ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE release_sparse_vectors_config();
  ::qdrant::SparseVectorConfig* PROTOBUF_NONNULL mutable_sparse_vectors_config();
  void set_allocated_sparse_vectors_config(::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sparse_vectors_config(::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE value);
  ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE unsafe_arena_release_sparse_vectors_config();

  private:
  const ::qdrant::SparseVectorConfig& _internal_sparse_vectors_config() const;
  ::qdrant::SparseVectorConfig* PROTOBUF_NONNULL _internal_mutable_sparse_vectors_config();

  public:
  // uint32 shard_number = 3;
  void clear_shard_number() ;
  ::uint32_t shard_number() const;
  void set_shard_number(::uint32_t value);

  private:
  ::uint32_t _internal_shard_number() const;
  void _internal_set_shard_number(::uint32_t value);

  public:
  // bool on_disk_payload = 4;
  void clear_on_disk_payload() ;
  bool on_disk_payload() const;
  void set_on_disk_payload(bool value);

  private:
  bool _internal_on_disk_payload() const;
  void _internal_set_on_disk_payload(bool value);

  public:
  // optional uint32 replication_factor = 6;
  bool has_replication_factor() const;
  void clear_replication_factor() ;
  ::uint32_t replication_factor() const;
  void set_replication_factor(::uint32_t value);

  private:
  ::uint32_t _internal_replication_factor() const;
  void _internal_set_replication_factor(::uint32_t value);

  public:
  // optional uint32 write_consistency_factor = 7;
  bool has_write_consistency_factor() const;
  void clear_write_consistency_factor() ;
  ::uint32_t write_consistency_factor() const;
  void set_write_consistency_factor(::uint32_t value);

  private:
  ::uint32_t _internal_write_consistency_factor() const;
  void _internal_set_write_consistency_factor(::uint32_t value);

  public:
  // optional uint32 read_fan_out_factor = 8;
  bool has_read_fan_out_factor() const;
  void clear_read_fan_out_factor() ;
  ::uint32_t read_fan_out_factor() const;
  void set_read_fan_out_factor(::uint32_t value);

  private:
  ::uint32_t _internal_read_fan_out_factor() const;
  void _internal_set_read_fan_out_factor(::uint32_t value);

  public:
  // optional .qdrant.ShardingMethod sharding_method = 9;
  bool has_sharding_method() const;
  void clear_sharding_method() ;
  ::qdrant::ShardingMethod sharding_method() const;
  void set_sharding_method(::qdrant::ShardingMethod value);

  private:
  ::qdrant::ShardingMethod _internal_sharding_method() const;
  void _internal_set_sharding_method(::qdrant::ShardingMethod value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CollectionParams)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CollectionParams& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::VectorsConfig* PROTOBUF_NULLABLE vectors_config_;
    ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE sparse_vectors_config_;
    ::uint32_t shard_number_;
    bool on_disk_payload_;
    ::uint32_t replication_factor_;
    ::uint32_t write_consistency_factor_;
    ::uint32_t read_fan_out_factor_;
    int sharding_method_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CollectionParams_class_data_;
// -------------------------------------------------------------------

class CollectionConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CollectionConfig) */ {
 public:
  inline CollectionConfig() : CollectionConfig(nullptr) {}
  ~CollectionConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CollectionConfig* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CollectionConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionConfig(::google::protobuf::internal::ConstantInitialized);

  inline CollectionConfig(const CollectionConfig& from) : CollectionConfig(nullptr, from) {}
  inline CollectionConfig(CollectionConfig&& from) noexcept
      : CollectionConfig(nullptr, ::std::move(from)) {}
  inline CollectionConfig& operator=(const CollectionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionConfig& operator=(CollectionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionConfig& default_instance() {
    return *reinterpret_cast<const CollectionConfig*>(
        &_CollectionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 49;
  friend void swap(CollectionConfig& a, CollectionConfig& b) { a.Swap(&b); }
  inline void Swap(CollectionConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CollectionConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectionConfig& from) { CollectionConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CollectionConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CollectionConfig"; }

  explicit CollectionConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CollectionConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CollectionConfig& from);
  CollectionConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CollectionConfig&& from) noexcept
      : CollectionConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kParamsFieldNumber = 1,
    kHnswConfigFieldNumber = 2,
    kOptimizerConfigFieldNumber = 3,
    kWalConfigFieldNumber = 4,
    kQuantizationConfigFieldNumber = 5,
    kStrictModeConfigFieldNumber = 6,
    kMetadataFieldNumber = 7,
  };
  // .qdrant.CollectionParams params = 1;
  bool has_params() const;
  void clear_params() ;
  const ::qdrant::CollectionParams& params() const;
  [[nodiscard]] ::qdrant::CollectionParams* PROTOBUF_NULLABLE release_params();
  ::qdrant::CollectionParams* PROTOBUF_NONNULL mutable_params();
  void set_allocated_params(::qdrant::CollectionParams* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_params(::qdrant::CollectionParams* PROTOBUF_NULLABLE value);
  ::qdrant::CollectionParams* PROTOBUF_NULLABLE unsafe_arena_release_params();

  private:
  const ::qdrant::CollectionParams& _internal_params() const;
  ::qdrant::CollectionParams* PROTOBUF_NONNULL _internal_mutable_params();

  public:
  // .qdrant.HnswConfigDiff hnsw_config = 2;
  bool has_hnsw_config() const;
  void clear_hnsw_config() ;
  const ::qdrant::HnswConfigDiff& hnsw_config() const;
  [[nodiscard]] ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE release_hnsw_config();
  ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL mutable_hnsw_config();
  void set_allocated_hnsw_config(::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_hnsw_config(::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value);
  ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE unsafe_arena_release_hnsw_config();

  private:
  const ::qdrant::HnswConfigDiff& _internal_hnsw_config() const;
  ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL _internal_mutable_hnsw_config();

  public:
  // .qdrant.OptimizersConfigDiff optimizer_config = 3;
  bool has_optimizer_config() const;
  void clear_optimizer_config() ;
  const ::qdrant::OptimizersConfigDiff& optimizer_config() const;
  [[nodiscard]] ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE release_optimizer_config();
  ::qdrant::OptimizersConfigDiff* PROTOBUF_NONNULL mutable_optimizer_config();
  void set_allocated_optimizer_config(::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_optimizer_config(::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE value);
  ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE unsafe_arena_release_optimizer_config();

  private:
  const ::qdrant::OptimizersConfigDiff& _internal_optimizer_config() const;
  ::qdrant::OptimizersConfigDiff* PROTOBUF_NONNULL _internal_mutable_optimizer_config();

  public:
  // .qdrant.WalConfigDiff wal_config = 4;
  bool has_wal_config() const;
  void clear_wal_config() ;
  const ::qdrant::WalConfigDiff& wal_config() const;
  [[nodiscard]] ::qdrant::WalConfigDiff* PROTOBUF_NULLABLE release_wal_config();
  ::qdrant::WalConfigDiff* PROTOBUF_NONNULL mutable_wal_config();
  void set_allocated_wal_config(::qdrant::WalConfigDiff* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_wal_config(::qdrant::WalConfigDiff* PROTOBUF_NULLABLE value);
  ::qdrant::WalConfigDiff* PROTOBUF_NULLABLE unsafe_arena_release_wal_config();

  private:
  const ::qdrant::WalConfigDiff& _internal_wal_config() const;
  ::qdrant::WalConfigDiff* PROTOBUF_NONNULL _internal_mutable_wal_config();

  public:
  // optional .qdrant.QuantizationConfig quantization_config = 5;
  bool has_quantization_config() const;
  void clear_quantization_config() ;
  const ::qdrant::QuantizationConfig& quantization_config() const;
  [[nodiscard]] ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE release_quantization_config();
  ::qdrant::QuantizationConfig* PROTOBUF_NONNULL mutable_quantization_config();
  void set_allocated_quantization_config(::qdrant::QuantizationConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_quantization_config(::qdrant::QuantizationConfig* PROTOBUF_NULLABLE value);
  ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE unsafe_arena_release_quantization_config();

  private:
  const ::qdrant::QuantizationConfig& _internal_quantization_config() const;
  ::qdrant::QuantizationConfig* PROTOBUF_NONNULL _internal_mutable_quantization_config();

  public:
  // optional .qdrant.StrictModeConfig strict_mode_config = 6;
  bool has_strict_mode_config() const;
  void clear_strict_mode_config() ;
  const ::qdrant::StrictModeConfig& strict_mode_config() const;
  [[nodiscard]] ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE release_strict_mode_config();
  ::qdrant::StrictModeConfig* PROTOBUF_NONNULL mutable_strict_mode_config();
  void set_allocated_strict_mode_config(::qdrant::StrictModeConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_strict_mode_config(::qdrant::StrictModeConfig* PROTOBUF_NULLABLE value);
  ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE unsafe_arena_release_strict_mode_config();

  private:
  const ::qdrant::StrictModeConfig& _internal_strict_mode_config() const;
  ::qdrant::StrictModeConfig* PROTOBUF_NONNULL _internal_mutable_strict_mode_config();

  public:
  // map<string, .qdrant.Value> metadata = 7;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& metadata() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL mutable_metadata();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::Value>& _internal_metadata() const;
  ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL _internal_mutable_metadata();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CollectionConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   8, 40,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CollectionConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::CollectionParams* PROTOBUF_NULLABLE params_;
    ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE hnsw_config_;
    ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE optimizer_config_;
    ::qdrant::WalConfigDiff* PROTOBUF_NULLABLE wal_config_;
    ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE quantization_config_;
    ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE strict_mode_config_;
    ::google::protobuf::internal::MapField<CollectionConfig_MetadataEntry_DoNotUse, ::std::string, ::qdrant::Value,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        metadata_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CollectionConfig_class_data_;
// -------------------------------------------------------------------

class CollectionInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.CollectionInfo) */ {
 public:
  inline CollectionInfo() : CollectionInfo(nullptr) {}
  ~CollectionInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CollectionInfo* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CollectionInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionInfo(::google::protobuf::internal::ConstantInitialized);

  inline CollectionInfo(const CollectionInfo& from) : CollectionInfo(nullptr, from) {}
  inline CollectionInfo(CollectionInfo&& from) noexcept
      : CollectionInfo(nullptr, ::std::move(from)) {}
  inline CollectionInfo& operator=(const CollectionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionInfo& operator=(CollectionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionInfo& default_instance() {
    return *reinterpret_cast<const CollectionInfo*>(
        &_CollectionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 64;
  friend void swap(CollectionInfo& a, CollectionInfo& b) { a.Swap(&b); }
  inline void Swap(CollectionInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CollectionInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectionInfo& from) { CollectionInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CollectionInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.CollectionInfo"; }

  explicit CollectionInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CollectionInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CollectionInfo& from);
  CollectionInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CollectionInfo&& from) noexcept
      : CollectionInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOptimizerStatusFieldNumber = 2,
    kConfigFieldNumber = 7,
    kSegmentsCountFieldNumber = 4,
    kPointsCountFieldNumber = 9,
    kIndexedVectorsCountFieldNumber = 10,
    kStatusFieldNumber = 1,
    kPayloadSchemaFieldNumber = 8,
  };
  // .qdrant.OptimizerStatus optimizer_status = 2;
  bool has_optimizer_status() const;
  void clear_optimizer_status() ;
  const ::qdrant::OptimizerStatus& optimizer_status() const;
  [[nodiscard]] ::qdrant::OptimizerStatus* PROTOBUF_NULLABLE release_optimizer_status();
  ::qdrant::OptimizerStatus* PROTOBUF_NONNULL mutable_optimizer_status();
  void set_allocated_optimizer_status(::qdrant::OptimizerStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_optimizer_status(::qdrant::OptimizerStatus* PROTOBUF_NULLABLE value);
  ::qdrant::OptimizerStatus* PROTOBUF_NULLABLE unsafe_arena_release_optimizer_status();

  private:
  const ::qdrant::OptimizerStatus& _internal_optimizer_status() const;
  ::qdrant::OptimizerStatus* PROTOBUF_NONNULL _internal_mutable_optimizer_status();

  public:
  // .qdrant.CollectionConfig config = 7;
  bool has_config() const;
  void clear_config() ;
  const ::qdrant::CollectionConfig& config() const;
  [[nodiscard]] ::qdrant::CollectionConfig* PROTOBUF_NULLABLE release_config();
  ::qdrant::CollectionConfig* PROTOBUF_NONNULL mutable_config();
  void set_allocated_config(::qdrant::CollectionConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_config(::qdrant::CollectionConfig* PROTOBUF_NULLABLE value);
  ::qdrant::CollectionConfig* PROTOBUF_NULLABLE unsafe_arena_release_config();

  private:
  const ::qdrant::CollectionConfig& _internal_config() const;
  ::qdrant::CollectionConfig* PROTOBUF_NONNULL _internal_mutable_config();

  public:
  // uint64 segments_count = 4;
  void clear_segments_count() ;
  ::uint64_t segments_count() const;
  void set_segments_count(::uint64_t value);

  private:
  ::uint64_t _internal_segments_count() const;
  void _internal_set_segments_count(::uint64_t value);

  public:
  // optional uint64 points_count = 9;
  bool has_points_count() const;
  void clear_points_count() ;
  ::uint64_t points_count() const;
  void set_points_count(::uint64_t value);

  private:
  ::uint64_t _internal_points_count() const;
  void _internal_set_points_count(::uint64_t value);

  public:
  // optional uint64 indexed_vectors_count = 10;
  bool has_indexed_vectors_count() const;
  void clear_indexed_vectors_count() ;
  ::uint64_t indexed_vectors_count() const;
  void set_indexed_vectors_count(::uint64_t value);

  private:
  ::uint64_t _internal_indexed_vectors_count() const;
  void _internal_set_indexed_vectors_count(::uint64_t value);

  public:
  // .qdrant.CollectionStatus status = 1;
  void clear_status() ;
  ::qdrant::CollectionStatus status() const;
  void set_status(::qdrant::CollectionStatus value);

  private:
  ::qdrant::CollectionStatus _internal_status() const;
  void _internal_set_status(::qdrant::CollectionStatus value);

  public:
  // map<string, .qdrant.PayloadSchemaInfo> payload_schema = 8;
  int payload_schema_size() const;
  private:
  int _internal_payload_schema_size() const;

  public:
  void clear_payload_schema() ;
  const ::google::protobuf::Map<::std::string, ::qdrant::PayloadSchemaInfo>& payload_schema() const;
  ::google::protobuf::Map<::std::string, ::qdrant::PayloadSchemaInfo>* PROTOBUF_NONNULL mutable_payload_schema();

  private:
  const ::google::protobuf::Map<::std::string, ::qdrant::PayloadSchemaInfo>& _internal_payload_schema() const;
  ::google::protobuf::Map<::std::string, ::qdrant::PayloadSchemaInfo>* PROTOBUF_NONNULL _internal_mutable_payload_schema();

  public:
  // @@protoc_insertion_point(class_scope:qdrant.CollectionInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 7,
                                   4, 44,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CollectionInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::OptimizerStatus* PROTOBUF_NULLABLE optimizer_status_;
    ::qdrant::CollectionConfig* PROTOBUF_NULLABLE config_;
    ::uint64_t segments_count_;
    ::uint64_t points_count_;
    ::uint64_t indexed_vectors_count_;
    int status_;
    ::google::protobuf::internal::MapField<CollectionInfo_PayloadSchemaEntry_DoNotUse, ::std::string, ::qdrant::PayloadSchemaInfo,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        payload_schema_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CollectionInfo_class_data_;
// -------------------------------------------------------------------

class GetCollectionInfoResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:qdrant.GetCollectionInfoResponse) */ {
 public:
  inline GetCollectionInfoResponse() : GetCollectionInfoResponse(nullptr) {}
  ~GetCollectionInfoResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetCollectionInfoResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetCollectionInfoResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetCollectionInfoResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetCollectionInfoResponse(const GetCollectionInfoResponse& from) : GetCollectionInfoResponse(nullptr, from) {}
  inline GetCollectionInfoResponse(GetCollectionInfoResponse&& from) noexcept
      : GetCollectionInfoResponse(nullptr, ::std::move(from)) {}
  inline GetCollectionInfoResponse& operator=(const GetCollectionInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCollectionInfoResponse& operator=(GetCollectionInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCollectionInfoResponse& default_instance() {
    return *reinterpret_cast<const GetCollectionInfoResponse*>(
        &_GetCollectionInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(GetCollectionInfoResponse& a, GetCollectionInfoResponse& b) { a.Swap(&b); }
  inline void Swap(GetCollectionInfoResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCollectionInfoResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCollectionInfoResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetCollectionInfoResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetCollectionInfoResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetCollectionInfoResponse& from) { GetCollectionInfoResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetCollectionInfoResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "qdrant.GetCollectionInfoResponse"; }

  explicit GetCollectionInfoResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetCollectionInfoResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetCollectionInfoResponse& from);
  GetCollectionInfoResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetCollectionInfoResponse&& from) noexcept
      : GetCollectionInfoResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // .qdrant.CollectionInfo result = 1;
  bool has_result() const;
  void clear_result() ;
  const ::qdrant::CollectionInfo& result() const;
  [[nodiscard]] ::qdrant::CollectionInfo* PROTOBUF_NULLABLE release_result();
  ::qdrant::CollectionInfo* PROTOBUF_NONNULL mutable_result();
  void set_allocated_result(::qdrant::CollectionInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_result(::qdrant::CollectionInfo* PROTOBUF_NULLABLE value);
  ::qdrant::CollectionInfo* PROTOBUF_NULLABLE unsafe_arena_release_result();

  private:
  const ::qdrant::CollectionInfo& _internal_result() const;
  ::qdrant::CollectionInfo* PROTOBUF_NONNULL _internal_mutable_result();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:qdrant.GetCollectionInfoResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetCollectionInfoResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::qdrant::CollectionInfo* PROTOBUF_NULLABLE result_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collections_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetCollectionInfoResponse_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// VectorParams

// uint64 size = 1;
inline void VectorParams::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint64_t VectorParams::size() const {
  // @@protoc_insertion_point(field_get:qdrant.VectorParams.size)
  return _internal_size();
}
inline void VectorParams::set_size(::uint64_t value) {
  _internal_set_size(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.VectorParams.size)
}
inline ::uint64_t VectorParams::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_;
}
inline void VectorParams::_internal_set_size(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// .qdrant.Distance distance = 2;
inline void VectorParams::clear_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::qdrant::Distance VectorParams::distance() const {
  // @@protoc_insertion_point(field_get:qdrant.VectorParams.distance)
  return _internal_distance();
}
inline void VectorParams::set_distance(::qdrant::Distance value) {
  _internal_set_distance(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.VectorParams.distance)
}
inline ::qdrant::Distance VectorParams::_internal_distance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::Distance>(_impl_.distance_);
}
inline void VectorParams::_internal_set_distance(::qdrant::Distance value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_ = value;
}

// optional .qdrant.HnswConfigDiff hnsw_config = 3;
inline bool VectorParams::has_hnsw_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.hnsw_config_ != nullptr);
  return value;
}
inline void VectorParams::clear_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hnsw_config_ != nullptr) _impl_.hnsw_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::HnswConfigDiff& VectorParams::_internal_hnsw_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::HnswConfigDiff* p = _impl_.hnsw_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::HnswConfigDiff&>(::qdrant::_HnswConfigDiff_default_instance_);
}
inline const ::qdrant::HnswConfigDiff& VectorParams::hnsw_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorParams.hnsw_config)
  return _internal_hnsw_config();
}
inline void VectorParams::unsafe_arena_set_allocated_hnsw_config(
    ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hnsw_config_);
  }
  _impl_.hnsw_config_ = reinterpret_cast<::qdrant::HnswConfigDiff*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorParams.hnsw_config)
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE VectorParams::release_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::HnswConfigDiff* released = _impl_.hnsw_config_;
  _impl_.hnsw_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE VectorParams::unsafe_arena_release_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.VectorParams.hnsw_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::HnswConfigDiff* temp = _impl_.hnsw_config_;
  _impl_.hnsw_config_ = nullptr;
  return temp;
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL VectorParams::_internal_mutable_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hnsw_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::HnswConfigDiff>(GetArena());
    _impl_.hnsw_config_ = reinterpret_cast<::qdrant::HnswConfigDiff*>(p);
  }
  return _impl_.hnsw_config_;
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL VectorParams::mutable_hnsw_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::HnswConfigDiff* _msg = _internal_mutable_hnsw_config();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorParams.hnsw_config)
  return _msg;
}
inline void VectorParams::set_allocated_hnsw_config(::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hnsw_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.hnsw_config_ = reinterpret_cast<::qdrant::HnswConfigDiff*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.VectorParams.hnsw_config)
}

// optional .qdrant.QuantizationConfig quantization_config = 4;
inline bool VectorParams::has_quantization_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.quantization_config_ != nullptr);
  return value;
}
inline void VectorParams::clear_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.quantization_config_ != nullptr) _impl_.quantization_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::QuantizationConfig& VectorParams::_internal_quantization_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::QuantizationConfig* p = _impl_.quantization_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::QuantizationConfig&>(::qdrant::_QuantizationConfig_default_instance_);
}
inline const ::qdrant::QuantizationConfig& VectorParams::quantization_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorParams.quantization_config)
  return _internal_quantization_config();
}
inline void VectorParams::unsafe_arena_set_allocated_quantization_config(
    ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quantization_config_);
  }
  _impl_.quantization_config_ = reinterpret_cast<::qdrant::QuantizationConfig*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorParams.quantization_config)
}
inline ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE VectorParams::release_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::QuantizationConfig* released = _impl_.quantization_config_;
  _impl_.quantization_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE VectorParams::unsafe_arena_release_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.VectorParams.quantization_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::QuantizationConfig* temp = _impl_.quantization_config_;
  _impl_.quantization_config_ = nullptr;
  return temp;
}
inline ::qdrant::QuantizationConfig* PROTOBUF_NONNULL VectorParams::_internal_mutable_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.quantization_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::QuantizationConfig>(GetArena());
    _impl_.quantization_config_ = reinterpret_cast<::qdrant::QuantizationConfig*>(p);
  }
  return _impl_.quantization_config_;
}
inline ::qdrant::QuantizationConfig* PROTOBUF_NONNULL VectorParams::mutable_quantization_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::QuantizationConfig* _msg = _internal_mutable_quantization_config();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorParams.quantization_config)
  return _msg;
}
inline void VectorParams::set_allocated_quantization_config(::qdrant::QuantizationConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quantization_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.quantization_config_ = reinterpret_cast<::qdrant::QuantizationConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.VectorParams.quantization_config)
}

// optional bool on_disk = 5;
inline bool VectorParams::has_on_disk() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void VectorParams::clear_on_disk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool VectorParams::on_disk() const {
  // @@protoc_insertion_point(field_get:qdrant.VectorParams.on_disk)
  return _internal_on_disk();
}
inline void VectorParams::set_on_disk(bool value) {
  _internal_set_on_disk(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.VectorParams.on_disk)
}
inline bool VectorParams::_internal_on_disk() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_disk_;
}
inline void VectorParams::_internal_set_on_disk(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = value;
}

// optional .qdrant.Datatype datatype = 6;
inline bool VectorParams::has_datatype() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  return value;
}
inline void VectorParams::clear_datatype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.datatype_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline ::qdrant::Datatype VectorParams::datatype() const {
  // @@protoc_insertion_point(field_get:qdrant.VectorParams.datatype)
  return _internal_datatype();
}
inline void VectorParams::set_datatype(::qdrant::Datatype value) {
  _internal_set_datatype(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:qdrant.VectorParams.datatype)
}
inline ::qdrant::Datatype VectorParams::_internal_datatype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::Datatype>(_impl_.datatype_);
}
inline void VectorParams::_internal_set_datatype(::qdrant::Datatype value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.datatype_ = value;
}

// optional .qdrant.MultiVectorConfig multivector_config = 7;
inline bool VectorParams::has_multivector_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.multivector_config_ != nullptr);
  return value;
}
inline void VectorParams::clear_multivector_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.multivector_config_ != nullptr) _impl_.multivector_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::MultiVectorConfig& VectorParams::_internal_multivector_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::MultiVectorConfig* p = _impl_.multivector_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::MultiVectorConfig&>(::qdrant::_MultiVectorConfig_default_instance_);
}
inline const ::qdrant::MultiVectorConfig& VectorParams::multivector_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorParams.multivector_config)
  return _internal_multivector_config();
}
inline void VectorParams::unsafe_arena_set_allocated_multivector_config(
    ::qdrant::MultiVectorConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.multivector_config_);
  }
  _impl_.multivector_config_ = reinterpret_cast<::qdrant::MultiVectorConfig*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorParams.multivector_config)
}
inline ::qdrant::MultiVectorConfig* PROTOBUF_NULLABLE VectorParams::release_multivector_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::MultiVectorConfig* released = _impl_.multivector_config_;
  _impl_.multivector_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::MultiVectorConfig* PROTOBUF_NULLABLE VectorParams::unsafe_arena_release_multivector_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.VectorParams.multivector_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::MultiVectorConfig* temp = _impl_.multivector_config_;
  _impl_.multivector_config_ = nullptr;
  return temp;
}
inline ::qdrant::MultiVectorConfig* PROTOBUF_NONNULL VectorParams::_internal_mutable_multivector_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.multivector_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::MultiVectorConfig>(GetArena());
    _impl_.multivector_config_ = reinterpret_cast<::qdrant::MultiVectorConfig*>(p);
  }
  return _impl_.multivector_config_;
}
inline ::qdrant::MultiVectorConfig* PROTOBUF_NONNULL VectorParams::mutable_multivector_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::MultiVectorConfig* _msg = _internal_mutable_multivector_config();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorParams.multivector_config)
  return _msg;
}
inline void VectorParams::set_allocated_multivector_config(::qdrant::MultiVectorConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.multivector_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.multivector_config_ = reinterpret_cast<::qdrant::MultiVectorConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.VectorParams.multivector_config)
}

// -------------------------------------------------------------------

// VectorParamsDiff

// optional .qdrant.HnswConfigDiff hnsw_config = 1;
inline bool VectorParamsDiff::has_hnsw_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.hnsw_config_ != nullptr);
  return value;
}
inline void VectorParamsDiff::clear_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hnsw_config_ != nullptr) _impl_.hnsw_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::HnswConfigDiff& VectorParamsDiff::_internal_hnsw_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::HnswConfigDiff* p = _impl_.hnsw_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::HnswConfigDiff&>(::qdrant::_HnswConfigDiff_default_instance_);
}
inline const ::qdrant::HnswConfigDiff& VectorParamsDiff::hnsw_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorParamsDiff.hnsw_config)
  return _internal_hnsw_config();
}
inline void VectorParamsDiff::unsafe_arena_set_allocated_hnsw_config(
    ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hnsw_config_);
  }
  _impl_.hnsw_config_ = reinterpret_cast<::qdrant::HnswConfigDiff*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorParamsDiff.hnsw_config)
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE VectorParamsDiff::release_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::HnswConfigDiff* released = _impl_.hnsw_config_;
  _impl_.hnsw_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE VectorParamsDiff::unsafe_arena_release_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.VectorParamsDiff.hnsw_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::HnswConfigDiff* temp = _impl_.hnsw_config_;
  _impl_.hnsw_config_ = nullptr;
  return temp;
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL VectorParamsDiff::_internal_mutable_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hnsw_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::HnswConfigDiff>(GetArena());
    _impl_.hnsw_config_ = reinterpret_cast<::qdrant::HnswConfigDiff*>(p);
  }
  return _impl_.hnsw_config_;
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL VectorParamsDiff::mutable_hnsw_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::HnswConfigDiff* _msg = _internal_mutable_hnsw_config();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorParamsDiff.hnsw_config)
  return _msg;
}
inline void VectorParamsDiff::set_allocated_hnsw_config(::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hnsw_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.hnsw_config_ = reinterpret_cast<::qdrant::HnswConfigDiff*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.VectorParamsDiff.hnsw_config)
}

// optional .qdrant.QuantizationConfigDiff quantization_config = 2;
inline bool VectorParamsDiff::has_quantization_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.quantization_config_ != nullptr);
  return value;
}
inline void VectorParamsDiff::clear_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.quantization_config_ != nullptr) _impl_.quantization_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::QuantizationConfigDiff& VectorParamsDiff::_internal_quantization_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::QuantizationConfigDiff* p = _impl_.quantization_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::QuantizationConfigDiff&>(::qdrant::_QuantizationConfigDiff_default_instance_);
}
inline const ::qdrant::QuantizationConfigDiff& VectorParamsDiff::quantization_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorParamsDiff.quantization_config)
  return _internal_quantization_config();
}
inline void VectorParamsDiff::unsafe_arena_set_allocated_quantization_config(
    ::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quantization_config_);
  }
  _impl_.quantization_config_ = reinterpret_cast<::qdrant::QuantizationConfigDiff*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorParamsDiff.quantization_config)
}
inline ::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE VectorParamsDiff::release_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::QuantizationConfigDiff* released = _impl_.quantization_config_;
  _impl_.quantization_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE VectorParamsDiff::unsafe_arena_release_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.VectorParamsDiff.quantization_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::QuantizationConfigDiff* temp = _impl_.quantization_config_;
  _impl_.quantization_config_ = nullptr;
  return temp;
}
inline ::qdrant::QuantizationConfigDiff* PROTOBUF_NONNULL VectorParamsDiff::_internal_mutable_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.quantization_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::QuantizationConfigDiff>(GetArena());
    _impl_.quantization_config_ = reinterpret_cast<::qdrant::QuantizationConfigDiff*>(p);
  }
  return _impl_.quantization_config_;
}
inline ::qdrant::QuantizationConfigDiff* PROTOBUF_NONNULL VectorParamsDiff::mutable_quantization_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::QuantizationConfigDiff* _msg = _internal_mutable_quantization_config();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorParamsDiff.quantization_config)
  return _msg;
}
inline void VectorParamsDiff::set_allocated_quantization_config(::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quantization_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.quantization_config_ = reinterpret_cast<::qdrant::QuantizationConfigDiff*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.VectorParamsDiff.quantization_config)
}

// optional bool on_disk = 3;
inline bool VectorParamsDiff::has_on_disk() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void VectorParamsDiff::clear_on_disk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline bool VectorParamsDiff::on_disk() const {
  // @@protoc_insertion_point(field_get:qdrant.VectorParamsDiff.on_disk)
  return _internal_on_disk();
}
inline void VectorParamsDiff::set_on_disk(bool value) {
  _internal_set_on_disk(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.VectorParamsDiff.on_disk)
}
inline bool VectorParamsDiff::_internal_on_disk() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_disk_;
}
inline void VectorParamsDiff::_internal_set_on_disk(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// VectorParamsMap

// map<string, .qdrant.VectorParams> map = 1;
inline int VectorParamsMap::_internal_map_size() const {
  return _internal_map().size();
}
inline int VectorParamsMap::map_size() const {
  return _internal_map_size();
}
inline void VectorParamsMap::clear_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.map_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::VectorParams>& VectorParamsMap::_internal_map() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.map_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::VectorParams>& VectorParamsMap::map() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.VectorParamsMap.map)
  return _internal_map();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::VectorParams>* PROTOBUF_NONNULL VectorParamsMap::_internal_mutable_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.map_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::VectorParams>* PROTOBUF_NONNULL VectorParamsMap::mutable_map()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.VectorParamsMap.map)
  return _internal_mutable_map();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// VectorParamsDiffMap

// map<string, .qdrant.VectorParamsDiff> map = 1;
inline int VectorParamsDiffMap::_internal_map_size() const {
  return _internal_map().size();
}
inline int VectorParamsDiffMap::map_size() const {
  return _internal_map_size();
}
inline void VectorParamsDiffMap::clear_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.map_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::VectorParamsDiff>& VectorParamsDiffMap::_internal_map() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.map_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::VectorParamsDiff>& VectorParamsDiffMap::map() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.VectorParamsDiffMap.map)
  return _internal_map();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::VectorParamsDiff>* PROTOBUF_NONNULL VectorParamsDiffMap::_internal_mutable_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.map_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::VectorParamsDiff>* PROTOBUF_NONNULL VectorParamsDiffMap::mutable_map()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.VectorParamsDiffMap.map)
  return _internal_mutable_map();
}

// -------------------------------------------------------------------

// VectorsConfig

// .qdrant.VectorParams params = 1;
inline bool VectorsConfig::has_params() const {
  return config_case() == kParams;
}
inline bool VectorsConfig::_internal_has_params() const {
  return config_case() == kParams;
}
inline void VectorsConfig::set_has_params() {
  _impl_._oneof_case_[0] = kParams;
}
inline void VectorsConfig::clear_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (config_case() == kParams) {
    if (GetArena() == nullptr) {
      delete _impl_.config_.params_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.config_.params_);
    }
    clear_has_config();
  }
}
inline ::qdrant::VectorParams* PROTOBUF_NULLABLE VectorsConfig::release_params() {
  // @@protoc_insertion_point(field_release:qdrant.VectorsConfig.params)
  if (config_case() == kParams) {
    clear_has_config();
    auto* temp = _impl_.config_.params_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::VectorParams& VectorsConfig::_internal_params() const {
  return config_case() == kParams ? static_cast<const ::qdrant::VectorParams&>(*_impl_.config_.params_)
                     : reinterpret_cast<const ::qdrant::VectorParams&>(::qdrant::_VectorParams_default_instance_);
}
inline const ::qdrant::VectorParams& VectorsConfig::params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorsConfig.params)
  return _internal_params();
}
inline ::qdrant::VectorParams* PROTOBUF_NULLABLE VectorsConfig::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorsConfig.params)
  if (config_case() == kParams) {
    clear_has_config();
    auto* temp = _impl_.config_.params_;
    _impl_.config_.params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorsConfig::unsafe_arena_set_allocated_params(
    ::qdrant::VectorParams* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_config();
  if (value) {
    set_has_params();
    _impl_.config_.params_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorsConfig.params)
}
inline ::qdrant::VectorParams* PROTOBUF_NONNULL VectorsConfig::_internal_mutable_params() {
  if (config_case() != kParams) {
    clear_config();
    set_has_params();
    _impl_.config_.params_ = 
        ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorParams>(GetArena());
  }
  return _impl_.config_.params_;
}
inline ::qdrant::VectorParams* PROTOBUF_NONNULL VectorsConfig::mutable_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::VectorParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorsConfig.params)
  return _msg;
}

// .qdrant.VectorParamsMap params_map = 2;
inline bool VectorsConfig::has_params_map() const {
  return config_case() == kParamsMap;
}
inline bool VectorsConfig::_internal_has_params_map() const {
  return config_case() == kParamsMap;
}
inline void VectorsConfig::set_has_params_map() {
  _impl_._oneof_case_[0] = kParamsMap;
}
inline void VectorsConfig::clear_params_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (config_case() == kParamsMap) {
    if (GetArena() == nullptr) {
      delete _impl_.config_.params_map_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.config_.params_map_);
    }
    clear_has_config();
  }
}
inline ::qdrant::VectorParamsMap* PROTOBUF_NULLABLE VectorsConfig::release_params_map() {
  // @@protoc_insertion_point(field_release:qdrant.VectorsConfig.params_map)
  if (config_case() == kParamsMap) {
    clear_has_config();
    auto* temp = _impl_.config_.params_map_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.params_map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::VectorParamsMap& VectorsConfig::_internal_params_map() const {
  return config_case() == kParamsMap ? static_cast<const ::qdrant::VectorParamsMap&>(*_impl_.config_.params_map_)
                     : reinterpret_cast<const ::qdrant::VectorParamsMap&>(::qdrant::_VectorParamsMap_default_instance_);
}
inline const ::qdrant::VectorParamsMap& VectorsConfig::params_map() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorsConfig.params_map)
  return _internal_params_map();
}
inline ::qdrant::VectorParamsMap* PROTOBUF_NULLABLE VectorsConfig::unsafe_arena_release_params_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorsConfig.params_map)
  if (config_case() == kParamsMap) {
    clear_has_config();
    auto* temp = _impl_.config_.params_map_;
    _impl_.config_.params_map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorsConfig::unsafe_arena_set_allocated_params_map(
    ::qdrant::VectorParamsMap* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_config();
  if (value) {
    set_has_params_map();
    _impl_.config_.params_map_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorsConfig.params_map)
}
inline ::qdrant::VectorParamsMap* PROTOBUF_NONNULL VectorsConfig::_internal_mutable_params_map() {
  if (config_case() != kParamsMap) {
    clear_config();
    set_has_params_map();
    _impl_.config_.params_map_ = 
        ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorParamsMap>(GetArena());
  }
  return _impl_.config_.params_map_;
}
inline ::qdrant::VectorParamsMap* PROTOBUF_NONNULL VectorsConfig::mutable_params_map()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::VectorParamsMap* _msg = _internal_mutable_params_map();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorsConfig.params_map)
  return _msg;
}

inline bool VectorsConfig::has_config() const {
  return config_case() != CONFIG_NOT_SET;
}
inline void VectorsConfig::clear_has_config() {
  _impl_._oneof_case_[0] = CONFIG_NOT_SET;
}
inline VectorsConfig::ConfigCase VectorsConfig::config_case() const {
  return VectorsConfig::ConfigCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VectorsConfigDiff

// .qdrant.VectorParamsDiff params = 1;
inline bool VectorsConfigDiff::has_params() const {
  return config_case() == kParams;
}
inline bool VectorsConfigDiff::_internal_has_params() const {
  return config_case() == kParams;
}
inline void VectorsConfigDiff::set_has_params() {
  _impl_._oneof_case_[0] = kParams;
}
inline void VectorsConfigDiff::clear_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (config_case() == kParams) {
    if (GetArena() == nullptr) {
      delete _impl_.config_.params_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.config_.params_);
    }
    clear_has_config();
  }
}
inline ::qdrant::VectorParamsDiff* PROTOBUF_NULLABLE VectorsConfigDiff::release_params() {
  // @@protoc_insertion_point(field_release:qdrant.VectorsConfigDiff.params)
  if (config_case() == kParams) {
    clear_has_config();
    auto* temp = _impl_.config_.params_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::VectorParamsDiff& VectorsConfigDiff::_internal_params() const {
  return config_case() == kParams ? static_cast<const ::qdrant::VectorParamsDiff&>(*_impl_.config_.params_)
                     : reinterpret_cast<const ::qdrant::VectorParamsDiff&>(::qdrant::_VectorParamsDiff_default_instance_);
}
inline const ::qdrant::VectorParamsDiff& VectorsConfigDiff::params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorsConfigDiff.params)
  return _internal_params();
}
inline ::qdrant::VectorParamsDiff* PROTOBUF_NULLABLE VectorsConfigDiff::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorsConfigDiff.params)
  if (config_case() == kParams) {
    clear_has_config();
    auto* temp = _impl_.config_.params_;
    _impl_.config_.params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorsConfigDiff::unsafe_arena_set_allocated_params(
    ::qdrant::VectorParamsDiff* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_config();
  if (value) {
    set_has_params();
    _impl_.config_.params_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorsConfigDiff.params)
}
inline ::qdrant::VectorParamsDiff* PROTOBUF_NONNULL VectorsConfigDiff::_internal_mutable_params() {
  if (config_case() != kParams) {
    clear_config();
    set_has_params();
    _impl_.config_.params_ = 
        ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorParamsDiff>(GetArena());
  }
  return _impl_.config_.params_;
}
inline ::qdrant::VectorParamsDiff* PROTOBUF_NONNULL VectorsConfigDiff::mutable_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::VectorParamsDiff* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorsConfigDiff.params)
  return _msg;
}

// .qdrant.VectorParamsDiffMap params_map = 2;
inline bool VectorsConfigDiff::has_params_map() const {
  return config_case() == kParamsMap;
}
inline bool VectorsConfigDiff::_internal_has_params_map() const {
  return config_case() == kParamsMap;
}
inline void VectorsConfigDiff::set_has_params_map() {
  _impl_._oneof_case_[0] = kParamsMap;
}
inline void VectorsConfigDiff::clear_params_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (config_case() == kParamsMap) {
    if (GetArena() == nullptr) {
      delete _impl_.config_.params_map_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.config_.params_map_);
    }
    clear_has_config();
  }
}
inline ::qdrant::VectorParamsDiffMap* PROTOBUF_NULLABLE VectorsConfigDiff::release_params_map() {
  // @@protoc_insertion_point(field_release:qdrant.VectorsConfigDiff.params_map)
  if (config_case() == kParamsMap) {
    clear_has_config();
    auto* temp = _impl_.config_.params_map_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.params_map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::VectorParamsDiffMap& VectorsConfigDiff::_internal_params_map() const {
  return config_case() == kParamsMap ? static_cast<const ::qdrant::VectorParamsDiffMap&>(*_impl_.config_.params_map_)
                     : reinterpret_cast<const ::qdrant::VectorParamsDiffMap&>(::qdrant::_VectorParamsDiffMap_default_instance_);
}
inline const ::qdrant::VectorParamsDiffMap& VectorsConfigDiff::params_map() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.VectorsConfigDiff.params_map)
  return _internal_params_map();
}
inline ::qdrant::VectorParamsDiffMap* PROTOBUF_NULLABLE VectorsConfigDiff::unsafe_arena_release_params_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.VectorsConfigDiff.params_map)
  if (config_case() == kParamsMap) {
    clear_has_config();
    auto* temp = _impl_.config_.params_map_;
    _impl_.config_.params_map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorsConfigDiff::unsafe_arena_set_allocated_params_map(
    ::qdrant::VectorParamsDiffMap* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_config();
  if (value) {
    set_has_params_map();
    _impl_.config_.params_map_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.VectorsConfigDiff.params_map)
}
inline ::qdrant::VectorParamsDiffMap* PROTOBUF_NONNULL VectorsConfigDiff::_internal_mutable_params_map() {
  if (config_case() != kParamsMap) {
    clear_config();
    set_has_params_map();
    _impl_.config_.params_map_ = 
        ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorParamsDiffMap>(GetArena());
  }
  return _impl_.config_.params_map_;
}
inline ::qdrant::VectorParamsDiffMap* PROTOBUF_NONNULL VectorsConfigDiff::mutable_params_map()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::VectorParamsDiffMap* _msg = _internal_mutable_params_map();
  // @@protoc_insertion_point(field_mutable:qdrant.VectorsConfigDiff.params_map)
  return _msg;
}

inline bool VectorsConfigDiff::has_config() const {
  return config_case() != CONFIG_NOT_SET;
}
inline void VectorsConfigDiff::clear_has_config() {
  _impl_._oneof_case_[0] = CONFIG_NOT_SET;
}
inline VectorsConfigDiff::ConfigCase VectorsConfigDiff::config_case() const {
  return VectorsConfigDiff::ConfigCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SparseVectorParams

// optional .qdrant.SparseIndexConfig index = 1;
inline bool SparseVectorParams::has_index() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.index_ != nullptr);
  return value;
}
inline void SparseVectorParams::clear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.index_ != nullptr) _impl_.index_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::SparseIndexConfig& SparseVectorParams::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SparseIndexConfig* p = _impl_.index_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SparseIndexConfig&>(::qdrant::_SparseIndexConfig_default_instance_);
}
inline const ::qdrant::SparseIndexConfig& SparseVectorParams::index() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SparseVectorParams.index)
  return _internal_index();
}
inline void SparseVectorParams::unsafe_arena_set_allocated_index(
    ::qdrant::SparseIndexConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.index_);
  }
  _impl_.index_ = reinterpret_cast<::qdrant::SparseIndexConfig*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.SparseVectorParams.index)
}
inline ::qdrant::SparseIndexConfig* PROTOBUF_NULLABLE SparseVectorParams::release_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::SparseIndexConfig* released = _impl_.index_;
  _impl_.index_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SparseIndexConfig* PROTOBUF_NULLABLE SparseVectorParams::unsafe_arena_release_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SparseVectorParams.index)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::SparseIndexConfig* temp = _impl_.index_;
  _impl_.index_ = nullptr;
  return temp;
}
inline ::qdrant::SparseIndexConfig* PROTOBUF_NONNULL SparseVectorParams::_internal_mutable_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.index_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SparseIndexConfig>(GetArena());
    _impl_.index_ = reinterpret_cast<::qdrant::SparseIndexConfig*>(p);
  }
  return _impl_.index_;
}
inline ::qdrant::SparseIndexConfig* PROTOBUF_NONNULL SparseVectorParams::mutable_index()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::SparseIndexConfig* _msg = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:qdrant.SparseVectorParams.index)
  return _msg;
}
inline void SparseVectorParams::set_allocated_index(::qdrant::SparseIndexConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.index_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.index_ = reinterpret_cast<::qdrant::SparseIndexConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.SparseVectorParams.index)
}

// optional .qdrant.Modifier modifier = 2;
inline bool SparseVectorParams::has_modifier() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void SparseVectorParams::clear_modifier() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modifier_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::qdrant::Modifier SparseVectorParams::modifier() const {
  // @@protoc_insertion_point(field_get:qdrant.SparseVectorParams.modifier)
  return _internal_modifier();
}
inline void SparseVectorParams::set_modifier(::qdrant::Modifier value) {
  _internal_set_modifier(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.SparseVectorParams.modifier)
}
inline ::qdrant::Modifier SparseVectorParams::_internal_modifier() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::Modifier>(_impl_.modifier_);
}
inline void SparseVectorParams::_internal_set_modifier(::qdrant::Modifier value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modifier_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SparseVectorConfig

// map<string, .qdrant.SparseVectorParams> map = 1;
inline int SparseVectorConfig::_internal_map_size() const {
  return _internal_map().size();
}
inline int SparseVectorConfig::map_size() const {
  return _internal_map_size();
}
inline void SparseVectorConfig::clear_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.map_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::SparseVectorParams>& SparseVectorConfig::_internal_map() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.map_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::SparseVectorParams>& SparseVectorConfig::map() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.SparseVectorConfig.map)
  return _internal_map();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::SparseVectorParams>* PROTOBUF_NONNULL SparseVectorConfig::_internal_mutable_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.map_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::SparseVectorParams>* PROTOBUF_NONNULL SparseVectorConfig::mutable_map()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.SparseVectorConfig.map)
  return _internal_mutable_map();
}

// -------------------------------------------------------------------

// MultiVectorConfig

// .qdrant.MultiVectorComparator comparator = 1;
inline void MultiVectorConfig::clear_comparator() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.comparator_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::MultiVectorComparator MultiVectorConfig::comparator() const {
  // @@protoc_insertion_point(field_get:qdrant.MultiVectorConfig.comparator)
  return _internal_comparator();
}
inline void MultiVectorConfig::set_comparator(::qdrant::MultiVectorComparator value) {
  _internal_set_comparator(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.MultiVectorConfig.comparator)
}
inline ::qdrant::MultiVectorComparator MultiVectorConfig::_internal_comparator() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::MultiVectorComparator>(_impl_.comparator_);
}
inline void MultiVectorConfig::_internal_set_comparator(::qdrant::MultiVectorComparator value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.comparator_ = value;
}

// -------------------------------------------------------------------

// GetCollectionInfoRequest

// string collection_name = 1;
inline void GetCollectionInfoRequest::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& GetCollectionInfoRequest::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GetCollectionInfoRequest.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetCollectionInfoRequest::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.GetCollectionInfoRequest.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL GetCollectionInfoRequest::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.GetCollectionInfoRequest.collection_name)
  return _s;
}
inline const ::std::string& GetCollectionInfoRequest::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void GetCollectionInfoRequest::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetCollectionInfoRequest::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetCollectionInfoRequest::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.GetCollectionInfoRequest.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void GetCollectionInfoRequest::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.GetCollectionInfoRequest.collection_name)
}

// -------------------------------------------------------------------

// CollectionExistsRequest

// string collection_name = 1;
inline void CollectionExistsRequest::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& CollectionExistsRequest::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionExistsRequest.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CollectionExistsRequest::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.CollectionExistsRequest.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL CollectionExistsRequest::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionExistsRequest.collection_name)
  return _s;
}
inline const ::std::string& CollectionExistsRequest::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void CollectionExistsRequest::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CollectionExistsRequest::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CollectionExistsRequest::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CollectionExistsRequest.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void CollectionExistsRequest::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.CollectionExistsRequest.collection_name)
}

// -------------------------------------------------------------------

// CollectionExists

// bool exists = 1;
inline void CollectionExists::clear_exists() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exists_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool CollectionExists::exists() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionExists.exists)
  return _internal_exists();
}
inline void CollectionExists::set_exists(bool value) {
  _internal_set_exists(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionExists.exists)
}
inline bool CollectionExists::_internal_exists() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exists_;
}
inline void CollectionExists::_internal_set_exists(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exists_ = value;
}

// -------------------------------------------------------------------

// CollectionExistsResponse

// .qdrant.CollectionExists result = 1;
inline bool CollectionExistsResponse::has_result() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void CollectionExistsResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::CollectionExists& CollectionExistsResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::CollectionExists* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::CollectionExists&>(::qdrant::_CollectionExists_default_instance_);
}
inline const ::qdrant::CollectionExists& CollectionExistsResponse::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionExistsResponse.result)
  return _internal_result();
}
inline void CollectionExistsResponse::unsafe_arena_set_allocated_result(
    ::qdrant::CollectionExists* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::qdrant::CollectionExists*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CollectionExistsResponse.result)
}
inline ::qdrant::CollectionExists* PROTOBUF_NULLABLE CollectionExistsResponse::release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::CollectionExists* released = _impl_.result_;
  _impl_.result_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::CollectionExists* PROTOBUF_NULLABLE CollectionExistsResponse::unsafe_arena_release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CollectionExistsResponse.result)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::CollectionExists* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::qdrant::CollectionExists* PROTOBUF_NONNULL CollectionExistsResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::CollectionExists>(GetArena());
    _impl_.result_ = reinterpret_cast<::qdrant::CollectionExists*>(p);
  }
  return _impl_.result_;
}
inline ::qdrant::CollectionExists* PROTOBUF_NONNULL CollectionExistsResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::CollectionExists* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionExistsResponse.result)
  return _msg;
}
inline void CollectionExistsResponse::set_allocated_result(::qdrant::CollectionExists* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.result_ = reinterpret_cast<::qdrant::CollectionExists*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CollectionExistsResponse.result)
}

// double time = 2;
inline void CollectionExistsResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline double CollectionExistsResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionExistsResponse.time)
  return _internal_time();
}
inline void CollectionExistsResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionExistsResponse.time)
}
inline double CollectionExistsResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void CollectionExistsResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// ListCollectionsRequest

// -------------------------------------------------------------------

// CollectionDescription

// string name = 1;
inline void CollectionDescription::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& CollectionDescription::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionDescription.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CollectionDescription::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.CollectionDescription.name)
}
inline ::std::string* PROTOBUF_NONNULL CollectionDescription::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionDescription.name)
  return _s;
}
inline const ::std::string& CollectionDescription::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void CollectionDescription::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CollectionDescription::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CollectionDescription::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CollectionDescription.name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void CollectionDescription::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.CollectionDescription.name)
}

// -------------------------------------------------------------------

// GetCollectionInfoResponse

// .qdrant.CollectionInfo result = 1;
inline bool GetCollectionInfoResponse::has_result() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void GetCollectionInfoResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::CollectionInfo& GetCollectionInfoResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::CollectionInfo* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::CollectionInfo&>(::qdrant::_CollectionInfo_default_instance_);
}
inline const ::qdrant::CollectionInfo& GetCollectionInfoResponse::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.GetCollectionInfoResponse.result)
  return _internal_result();
}
inline void GetCollectionInfoResponse::unsafe_arena_set_allocated_result(
    ::qdrant::CollectionInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::qdrant::CollectionInfo*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.GetCollectionInfoResponse.result)
}
inline ::qdrant::CollectionInfo* PROTOBUF_NULLABLE GetCollectionInfoResponse::release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::CollectionInfo* released = _impl_.result_;
  _impl_.result_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::CollectionInfo* PROTOBUF_NULLABLE GetCollectionInfoResponse::unsafe_arena_release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.GetCollectionInfoResponse.result)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::CollectionInfo* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::qdrant::CollectionInfo* PROTOBUF_NONNULL GetCollectionInfoResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::CollectionInfo>(GetArena());
    _impl_.result_ = reinterpret_cast<::qdrant::CollectionInfo*>(p);
  }
  return _impl_.result_;
}
inline ::qdrant::CollectionInfo* PROTOBUF_NONNULL GetCollectionInfoResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::CollectionInfo* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:qdrant.GetCollectionInfoResponse.result)
  return _msg;
}
inline void GetCollectionInfoResponse::set_allocated_result(::qdrant::CollectionInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.result_ = reinterpret_cast<::qdrant::CollectionInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.GetCollectionInfoResponse.result)
}

// double time = 2;
inline void GetCollectionInfoResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline double GetCollectionInfoResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.GetCollectionInfoResponse.time)
  return _internal_time();
}
inline void GetCollectionInfoResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.GetCollectionInfoResponse.time)
}
inline double GetCollectionInfoResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void GetCollectionInfoResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// ListCollectionsResponse

// repeated .qdrant.CollectionDescription collections = 1;
inline int ListCollectionsResponse::_internal_collections_size() const {
  return _internal_collections().size();
}
inline int ListCollectionsResponse::collections_size() const {
  return _internal_collections_size();
}
inline void ListCollectionsResponse::clear_collections() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collections_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::CollectionDescription* PROTOBUF_NONNULL ListCollectionsResponse::mutable_collections(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.ListCollectionsResponse.collections)
  return _internal_mutable_collections()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::CollectionDescription>* PROTOBUF_NONNULL ListCollectionsResponse::mutable_collections()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.ListCollectionsResponse.collections)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_collections();
}
inline const ::qdrant::CollectionDescription& ListCollectionsResponse::collections(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ListCollectionsResponse.collections)
  return _internal_collections().Get(index);
}
inline ::qdrant::CollectionDescription* PROTOBUF_NONNULL ListCollectionsResponse::add_collections()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::CollectionDescription* _add =
      _internal_mutable_collections()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.ListCollectionsResponse.collections)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::CollectionDescription>& ListCollectionsResponse::collections() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.ListCollectionsResponse.collections)
  return _internal_collections();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::CollectionDescription>&
ListCollectionsResponse::_internal_collections() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collections_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::CollectionDescription>* PROTOBUF_NONNULL
ListCollectionsResponse::_internal_mutable_collections() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.collections_;
}

// double time = 2;
inline void ListCollectionsResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline double ListCollectionsResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.ListCollectionsResponse.time)
  return _internal_time();
}
inline void ListCollectionsResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.ListCollectionsResponse.time)
}
inline double ListCollectionsResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void ListCollectionsResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// MaxOptimizationThreads

// uint64 value = 1;
inline bool MaxOptimizationThreads::has_value() const {
  return variant_case() == kValue;
}
inline void MaxOptimizationThreads::set_has_value() {
  _impl_._oneof_case_[0] = kValue;
}
inline void MaxOptimizationThreads::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kValue) {
    _impl_.variant_.value_ = ::uint64_t{0u};
    clear_has_variant();
  }
}
inline ::uint64_t MaxOptimizationThreads::value() const {
  // @@protoc_insertion_point(field_get:qdrant.MaxOptimizationThreads.value)
  return _internal_value();
}
inline void MaxOptimizationThreads::set_value(::uint64_t value) {
  if (variant_case() != kValue) {
    clear_variant();
    set_has_value();
  }
  _impl_.variant_.value_ = value;
  // @@protoc_insertion_point(field_set:qdrant.MaxOptimizationThreads.value)
}
inline ::uint64_t MaxOptimizationThreads::_internal_value() const {
  if (variant_case() == kValue) {
    return _impl_.variant_.value_;
  }
  return ::uint64_t{0u};
}

// .qdrant.MaxOptimizationThreads.Setting setting = 2;
inline bool MaxOptimizationThreads::has_setting() const {
  return variant_case() == kSetting;
}
inline void MaxOptimizationThreads::set_has_setting() {
  _impl_._oneof_case_[0] = kSetting;
}
inline void MaxOptimizationThreads::clear_setting() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kSetting) {
    _impl_.variant_.setting_ = 0;
    clear_has_variant();
  }
}
inline ::qdrant::MaxOptimizationThreads_Setting MaxOptimizationThreads::setting() const {
  // @@protoc_insertion_point(field_get:qdrant.MaxOptimizationThreads.setting)
  return _internal_setting();
}
inline void MaxOptimizationThreads::set_setting(::qdrant::MaxOptimizationThreads_Setting value) {
  if (variant_case() != kSetting) {
    clear_variant();
    set_has_setting();
  }
  _impl_.variant_.setting_ = value;
  // @@protoc_insertion_point(field_set:qdrant.MaxOptimizationThreads.setting)
}
inline ::qdrant::MaxOptimizationThreads_Setting MaxOptimizationThreads::_internal_setting() const {
  if (variant_case() == kSetting) {
    return static_cast<::qdrant::MaxOptimizationThreads_Setting>(_impl_.variant_.setting_);
  }
  return static_cast<::qdrant::MaxOptimizationThreads_Setting>(0);
}

inline bool MaxOptimizationThreads::has_variant() const {
  return variant_case() != VARIANT_NOT_SET;
}
inline void MaxOptimizationThreads::clear_has_variant() {
  _impl_._oneof_case_[0] = VARIANT_NOT_SET;
}
inline MaxOptimizationThreads::VariantCase MaxOptimizationThreads::variant_case() const {
  return MaxOptimizationThreads::VariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OptimizerStatus

// bool ok = 1;
inline void OptimizerStatus::clear_ok() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ok_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool OptimizerStatus::ok() const {
  // @@protoc_insertion_point(field_get:qdrant.OptimizerStatus.ok)
  return _internal_ok();
}
inline void OptimizerStatus::set_ok(bool value) {
  _internal_set_ok(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.OptimizerStatus.ok)
}
inline bool OptimizerStatus::_internal_ok() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ok_;
}
inline void OptimizerStatus::_internal_set_ok(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ok_ = value;
}

// string error = 2;
inline void OptimizerStatus::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& OptimizerStatus::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.OptimizerStatus.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void OptimizerStatus::set_error(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.OptimizerStatus.error)
}
inline ::std::string* PROTOBUF_NONNULL OptimizerStatus::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:qdrant.OptimizerStatus.error)
  return _s;
}
inline const ::std::string& OptimizerStatus::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_.Get();
}
inline void OptimizerStatus::_internal_set_error(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL OptimizerStatus::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE OptimizerStatus::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.OptimizerStatus.error)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.error_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.error_.Set("", GetArena());
  }
  return released;
}
inline void OptimizerStatus::set_allocated_error(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.OptimizerStatus.error)
}

// -------------------------------------------------------------------

// HnswConfigDiff

// optional uint64 m = 1;
inline bool HnswConfigDiff::has_m() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void HnswConfigDiff::clear_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.m_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t HnswConfigDiff::m() const {
  // @@protoc_insertion_point(field_get:qdrant.HnswConfigDiff.m)
  return _internal_m();
}
inline void HnswConfigDiff::set_m(::uint64_t value) {
  _internal_set_m(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.HnswConfigDiff.m)
}
inline ::uint64_t HnswConfigDiff::_internal_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.m_;
}
inline void HnswConfigDiff::_internal_set_m(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.m_ = value;
}

// optional uint64 ef_construct = 2;
inline bool HnswConfigDiff::has_ef_construct() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void HnswConfigDiff::clear_ef_construct() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ef_construct_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint64_t HnswConfigDiff::ef_construct() const {
  // @@protoc_insertion_point(field_get:qdrant.HnswConfigDiff.ef_construct)
  return _internal_ef_construct();
}
inline void HnswConfigDiff::set_ef_construct(::uint64_t value) {
  _internal_set_ef_construct(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.HnswConfigDiff.ef_construct)
}
inline ::uint64_t HnswConfigDiff::_internal_ef_construct() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ef_construct_;
}
inline void HnswConfigDiff::_internal_set_ef_construct(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ef_construct_ = value;
}

// optional uint64 full_scan_threshold = 3;
inline bool HnswConfigDiff::has_full_scan_threshold() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void HnswConfigDiff::clear_full_scan_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_scan_threshold_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint64_t HnswConfigDiff::full_scan_threshold() const {
  // @@protoc_insertion_point(field_get:qdrant.HnswConfigDiff.full_scan_threshold)
  return _internal_full_scan_threshold();
}
inline void HnswConfigDiff::set_full_scan_threshold(::uint64_t value) {
  _internal_set_full_scan_threshold(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.HnswConfigDiff.full_scan_threshold)
}
inline ::uint64_t HnswConfigDiff::_internal_full_scan_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.full_scan_threshold_;
}
inline void HnswConfigDiff::_internal_set_full_scan_threshold(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_scan_threshold_ = value;
}

// optional uint64 max_indexing_threads = 4;
inline bool HnswConfigDiff::has_max_indexing_threads() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void HnswConfigDiff::clear_max_indexing_threads() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_indexing_threads_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint64_t HnswConfigDiff::max_indexing_threads() const {
  // @@protoc_insertion_point(field_get:qdrant.HnswConfigDiff.max_indexing_threads)
  return _internal_max_indexing_threads();
}
inline void HnswConfigDiff::set_max_indexing_threads(::uint64_t value) {
  _internal_set_max_indexing_threads(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.HnswConfigDiff.max_indexing_threads)
}
inline ::uint64_t HnswConfigDiff::_internal_max_indexing_threads() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_indexing_threads_;
}
inline void HnswConfigDiff::_internal_set_max_indexing_threads(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_indexing_threads_ = value;
}

// optional bool on_disk = 5;
inline bool HnswConfigDiff::has_on_disk() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void HnswConfigDiff::clear_on_disk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool HnswConfigDiff::on_disk() const {
  // @@protoc_insertion_point(field_get:qdrant.HnswConfigDiff.on_disk)
  return _internal_on_disk();
}
inline void HnswConfigDiff::set_on_disk(bool value) {
  _internal_set_on_disk(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.HnswConfigDiff.on_disk)
}
inline bool HnswConfigDiff::_internal_on_disk() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_disk_;
}
inline void HnswConfigDiff::_internal_set_on_disk(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = value;
}

// optional uint64 payload_m = 6;
inline bool HnswConfigDiff::has_payload_m() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void HnswConfigDiff::clear_payload_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_m_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::uint64_t HnswConfigDiff::payload_m() const {
  // @@protoc_insertion_point(field_get:qdrant.HnswConfigDiff.payload_m)
  return _internal_payload_m();
}
inline void HnswConfigDiff::set_payload_m(::uint64_t value) {
  _internal_set_payload_m(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.HnswConfigDiff.payload_m)
}
inline ::uint64_t HnswConfigDiff::_internal_payload_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_m_;
}
inline void HnswConfigDiff::_internal_set_payload_m(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_m_ = value;
}

// optional bool copy_vectors = 7;
inline bool HnswConfigDiff::has_copy_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  return value;
}
inline void HnswConfigDiff::clear_copy_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.copy_vectors_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline bool HnswConfigDiff::copy_vectors() const {
  // @@protoc_insertion_point(field_get:qdrant.HnswConfigDiff.copy_vectors)
  return _internal_copy_vectors();
}
inline void HnswConfigDiff::set_copy_vectors(bool value) {
  _internal_set_copy_vectors(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:qdrant.HnswConfigDiff.copy_vectors)
}
inline bool HnswConfigDiff::_internal_copy_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.copy_vectors_;
}
inline void HnswConfigDiff::_internal_set_copy_vectors(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.copy_vectors_ = value;
}

// -------------------------------------------------------------------

// SparseIndexConfig

// optional uint64 full_scan_threshold = 1;
inline bool SparseIndexConfig::has_full_scan_threshold() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void SparseIndexConfig::clear_full_scan_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_scan_threshold_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t SparseIndexConfig::full_scan_threshold() const {
  // @@protoc_insertion_point(field_get:qdrant.SparseIndexConfig.full_scan_threshold)
  return _internal_full_scan_threshold();
}
inline void SparseIndexConfig::set_full_scan_threshold(::uint64_t value) {
  _internal_set_full_scan_threshold(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.SparseIndexConfig.full_scan_threshold)
}
inline ::uint64_t SparseIndexConfig::_internal_full_scan_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.full_scan_threshold_;
}
inline void SparseIndexConfig::_internal_set_full_scan_threshold(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_scan_threshold_ = value;
}

// optional bool on_disk = 2;
inline bool SparseIndexConfig::has_on_disk() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void SparseIndexConfig::clear_on_disk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool SparseIndexConfig::on_disk() const {
  // @@protoc_insertion_point(field_get:qdrant.SparseIndexConfig.on_disk)
  return _internal_on_disk();
}
inline void SparseIndexConfig::set_on_disk(bool value) {
  _internal_set_on_disk(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.SparseIndexConfig.on_disk)
}
inline bool SparseIndexConfig::_internal_on_disk() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_disk_;
}
inline void SparseIndexConfig::_internal_set_on_disk(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = value;
}

// optional .qdrant.Datatype datatype = 3;
inline bool SparseIndexConfig::has_datatype() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void SparseIndexConfig::clear_datatype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.datatype_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::qdrant::Datatype SparseIndexConfig::datatype() const {
  // @@protoc_insertion_point(field_get:qdrant.SparseIndexConfig.datatype)
  return _internal_datatype();
}
inline void SparseIndexConfig::set_datatype(::qdrant::Datatype value) {
  _internal_set_datatype(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.SparseIndexConfig.datatype)
}
inline ::qdrant::Datatype SparseIndexConfig::_internal_datatype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::Datatype>(_impl_.datatype_);
}
inline void SparseIndexConfig::_internal_set_datatype(::qdrant::Datatype value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.datatype_ = value;
}

// -------------------------------------------------------------------

// WalConfigDiff

// optional uint64 wal_capacity_mb = 1;
inline bool WalConfigDiff::has_wal_capacity_mb() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void WalConfigDiff::clear_wal_capacity_mb() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wal_capacity_mb_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t WalConfigDiff::wal_capacity_mb() const {
  // @@protoc_insertion_point(field_get:qdrant.WalConfigDiff.wal_capacity_mb)
  return _internal_wal_capacity_mb();
}
inline void WalConfigDiff::set_wal_capacity_mb(::uint64_t value) {
  _internal_set_wal_capacity_mb(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.WalConfigDiff.wal_capacity_mb)
}
inline ::uint64_t WalConfigDiff::_internal_wal_capacity_mb() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wal_capacity_mb_;
}
inline void WalConfigDiff::_internal_set_wal_capacity_mb(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wal_capacity_mb_ = value;
}

// optional uint64 wal_segments_ahead = 2;
inline bool WalConfigDiff::has_wal_segments_ahead() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void WalConfigDiff::clear_wal_segments_ahead() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wal_segments_ahead_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint64_t WalConfigDiff::wal_segments_ahead() const {
  // @@protoc_insertion_point(field_get:qdrant.WalConfigDiff.wal_segments_ahead)
  return _internal_wal_segments_ahead();
}
inline void WalConfigDiff::set_wal_segments_ahead(::uint64_t value) {
  _internal_set_wal_segments_ahead(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.WalConfigDiff.wal_segments_ahead)
}
inline ::uint64_t WalConfigDiff::_internal_wal_segments_ahead() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wal_segments_ahead_;
}
inline void WalConfigDiff::_internal_set_wal_segments_ahead(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wal_segments_ahead_ = value;
}

// optional uint64 wal_retain_closed = 3;
inline bool WalConfigDiff::has_wal_retain_closed() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void WalConfigDiff::clear_wal_retain_closed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wal_retain_closed_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint64_t WalConfigDiff::wal_retain_closed() const {
  // @@protoc_insertion_point(field_get:qdrant.WalConfigDiff.wal_retain_closed)
  return _internal_wal_retain_closed();
}
inline void WalConfigDiff::set_wal_retain_closed(::uint64_t value) {
  _internal_set_wal_retain_closed(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.WalConfigDiff.wal_retain_closed)
}
inline ::uint64_t WalConfigDiff::_internal_wal_retain_closed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wal_retain_closed_;
}
inline void WalConfigDiff::_internal_set_wal_retain_closed(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wal_retain_closed_ = value;
}

// -------------------------------------------------------------------

// OptimizersConfigDiff

// optional double deleted_threshold = 1;
inline bool OptimizersConfigDiff::has_deleted_threshold() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void OptimizersConfigDiff::clear_deleted_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.deleted_threshold_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline double OptimizersConfigDiff::deleted_threshold() const {
  // @@protoc_insertion_point(field_get:qdrant.OptimizersConfigDiff.deleted_threshold)
  return _internal_deleted_threshold();
}
inline void OptimizersConfigDiff::set_deleted_threshold(double value) {
  _internal_set_deleted_threshold(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.OptimizersConfigDiff.deleted_threshold)
}
inline double OptimizersConfigDiff::_internal_deleted_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.deleted_threshold_;
}
inline void OptimizersConfigDiff::_internal_set_deleted_threshold(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.deleted_threshold_ = value;
}

// optional uint64 vacuum_min_vector_number = 2;
inline bool OptimizersConfigDiff::has_vacuum_min_vector_number() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void OptimizersConfigDiff::clear_vacuum_min_vector_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vacuum_min_vector_number_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint64_t OptimizersConfigDiff::vacuum_min_vector_number() const {
  // @@protoc_insertion_point(field_get:qdrant.OptimizersConfigDiff.vacuum_min_vector_number)
  return _internal_vacuum_min_vector_number();
}
inline void OptimizersConfigDiff::set_vacuum_min_vector_number(::uint64_t value) {
  _internal_set_vacuum_min_vector_number(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.OptimizersConfigDiff.vacuum_min_vector_number)
}
inline ::uint64_t OptimizersConfigDiff::_internal_vacuum_min_vector_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vacuum_min_vector_number_;
}
inline void OptimizersConfigDiff::_internal_set_vacuum_min_vector_number(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vacuum_min_vector_number_ = value;
}

// optional uint64 default_segment_number = 3;
inline bool OptimizersConfigDiff::has_default_segment_number() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void OptimizersConfigDiff::clear_default_segment_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_segment_number_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint64_t OptimizersConfigDiff::default_segment_number() const {
  // @@protoc_insertion_point(field_get:qdrant.OptimizersConfigDiff.default_segment_number)
  return _internal_default_segment_number();
}
inline void OptimizersConfigDiff::set_default_segment_number(::uint64_t value) {
  _internal_set_default_segment_number(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.OptimizersConfigDiff.default_segment_number)
}
inline ::uint64_t OptimizersConfigDiff::_internal_default_segment_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.default_segment_number_;
}
inline void OptimizersConfigDiff::_internal_set_default_segment_number(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_segment_number_ = value;
}

// optional uint64 max_segment_size = 4;
inline bool OptimizersConfigDiff::has_max_segment_size() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void OptimizersConfigDiff::clear_max_segment_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_segment_size_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::uint64_t OptimizersConfigDiff::max_segment_size() const {
  // @@protoc_insertion_point(field_get:qdrant.OptimizersConfigDiff.max_segment_size)
  return _internal_max_segment_size();
}
inline void OptimizersConfigDiff::set_max_segment_size(::uint64_t value) {
  _internal_set_max_segment_size(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.OptimizersConfigDiff.max_segment_size)
}
inline ::uint64_t OptimizersConfigDiff::_internal_max_segment_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_segment_size_;
}
inline void OptimizersConfigDiff::_internal_set_max_segment_size(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_segment_size_ = value;
}

// optional uint64 memmap_threshold = 5;
inline bool OptimizersConfigDiff::has_memmap_threshold() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void OptimizersConfigDiff::clear_memmap_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memmap_threshold_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::uint64_t OptimizersConfigDiff::memmap_threshold() const {
  // @@protoc_insertion_point(field_get:qdrant.OptimizersConfigDiff.memmap_threshold)
  return _internal_memmap_threshold();
}
inline void OptimizersConfigDiff::set_memmap_threshold(::uint64_t value) {
  _internal_set_memmap_threshold(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.OptimizersConfigDiff.memmap_threshold)
}
inline ::uint64_t OptimizersConfigDiff::_internal_memmap_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.memmap_threshold_;
}
inline void OptimizersConfigDiff::_internal_set_memmap_threshold(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memmap_threshold_ = value;
}

// optional uint64 indexing_threshold = 6;
inline bool OptimizersConfigDiff::has_indexing_threshold() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  return value;
}
inline void OptimizersConfigDiff::clear_indexing_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.indexing_threshold_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline ::uint64_t OptimizersConfigDiff::indexing_threshold() const {
  // @@protoc_insertion_point(field_get:qdrant.OptimizersConfigDiff.indexing_threshold)
  return _internal_indexing_threshold();
}
inline void OptimizersConfigDiff::set_indexing_threshold(::uint64_t value) {
  _internal_set_indexing_threshold(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:qdrant.OptimizersConfigDiff.indexing_threshold)
}
inline ::uint64_t OptimizersConfigDiff::_internal_indexing_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.indexing_threshold_;
}
inline void OptimizersConfigDiff::_internal_set_indexing_threshold(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.indexing_threshold_ = value;
}

// optional uint64 flush_interval_sec = 7;
inline bool OptimizersConfigDiff::has_flush_interval_sec() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  return value;
}
inline void OptimizersConfigDiff::clear_flush_interval_sec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flush_interval_sec_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline ::uint64_t OptimizersConfigDiff::flush_interval_sec() const {
  // @@protoc_insertion_point(field_get:qdrant.OptimizersConfigDiff.flush_interval_sec)
  return _internal_flush_interval_sec();
}
inline void OptimizersConfigDiff::set_flush_interval_sec(::uint64_t value) {
  _internal_set_flush_interval_sec(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  // @@protoc_insertion_point(field_set:qdrant.OptimizersConfigDiff.flush_interval_sec)
}
inline ::uint64_t OptimizersConfigDiff::_internal_flush_interval_sec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.flush_interval_sec_;
}
inline void OptimizersConfigDiff::_internal_set_flush_interval_sec(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flush_interval_sec_ = value;
}

// optional uint64 deprecated_max_optimization_threads = 8;
inline bool OptimizersConfigDiff::has_deprecated_max_optimization_threads() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000100U);
  return value;
}
inline void OptimizersConfigDiff::clear_deprecated_max_optimization_threads() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.deprecated_max_optimization_threads_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline ::uint64_t OptimizersConfigDiff::deprecated_max_optimization_threads() const {
  // @@protoc_insertion_point(field_get:qdrant.OptimizersConfigDiff.deprecated_max_optimization_threads)
  return _internal_deprecated_max_optimization_threads();
}
inline void OptimizersConfigDiff::set_deprecated_max_optimization_threads(::uint64_t value) {
  _internal_set_deprecated_max_optimization_threads(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  // @@protoc_insertion_point(field_set:qdrant.OptimizersConfigDiff.deprecated_max_optimization_threads)
}
inline ::uint64_t OptimizersConfigDiff::_internal_deprecated_max_optimization_threads() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.deprecated_max_optimization_threads_;
}
inline void OptimizersConfigDiff::_internal_set_deprecated_max_optimization_threads(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.deprecated_max_optimization_threads_ = value;
}

// optional .qdrant.MaxOptimizationThreads max_optimization_threads = 9;
inline bool OptimizersConfigDiff::has_max_optimization_threads() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.max_optimization_threads_ != nullptr);
  return value;
}
inline void OptimizersConfigDiff::clear_max_optimization_threads() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.max_optimization_threads_ != nullptr) _impl_.max_optimization_threads_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::MaxOptimizationThreads& OptimizersConfigDiff::_internal_max_optimization_threads() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::MaxOptimizationThreads* p = _impl_.max_optimization_threads_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::MaxOptimizationThreads&>(::qdrant::_MaxOptimizationThreads_default_instance_);
}
inline const ::qdrant::MaxOptimizationThreads& OptimizersConfigDiff::max_optimization_threads() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.OptimizersConfigDiff.max_optimization_threads)
  return _internal_max_optimization_threads();
}
inline void OptimizersConfigDiff::unsafe_arena_set_allocated_max_optimization_threads(
    ::qdrant::MaxOptimizationThreads* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.max_optimization_threads_);
  }
  _impl_.max_optimization_threads_ = reinterpret_cast<::qdrant::MaxOptimizationThreads*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.OptimizersConfigDiff.max_optimization_threads)
}
inline ::qdrant::MaxOptimizationThreads* PROTOBUF_NULLABLE OptimizersConfigDiff::release_max_optimization_threads() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::MaxOptimizationThreads* released = _impl_.max_optimization_threads_;
  _impl_.max_optimization_threads_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::MaxOptimizationThreads* PROTOBUF_NULLABLE OptimizersConfigDiff::unsafe_arena_release_max_optimization_threads() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.OptimizersConfigDiff.max_optimization_threads)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::MaxOptimizationThreads* temp = _impl_.max_optimization_threads_;
  _impl_.max_optimization_threads_ = nullptr;
  return temp;
}
inline ::qdrant::MaxOptimizationThreads* PROTOBUF_NONNULL OptimizersConfigDiff::_internal_mutable_max_optimization_threads() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.max_optimization_threads_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::MaxOptimizationThreads>(GetArena());
    _impl_.max_optimization_threads_ = reinterpret_cast<::qdrant::MaxOptimizationThreads*>(p);
  }
  return _impl_.max_optimization_threads_;
}
inline ::qdrant::MaxOptimizationThreads* PROTOBUF_NONNULL OptimizersConfigDiff::mutable_max_optimization_threads()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::MaxOptimizationThreads* _msg = _internal_mutable_max_optimization_threads();
  // @@protoc_insertion_point(field_mutable:qdrant.OptimizersConfigDiff.max_optimization_threads)
  return _msg;
}
inline void OptimizersConfigDiff::set_allocated_max_optimization_threads(::qdrant::MaxOptimizationThreads* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.max_optimization_threads_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.max_optimization_threads_ = reinterpret_cast<::qdrant::MaxOptimizationThreads*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.OptimizersConfigDiff.max_optimization_threads)
}

// -------------------------------------------------------------------

// ScalarQuantization

// .qdrant.QuantizationType type = 1;
inline void ScalarQuantization::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::QuantizationType ScalarQuantization::type() const {
  // @@protoc_insertion_point(field_get:qdrant.ScalarQuantization.type)
  return _internal_type();
}
inline void ScalarQuantization::set_type(::qdrant::QuantizationType value) {
  _internal_set_type(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.ScalarQuantization.type)
}
inline ::qdrant::QuantizationType ScalarQuantization::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::QuantizationType>(_impl_.type_);
}
inline void ScalarQuantization::_internal_set_type(::qdrant::QuantizationType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// optional float quantile = 2;
inline bool ScalarQuantization::has_quantile() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void ScalarQuantization::clear_quantile() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantile_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline float ScalarQuantization::quantile() const {
  // @@protoc_insertion_point(field_get:qdrant.ScalarQuantization.quantile)
  return _internal_quantile();
}
inline void ScalarQuantization::set_quantile(float value) {
  _internal_set_quantile(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.ScalarQuantization.quantile)
}
inline float ScalarQuantization::_internal_quantile() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.quantile_;
}
inline void ScalarQuantization::_internal_set_quantile(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantile_ = value;
}

// optional bool always_ram = 3;
inline bool ScalarQuantization::has_always_ram() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void ScalarQuantization::clear_always_ram() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.always_ram_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline bool ScalarQuantization::always_ram() const {
  // @@protoc_insertion_point(field_get:qdrant.ScalarQuantization.always_ram)
  return _internal_always_ram();
}
inline void ScalarQuantization::set_always_ram(bool value) {
  _internal_set_always_ram(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.ScalarQuantization.always_ram)
}
inline bool ScalarQuantization::_internal_always_ram() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.always_ram_;
}
inline void ScalarQuantization::_internal_set_always_ram(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.always_ram_ = value;
}

// -------------------------------------------------------------------

// ProductQuantization

// .qdrant.CompressionRatio compression = 1;
inline void ProductQuantization::clear_compression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compression_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::CompressionRatio ProductQuantization::compression() const {
  // @@protoc_insertion_point(field_get:qdrant.ProductQuantization.compression)
  return _internal_compression();
}
inline void ProductQuantization::set_compression(::qdrant::CompressionRatio value) {
  _internal_set_compression(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.ProductQuantization.compression)
}
inline ::qdrant::CompressionRatio ProductQuantization::_internal_compression() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::CompressionRatio>(_impl_.compression_);
}
inline void ProductQuantization::_internal_set_compression(::qdrant::CompressionRatio value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compression_ = value;
}

// optional bool always_ram = 2;
inline bool ProductQuantization::has_always_ram() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void ProductQuantization::clear_always_ram() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.always_ram_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool ProductQuantization::always_ram() const {
  // @@protoc_insertion_point(field_get:qdrant.ProductQuantization.always_ram)
  return _internal_always_ram();
}
inline void ProductQuantization::set_always_ram(bool value) {
  _internal_set_always_ram(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.ProductQuantization.always_ram)
}
inline bool ProductQuantization::_internal_always_ram() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.always_ram_;
}
inline void ProductQuantization::_internal_set_always_ram(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.always_ram_ = value;
}

// -------------------------------------------------------------------

// BinaryQuantizationQueryEncoding

// .qdrant.BinaryQuantizationQueryEncoding.Setting setting = 4;
inline bool BinaryQuantizationQueryEncoding::has_setting() const {
  return variant_case() == kSetting;
}
inline void BinaryQuantizationQueryEncoding::set_has_setting() {
  _impl_._oneof_case_[0] = kSetting;
}
inline void BinaryQuantizationQueryEncoding::clear_setting() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kSetting) {
    _impl_.variant_.setting_ = 0;
    clear_has_variant();
  }
}
inline ::qdrant::BinaryQuantizationQueryEncoding_Setting BinaryQuantizationQueryEncoding::setting() const {
  // @@protoc_insertion_point(field_get:qdrant.BinaryQuantizationQueryEncoding.setting)
  return _internal_setting();
}
inline void BinaryQuantizationQueryEncoding::set_setting(::qdrant::BinaryQuantizationQueryEncoding_Setting value) {
  if (variant_case() != kSetting) {
    clear_variant();
    set_has_setting();
  }
  _impl_.variant_.setting_ = value;
  // @@protoc_insertion_point(field_set:qdrant.BinaryQuantizationQueryEncoding.setting)
}
inline ::qdrant::BinaryQuantizationQueryEncoding_Setting BinaryQuantizationQueryEncoding::_internal_setting() const {
  if (variant_case() == kSetting) {
    return static_cast<::qdrant::BinaryQuantizationQueryEncoding_Setting>(_impl_.variant_.setting_);
  }
  return static_cast<::qdrant::BinaryQuantizationQueryEncoding_Setting>(0);
}

inline bool BinaryQuantizationQueryEncoding::has_variant() const {
  return variant_case() != VARIANT_NOT_SET;
}
inline void BinaryQuantizationQueryEncoding::clear_has_variant() {
  _impl_._oneof_case_[0] = VARIANT_NOT_SET;
}
inline BinaryQuantizationQueryEncoding::VariantCase BinaryQuantizationQueryEncoding::variant_case() const {
  return BinaryQuantizationQueryEncoding::VariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BinaryQuantization

// optional bool always_ram = 1;
inline bool BinaryQuantization::has_always_ram() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void BinaryQuantization::clear_always_ram() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.always_ram_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool BinaryQuantization::always_ram() const {
  // @@protoc_insertion_point(field_get:qdrant.BinaryQuantization.always_ram)
  return _internal_always_ram();
}
inline void BinaryQuantization::set_always_ram(bool value) {
  _internal_set_always_ram(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.BinaryQuantization.always_ram)
}
inline bool BinaryQuantization::_internal_always_ram() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.always_ram_;
}
inline void BinaryQuantization::_internal_set_always_ram(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.always_ram_ = value;
}

// optional .qdrant.BinaryQuantizationEncoding encoding = 2;
inline bool BinaryQuantization::has_encoding() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void BinaryQuantization::clear_encoding() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encoding_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::qdrant::BinaryQuantizationEncoding BinaryQuantization::encoding() const {
  // @@protoc_insertion_point(field_get:qdrant.BinaryQuantization.encoding)
  return _internal_encoding();
}
inline void BinaryQuantization::set_encoding(::qdrant::BinaryQuantizationEncoding value) {
  _internal_set_encoding(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.BinaryQuantization.encoding)
}
inline ::qdrant::BinaryQuantizationEncoding BinaryQuantization::_internal_encoding() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::BinaryQuantizationEncoding>(_impl_.encoding_);
}
inline void BinaryQuantization::_internal_set_encoding(::qdrant::BinaryQuantizationEncoding value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encoding_ = value;
}

// optional .qdrant.BinaryQuantizationQueryEncoding query_encoding = 3;
inline bool BinaryQuantization::has_query_encoding() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.query_encoding_ != nullptr);
  return value;
}
inline void BinaryQuantization::clear_query_encoding() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.query_encoding_ != nullptr) _impl_.query_encoding_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::BinaryQuantizationQueryEncoding& BinaryQuantization::_internal_query_encoding() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::BinaryQuantizationQueryEncoding* p = _impl_.query_encoding_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::BinaryQuantizationQueryEncoding&>(::qdrant::_BinaryQuantizationQueryEncoding_default_instance_);
}
inline const ::qdrant::BinaryQuantizationQueryEncoding& BinaryQuantization::query_encoding() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.BinaryQuantization.query_encoding)
  return _internal_query_encoding();
}
inline void BinaryQuantization::unsafe_arena_set_allocated_query_encoding(
    ::qdrant::BinaryQuantizationQueryEncoding* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_encoding_);
  }
  _impl_.query_encoding_ = reinterpret_cast<::qdrant::BinaryQuantizationQueryEncoding*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.BinaryQuantization.query_encoding)
}
inline ::qdrant::BinaryQuantizationQueryEncoding* PROTOBUF_NULLABLE BinaryQuantization::release_query_encoding() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::BinaryQuantizationQueryEncoding* released = _impl_.query_encoding_;
  _impl_.query_encoding_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::BinaryQuantizationQueryEncoding* PROTOBUF_NULLABLE BinaryQuantization::unsafe_arena_release_query_encoding() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.BinaryQuantization.query_encoding)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::BinaryQuantizationQueryEncoding* temp = _impl_.query_encoding_;
  _impl_.query_encoding_ = nullptr;
  return temp;
}
inline ::qdrant::BinaryQuantizationQueryEncoding* PROTOBUF_NONNULL BinaryQuantization::_internal_mutable_query_encoding() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.query_encoding_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::BinaryQuantizationQueryEncoding>(GetArena());
    _impl_.query_encoding_ = reinterpret_cast<::qdrant::BinaryQuantizationQueryEncoding*>(p);
  }
  return _impl_.query_encoding_;
}
inline ::qdrant::BinaryQuantizationQueryEncoding* PROTOBUF_NONNULL BinaryQuantization::mutable_query_encoding()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::BinaryQuantizationQueryEncoding* _msg = _internal_mutable_query_encoding();
  // @@protoc_insertion_point(field_mutable:qdrant.BinaryQuantization.query_encoding)
  return _msg;
}
inline void BinaryQuantization::set_allocated_query_encoding(::qdrant::BinaryQuantizationQueryEncoding* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_encoding_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.query_encoding_ = reinterpret_cast<::qdrant::BinaryQuantizationQueryEncoding*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.BinaryQuantization.query_encoding)
}

// -------------------------------------------------------------------

// QuantizationConfig

// .qdrant.ScalarQuantization scalar = 1;
inline bool QuantizationConfig::has_scalar() const {
  return quantization_case() == kScalar;
}
inline bool QuantizationConfig::_internal_has_scalar() const {
  return quantization_case() == kScalar;
}
inline void QuantizationConfig::set_has_scalar() {
  _impl_._oneof_case_[0] = kScalar;
}
inline void QuantizationConfig::clear_scalar() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (quantization_case() == kScalar) {
    if (GetArena() == nullptr) {
      delete _impl_.quantization_.scalar_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.quantization_.scalar_);
    }
    clear_has_quantization();
  }
}
inline ::qdrant::ScalarQuantization* PROTOBUF_NULLABLE QuantizationConfig::release_scalar() {
  // @@protoc_insertion_point(field_release:qdrant.QuantizationConfig.scalar)
  if (quantization_case() == kScalar) {
    clear_has_quantization();
    auto* temp = reinterpret_cast<::qdrant::ScalarQuantization*>(_impl_.quantization_.scalar_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.quantization_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::ScalarQuantization& QuantizationConfig::_internal_scalar() const {
  return quantization_case() == kScalar ? static_cast<const ::qdrant::ScalarQuantization&>(*reinterpret_cast<::qdrant::ScalarQuantization*>(_impl_.quantization_.scalar_))
                     : reinterpret_cast<const ::qdrant::ScalarQuantization&>(::qdrant::_ScalarQuantization_default_instance_);
}
inline const ::qdrant::ScalarQuantization& QuantizationConfig::scalar() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QuantizationConfig.scalar)
  return _internal_scalar();
}
inline ::qdrant::ScalarQuantization* PROTOBUF_NULLABLE QuantizationConfig::unsafe_arena_release_scalar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.QuantizationConfig.scalar)
  if (quantization_case() == kScalar) {
    clear_has_quantization();
    auto* temp = reinterpret_cast<::qdrant::ScalarQuantization*>(_impl_.quantization_.scalar_);
    _impl_.quantization_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QuantizationConfig::unsafe_arena_set_allocated_scalar(
    ::qdrant::ScalarQuantization* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_quantization();
  if (value) {
    set_has_scalar();
    _impl_.quantization_.scalar_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QuantizationConfig.scalar)
}
inline ::qdrant::ScalarQuantization* PROTOBUF_NONNULL QuantizationConfig::_internal_mutable_scalar() {
  if (quantization_case() != kScalar) {
    clear_quantization();
    set_has_scalar();
    _impl_.quantization_.scalar_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::ScalarQuantization>(GetArena()));
  }
  return reinterpret_cast<::qdrant::ScalarQuantization*>(_impl_.quantization_.scalar_);
}
inline ::qdrant::ScalarQuantization* PROTOBUF_NONNULL QuantizationConfig::mutable_scalar()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::ScalarQuantization* _msg = _internal_mutable_scalar();
  // @@protoc_insertion_point(field_mutable:qdrant.QuantizationConfig.scalar)
  return _msg;
}

// .qdrant.ProductQuantization product = 2;
inline bool QuantizationConfig::has_product() const {
  return quantization_case() == kProduct;
}
inline bool QuantizationConfig::_internal_has_product() const {
  return quantization_case() == kProduct;
}
inline void QuantizationConfig::set_has_product() {
  _impl_._oneof_case_[0] = kProduct;
}
inline void QuantizationConfig::clear_product() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (quantization_case() == kProduct) {
    if (GetArena() == nullptr) {
      delete _impl_.quantization_.product_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.quantization_.product_);
    }
    clear_has_quantization();
  }
}
inline ::qdrant::ProductQuantization* PROTOBUF_NULLABLE QuantizationConfig::release_product() {
  // @@protoc_insertion_point(field_release:qdrant.QuantizationConfig.product)
  if (quantization_case() == kProduct) {
    clear_has_quantization();
    auto* temp = reinterpret_cast<::qdrant::ProductQuantization*>(_impl_.quantization_.product_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.quantization_.product_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::ProductQuantization& QuantizationConfig::_internal_product() const {
  return quantization_case() == kProduct ? static_cast<const ::qdrant::ProductQuantization&>(*reinterpret_cast<::qdrant::ProductQuantization*>(_impl_.quantization_.product_))
                     : reinterpret_cast<const ::qdrant::ProductQuantization&>(::qdrant::_ProductQuantization_default_instance_);
}
inline const ::qdrant::ProductQuantization& QuantizationConfig::product() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QuantizationConfig.product)
  return _internal_product();
}
inline ::qdrant::ProductQuantization* PROTOBUF_NULLABLE QuantizationConfig::unsafe_arena_release_product() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.QuantizationConfig.product)
  if (quantization_case() == kProduct) {
    clear_has_quantization();
    auto* temp = reinterpret_cast<::qdrant::ProductQuantization*>(_impl_.quantization_.product_);
    _impl_.quantization_.product_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QuantizationConfig::unsafe_arena_set_allocated_product(
    ::qdrant::ProductQuantization* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_quantization();
  if (value) {
    set_has_product();
    _impl_.quantization_.product_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QuantizationConfig.product)
}
inline ::qdrant::ProductQuantization* PROTOBUF_NONNULL QuantizationConfig::_internal_mutable_product() {
  if (quantization_case() != kProduct) {
    clear_quantization();
    set_has_product();
    _impl_.quantization_.product_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::ProductQuantization>(GetArena()));
  }
  return reinterpret_cast<::qdrant::ProductQuantization*>(_impl_.quantization_.product_);
}
inline ::qdrant::ProductQuantization* PROTOBUF_NONNULL QuantizationConfig::mutable_product()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::ProductQuantization* _msg = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:qdrant.QuantizationConfig.product)
  return _msg;
}

// .qdrant.BinaryQuantization binary = 3;
inline bool QuantizationConfig::has_binary() const {
  return quantization_case() == kBinary;
}
inline bool QuantizationConfig::_internal_has_binary() const {
  return quantization_case() == kBinary;
}
inline void QuantizationConfig::set_has_binary() {
  _impl_._oneof_case_[0] = kBinary;
}
inline void QuantizationConfig::clear_binary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (quantization_case() == kBinary) {
    if (GetArena() == nullptr) {
      delete _impl_.quantization_.binary_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.quantization_.binary_);
    }
    clear_has_quantization();
  }
}
inline ::qdrant::BinaryQuantization* PROTOBUF_NULLABLE QuantizationConfig::release_binary() {
  // @@protoc_insertion_point(field_release:qdrant.QuantizationConfig.binary)
  if (quantization_case() == kBinary) {
    clear_has_quantization();
    auto* temp = reinterpret_cast<::qdrant::BinaryQuantization*>(_impl_.quantization_.binary_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.quantization_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::BinaryQuantization& QuantizationConfig::_internal_binary() const {
  return quantization_case() == kBinary ? static_cast<const ::qdrant::BinaryQuantization&>(*reinterpret_cast<::qdrant::BinaryQuantization*>(_impl_.quantization_.binary_))
                     : reinterpret_cast<const ::qdrant::BinaryQuantization&>(::qdrant::_BinaryQuantization_default_instance_);
}
inline const ::qdrant::BinaryQuantization& QuantizationConfig::binary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QuantizationConfig.binary)
  return _internal_binary();
}
inline ::qdrant::BinaryQuantization* PROTOBUF_NULLABLE QuantizationConfig::unsafe_arena_release_binary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.QuantizationConfig.binary)
  if (quantization_case() == kBinary) {
    clear_has_quantization();
    auto* temp = reinterpret_cast<::qdrant::BinaryQuantization*>(_impl_.quantization_.binary_);
    _impl_.quantization_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QuantizationConfig::unsafe_arena_set_allocated_binary(
    ::qdrant::BinaryQuantization* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_quantization();
  if (value) {
    set_has_binary();
    _impl_.quantization_.binary_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QuantizationConfig.binary)
}
inline ::qdrant::BinaryQuantization* PROTOBUF_NONNULL QuantizationConfig::_internal_mutable_binary() {
  if (quantization_case() != kBinary) {
    clear_quantization();
    set_has_binary();
    _impl_.quantization_.binary_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::BinaryQuantization>(GetArena()));
  }
  return reinterpret_cast<::qdrant::BinaryQuantization*>(_impl_.quantization_.binary_);
}
inline ::qdrant::BinaryQuantization* PROTOBUF_NONNULL QuantizationConfig::mutable_binary()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::BinaryQuantization* _msg = _internal_mutable_binary();
  // @@protoc_insertion_point(field_mutable:qdrant.QuantizationConfig.binary)
  return _msg;
}

inline bool QuantizationConfig::has_quantization() const {
  return quantization_case() != QUANTIZATION_NOT_SET;
}
inline void QuantizationConfig::clear_has_quantization() {
  _impl_._oneof_case_[0] = QUANTIZATION_NOT_SET;
}
inline QuantizationConfig::QuantizationCase QuantizationConfig::quantization_case() const {
  return QuantizationConfig::QuantizationCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Disabled

// -------------------------------------------------------------------

// QuantizationConfigDiff

// .qdrant.ScalarQuantization scalar = 1;
inline bool QuantizationConfigDiff::has_scalar() const {
  return quantization_case() == kScalar;
}
inline bool QuantizationConfigDiff::_internal_has_scalar() const {
  return quantization_case() == kScalar;
}
inline void QuantizationConfigDiff::set_has_scalar() {
  _impl_._oneof_case_[0] = kScalar;
}
inline void QuantizationConfigDiff::clear_scalar() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (quantization_case() == kScalar) {
    if (GetArena() == nullptr) {
      delete _impl_.quantization_.scalar_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.quantization_.scalar_);
    }
    clear_has_quantization();
  }
}
inline ::qdrant::ScalarQuantization* PROTOBUF_NULLABLE QuantizationConfigDiff::release_scalar() {
  // @@protoc_insertion_point(field_release:qdrant.QuantizationConfigDiff.scalar)
  if (quantization_case() == kScalar) {
    clear_has_quantization();
    auto* temp = reinterpret_cast<::qdrant::ScalarQuantization*>(_impl_.quantization_.scalar_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.quantization_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::ScalarQuantization& QuantizationConfigDiff::_internal_scalar() const {
  return quantization_case() == kScalar ? static_cast<const ::qdrant::ScalarQuantization&>(*reinterpret_cast<::qdrant::ScalarQuantization*>(_impl_.quantization_.scalar_))
                     : reinterpret_cast<const ::qdrant::ScalarQuantization&>(::qdrant::_ScalarQuantization_default_instance_);
}
inline const ::qdrant::ScalarQuantization& QuantizationConfigDiff::scalar() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QuantizationConfigDiff.scalar)
  return _internal_scalar();
}
inline ::qdrant::ScalarQuantization* PROTOBUF_NULLABLE QuantizationConfigDiff::unsafe_arena_release_scalar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.QuantizationConfigDiff.scalar)
  if (quantization_case() == kScalar) {
    clear_has_quantization();
    auto* temp = reinterpret_cast<::qdrant::ScalarQuantization*>(_impl_.quantization_.scalar_);
    _impl_.quantization_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QuantizationConfigDiff::unsafe_arena_set_allocated_scalar(
    ::qdrant::ScalarQuantization* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_quantization();
  if (value) {
    set_has_scalar();
    _impl_.quantization_.scalar_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QuantizationConfigDiff.scalar)
}
inline ::qdrant::ScalarQuantization* PROTOBUF_NONNULL QuantizationConfigDiff::_internal_mutable_scalar() {
  if (quantization_case() != kScalar) {
    clear_quantization();
    set_has_scalar();
    _impl_.quantization_.scalar_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::ScalarQuantization>(GetArena()));
  }
  return reinterpret_cast<::qdrant::ScalarQuantization*>(_impl_.quantization_.scalar_);
}
inline ::qdrant::ScalarQuantization* PROTOBUF_NONNULL QuantizationConfigDiff::mutable_scalar()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::ScalarQuantization* _msg = _internal_mutable_scalar();
  // @@protoc_insertion_point(field_mutable:qdrant.QuantizationConfigDiff.scalar)
  return _msg;
}

// .qdrant.ProductQuantization product = 2;
inline bool QuantizationConfigDiff::has_product() const {
  return quantization_case() == kProduct;
}
inline bool QuantizationConfigDiff::_internal_has_product() const {
  return quantization_case() == kProduct;
}
inline void QuantizationConfigDiff::set_has_product() {
  _impl_._oneof_case_[0] = kProduct;
}
inline void QuantizationConfigDiff::clear_product() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (quantization_case() == kProduct) {
    if (GetArena() == nullptr) {
      delete _impl_.quantization_.product_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.quantization_.product_);
    }
    clear_has_quantization();
  }
}
inline ::qdrant::ProductQuantization* PROTOBUF_NULLABLE QuantizationConfigDiff::release_product() {
  // @@protoc_insertion_point(field_release:qdrant.QuantizationConfigDiff.product)
  if (quantization_case() == kProduct) {
    clear_has_quantization();
    auto* temp = reinterpret_cast<::qdrant::ProductQuantization*>(_impl_.quantization_.product_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.quantization_.product_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::ProductQuantization& QuantizationConfigDiff::_internal_product() const {
  return quantization_case() == kProduct ? static_cast<const ::qdrant::ProductQuantization&>(*reinterpret_cast<::qdrant::ProductQuantization*>(_impl_.quantization_.product_))
                     : reinterpret_cast<const ::qdrant::ProductQuantization&>(::qdrant::_ProductQuantization_default_instance_);
}
inline const ::qdrant::ProductQuantization& QuantizationConfigDiff::product() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QuantizationConfigDiff.product)
  return _internal_product();
}
inline ::qdrant::ProductQuantization* PROTOBUF_NULLABLE QuantizationConfigDiff::unsafe_arena_release_product() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.QuantizationConfigDiff.product)
  if (quantization_case() == kProduct) {
    clear_has_quantization();
    auto* temp = reinterpret_cast<::qdrant::ProductQuantization*>(_impl_.quantization_.product_);
    _impl_.quantization_.product_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QuantizationConfigDiff::unsafe_arena_set_allocated_product(
    ::qdrant::ProductQuantization* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_quantization();
  if (value) {
    set_has_product();
    _impl_.quantization_.product_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QuantizationConfigDiff.product)
}
inline ::qdrant::ProductQuantization* PROTOBUF_NONNULL QuantizationConfigDiff::_internal_mutable_product() {
  if (quantization_case() != kProduct) {
    clear_quantization();
    set_has_product();
    _impl_.quantization_.product_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::ProductQuantization>(GetArena()));
  }
  return reinterpret_cast<::qdrant::ProductQuantization*>(_impl_.quantization_.product_);
}
inline ::qdrant::ProductQuantization* PROTOBUF_NONNULL QuantizationConfigDiff::mutable_product()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::ProductQuantization* _msg = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:qdrant.QuantizationConfigDiff.product)
  return _msg;
}

// .qdrant.Disabled disabled = 3;
inline bool QuantizationConfigDiff::has_disabled() const {
  return quantization_case() == kDisabled;
}
inline bool QuantizationConfigDiff::_internal_has_disabled() const {
  return quantization_case() == kDisabled;
}
inline void QuantizationConfigDiff::set_has_disabled() {
  _impl_._oneof_case_[0] = kDisabled;
}
inline void QuantizationConfigDiff::clear_disabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (quantization_case() == kDisabled) {
    if (GetArena() == nullptr) {
      delete _impl_.quantization_.disabled_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.quantization_.disabled_);
    }
    clear_has_quantization();
  }
}
inline ::qdrant::Disabled* PROTOBUF_NULLABLE QuantizationConfigDiff::release_disabled() {
  // @@protoc_insertion_point(field_release:qdrant.QuantizationConfigDiff.disabled)
  if (quantization_case() == kDisabled) {
    clear_has_quantization();
    auto* temp = reinterpret_cast<::qdrant::Disabled*>(_impl_.quantization_.disabled_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.quantization_.disabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Disabled& QuantizationConfigDiff::_internal_disabled() const {
  return quantization_case() == kDisabled ? static_cast<const ::qdrant::Disabled&>(*reinterpret_cast<::qdrant::Disabled*>(_impl_.quantization_.disabled_))
                     : reinterpret_cast<const ::qdrant::Disabled&>(::qdrant::_Disabled_default_instance_);
}
inline const ::qdrant::Disabled& QuantizationConfigDiff::disabled() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QuantizationConfigDiff.disabled)
  return _internal_disabled();
}
inline ::qdrant::Disabled* PROTOBUF_NULLABLE QuantizationConfigDiff::unsafe_arena_release_disabled() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.QuantizationConfigDiff.disabled)
  if (quantization_case() == kDisabled) {
    clear_has_quantization();
    auto* temp = reinterpret_cast<::qdrant::Disabled*>(_impl_.quantization_.disabled_);
    _impl_.quantization_.disabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QuantizationConfigDiff::unsafe_arena_set_allocated_disabled(
    ::qdrant::Disabled* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_quantization();
  if (value) {
    set_has_disabled();
    _impl_.quantization_.disabled_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QuantizationConfigDiff.disabled)
}
inline ::qdrant::Disabled* PROTOBUF_NONNULL QuantizationConfigDiff::_internal_mutable_disabled() {
  if (quantization_case() != kDisabled) {
    clear_quantization();
    set_has_disabled();
    _impl_.quantization_.disabled_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Disabled>(GetArena()));
  }
  return reinterpret_cast<::qdrant::Disabled*>(_impl_.quantization_.disabled_);
}
inline ::qdrant::Disabled* PROTOBUF_NONNULL QuantizationConfigDiff::mutable_disabled()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Disabled* _msg = _internal_mutable_disabled();
  // @@protoc_insertion_point(field_mutable:qdrant.QuantizationConfigDiff.disabled)
  return _msg;
}

// .qdrant.BinaryQuantization binary = 4;
inline bool QuantizationConfigDiff::has_binary() const {
  return quantization_case() == kBinary;
}
inline bool QuantizationConfigDiff::_internal_has_binary() const {
  return quantization_case() == kBinary;
}
inline void QuantizationConfigDiff::set_has_binary() {
  _impl_._oneof_case_[0] = kBinary;
}
inline void QuantizationConfigDiff::clear_binary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (quantization_case() == kBinary) {
    if (GetArena() == nullptr) {
      delete _impl_.quantization_.binary_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.quantization_.binary_);
    }
    clear_has_quantization();
  }
}
inline ::qdrant::BinaryQuantization* PROTOBUF_NULLABLE QuantizationConfigDiff::release_binary() {
  // @@protoc_insertion_point(field_release:qdrant.QuantizationConfigDiff.binary)
  if (quantization_case() == kBinary) {
    clear_has_quantization();
    auto* temp = reinterpret_cast<::qdrant::BinaryQuantization*>(_impl_.quantization_.binary_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.quantization_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::BinaryQuantization& QuantizationConfigDiff::_internal_binary() const {
  return quantization_case() == kBinary ? static_cast<const ::qdrant::BinaryQuantization&>(*reinterpret_cast<::qdrant::BinaryQuantization*>(_impl_.quantization_.binary_))
                     : reinterpret_cast<const ::qdrant::BinaryQuantization&>(::qdrant::_BinaryQuantization_default_instance_);
}
inline const ::qdrant::BinaryQuantization& QuantizationConfigDiff::binary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.QuantizationConfigDiff.binary)
  return _internal_binary();
}
inline ::qdrant::BinaryQuantization* PROTOBUF_NULLABLE QuantizationConfigDiff::unsafe_arena_release_binary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.QuantizationConfigDiff.binary)
  if (quantization_case() == kBinary) {
    clear_has_quantization();
    auto* temp = reinterpret_cast<::qdrant::BinaryQuantization*>(_impl_.quantization_.binary_);
    _impl_.quantization_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QuantizationConfigDiff::unsafe_arena_set_allocated_binary(
    ::qdrant::BinaryQuantization* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_quantization();
  if (value) {
    set_has_binary();
    _impl_.quantization_.binary_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.QuantizationConfigDiff.binary)
}
inline ::qdrant::BinaryQuantization* PROTOBUF_NONNULL QuantizationConfigDiff::_internal_mutable_binary() {
  if (quantization_case() != kBinary) {
    clear_quantization();
    set_has_binary();
    _impl_.quantization_.binary_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::BinaryQuantization>(GetArena()));
  }
  return reinterpret_cast<::qdrant::BinaryQuantization*>(_impl_.quantization_.binary_);
}
inline ::qdrant::BinaryQuantization* PROTOBUF_NONNULL QuantizationConfigDiff::mutable_binary()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::BinaryQuantization* _msg = _internal_mutable_binary();
  // @@protoc_insertion_point(field_mutable:qdrant.QuantizationConfigDiff.binary)
  return _msg;
}

inline bool QuantizationConfigDiff::has_quantization() const {
  return quantization_case() != QUANTIZATION_NOT_SET;
}
inline void QuantizationConfigDiff::clear_has_quantization() {
  _impl_._oneof_case_[0] = QUANTIZATION_NOT_SET;
}
inline QuantizationConfigDiff::QuantizationCase QuantizationConfigDiff::quantization_case() const {
  return QuantizationConfigDiff::QuantizationCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StrictModeConfig

// optional bool enabled = 1;
inline bool StrictModeConfig::has_enabled() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void StrictModeConfig::clear_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool StrictModeConfig::enabled() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.enabled)
  return _internal_enabled();
}
inline void StrictModeConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeConfig.enabled)
}
inline bool StrictModeConfig::_internal_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enabled_;
}
inline void StrictModeConfig::_internal_set_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = value;
}

// optional uint32 max_query_limit = 2;
inline bool StrictModeConfig::has_max_query_limit() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void StrictModeConfig::clear_max_query_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_query_limit_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint32_t StrictModeConfig::max_query_limit() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.max_query_limit)
  return _internal_max_query_limit();
}
inline void StrictModeConfig::set_max_query_limit(::uint32_t value) {
  _internal_set_max_query_limit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeConfig.max_query_limit)
}
inline ::uint32_t StrictModeConfig::_internal_max_query_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_query_limit_;
}
inline void StrictModeConfig::_internal_set_max_query_limit(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_query_limit_ = value;
}

// optional uint32 max_timeout = 3;
inline bool StrictModeConfig::has_max_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void StrictModeConfig::clear_max_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_timeout_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint32_t StrictModeConfig::max_timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.max_timeout)
  return _internal_max_timeout();
}
inline void StrictModeConfig::set_max_timeout(::uint32_t value) {
  _internal_set_max_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeConfig.max_timeout)
}
inline ::uint32_t StrictModeConfig::_internal_max_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_timeout_;
}
inline void StrictModeConfig::_internal_set_max_timeout(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_timeout_ = value;
}

// optional bool unindexed_filtering_retrieve = 4;
inline bool StrictModeConfig::has_unindexed_filtering_retrieve() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void StrictModeConfig::clear_unindexed_filtering_retrieve() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unindexed_filtering_retrieve_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool StrictModeConfig::unindexed_filtering_retrieve() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.unindexed_filtering_retrieve)
  return _internal_unindexed_filtering_retrieve();
}
inline void StrictModeConfig::set_unindexed_filtering_retrieve(bool value) {
  _internal_set_unindexed_filtering_retrieve(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeConfig.unindexed_filtering_retrieve)
}
inline bool StrictModeConfig::_internal_unindexed_filtering_retrieve() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unindexed_filtering_retrieve_;
}
inline void StrictModeConfig::_internal_set_unindexed_filtering_retrieve(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unindexed_filtering_retrieve_ = value;
}

// optional bool unindexed_filtering_update = 5;
inline bool StrictModeConfig::has_unindexed_filtering_update() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  return value;
}
inline void StrictModeConfig::clear_unindexed_filtering_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unindexed_filtering_update_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline bool StrictModeConfig::unindexed_filtering_update() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.unindexed_filtering_update)
  return _internal_unindexed_filtering_update();
}
inline void StrictModeConfig::set_unindexed_filtering_update(bool value) {
  _internal_set_unindexed_filtering_update(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeConfig.unindexed_filtering_update)
}
inline bool StrictModeConfig::_internal_unindexed_filtering_update() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unindexed_filtering_update_;
}
inline void StrictModeConfig::_internal_set_unindexed_filtering_update(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unindexed_filtering_update_ = value;
}

// optional uint32 search_max_hnsw_ef = 6;
inline bool StrictModeConfig::has_search_max_hnsw_ef() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000100U);
  return value;
}
inline void StrictModeConfig::clear_search_max_hnsw_ef() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.search_max_hnsw_ef_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline ::uint32_t StrictModeConfig::search_max_hnsw_ef() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.search_max_hnsw_ef)
  return _internal_search_max_hnsw_ef();
}
inline void StrictModeConfig::set_search_max_hnsw_ef(::uint32_t value) {
  _internal_set_search_max_hnsw_ef(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeConfig.search_max_hnsw_ef)
}
inline ::uint32_t StrictModeConfig::_internal_search_max_hnsw_ef() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.search_max_hnsw_ef_;
}
inline void StrictModeConfig::_internal_set_search_max_hnsw_ef(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.search_max_hnsw_ef_ = value;
}

// optional bool search_allow_exact = 7;
inline bool StrictModeConfig::has_search_allow_exact() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  return value;
}
inline void StrictModeConfig::clear_search_allow_exact() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.search_allow_exact_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline bool StrictModeConfig::search_allow_exact() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.search_allow_exact)
  return _internal_search_allow_exact();
}
inline void StrictModeConfig::set_search_allow_exact(bool value) {
  _internal_set_search_allow_exact(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeConfig.search_allow_exact)
}
inline bool StrictModeConfig::_internal_search_allow_exact() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.search_allow_exact_;
}
inline void StrictModeConfig::_internal_set_search_allow_exact(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.search_allow_exact_ = value;
}

// optional float search_max_oversampling = 8;
inline bool StrictModeConfig::has_search_max_oversampling() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000400U);
  return value;
}
inline void StrictModeConfig::clear_search_max_oversampling() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.search_max_oversampling_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000400U);
}
inline float StrictModeConfig::search_max_oversampling() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.search_max_oversampling)
  return _internal_search_max_oversampling();
}
inline void StrictModeConfig::set_search_max_oversampling(float value) {
  _internal_set_search_max_oversampling(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeConfig.search_max_oversampling)
}
inline float StrictModeConfig::_internal_search_max_oversampling() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.search_max_oversampling_;
}
inline void StrictModeConfig::_internal_set_search_max_oversampling(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.search_max_oversampling_ = value;
}

// optional uint64 upsert_max_batchsize = 9;
inline bool StrictModeConfig::has_upsert_max_batchsize() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000200U);
  return value;
}
inline void StrictModeConfig::clear_upsert_max_batchsize() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.upsert_max_batchsize_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000200U);
}
inline ::uint64_t StrictModeConfig::upsert_max_batchsize() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.upsert_max_batchsize)
  return _internal_upsert_max_batchsize();
}
inline void StrictModeConfig::set_upsert_max_batchsize(::uint64_t value) {
  _internal_set_upsert_max_batchsize(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeConfig.upsert_max_batchsize)
}
inline ::uint64_t StrictModeConfig::_internal_upsert_max_batchsize() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.upsert_max_batchsize_;
}
inline void StrictModeConfig::_internal_set_upsert_max_batchsize(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.upsert_max_batchsize_ = value;
}

// optional uint64 max_collection_vector_size_bytes = 10;
inline bool StrictModeConfig::has_max_collection_vector_size_bytes() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00001000U);
  return value;
}
inline void StrictModeConfig::clear_max_collection_vector_size_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_collection_vector_size_bytes_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00001000U);
}
inline ::uint64_t StrictModeConfig::max_collection_vector_size_bytes() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.max_collection_vector_size_bytes)
  return _internal_max_collection_vector_size_bytes();
}
inline void StrictModeConfig::set_max_collection_vector_size_bytes(::uint64_t value) {
  _internal_set_max_collection_vector_size_bytes(value);
  SetHasBit(_impl_._has_bits_[0], 0x00001000U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeConfig.max_collection_vector_size_bytes)
}
inline ::uint64_t StrictModeConfig::_internal_max_collection_vector_size_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_collection_vector_size_bytes_;
}
inline void StrictModeConfig::_internal_set_max_collection_vector_size_bytes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_collection_vector_size_bytes_ = value;
}

// optional uint32 read_rate_limit = 11;
inline bool StrictModeConfig::has_read_rate_limit() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000800U);
  return value;
}
inline void StrictModeConfig::clear_read_rate_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.read_rate_limit_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000800U);
}
inline ::uint32_t StrictModeConfig::read_rate_limit() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.read_rate_limit)
  return _internal_read_rate_limit();
}
inline void StrictModeConfig::set_read_rate_limit(::uint32_t value) {
  _internal_set_read_rate_limit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeConfig.read_rate_limit)
}
inline ::uint32_t StrictModeConfig::_internal_read_rate_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.read_rate_limit_;
}
inline void StrictModeConfig::_internal_set_read_rate_limit(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.read_rate_limit_ = value;
}

// optional uint32 write_rate_limit = 12;
inline bool StrictModeConfig::has_write_rate_limit() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00040000U);
  return value;
}
inline void StrictModeConfig::clear_write_rate_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.write_rate_limit_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00040000U);
}
inline ::uint32_t StrictModeConfig::write_rate_limit() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.write_rate_limit)
  return _internal_write_rate_limit();
}
inline void StrictModeConfig::set_write_rate_limit(::uint32_t value) {
  _internal_set_write_rate_limit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00040000U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeConfig.write_rate_limit)
}
inline ::uint32_t StrictModeConfig::_internal_write_rate_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.write_rate_limit_;
}
inline void StrictModeConfig::_internal_set_write_rate_limit(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.write_rate_limit_ = value;
}

// optional uint64 max_collection_payload_size_bytes = 13;
inline bool StrictModeConfig::has_max_collection_payload_size_bytes() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00002000U);
  return value;
}
inline void StrictModeConfig::clear_max_collection_payload_size_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_collection_payload_size_bytes_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00002000U);
}
inline ::uint64_t StrictModeConfig::max_collection_payload_size_bytes() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.max_collection_payload_size_bytes)
  return _internal_max_collection_payload_size_bytes();
}
inline void StrictModeConfig::set_max_collection_payload_size_bytes(::uint64_t value) {
  _internal_set_max_collection_payload_size_bytes(value);
  SetHasBit(_impl_._has_bits_[0], 0x00002000U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeConfig.max_collection_payload_size_bytes)
}
inline ::uint64_t StrictModeConfig::_internal_max_collection_payload_size_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_collection_payload_size_bytes_;
}
inline void StrictModeConfig::_internal_set_max_collection_payload_size_bytes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_collection_payload_size_bytes_ = value;
}

// optional uint64 filter_max_conditions = 14;
inline bool StrictModeConfig::has_filter_max_conditions() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00004000U);
  return value;
}
inline void StrictModeConfig::clear_filter_max_conditions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_max_conditions_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00004000U);
}
inline ::uint64_t StrictModeConfig::filter_max_conditions() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.filter_max_conditions)
  return _internal_filter_max_conditions();
}
inline void StrictModeConfig::set_filter_max_conditions(::uint64_t value) {
  _internal_set_filter_max_conditions(value);
  SetHasBit(_impl_._has_bits_[0], 0x00004000U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeConfig.filter_max_conditions)
}
inline ::uint64_t StrictModeConfig::_internal_filter_max_conditions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filter_max_conditions_;
}
inline void StrictModeConfig::_internal_set_filter_max_conditions(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_max_conditions_ = value;
}

// optional uint64 condition_max_size = 15;
inline bool StrictModeConfig::has_condition_max_size() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00008000U);
  return value;
}
inline void StrictModeConfig::clear_condition_max_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.condition_max_size_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00008000U);
}
inline ::uint64_t StrictModeConfig::condition_max_size() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.condition_max_size)
  return _internal_condition_max_size();
}
inline void StrictModeConfig::set_condition_max_size(::uint64_t value) {
  _internal_set_condition_max_size(value);
  SetHasBit(_impl_._has_bits_[0], 0x00008000U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeConfig.condition_max_size)
}
inline ::uint64_t StrictModeConfig::_internal_condition_max_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.condition_max_size_;
}
inline void StrictModeConfig::_internal_set_condition_max_size(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.condition_max_size_ = value;
}

// optional .qdrant.StrictModeMultivectorConfig multivector_config = 16;
inline bool StrictModeConfig::has_multivector_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.multivector_config_ != nullptr);
  return value;
}
inline void StrictModeConfig::clear_multivector_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.multivector_config_ != nullptr) _impl_.multivector_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::StrictModeMultivectorConfig& StrictModeConfig::_internal_multivector_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::StrictModeMultivectorConfig* p = _impl_.multivector_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::StrictModeMultivectorConfig&>(::qdrant::_StrictModeMultivectorConfig_default_instance_);
}
inline const ::qdrant::StrictModeMultivectorConfig& StrictModeConfig::multivector_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.multivector_config)
  return _internal_multivector_config();
}
inline void StrictModeConfig::unsafe_arena_set_allocated_multivector_config(
    ::qdrant::StrictModeMultivectorConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.multivector_config_);
  }
  _impl_.multivector_config_ = reinterpret_cast<::qdrant::StrictModeMultivectorConfig*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.StrictModeConfig.multivector_config)
}
inline ::qdrant::StrictModeMultivectorConfig* PROTOBUF_NULLABLE StrictModeConfig::release_multivector_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::StrictModeMultivectorConfig* released = _impl_.multivector_config_;
  _impl_.multivector_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::StrictModeMultivectorConfig* PROTOBUF_NULLABLE StrictModeConfig::unsafe_arena_release_multivector_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.StrictModeConfig.multivector_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::StrictModeMultivectorConfig* temp = _impl_.multivector_config_;
  _impl_.multivector_config_ = nullptr;
  return temp;
}
inline ::qdrant::StrictModeMultivectorConfig* PROTOBUF_NONNULL StrictModeConfig::_internal_mutable_multivector_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.multivector_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::StrictModeMultivectorConfig>(GetArena());
    _impl_.multivector_config_ = reinterpret_cast<::qdrant::StrictModeMultivectorConfig*>(p);
  }
  return _impl_.multivector_config_;
}
inline ::qdrant::StrictModeMultivectorConfig* PROTOBUF_NONNULL StrictModeConfig::mutable_multivector_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::StrictModeMultivectorConfig* _msg = _internal_mutable_multivector_config();
  // @@protoc_insertion_point(field_mutable:qdrant.StrictModeConfig.multivector_config)
  return _msg;
}
inline void StrictModeConfig::set_allocated_multivector_config(::qdrant::StrictModeMultivectorConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.multivector_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.multivector_config_ = reinterpret_cast<::qdrant::StrictModeMultivectorConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.StrictModeConfig.multivector_config)
}

// optional .qdrant.StrictModeSparseConfig sparse_config = 17;
inline bool StrictModeConfig::has_sparse_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.sparse_config_ != nullptr);
  return value;
}
inline void StrictModeConfig::clear_sparse_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sparse_config_ != nullptr) _impl_.sparse_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::StrictModeSparseConfig& StrictModeConfig::_internal_sparse_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::StrictModeSparseConfig* p = _impl_.sparse_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::StrictModeSparseConfig&>(::qdrant::_StrictModeSparseConfig_default_instance_);
}
inline const ::qdrant::StrictModeSparseConfig& StrictModeConfig::sparse_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.sparse_config)
  return _internal_sparse_config();
}
inline void StrictModeConfig::unsafe_arena_set_allocated_sparse_config(
    ::qdrant::StrictModeSparseConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sparse_config_);
  }
  _impl_.sparse_config_ = reinterpret_cast<::qdrant::StrictModeSparseConfig*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.StrictModeConfig.sparse_config)
}
inline ::qdrant::StrictModeSparseConfig* PROTOBUF_NULLABLE StrictModeConfig::release_sparse_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::StrictModeSparseConfig* released = _impl_.sparse_config_;
  _impl_.sparse_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::StrictModeSparseConfig* PROTOBUF_NULLABLE StrictModeConfig::unsafe_arena_release_sparse_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.StrictModeConfig.sparse_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::StrictModeSparseConfig* temp = _impl_.sparse_config_;
  _impl_.sparse_config_ = nullptr;
  return temp;
}
inline ::qdrant::StrictModeSparseConfig* PROTOBUF_NONNULL StrictModeConfig::_internal_mutable_sparse_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sparse_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::StrictModeSparseConfig>(GetArena());
    _impl_.sparse_config_ = reinterpret_cast<::qdrant::StrictModeSparseConfig*>(p);
  }
  return _impl_.sparse_config_;
}
inline ::qdrant::StrictModeSparseConfig* PROTOBUF_NONNULL StrictModeConfig::mutable_sparse_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::StrictModeSparseConfig* _msg = _internal_mutable_sparse_config();
  // @@protoc_insertion_point(field_mutable:qdrant.StrictModeConfig.sparse_config)
  return _msg;
}
inline void StrictModeConfig::set_allocated_sparse_config(::qdrant::StrictModeSparseConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sparse_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.sparse_config_ = reinterpret_cast<::qdrant::StrictModeSparseConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.StrictModeConfig.sparse_config)
}

// optional uint64 max_points_count = 18;
inline bool StrictModeConfig::has_max_points_count() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00010000U);
  return value;
}
inline void StrictModeConfig::clear_max_points_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_points_count_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00010000U);
}
inline ::uint64_t StrictModeConfig::max_points_count() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.max_points_count)
  return _internal_max_points_count();
}
inline void StrictModeConfig::set_max_points_count(::uint64_t value) {
  _internal_set_max_points_count(value);
  SetHasBit(_impl_._has_bits_[0], 0x00010000U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeConfig.max_points_count)
}
inline ::uint64_t StrictModeConfig::_internal_max_points_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_points_count_;
}
inline void StrictModeConfig::_internal_set_max_points_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_points_count_ = value;
}

// optional uint64 max_payload_index_count = 19;
inline bool StrictModeConfig::has_max_payload_index_count() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00020000U);
  return value;
}
inline void StrictModeConfig::clear_max_payload_index_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_payload_index_count_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00020000U);
}
inline ::uint64_t StrictModeConfig::max_payload_index_count() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeConfig.max_payload_index_count)
  return _internal_max_payload_index_count();
}
inline void StrictModeConfig::set_max_payload_index_count(::uint64_t value) {
  _internal_set_max_payload_index_count(value);
  SetHasBit(_impl_._has_bits_[0], 0x00020000U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeConfig.max_payload_index_count)
}
inline ::uint64_t StrictModeConfig::_internal_max_payload_index_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_payload_index_count_;
}
inline void StrictModeConfig::_internal_set_max_payload_index_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_payload_index_count_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StrictModeSparseConfig

// map<string, .qdrant.StrictModeSparse> sparse_config = 1;
inline int StrictModeSparseConfig::_internal_sparse_config_size() const {
  return _internal_sparse_config().size();
}
inline int StrictModeSparseConfig::sparse_config_size() const {
  return _internal_sparse_config_size();
}
inline void StrictModeSparseConfig::clear_sparse_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sparse_config_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::StrictModeSparse>& StrictModeSparseConfig::_internal_sparse_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sparse_config_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::StrictModeSparse>& StrictModeSparseConfig::sparse_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.StrictModeSparseConfig.sparse_config)
  return _internal_sparse_config();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::StrictModeSparse>* PROTOBUF_NONNULL StrictModeSparseConfig::_internal_mutable_sparse_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sparse_config_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::StrictModeSparse>* PROTOBUF_NONNULL StrictModeSparseConfig::mutable_sparse_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.StrictModeSparseConfig.sparse_config)
  return _internal_mutable_sparse_config();
}

// -------------------------------------------------------------------

// StrictModeSparse

// optional uint64 max_length = 10;
inline bool StrictModeSparse::has_max_length() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void StrictModeSparse::clear_max_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_length_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t StrictModeSparse::max_length() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeSparse.max_length)
  return _internal_max_length();
}
inline void StrictModeSparse::set_max_length(::uint64_t value) {
  _internal_set_max_length(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeSparse.max_length)
}
inline ::uint64_t StrictModeSparse::_internal_max_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_length_;
}
inline void StrictModeSparse::_internal_set_max_length(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_length_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StrictModeMultivectorConfig

// map<string, .qdrant.StrictModeMultivector> multivector_config = 1;
inline int StrictModeMultivectorConfig::_internal_multivector_config_size() const {
  return _internal_multivector_config().size();
}
inline int StrictModeMultivectorConfig::multivector_config_size() const {
  return _internal_multivector_config_size();
}
inline void StrictModeMultivectorConfig::clear_multivector_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.multivector_config_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::StrictModeMultivector>& StrictModeMultivectorConfig::_internal_multivector_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.multivector_config_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::StrictModeMultivector>& StrictModeMultivectorConfig::multivector_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.StrictModeMultivectorConfig.multivector_config)
  return _internal_multivector_config();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::StrictModeMultivector>* PROTOBUF_NONNULL StrictModeMultivectorConfig::_internal_mutable_multivector_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.multivector_config_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::StrictModeMultivector>* PROTOBUF_NONNULL StrictModeMultivectorConfig::mutable_multivector_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.StrictModeMultivectorConfig.multivector_config)
  return _internal_mutable_multivector_config();
}

// -------------------------------------------------------------------

// StrictModeMultivector

// optional uint64 max_vectors = 1;
inline bool StrictModeMultivector::has_max_vectors() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void StrictModeMultivector::clear_max_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_vectors_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t StrictModeMultivector::max_vectors() const {
  // @@protoc_insertion_point(field_get:qdrant.StrictModeMultivector.max_vectors)
  return _internal_max_vectors();
}
inline void StrictModeMultivector::set_max_vectors(::uint64_t value) {
  _internal_set_max_vectors(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.StrictModeMultivector.max_vectors)
}
inline ::uint64_t StrictModeMultivector::_internal_max_vectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_vectors_;
}
inline void StrictModeMultivector::_internal_set_max_vectors(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_vectors_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateCollection

// string collection_name = 1;
inline void CreateCollection::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& CreateCollection::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateCollection.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CreateCollection::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.CreateCollection.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL CreateCollection::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateCollection.collection_name)
  return _s;
}
inline const ::std::string& CreateCollection::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void CreateCollection::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CreateCollection::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CreateCollection::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateCollection.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void CreateCollection::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateCollection.collection_name)
}

// optional .qdrant.HnswConfigDiff hnsw_config = 4;
inline bool CreateCollection::has_hnsw_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.hnsw_config_ != nullptr);
  return value;
}
inline void CreateCollection::clear_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hnsw_config_ != nullptr) _impl_.hnsw_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::HnswConfigDiff& CreateCollection::_internal_hnsw_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::HnswConfigDiff* p = _impl_.hnsw_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::HnswConfigDiff&>(::qdrant::_HnswConfigDiff_default_instance_);
}
inline const ::qdrant::HnswConfigDiff& CreateCollection::hnsw_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateCollection.hnsw_config)
  return _internal_hnsw_config();
}
inline void CreateCollection::unsafe_arena_set_allocated_hnsw_config(
    ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hnsw_config_);
  }
  _impl_.hnsw_config_ = reinterpret_cast<::qdrant::HnswConfigDiff*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CreateCollection.hnsw_config)
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE CreateCollection::release_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::HnswConfigDiff* released = _impl_.hnsw_config_;
  _impl_.hnsw_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE CreateCollection::unsafe_arena_release_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateCollection.hnsw_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::HnswConfigDiff* temp = _impl_.hnsw_config_;
  _impl_.hnsw_config_ = nullptr;
  return temp;
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL CreateCollection::_internal_mutable_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hnsw_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::HnswConfigDiff>(GetArena());
    _impl_.hnsw_config_ = reinterpret_cast<::qdrant::HnswConfigDiff*>(p);
  }
  return _impl_.hnsw_config_;
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL CreateCollection::mutable_hnsw_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::HnswConfigDiff* _msg = _internal_mutable_hnsw_config();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateCollection.hnsw_config)
  return _msg;
}
inline void CreateCollection::set_allocated_hnsw_config(::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hnsw_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.hnsw_config_ = reinterpret_cast<::qdrant::HnswConfigDiff*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateCollection.hnsw_config)
}

// optional .qdrant.WalConfigDiff wal_config = 5;
inline bool CreateCollection::has_wal_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.wal_config_ != nullptr);
  return value;
}
inline void CreateCollection::clear_wal_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.wal_config_ != nullptr) _impl_.wal_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::WalConfigDiff& CreateCollection::_internal_wal_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WalConfigDiff* p = _impl_.wal_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WalConfigDiff&>(::qdrant::_WalConfigDiff_default_instance_);
}
inline const ::qdrant::WalConfigDiff& CreateCollection::wal_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateCollection.wal_config)
  return _internal_wal_config();
}
inline void CreateCollection::unsafe_arena_set_allocated_wal_config(
    ::qdrant::WalConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.wal_config_);
  }
  _impl_.wal_config_ = reinterpret_cast<::qdrant::WalConfigDiff*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CreateCollection.wal_config)
}
inline ::qdrant::WalConfigDiff* PROTOBUF_NULLABLE CreateCollection::release_wal_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WalConfigDiff* released = _impl_.wal_config_;
  _impl_.wal_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WalConfigDiff* PROTOBUF_NULLABLE CreateCollection::unsafe_arena_release_wal_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateCollection.wal_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WalConfigDiff* temp = _impl_.wal_config_;
  _impl_.wal_config_ = nullptr;
  return temp;
}
inline ::qdrant::WalConfigDiff* PROTOBUF_NONNULL CreateCollection::_internal_mutable_wal_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.wal_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WalConfigDiff>(GetArena());
    _impl_.wal_config_ = reinterpret_cast<::qdrant::WalConfigDiff*>(p);
  }
  return _impl_.wal_config_;
}
inline ::qdrant::WalConfigDiff* PROTOBUF_NONNULL CreateCollection::mutable_wal_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WalConfigDiff* _msg = _internal_mutable_wal_config();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateCollection.wal_config)
  return _msg;
}
inline void CreateCollection::set_allocated_wal_config(::qdrant::WalConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.wal_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.wal_config_ = reinterpret_cast<::qdrant::WalConfigDiff*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateCollection.wal_config)
}

// optional .qdrant.OptimizersConfigDiff optimizers_config = 6;
inline bool CreateCollection::has_optimizers_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.optimizers_config_ != nullptr);
  return value;
}
inline void CreateCollection::clear_optimizers_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.optimizers_config_ != nullptr) _impl_.optimizers_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::OptimizersConfigDiff& CreateCollection::_internal_optimizers_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::OptimizersConfigDiff* p = _impl_.optimizers_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::OptimizersConfigDiff&>(::qdrant::_OptimizersConfigDiff_default_instance_);
}
inline const ::qdrant::OptimizersConfigDiff& CreateCollection::optimizers_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateCollection.optimizers_config)
  return _internal_optimizers_config();
}
inline void CreateCollection::unsafe_arena_set_allocated_optimizers_config(
    ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.optimizers_config_);
  }
  _impl_.optimizers_config_ = reinterpret_cast<::qdrant::OptimizersConfigDiff*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CreateCollection.optimizers_config)
}
inline ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE CreateCollection::release_optimizers_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::OptimizersConfigDiff* released = _impl_.optimizers_config_;
  _impl_.optimizers_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE CreateCollection::unsafe_arena_release_optimizers_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateCollection.optimizers_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::OptimizersConfigDiff* temp = _impl_.optimizers_config_;
  _impl_.optimizers_config_ = nullptr;
  return temp;
}
inline ::qdrant::OptimizersConfigDiff* PROTOBUF_NONNULL CreateCollection::_internal_mutable_optimizers_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.optimizers_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::OptimizersConfigDiff>(GetArena());
    _impl_.optimizers_config_ = reinterpret_cast<::qdrant::OptimizersConfigDiff*>(p);
  }
  return _impl_.optimizers_config_;
}
inline ::qdrant::OptimizersConfigDiff* PROTOBUF_NONNULL CreateCollection::mutable_optimizers_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::OptimizersConfigDiff* _msg = _internal_mutable_optimizers_config();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateCollection.optimizers_config)
  return _msg;
}
inline void CreateCollection::set_allocated_optimizers_config(::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.optimizers_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.optimizers_config_ = reinterpret_cast<::qdrant::OptimizersConfigDiff*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateCollection.optimizers_config)
}

// optional uint32 shard_number = 7;
inline bool CreateCollection::has_shard_number() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000200U);
  return value;
}
inline void CreateCollection::clear_shard_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_number_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000200U);
}
inline ::uint32_t CreateCollection::shard_number() const {
  // @@protoc_insertion_point(field_get:qdrant.CreateCollection.shard_number)
  return _internal_shard_number();
}
inline void CreateCollection::set_shard_number(::uint32_t value) {
  _internal_set_shard_number(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  // @@protoc_insertion_point(field_set:qdrant.CreateCollection.shard_number)
}
inline ::uint32_t CreateCollection::_internal_shard_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shard_number_;
}
inline void CreateCollection::_internal_set_shard_number(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_number_ = value;
}

// optional bool on_disk_payload = 8;
inline bool CreateCollection::has_on_disk_payload() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000400U);
  return value;
}
inline void CreateCollection::clear_on_disk_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_payload_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000400U);
}
inline bool CreateCollection::on_disk_payload() const {
  // @@protoc_insertion_point(field_get:qdrant.CreateCollection.on_disk_payload)
  return _internal_on_disk_payload();
}
inline void CreateCollection::set_on_disk_payload(bool value) {
  _internal_set_on_disk_payload(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  // @@protoc_insertion_point(field_set:qdrant.CreateCollection.on_disk_payload)
}
inline bool CreateCollection::_internal_on_disk_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_disk_payload_;
}
inline void CreateCollection::_internal_set_on_disk_payload(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_payload_ = value;
}

// optional uint64 timeout = 9;
inline bool CreateCollection::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000800U);
  return value;
}
inline void CreateCollection::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000800U);
}
inline ::uint64_t CreateCollection::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.CreateCollection.timeout)
  return _internal_timeout();
}
inline void CreateCollection::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  // @@protoc_insertion_point(field_set:qdrant.CreateCollection.timeout)
}
inline ::uint64_t CreateCollection::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void CreateCollection::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// optional .qdrant.VectorsConfig vectors_config = 10;
inline bool CreateCollection::has_vectors_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.vectors_config_ != nullptr);
  return value;
}
inline void CreateCollection::clear_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_config_ != nullptr) _impl_.vectors_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::qdrant::VectorsConfig& CreateCollection::_internal_vectors_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::VectorsConfig* p = _impl_.vectors_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::VectorsConfig&>(::qdrant::_VectorsConfig_default_instance_);
}
inline const ::qdrant::VectorsConfig& CreateCollection::vectors_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateCollection.vectors_config)
  return _internal_vectors_config();
}
inline void CreateCollection::unsafe_arena_set_allocated_vectors_config(
    ::qdrant::VectorsConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_config_);
  }
  _impl_.vectors_config_ = reinterpret_cast<::qdrant::VectorsConfig*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CreateCollection.vectors_config)
}
inline ::qdrant::VectorsConfig* PROTOBUF_NULLABLE CreateCollection::release_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::VectorsConfig* released = _impl_.vectors_config_;
  _impl_.vectors_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::VectorsConfig* PROTOBUF_NULLABLE CreateCollection::unsafe_arena_release_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateCollection.vectors_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::VectorsConfig* temp = _impl_.vectors_config_;
  _impl_.vectors_config_ = nullptr;
  return temp;
}
inline ::qdrant::VectorsConfig* PROTOBUF_NONNULL CreateCollection::_internal_mutable_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorsConfig>(GetArena());
    _impl_.vectors_config_ = reinterpret_cast<::qdrant::VectorsConfig*>(p);
  }
  return _impl_.vectors_config_;
}
inline ::qdrant::VectorsConfig* PROTOBUF_NONNULL CreateCollection::mutable_vectors_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::VectorsConfig* _msg = _internal_mutable_vectors_config();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateCollection.vectors_config)
  return _msg;
}
inline void CreateCollection::set_allocated_vectors_config(::qdrant::VectorsConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.vectors_config_ = reinterpret_cast<::qdrant::VectorsConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateCollection.vectors_config)
}

// optional uint32 replication_factor = 11;
inline bool CreateCollection::has_replication_factor() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00001000U);
  return value;
}
inline void CreateCollection::clear_replication_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_factor_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00001000U);
}
inline ::uint32_t CreateCollection::replication_factor() const {
  // @@protoc_insertion_point(field_get:qdrant.CreateCollection.replication_factor)
  return _internal_replication_factor();
}
inline void CreateCollection::set_replication_factor(::uint32_t value) {
  _internal_set_replication_factor(value);
  SetHasBit(_impl_._has_bits_[0], 0x00001000U);
  // @@protoc_insertion_point(field_set:qdrant.CreateCollection.replication_factor)
}
inline ::uint32_t CreateCollection::_internal_replication_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replication_factor_;
}
inline void CreateCollection::_internal_set_replication_factor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_factor_ = value;
}

// optional uint32 write_consistency_factor = 12;
inline bool CreateCollection::has_write_consistency_factor() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00002000U);
  return value;
}
inline void CreateCollection::clear_write_consistency_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.write_consistency_factor_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00002000U);
}
inline ::uint32_t CreateCollection::write_consistency_factor() const {
  // @@protoc_insertion_point(field_get:qdrant.CreateCollection.write_consistency_factor)
  return _internal_write_consistency_factor();
}
inline void CreateCollection::set_write_consistency_factor(::uint32_t value) {
  _internal_set_write_consistency_factor(value);
  SetHasBit(_impl_._has_bits_[0], 0x00002000U);
  // @@protoc_insertion_point(field_set:qdrant.CreateCollection.write_consistency_factor)
}
inline ::uint32_t CreateCollection::_internal_write_consistency_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.write_consistency_factor_;
}
inline void CreateCollection::_internal_set_write_consistency_factor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.write_consistency_factor_ = value;
}

// optional string init_from_collection = 13;
inline bool CreateCollection::has_init_from_collection() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void CreateCollection::clear_init_from_collection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.init_from_collection_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& CreateCollection::init_from_collection() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateCollection.init_from_collection)
  return _internal_init_from_collection();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CreateCollection::set_init_from_collection(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.init_from_collection_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.CreateCollection.init_from_collection)
}
inline ::std::string* PROTOBUF_NONNULL CreateCollection::mutable_init_from_collection()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_init_from_collection();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateCollection.init_from_collection)
  return _s;
}
inline const ::std::string& CreateCollection::_internal_init_from_collection() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.init_from_collection_.Get();
}
inline void CreateCollection::_internal_set_init_from_collection(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.init_from_collection_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CreateCollection::_internal_mutable_init_from_collection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.init_from_collection_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CreateCollection::release_init_from_collection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateCollection.init_from_collection)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.init_from_collection_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.init_from_collection_.Set("", GetArena());
  }
  return released;
}
inline void CreateCollection::set_allocated_init_from_collection(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.init_from_collection_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.init_from_collection_.IsDefault()) {
    _impl_.init_from_collection_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateCollection.init_from_collection)
}

// optional .qdrant.QuantizationConfig quantization_config = 14;
inline bool CreateCollection::has_quantization_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  PROTOBUF_ASSUME(!value || _impl_.quantization_config_ != nullptr);
  return value;
}
inline void CreateCollection::clear_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.quantization_config_ != nullptr) _impl_.quantization_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::qdrant::QuantizationConfig& CreateCollection::_internal_quantization_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::QuantizationConfig* p = _impl_.quantization_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::QuantizationConfig&>(::qdrant::_QuantizationConfig_default_instance_);
}
inline const ::qdrant::QuantizationConfig& CreateCollection::quantization_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateCollection.quantization_config)
  return _internal_quantization_config();
}
inline void CreateCollection::unsafe_arena_set_allocated_quantization_config(
    ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quantization_config_);
  }
  _impl_.quantization_config_ = reinterpret_cast<::qdrant::QuantizationConfig*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CreateCollection.quantization_config)
}
inline ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE CreateCollection::release_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::QuantizationConfig* released = _impl_.quantization_config_;
  _impl_.quantization_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE CreateCollection::unsafe_arena_release_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateCollection.quantization_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::QuantizationConfig* temp = _impl_.quantization_config_;
  _impl_.quantization_config_ = nullptr;
  return temp;
}
inline ::qdrant::QuantizationConfig* PROTOBUF_NONNULL CreateCollection::_internal_mutable_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.quantization_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::QuantizationConfig>(GetArena());
    _impl_.quantization_config_ = reinterpret_cast<::qdrant::QuantizationConfig*>(p);
  }
  return _impl_.quantization_config_;
}
inline ::qdrant::QuantizationConfig* PROTOBUF_NONNULL CreateCollection::mutable_quantization_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::QuantizationConfig* _msg = _internal_mutable_quantization_config();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateCollection.quantization_config)
  return _msg;
}
inline void CreateCollection::set_allocated_quantization_config(::qdrant::QuantizationConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quantization_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }

  _impl_.quantization_config_ = reinterpret_cast<::qdrant::QuantizationConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateCollection.quantization_config)
}

// optional .qdrant.ShardingMethod sharding_method = 15;
inline bool CreateCollection::has_sharding_method() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00004000U);
  return value;
}
inline void CreateCollection::clear_sharding_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sharding_method_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00004000U);
}
inline ::qdrant::ShardingMethod CreateCollection::sharding_method() const {
  // @@protoc_insertion_point(field_get:qdrant.CreateCollection.sharding_method)
  return _internal_sharding_method();
}
inline void CreateCollection::set_sharding_method(::qdrant::ShardingMethod value) {
  _internal_set_sharding_method(value);
  SetHasBit(_impl_._has_bits_[0], 0x00004000U);
  // @@protoc_insertion_point(field_set:qdrant.CreateCollection.sharding_method)
}
inline ::qdrant::ShardingMethod CreateCollection::_internal_sharding_method() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::ShardingMethod>(_impl_.sharding_method_);
}
inline void CreateCollection::_internal_set_sharding_method(::qdrant::ShardingMethod value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sharding_method_ = value;
}

// optional .qdrant.SparseVectorConfig sparse_vectors_config = 16;
inline bool CreateCollection::has_sparse_vectors_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  PROTOBUF_ASSUME(!value || _impl_.sparse_vectors_config_ != nullptr);
  return value;
}
inline void CreateCollection::clear_sparse_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sparse_vectors_config_ != nullptr) _impl_.sparse_vectors_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline const ::qdrant::SparseVectorConfig& CreateCollection::_internal_sparse_vectors_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SparseVectorConfig* p = _impl_.sparse_vectors_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SparseVectorConfig&>(::qdrant::_SparseVectorConfig_default_instance_);
}
inline const ::qdrant::SparseVectorConfig& CreateCollection::sparse_vectors_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateCollection.sparse_vectors_config)
  return _internal_sparse_vectors_config();
}
inline void CreateCollection::unsafe_arena_set_allocated_sparse_vectors_config(
    ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sparse_vectors_config_);
  }
  _impl_.sparse_vectors_config_ = reinterpret_cast<::qdrant::SparseVectorConfig*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CreateCollection.sparse_vectors_config)
}
inline ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE CreateCollection::release_sparse_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::SparseVectorConfig* released = _impl_.sparse_vectors_config_;
  _impl_.sparse_vectors_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE CreateCollection::unsafe_arena_release_sparse_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateCollection.sparse_vectors_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::SparseVectorConfig* temp = _impl_.sparse_vectors_config_;
  _impl_.sparse_vectors_config_ = nullptr;
  return temp;
}
inline ::qdrant::SparseVectorConfig* PROTOBUF_NONNULL CreateCollection::_internal_mutable_sparse_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sparse_vectors_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SparseVectorConfig>(GetArena());
    _impl_.sparse_vectors_config_ = reinterpret_cast<::qdrant::SparseVectorConfig*>(p);
  }
  return _impl_.sparse_vectors_config_;
}
inline ::qdrant::SparseVectorConfig* PROTOBUF_NONNULL CreateCollection::mutable_sparse_vectors_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::SparseVectorConfig* _msg = _internal_mutable_sparse_vectors_config();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateCollection.sparse_vectors_config)
  return _msg;
}
inline void CreateCollection::set_allocated_sparse_vectors_config(::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sparse_vectors_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }

  _impl_.sparse_vectors_config_ = reinterpret_cast<::qdrant::SparseVectorConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateCollection.sparse_vectors_config)
}

// optional .qdrant.StrictModeConfig strict_mode_config = 17;
inline bool CreateCollection::has_strict_mode_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000100U);
  PROTOBUF_ASSUME(!value || _impl_.strict_mode_config_ != nullptr);
  return value;
}
inline void CreateCollection::clear_strict_mode_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.strict_mode_config_ != nullptr) _impl_.strict_mode_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline const ::qdrant::StrictModeConfig& CreateCollection::_internal_strict_mode_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::StrictModeConfig* p = _impl_.strict_mode_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::StrictModeConfig&>(::qdrant::_StrictModeConfig_default_instance_);
}
inline const ::qdrant::StrictModeConfig& CreateCollection::strict_mode_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateCollection.strict_mode_config)
  return _internal_strict_mode_config();
}
inline void CreateCollection::unsafe_arena_set_allocated_strict_mode_config(
    ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.strict_mode_config_);
  }
  _impl_.strict_mode_config_ = reinterpret_cast<::qdrant::StrictModeConfig*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CreateCollection.strict_mode_config)
}
inline ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE CreateCollection::release_strict_mode_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::StrictModeConfig* released = _impl_.strict_mode_config_;
  _impl_.strict_mode_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE CreateCollection::unsafe_arena_release_strict_mode_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateCollection.strict_mode_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::StrictModeConfig* temp = _impl_.strict_mode_config_;
  _impl_.strict_mode_config_ = nullptr;
  return temp;
}
inline ::qdrant::StrictModeConfig* PROTOBUF_NONNULL CreateCollection::_internal_mutable_strict_mode_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.strict_mode_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::StrictModeConfig>(GetArena());
    _impl_.strict_mode_config_ = reinterpret_cast<::qdrant::StrictModeConfig*>(p);
  }
  return _impl_.strict_mode_config_;
}
inline ::qdrant::StrictModeConfig* PROTOBUF_NONNULL CreateCollection::mutable_strict_mode_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::qdrant::StrictModeConfig* _msg = _internal_mutable_strict_mode_config();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateCollection.strict_mode_config)
  return _msg;
}
inline void CreateCollection::set_allocated_strict_mode_config(::qdrant::StrictModeConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.strict_mode_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }

  _impl_.strict_mode_config_ = reinterpret_cast<::qdrant::StrictModeConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateCollection.strict_mode_config)
}

// map<string, .qdrant.Value> metadata = 18;
inline int CreateCollection::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int CreateCollection::metadata_size() const {
  return _internal_metadata_size();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& CreateCollection::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& CreateCollection::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.CreateCollection.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL CreateCollection::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL CreateCollection::mutable_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00008000U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.CreateCollection.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UpdateCollection

// string collection_name = 1;
inline void UpdateCollection::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& UpdateCollection::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollection.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateCollection::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.UpdateCollection.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL UpdateCollection::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateCollection.collection_name)
  return _s;
}
inline const ::std::string& UpdateCollection::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void UpdateCollection::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UpdateCollection::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UpdateCollection::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpdateCollection.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void UpdateCollection::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpdateCollection.collection_name)
}

// optional .qdrant.OptimizersConfigDiff optimizers_config = 2;
inline bool UpdateCollection::has_optimizers_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.optimizers_config_ != nullptr);
  return value;
}
inline void UpdateCollection::clear_optimizers_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.optimizers_config_ != nullptr) _impl_.optimizers_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::OptimizersConfigDiff& UpdateCollection::_internal_optimizers_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::OptimizersConfigDiff* p = _impl_.optimizers_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::OptimizersConfigDiff&>(::qdrant::_OptimizersConfigDiff_default_instance_);
}
inline const ::qdrant::OptimizersConfigDiff& UpdateCollection::optimizers_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollection.optimizers_config)
  return _internal_optimizers_config();
}
inline void UpdateCollection::unsafe_arena_set_allocated_optimizers_config(
    ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.optimizers_config_);
  }
  _impl_.optimizers_config_ = reinterpret_cast<::qdrant::OptimizersConfigDiff*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdateCollection.optimizers_config)
}
inline ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE UpdateCollection::release_optimizers_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::OptimizersConfigDiff* released = _impl_.optimizers_config_;
  _impl_.optimizers_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE UpdateCollection::unsafe_arena_release_optimizers_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpdateCollection.optimizers_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::OptimizersConfigDiff* temp = _impl_.optimizers_config_;
  _impl_.optimizers_config_ = nullptr;
  return temp;
}
inline ::qdrant::OptimizersConfigDiff* PROTOBUF_NONNULL UpdateCollection::_internal_mutable_optimizers_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.optimizers_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::OptimizersConfigDiff>(GetArena());
    _impl_.optimizers_config_ = reinterpret_cast<::qdrant::OptimizersConfigDiff*>(p);
  }
  return _impl_.optimizers_config_;
}
inline ::qdrant::OptimizersConfigDiff* PROTOBUF_NONNULL UpdateCollection::mutable_optimizers_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::OptimizersConfigDiff* _msg = _internal_mutable_optimizers_config();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateCollection.optimizers_config)
  return _msg;
}
inline void UpdateCollection::set_allocated_optimizers_config(::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.optimizers_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.optimizers_config_ = reinterpret_cast<::qdrant::OptimizersConfigDiff*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpdateCollection.optimizers_config)
}

// optional uint64 timeout = 3;
inline bool UpdateCollection::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000100U);
  return value;
}
inline void UpdateCollection::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline ::uint64_t UpdateCollection::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollection.timeout)
  return _internal_timeout();
}
inline void UpdateCollection::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  // @@protoc_insertion_point(field_set:qdrant.UpdateCollection.timeout)
}
inline ::uint64_t UpdateCollection::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void UpdateCollection::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// optional .qdrant.CollectionParamsDiff params = 4;
inline bool UpdateCollection::has_params() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.params_ != nullptr);
  return value;
}
inline void UpdateCollection::clear_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ != nullptr) _impl_.params_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::CollectionParamsDiff& UpdateCollection::_internal_params() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::CollectionParamsDiff* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::CollectionParamsDiff&>(::qdrant::_CollectionParamsDiff_default_instance_);
}
inline const ::qdrant::CollectionParamsDiff& UpdateCollection::params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollection.params)
  return _internal_params();
}
inline void UpdateCollection::unsafe_arena_set_allocated_params(
    ::qdrant::CollectionParamsDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = reinterpret_cast<::qdrant::CollectionParamsDiff*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdateCollection.params)
}
inline ::qdrant::CollectionParamsDiff* PROTOBUF_NULLABLE UpdateCollection::release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::CollectionParamsDiff* released = _impl_.params_;
  _impl_.params_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::CollectionParamsDiff* PROTOBUF_NULLABLE UpdateCollection::unsafe_arena_release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpdateCollection.params)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::CollectionParamsDiff* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::qdrant::CollectionParamsDiff* PROTOBUF_NONNULL UpdateCollection::_internal_mutable_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::CollectionParamsDiff>(GetArena());
    _impl_.params_ = reinterpret_cast<::qdrant::CollectionParamsDiff*>(p);
  }
  return _impl_.params_;
}
inline ::qdrant::CollectionParamsDiff* PROTOBUF_NONNULL UpdateCollection::mutable_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::CollectionParamsDiff* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateCollection.params)
  return _msg;
}
inline void UpdateCollection::set_allocated_params(::qdrant::CollectionParamsDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.params_ = reinterpret_cast<::qdrant::CollectionParamsDiff*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpdateCollection.params)
}

// optional .qdrant.HnswConfigDiff hnsw_config = 5;
inline bool UpdateCollection::has_hnsw_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.hnsw_config_ != nullptr);
  return value;
}
inline void UpdateCollection::clear_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hnsw_config_ != nullptr) _impl_.hnsw_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::HnswConfigDiff& UpdateCollection::_internal_hnsw_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::HnswConfigDiff* p = _impl_.hnsw_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::HnswConfigDiff&>(::qdrant::_HnswConfigDiff_default_instance_);
}
inline const ::qdrant::HnswConfigDiff& UpdateCollection::hnsw_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollection.hnsw_config)
  return _internal_hnsw_config();
}
inline void UpdateCollection::unsafe_arena_set_allocated_hnsw_config(
    ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hnsw_config_);
  }
  _impl_.hnsw_config_ = reinterpret_cast<::qdrant::HnswConfigDiff*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdateCollection.hnsw_config)
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE UpdateCollection::release_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::HnswConfigDiff* released = _impl_.hnsw_config_;
  _impl_.hnsw_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE UpdateCollection::unsafe_arena_release_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpdateCollection.hnsw_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::HnswConfigDiff* temp = _impl_.hnsw_config_;
  _impl_.hnsw_config_ = nullptr;
  return temp;
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL UpdateCollection::_internal_mutable_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hnsw_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::HnswConfigDiff>(GetArena());
    _impl_.hnsw_config_ = reinterpret_cast<::qdrant::HnswConfigDiff*>(p);
  }
  return _impl_.hnsw_config_;
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL UpdateCollection::mutable_hnsw_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::HnswConfigDiff* _msg = _internal_mutable_hnsw_config();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateCollection.hnsw_config)
  return _msg;
}
inline void UpdateCollection::set_allocated_hnsw_config(::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hnsw_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.hnsw_config_ = reinterpret_cast<::qdrant::HnswConfigDiff*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpdateCollection.hnsw_config)
}

// optional .qdrant.VectorsConfigDiff vectors_config = 6;
inline bool UpdateCollection::has_vectors_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.vectors_config_ != nullptr);
  return value;
}
inline void UpdateCollection::clear_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_config_ != nullptr) _impl_.vectors_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::VectorsConfigDiff& UpdateCollection::_internal_vectors_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::VectorsConfigDiff* p = _impl_.vectors_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::VectorsConfigDiff&>(::qdrant::_VectorsConfigDiff_default_instance_);
}
inline const ::qdrant::VectorsConfigDiff& UpdateCollection::vectors_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollection.vectors_config)
  return _internal_vectors_config();
}
inline void UpdateCollection::unsafe_arena_set_allocated_vectors_config(
    ::qdrant::VectorsConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_config_);
  }
  _impl_.vectors_config_ = reinterpret_cast<::qdrant::VectorsConfigDiff*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdateCollection.vectors_config)
}
inline ::qdrant::VectorsConfigDiff* PROTOBUF_NULLABLE UpdateCollection::release_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::VectorsConfigDiff* released = _impl_.vectors_config_;
  _impl_.vectors_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::VectorsConfigDiff* PROTOBUF_NULLABLE UpdateCollection::unsafe_arena_release_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpdateCollection.vectors_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::VectorsConfigDiff* temp = _impl_.vectors_config_;
  _impl_.vectors_config_ = nullptr;
  return temp;
}
inline ::qdrant::VectorsConfigDiff* PROTOBUF_NONNULL UpdateCollection::_internal_mutable_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorsConfigDiff>(GetArena());
    _impl_.vectors_config_ = reinterpret_cast<::qdrant::VectorsConfigDiff*>(p);
  }
  return _impl_.vectors_config_;
}
inline ::qdrant::VectorsConfigDiff* PROTOBUF_NONNULL UpdateCollection::mutable_vectors_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::VectorsConfigDiff* _msg = _internal_mutable_vectors_config();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateCollection.vectors_config)
  return _msg;
}
inline void UpdateCollection::set_allocated_vectors_config(::qdrant::VectorsConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.vectors_config_ = reinterpret_cast<::qdrant::VectorsConfigDiff*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpdateCollection.vectors_config)
}

// optional .qdrant.QuantizationConfigDiff quantization_config = 7;
inline bool UpdateCollection::has_quantization_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.quantization_config_ != nullptr);
  return value;
}
inline void UpdateCollection::clear_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.quantization_config_ != nullptr) _impl_.quantization_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::qdrant::QuantizationConfigDiff& UpdateCollection::_internal_quantization_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::QuantizationConfigDiff* p = _impl_.quantization_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::QuantizationConfigDiff&>(::qdrant::_QuantizationConfigDiff_default_instance_);
}
inline const ::qdrant::QuantizationConfigDiff& UpdateCollection::quantization_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollection.quantization_config)
  return _internal_quantization_config();
}
inline void UpdateCollection::unsafe_arena_set_allocated_quantization_config(
    ::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quantization_config_);
  }
  _impl_.quantization_config_ = reinterpret_cast<::qdrant::QuantizationConfigDiff*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdateCollection.quantization_config)
}
inline ::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE UpdateCollection::release_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::QuantizationConfigDiff* released = _impl_.quantization_config_;
  _impl_.quantization_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE UpdateCollection::unsafe_arena_release_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpdateCollection.quantization_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::QuantizationConfigDiff* temp = _impl_.quantization_config_;
  _impl_.quantization_config_ = nullptr;
  return temp;
}
inline ::qdrant::QuantizationConfigDiff* PROTOBUF_NONNULL UpdateCollection::_internal_mutable_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.quantization_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::QuantizationConfigDiff>(GetArena());
    _impl_.quantization_config_ = reinterpret_cast<::qdrant::QuantizationConfigDiff*>(p);
  }
  return _impl_.quantization_config_;
}
inline ::qdrant::QuantizationConfigDiff* PROTOBUF_NONNULL UpdateCollection::mutable_quantization_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::QuantizationConfigDiff* _msg = _internal_mutable_quantization_config();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateCollection.quantization_config)
  return _msg;
}
inline void UpdateCollection::set_allocated_quantization_config(::qdrant::QuantizationConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quantization_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.quantization_config_ = reinterpret_cast<::qdrant::QuantizationConfigDiff*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpdateCollection.quantization_config)
}

// optional .qdrant.SparseVectorConfig sparse_vectors_config = 8;
inline bool UpdateCollection::has_sparse_vectors_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  PROTOBUF_ASSUME(!value || _impl_.sparse_vectors_config_ != nullptr);
  return value;
}
inline void UpdateCollection::clear_sparse_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sparse_vectors_config_ != nullptr) _impl_.sparse_vectors_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::qdrant::SparseVectorConfig& UpdateCollection::_internal_sparse_vectors_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SparseVectorConfig* p = _impl_.sparse_vectors_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SparseVectorConfig&>(::qdrant::_SparseVectorConfig_default_instance_);
}
inline const ::qdrant::SparseVectorConfig& UpdateCollection::sparse_vectors_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollection.sparse_vectors_config)
  return _internal_sparse_vectors_config();
}
inline void UpdateCollection::unsafe_arena_set_allocated_sparse_vectors_config(
    ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sparse_vectors_config_);
  }
  _impl_.sparse_vectors_config_ = reinterpret_cast<::qdrant::SparseVectorConfig*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdateCollection.sparse_vectors_config)
}
inline ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE UpdateCollection::release_sparse_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::SparseVectorConfig* released = _impl_.sparse_vectors_config_;
  _impl_.sparse_vectors_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE UpdateCollection::unsafe_arena_release_sparse_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpdateCollection.sparse_vectors_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::SparseVectorConfig* temp = _impl_.sparse_vectors_config_;
  _impl_.sparse_vectors_config_ = nullptr;
  return temp;
}
inline ::qdrant::SparseVectorConfig* PROTOBUF_NONNULL UpdateCollection::_internal_mutable_sparse_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sparse_vectors_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SparseVectorConfig>(GetArena());
    _impl_.sparse_vectors_config_ = reinterpret_cast<::qdrant::SparseVectorConfig*>(p);
  }
  return _impl_.sparse_vectors_config_;
}
inline ::qdrant::SparseVectorConfig* PROTOBUF_NONNULL UpdateCollection::mutable_sparse_vectors_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::qdrant::SparseVectorConfig* _msg = _internal_mutable_sparse_vectors_config();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateCollection.sparse_vectors_config)
  return _msg;
}
inline void UpdateCollection::set_allocated_sparse_vectors_config(::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sparse_vectors_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }

  _impl_.sparse_vectors_config_ = reinterpret_cast<::qdrant::SparseVectorConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpdateCollection.sparse_vectors_config)
}

// optional .qdrant.StrictModeConfig strict_mode_config = 9;
inline bool UpdateCollection::has_strict_mode_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  PROTOBUF_ASSUME(!value || _impl_.strict_mode_config_ != nullptr);
  return value;
}
inline void UpdateCollection::clear_strict_mode_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.strict_mode_config_ != nullptr) _impl_.strict_mode_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline const ::qdrant::StrictModeConfig& UpdateCollection::_internal_strict_mode_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::StrictModeConfig* p = _impl_.strict_mode_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::StrictModeConfig&>(::qdrant::_StrictModeConfig_default_instance_);
}
inline const ::qdrant::StrictModeConfig& UpdateCollection::strict_mode_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollection.strict_mode_config)
  return _internal_strict_mode_config();
}
inline void UpdateCollection::unsafe_arena_set_allocated_strict_mode_config(
    ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.strict_mode_config_);
  }
  _impl_.strict_mode_config_ = reinterpret_cast<::qdrant::StrictModeConfig*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdateCollection.strict_mode_config)
}
inline ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE UpdateCollection::release_strict_mode_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::StrictModeConfig* released = _impl_.strict_mode_config_;
  _impl_.strict_mode_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE UpdateCollection::unsafe_arena_release_strict_mode_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpdateCollection.strict_mode_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::StrictModeConfig* temp = _impl_.strict_mode_config_;
  _impl_.strict_mode_config_ = nullptr;
  return temp;
}
inline ::qdrant::StrictModeConfig* PROTOBUF_NONNULL UpdateCollection::_internal_mutable_strict_mode_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.strict_mode_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::StrictModeConfig>(GetArena());
    _impl_.strict_mode_config_ = reinterpret_cast<::qdrant::StrictModeConfig*>(p);
  }
  return _impl_.strict_mode_config_;
}
inline ::qdrant::StrictModeConfig* PROTOBUF_NONNULL UpdateCollection::mutable_strict_mode_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::qdrant::StrictModeConfig* _msg = _internal_mutable_strict_mode_config();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateCollection.strict_mode_config)
  return _msg;
}
inline void UpdateCollection::set_allocated_strict_mode_config(::qdrant::StrictModeConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.strict_mode_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }

  _impl_.strict_mode_config_ = reinterpret_cast<::qdrant::StrictModeConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpdateCollection.strict_mode_config)
}

// map<string, .qdrant.Value> metadata = 10;
inline int UpdateCollection::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int UpdateCollection::metadata_size() const {
  return _internal_metadata_size();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& UpdateCollection::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& UpdateCollection::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.UpdateCollection.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL UpdateCollection::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL UpdateCollection::mutable_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000200U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.UpdateCollection.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// DeleteCollection

// string collection_name = 1;
inline void DeleteCollection::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& DeleteCollection::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeleteCollection.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DeleteCollection::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.DeleteCollection.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL DeleteCollection::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.DeleteCollection.collection_name)
  return _s;
}
inline const ::std::string& DeleteCollection::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void DeleteCollection::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DeleteCollection::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DeleteCollection::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeleteCollection.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void DeleteCollection::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeleteCollection.collection_name)
}

// optional uint64 timeout = 2;
inline bool DeleteCollection::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void DeleteCollection::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint64_t DeleteCollection::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.DeleteCollection.timeout)
  return _internal_timeout();
}
inline void DeleteCollection::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.DeleteCollection.timeout)
}
inline ::uint64_t DeleteCollection::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void DeleteCollection::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// -------------------------------------------------------------------

// CollectionOperationResponse

// bool result = 1;
inline void CollectionOperationResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool CollectionOperationResponse::result() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionOperationResponse.result)
  return _internal_result();
}
inline void CollectionOperationResponse::set_result(bool value) {
  _internal_set_result(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionOperationResponse.result)
}
inline bool CollectionOperationResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline void CollectionOperationResponse::_internal_set_result(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// double time = 2;
inline void CollectionOperationResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline double CollectionOperationResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionOperationResponse.time)
  return _internal_time();
}
inline void CollectionOperationResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionOperationResponse.time)
}
inline double CollectionOperationResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void CollectionOperationResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// CollectionParams

// uint32 shard_number = 3;
inline void CollectionParams::clear_shard_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_number_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint32_t CollectionParams::shard_number() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionParams.shard_number)
  return _internal_shard_number();
}
inline void CollectionParams::set_shard_number(::uint32_t value) {
  _internal_set_shard_number(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionParams.shard_number)
}
inline ::uint32_t CollectionParams::_internal_shard_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shard_number_;
}
inline void CollectionParams::_internal_set_shard_number(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_number_ = value;
}

// bool on_disk_payload = 4;
inline void CollectionParams::clear_on_disk_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_payload_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool CollectionParams::on_disk_payload() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionParams.on_disk_payload)
  return _internal_on_disk_payload();
}
inline void CollectionParams::set_on_disk_payload(bool value) {
  _internal_set_on_disk_payload(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionParams.on_disk_payload)
}
inline bool CollectionParams::_internal_on_disk_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_disk_payload_;
}
inline void CollectionParams::_internal_set_on_disk_payload(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_payload_ = value;
}

// optional .qdrant.VectorsConfig vectors_config = 5;
inline bool CollectionParams::has_vectors_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.vectors_config_ != nullptr);
  return value;
}
inline void CollectionParams::clear_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_config_ != nullptr) _impl_.vectors_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::VectorsConfig& CollectionParams::_internal_vectors_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::VectorsConfig* p = _impl_.vectors_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::VectorsConfig&>(::qdrant::_VectorsConfig_default_instance_);
}
inline const ::qdrant::VectorsConfig& CollectionParams::vectors_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionParams.vectors_config)
  return _internal_vectors_config();
}
inline void CollectionParams::unsafe_arena_set_allocated_vectors_config(
    ::qdrant::VectorsConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_config_);
  }
  _impl_.vectors_config_ = reinterpret_cast<::qdrant::VectorsConfig*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CollectionParams.vectors_config)
}
inline ::qdrant::VectorsConfig* PROTOBUF_NULLABLE CollectionParams::release_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::VectorsConfig* released = _impl_.vectors_config_;
  _impl_.vectors_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::VectorsConfig* PROTOBUF_NULLABLE CollectionParams::unsafe_arena_release_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CollectionParams.vectors_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::VectorsConfig* temp = _impl_.vectors_config_;
  _impl_.vectors_config_ = nullptr;
  return temp;
}
inline ::qdrant::VectorsConfig* PROTOBUF_NONNULL CollectionParams::_internal_mutable_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vectors_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::VectorsConfig>(GetArena());
    _impl_.vectors_config_ = reinterpret_cast<::qdrant::VectorsConfig*>(p);
  }
  return _impl_.vectors_config_;
}
inline ::qdrant::VectorsConfig* PROTOBUF_NONNULL CollectionParams::mutable_vectors_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::VectorsConfig* _msg = _internal_mutable_vectors_config();
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionParams.vectors_config)
  return _msg;
}
inline void CollectionParams::set_allocated_vectors_config(::qdrant::VectorsConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vectors_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.vectors_config_ = reinterpret_cast<::qdrant::VectorsConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CollectionParams.vectors_config)
}

// optional uint32 replication_factor = 6;
inline bool CollectionParams::has_replication_factor() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void CollectionParams::clear_replication_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_factor_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::uint32_t CollectionParams::replication_factor() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionParams.replication_factor)
  return _internal_replication_factor();
}
inline void CollectionParams::set_replication_factor(::uint32_t value) {
  _internal_set_replication_factor(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionParams.replication_factor)
}
inline ::uint32_t CollectionParams::_internal_replication_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replication_factor_;
}
inline void CollectionParams::_internal_set_replication_factor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_factor_ = value;
}

// optional uint32 write_consistency_factor = 7;
inline bool CollectionParams::has_write_consistency_factor() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void CollectionParams::clear_write_consistency_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.write_consistency_factor_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::uint32_t CollectionParams::write_consistency_factor() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionParams.write_consistency_factor)
  return _internal_write_consistency_factor();
}
inline void CollectionParams::set_write_consistency_factor(::uint32_t value) {
  _internal_set_write_consistency_factor(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionParams.write_consistency_factor)
}
inline ::uint32_t CollectionParams::_internal_write_consistency_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.write_consistency_factor_;
}
inline void CollectionParams::_internal_set_write_consistency_factor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.write_consistency_factor_ = value;
}

// optional uint32 read_fan_out_factor = 8;
inline bool CollectionParams::has_read_fan_out_factor() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  return value;
}
inline void CollectionParams::clear_read_fan_out_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.read_fan_out_factor_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline ::uint32_t CollectionParams::read_fan_out_factor() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionParams.read_fan_out_factor)
  return _internal_read_fan_out_factor();
}
inline void CollectionParams::set_read_fan_out_factor(::uint32_t value) {
  _internal_set_read_fan_out_factor(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionParams.read_fan_out_factor)
}
inline ::uint32_t CollectionParams::_internal_read_fan_out_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.read_fan_out_factor_;
}
inline void CollectionParams::_internal_set_read_fan_out_factor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.read_fan_out_factor_ = value;
}

// optional .qdrant.ShardingMethod sharding_method = 9;
inline bool CollectionParams::has_sharding_method() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  return value;
}
inline void CollectionParams::clear_sharding_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sharding_method_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline ::qdrant::ShardingMethod CollectionParams::sharding_method() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionParams.sharding_method)
  return _internal_sharding_method();
}
inline void CollectionParams::set_sharding_method(::qdrant::ShardingMethod value) {
  _internal_set_sharding_method(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionParams.sharding_method)
}
inline ::qdrant::ShardingMethod CollectionParams::_internal_sharding_method() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::ShardingMethod>(_impl_.sharding_method_);
}
inline void CollectionParams::_internal_set_sharding_method(::qdrant::ShardingMethod value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sharding_method_ = value;
}

// optional .qdrant.SparseVectorConfig sparse_vectors_config = 10;
inline bool CollectionParams::has_sparse_vectors_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.sparse_vectors_config_ != nullptr);
  return value;
}
inline void CollectionParams::clear_sparse_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sparse_vectors_config_ != nullptr) _impl_.sparse_vectors_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::SparseVectorConfig& CollectionParams::_internal_sparse_vectors_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::SparseVectorConfig* p = _impl_.sparse_vectors_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::SparseVectorConfig&>(::qdrant::_SparseVectorConfig_default_instance_);
}
inline const ::qdrant::SparseVectorConfig& CollectionParams::sparse_vectors_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionParams.sparse_vectors_config)
  return _internal_sparse_vectors_config();
}
inline void CollectionParams::unsafe_arena_set_allocated_sparse_vectors_config(
    ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sparse_vectors_config_);
  }
  _impl_.sparse_vectors_config_ = reinterpret_cast<::qdrant::SparseVectorConfig*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CollectionParams.sparse_vectors_config)
}
inline ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE CollectionParams::release_sparse_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::SparseVectorConfig* released = _impl_.sparse_vectors_config_;
  _impl_.sparse_vectors_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE CollectionParams::unsafe_arena_release_sparse_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CollectionParams.sparse_vectors_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::SparseVectorConfig* temp = _impl_.sparse_vectors_config_;
  _impl_.sparse_vectors_config_ = nullptr;
  return temp;
}
inline ::qdrant::SparseVectorConfig* PROTOBUF_NONNULL CollectionParams::_internal_mutable_sparse_vectors_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sparse_vectors_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::SparseVectorConfig>(GetArena());
    _impl_.sparse_vectors_config_ = reinterpret_cast<::qdrant::SparseVectorConfig*>(p);
  }
  return _impl_.sparse_vectors_config_;
}
inline ::qdrant::SparseVectorConfig* PROTOBUF_NONNULL CollectionParams::mutable_sparse_vectors_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::SparseVectorConfig* _msg = _internal_mutable_sparse_vectors_config();
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionParams.sparse_vectors_config)
  return _msg;
}
inline void CollectionParams::set_allocated_sparse_vectors_config(::qdrant::SparseVectorConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sparse_vectors_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.sparse_vectors_config_ = reinterpret_cast<::qdrant::SparseVectorConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CollectionParams.sparse_vectors_config)
}

// -------------------------------------------------------------------

// CollectionParamsDiff

// optional uint32 replication_factor = 1;
inline bool CollectionParamsDiff::has_replication_factor() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void CollectionParamsDiff::clear_replication_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_factor_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint32_t CollectionParamsDiff::replication_factor() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionParamsDiff.replication_factor)
  return _internal_replication_factor();
}
inline void CollectionParamsDiff::set_replication_factor(::uint32_t value) {
  _internal_set_replication_factor(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionParamsDiff.replication_factor)
}
inline ::uint32_t CollectionParamsDiff::_internal_replication_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replication_factor_;
}
inline void CollectionParamsDiff::_internal_set_replication_factor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_factor_ = value;
}

// optional uint32 write_consistency_factor = 2;
inline bool CollectionParamsDiff::has_write_consistency_factor() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void CollectionParamsDiff::clear_write_consistency_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.write_consistency_factor_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint32_t CollectionParamsDiff::write_consistency_factor() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionParamsDiff.write_consistency_factor)
  return _internal_write_consistency_factor();
}
inline void CollectionParamsDiff::set_write_consistency_factor(::uint32_t value) {
  _internal_set_write_consistency_factor(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionParamsDiff.write_consistency_factor)
}
inline ::uint32_t CollectionParamsDiff::_internal_write_consistency_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.write_consistency_factor_;
}
inline void CollectionParamsDiff::_internal_set_write_consistency_factor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.write_consistency_factor_ = value;
}

// optional bool on_disk_payload = 3;
inline bool CollectionParamsDiff::has_on_disk_payload() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void CollectionParamsDiff::clear_on_disk_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_payload_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline bool CollectionParamsDiff::on_disk_payload() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionParamsDiff.on_disk_payload)
  return _internal_on_disk_payload();
}
inline void CollectionParamsDiff::set_on_disk_payload(bool value) {
  _internal_set_on_disk_payload(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionParamsDiff.on_disk_payload)
}
inline bool CollectionParamsDiff::_internal_on_disk_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_disk_payload_;
}
inline void CollectionParamsDiff::_internal_set_on_disk_payload(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_payload_ = value;
}

// optional uint32 read_fan_out_factor = 4;
inline bool CollectionParamsDiff::has_read_fan_out_factor() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void CollectionParamsDiff::clear_read_fan_out_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.read_fan_out_factor_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint32_t CollectionParamsDiff::read_fan_out_factor() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionParamsDiff.read_fan_out_factor)
  return _internal_read_fan_out_factor();
}
inline void CollectionParamsDiff::set_read_fan_out_factor(::uint32_t value) {
  _internal_set_read_fan_out_factor(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionParamsDiff.read_fan_out_factor)
}
inline ::uint32_t CollectionParamsDiff::_internal_read_fan_out_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.read_fan_out_factor_;
}
inline void CollectionParamsDiff::_internal_set_read_fan_out_factor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.read_fan_out_factor_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CollectionConfig

// .qdrant.CollectionParams params = 1;
inline bool CollectionConfig::has_params() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.params_ != nullptr);
  return value;
}
inline void CollectionConfig::clear_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ != nullptr) _impl_.params_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::CollectionParams& CollectionConfig::_internal_params() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::CollectionParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::CollectionParams&>(::qdrant::_CollectionParams_default_instance_);
}
inline const ::qdrant::CollectionParams& CollectionConfig::params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionConfig.params)
  return _internal_params();
}
inline void CollectionConfig::unsafe_arena_set_allocated_params(
    ::qdrant::CollectionParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = reinterpret_cast<::qdrant::CollectionParams*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CollectionConfig.params)
}
inline ::qdrant::CollectionParams* PROTOBUF_NULLABLE CollectionConfig::release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::CollectionParams* released = _impl_.params_;
  _impl_.params_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::CollectionParams* PROTOBUF_NULLABLE CollectionConfig::unsafe_arena_release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CollectionConfig.params)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::CollectionParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::qdrant::CollectionParams* PROTOBUF_NONNULL CollectionConfig::_internal_mutable_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::CollectionParams>(GetArena());
    _impl_.params_ = reinterpret_cast<::qdrant::CollectionParams*>(p);
  }
  return _impl_.params_;
}
inline ::qdrant::CollectionParams* PROTOBUF_NONNULL CollectionConfig::mutable_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::CollectionParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionConfig.params)
  return _msg;
}
inline void CollectionConfig::set_allocated_params(::qdrant::CollectionParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.params_ = reinterpret_cast<::qdrant::CollectionParams*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CollectionConfig.params)
}

// .qdrant.HnswConfigDiff hnsw_config = 2;
inline bool CollectionConfig::has_hnsw_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.hnsw_config_ != nullptr);
  return value;
}
inline void CollectionConfig::clear_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hnsw_config_ != nullptr) _impl_.hnsw_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::HnswConfigDiff& CollectionConfig::_internal_hnsw_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::HnswConfigDiff* p = _impl_.hnsw_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::HnswConfigDiff&>(::qdrant::_HnswConfigDiff_default_instance_);
}
inline const ::qdrant::HnswConfigDiff& CollectionConfig::hnsw_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionConfig.hnsw_config)
  return _internal_hnsw_config();
}
inline void CollectionConfig::unsafe_arena_set_allocated_hnsw_config(
    ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hnsw_config_);
  }
  _impl_.hnsw_config_ = reinterpret_cast<::qdrant::HnswConfigDiff*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CollectionConfig.hnsw_config)
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE CollectionConfig::release_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::HnswConfigDiff* released = _impl_.hnsw_config_;
  _impl_.hnsw_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE CollectionConfig::unsafe_arena_release_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CollectionConfig.hnsw_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::HnswConfigDiff* temp = _impl_.hnsw_config_;
  _impl_.hnsw_config_ = nullptr;
  return temp;
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL CollectionConfig::_internal_mutable_hnsw_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hnsw_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::HnswConfigDiff>(GetArena());
    _impl_.hnsw_config_ = reinterpret_cast<::qdrant::HnswConfigDiff*>(p);
  }
  return _impl_.hnsw_config_;
}
inline ::qdrant::HnswConfigDiff* PROTOBUF_NONNULL CollectionConfig::mutable_hnsw_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::HnswConfigDiff* _msg = _internal_mutable_hnsw_config();
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionConfig.hnsw_config)
  return _msg;
}
inline void CollectionConfig::set_allocated_hnsw_config(::qdrant::HnswConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hnsw_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.hnsw_config_ = reinterpret_cast<::qdrant::HnswConfigDiff*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CollectionConfig.hnsw_config)
}

// .qdrant.OptimizersConfigDiff optimizer_config = 3;
inline bool CollectionConfig::has_optimizer_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.optimizer_config_ != nullptr);
  return value;
}
inline void CollectionConfig::clear_optimizer_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.optimizer_config_ != nullptr) _impl_.optimizer_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::qdrant::OptimizersConfigDiff& CollectionConfig::_internal_optimizer_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::OptimizersConfigDiff* p = _impl_.optimizer_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::OptimizersConfigDiff&>(::qdrant::_OptimizersConfigDiff_default_instance_);
}
inline const ::qdrant::OptimizersConfigDiff& CollectionConfig::optimizer_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionConfig.optimizer_config)
  return _internal_optimizer_config();
}
inline void CollectionConfig::unsafe_arena_set_allocated_optimizer_config(
    ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.optimizer_config_);
  }
  _impl_.optimizer_config_ = reinterpret_cast<::qdrant::OptimizersConfigDiff*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CollectionConfig.optimizer_config)
}
inline ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE CollectionConfig::release_optimizer_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::OptimizersConfigDiff* released = _impl_.optimizer_config_;
  _impl_.optimizer_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE CollectionConfig::unsafe_arena_release_optimizer_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CollectionConfig.optimizer_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::OptimizersConfigDiff* temp = _impl_.optimizer_config_;
  _impl_.optimizer_config_ = nullptr;
  return temp;
}
inline ::qdrant::OptimizersConfigDiff* PROTOBUF_NONNULL CollectionConfig::_internal_mutable_optimizer_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.optimizer_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::OptimizersConfigDiff>(GetArena());
    _impl_.optimizer_config_ = reinterpret_cast<::qdrant::OptimizersConfigDiff*>(p);
  }
  return _impl_.optimizer_config_;
}
inline ::qdrant::OptimizersConfigDiff* PROTOBUF_NONNULL CollectionConfig::mutable_optimizer_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::qdrant::OptimizersConfigDiff* _msg = _internal_mutable_optimizer_config();
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionConfig.optimizer_config)
  return _msg;
}
inline void CollectionConfig::set_allocated_optimizer_config(::qdrant::OptimizersConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.optimizer_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.optimizer_config_ = reinterpret_cast<::qdrant::OptimizersConfigDiff*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CollectionConfig.optimizer_config)
}

// .qdrant.WalConfigDiff wal_config = 4;
inline bool CollectionConfig::has_wal_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.wal_config_ != nullptr);
  return value;
}
inline void CollectionConfig::clear_wal_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.wal_config_ != nullptr) _impl_.wal_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::qdrant::WalConfigDiff& CollectionConfig::_internal_wal_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::WalConfigDiff* p = _impl_.wal_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::WalConfigDiff&>(::qdrant::_WalConfigDiff_default_instance_);
}
inline const ::qdrant::WalConfigDiff& CollectionConfig::wal_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionConfig.wal_config)
  return _internal_wal_config();
}
inline void CollectionConfig::unsafe_arena_set_allocated_wal_config(
    ::qdrant::WalConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.wal_config_);
  }
  _impl_.wal_config_ = reinterpret_cast<::qdrant::WalConfigDiff*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CollectionConfig.wal_config)
}
inline ::qdrant::WalConfigDiff* PROTOBUF_NULLABLE CollectionConfig::release_wal_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WalConfigDiff* released = _impl_.wal_config_;
  _impl_.wal_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::WalConfigDiff* PROTOBUF_NULLABLE CollectionConfig::unsafe_arena_release_wal_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CollectionConfig.wal_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WalConfigDiff* temp = _impl_.wal_config_;
  _impl_.wal_config_ = nullptr;
  return temp;
}
inline ::qdrant::WalConfigDiff* PROTOBUF_NONNULL CollectionConfig::_internal_mutable_wal_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.wal_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::WalConfigDiff>(GetArena());
    _impl_.wal_config_ = reinterpret_cast<::qdrant::WalConfigDiff*>(p);
  }
  return _impl_.wal_config_;
}
inline ::qdrant::WalConfigDiff* PROTOBUF_NONNULL CollectionConfig::mutable_wal_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::qdrant::WalConfigDiff* _msg = _internal_mutable_wal_config();
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionConfig.wal_config)
  return _msg;
}
inline void CollectionConfig::set_allocated_wal_config(::qdrant::WalConfigDiff* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.wal_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.wal_config_ = reinterpret_cast<::qdrant::WalConfigDiff*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CollectionConfig.wal_config)
}

// optional .qdrant.QuantizationConfig quantization_config = 5;
inline bool CollectionConfig::has_quantization_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.quantization_config_ != nullptr);
  return value;
}
inline void CollectionConfig::clear_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.quantization_config_ != nullptr) _impl_.quantization_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::qdrant::QuantizationConfig& CollectionConfig::_internal_quantization_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::QuantizationConfig* p = _impl_.quantization_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::QuantizationConfig&>(::qdrant::_QuantizationConfig_default_instance_);
}
inline const ::qdrant::QuantizationConfig& CollectionConfig::quantization_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionConfig.quantization_config)
  return _internal_quantization_config();
}
inline void CollectionConfig::unsafe_arena_set_allocated_quantization_config(
    ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quantization_config_);
  }
  _impl_.quantization_config_ = reinterpret_cast<::qdrant::QuantizationConfig*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CollectionConfig.quantization_config)
}
inline ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE CollectionConfig::release_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::QuantizationConfig* released = _impl_.quantization_config_;
  _impl_.quantization_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::QuantizationConfig* PROTOBUF_NULLABLE CollectionConfig::unsafe_arena_release_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CollectionConfig.quantization_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::QuantizationConfig* temp = _impl_.quantization_config_;
  _impl_.quantization_config_ = nullptr;
  return temp;
}
inline ::qdrant::QuantizationConfig* PROTOBUF_NONNULL CollectionConfig::_internal_mutable_quantization_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.quantization_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::QuantizationConfig>(GetArena());
    _impl_.quantization_config_ = reinterpret_cast<::qdrant::QuantizationConfig*>(p);
  }
  return _impl_.quantization_config_;
}
inline ::qdrant::QuantizationConfig* PROTOBUF_NONNULL CollectionConfig::mutable_quantization_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::qdrant::QuantizationConfig* _msg = _internal_mutable_quantization_config();
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionConfig.quantization_config)
  return _msg;
}
inline void CollectionConfig::set_allocated_quantization_config(::qdrant::QuantizationConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quantization_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.quantization_config_ = reinterpret_cast<::qdrant::QuantizationConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CollectionConfig.quantization_config)
}

// optional .qdrant.StrictModeConfig strict_mode_config = 6;
inline bool CollectionConfig::has_strict_mode_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.strict_mode_config_ != nullptr);
  return value;
}
inline void CollectionConfig::clear_strict_mode_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.strict_mode_config_ != nullptr) _impl_.strict_mode_config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::qdrant::StrictModeConfig& CollectionConfig::_internal_strict_mode_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::StrictModeConfig* p = _impl_.strict_mode_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::StrictModeConfig&>(::qdrant::_StrictModeConfig_default_instance_);
}
inline const ::qdrant::StrictModeConfig& CollectionConfig::strict_mode_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionConfig.strict_mode_config)
  return _internal_strict_mode_config();
}
inline void CollectionConfig::unsafe_arena_set_allocated_strict_mode_config(
    ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.strict_mode_config_);
  }
  _impl_.strict_mode_config_ = reinterpret_cast<::qdrant::StrictModeConfig*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CollectionConfig.strict_mode_config)
}
inline ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE CollectionConfig::release_strict_mode_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::StrictModeConfig* released = _impl_.strict_mode_config_;
  _impl_.strict_mode_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::StrictModeConfig* PROTOBUF_NULLABLE CollectionConfig::unsafe_arena_release_strict_mode_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CollectionConfig.strict_mode_config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::StrictModeConfig* temp = _impl_.strict_mode_config_;
  _impl_.strict_mode_config_ = nullptr;
  return temp;
}
inline ::qdrant::StrictModeConfig* PROTOBUF_NONNULL CollectionConfig::_internal_mutable_strict_mode_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.strict_mode_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::StrictModeConfig>(GetArena());
    _impl_.strict_mode_config_ = reinterpret_cast<::qdrant::StrictModeConfig*>(p);
  }
  return _impl_.strict_mode_config_;
}
inline ::qdrant::StrictModeConfig* PROTOBUF_NONNULL CollectionConfig::mutable_strict_mode_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::qdrant::StrictModeConfig* _msg = _internal_mutable_strict_mode_config();
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionConfig.strict_mode_config)
  return _msg;
}
inline void CollectionConfig::set_allocated_strict_mode_config(::qdrant::StrictModeConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.strict_mode_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.strict_mode_config_ = reinterpret_cast<::qdrant::StrictModeConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CollectionConfig.strict_mode_config)
}

// map<string, .qdrant.Value> metadata = 7;
inline int CollectionConfig::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int CollectionConfig::metadata_size() const {
  return _internal_metadata_size();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& CollectionConfig::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::Value>& CollectionConfig::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.CollectionConfig.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL CollectionConfig::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::Value>* PROTOBUF_NONNULL CollectionConfig::mutable_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.CollectionConfig.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// KeywordIndexParams

// optional bool is_tenant = 1;
inline bool KeywordIndexParams::has_is_tenant() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void KeywordIndexParams::clear_is_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_tenant_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool KeywordIndexParams::is_tenant() const {
  // @@protoc_insertion_point(field_get:qdrant.KeywordIndexParams.is_tenant)
  return _internal_is_tenant();
}
inline void KeywordIndexParams::set_is_tenant(bool value) {
  _internal_set_is_tenant(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.KeywordIndexParams.is_tenant)
}
inline bool KeywordIndexParams::_internal_is_tenant() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_tenant_;
}
inline void KeywordIndexParams::_internal_set_is_tenant(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_tenant_ = value;
}

// optional bool on_disk = 2;
inline bool KeywordIndexParams::has_on_disk() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void KeywordIndexParams::clear_on_disk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool KeywordIndexParams::on_disk() const {
  // @@protoc_insertion_point(field_get:qdrant.KeywordIndexParams.on_disk)
  return _internal_on_disk();
}
inline void KeywordIndexParams::set_on_disk(bool value) {
  _internal_set_on_disk(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.KeywordIndexParams.on_disk)
}
inline bool KeywordIndexParams::_internal_on_disk() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_disk_;
}
inline void KeywordIndexParams::_internal_set_on_disk(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = value;
}

// -------------------------------------------------------------------

// IntegerIndexParams

// optional bool lookup = 1;
inline bool IntegerIndexParams::has_lookup() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void IntegerIndexParams::clear_lookup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lookup_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool IntegerIndexParams::lookup() const {
  // @@protoc_insertion_point(field_get:qdrant.IntegerIndexParams.lookup)
  return _internal_lookup();
}
inline void IntegerIndexParams::set_lookup(bool value) {
  _internal_set_lookup(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.IntegerIndexParams.lookup)
}
inline bool IntegerIndexParams::_internal_lookup() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lookup_;
}
inline void IntegerIndexParams::_internal_set_lookup(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lookup_ = value;
}

// optional bool range = 2;
inline bool IntegerIndexParams::has_range() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void IntegerIndexParams::clear_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.range_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool IntegerIndexParams::range() const {
  // @@protoc_insertion_point(field_get:qdrant.IntegerIndexParams.range)
  return _internal_range();
}
inline void IntegerIndexParams::set_range(bool value) {
  _internal_set_range(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.IntegerIndexParams.range)
}
inline bool IntegerIndexParams::_internal_range() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.range_;
}
inline void IntegerIndexParams::_internal_set_range(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.range_ = value;
}

// optional bool is_principal = 3;
inline bool IntegerIndexParams::has_is_principal() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void IntegerIndexParams::clear_is_principal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_principal_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline bool IntegerIndexParams::is_principal() const {
  // @@protoc_insertion_point(field_get:qdrant.IntegerIndexParams.is_principal)
  return _internal_is_principal();
}
inline void IntegerIndexParams::set_is_principal(bool value) {
  _internal_set_is_principal(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.IntegerIndexParams.is_principal)
}
inline bool IntegerIndexParams::_internal_is_principal() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_principal_;
}
inline void IntegerIndexParams::_internal_set_is_principal(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_principal_ = value;
}

// optional bool on_disk = 4;
inline bool IntegerIndexParams::has_on_disk() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void IntegerIndexParams::clear_on_disk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool IntegerIndexParams::on_disk() const {
  // @@protoc_insertion_point(field_get:qdrant.IntegerIndexParams.on_disk)
  return _internal_on_disk();
}
inline void IntegerIndexParams::set_on_disk(bool value) {
  _internal_set_on_disk(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.IntegerIndexParams.on_disk)
}
inline bool IntegerIndexParams::_internal_on_disk() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_disk_;
}
inline void IntegerIndexParams::_internal_set_on_disk(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = value;
}

// -------------------------------------------------------------------

// FloatIndexParams

// optional bool on_disk = 1;
inline bool FloatIndexParams::has_on_disk() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void FloatIndexParams::clear_on_disk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool FloatIndexParams::on_disk() const {
  // @@protoc_insertion_point(field_get:qdrant.FloatIndexParams.on_disk)
  return _internal_on_disk();
}
inline void FloatIndexParams::set_on_disk(bool value) {
  _internal_set_on_disk(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.FloatIndexParams.on_disk)
}
inline bool FloatIndexParams::_internal_on_disk() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_disk_;
}
inline void FloatIndexParams::_internal_set_on_disk(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = value;
}

// optional bool is_principal = 2;
inline bool FloatIndexParams::has_is_principal() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void FloatIndexParams::clear_is_principal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_principal_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool FloatIndexParams::is_principal() const {
  // @@protoc_insertion_point(field_get:qdrant.FloatIndexParams.is_principal)
  return _internal_is_principal();
}
inline void FloatIndexParams::set_is_principal(bool value) {
  _internal_set_is_principal(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.FloatIndexParams.is_principal)
}
inline bool FloatIndexParams::_internal_is_principal() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_principal_;
}
inline void FloatIndexParams::_internal_set_is_principal(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_principal_ = value;
}

// -------------------------------------------------------------------

// GeoIndexParams

// optional bool on_disk = 1;
inline bool GeoIndexParams::has_on_disk() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void GeoIndexParams::clear_on_disk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool GeoIndexParams::on_disk() const {
  // @@protoc_insertion_point(field_get:qdrant.GeoIndexParams.on_disk)
  return _internal_on_disk();
}
inline void GeoIndexParams::set_on_disk(bool value) {
  _internal_set_on_disk(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.GeoIndexParams.on_disk)
}
inline bool GeoIndexParams::_internal_on_disk() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_disk_;
}
inline void GeoIndexParams::_internal_set_on_disk(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = value;
}

// -------------------------------------------------------------------

// StopwordsSet

// repeated string languages = 1;
inline int StopwordsSet::_internal_languages_size() const {
  return _internal_languages().size();
}
inline int StopwordsSet::languages_size() const {
  return _internal_languages_size();
}
inline void StopwordsSet::clear_languages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.languages_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL StopwordsSet::add_languages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_languages()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:qdrant.StopwordsSet.languages)
  return _s;
}
inline const ::std::string& StopwordsSet::languages(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.StopwordsSet.languages)
  return _internal_languages().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL StopwordsSet::mutable_languages(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.StopwordsSet.languages)
  return _internal_mutable_languages()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void StopwordsSet::set_languages(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_languages()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:qdrant.StopwordsSet.languages)
}
template <typename Arg_, typename... Args_>
inline void StopwordsSet::add_languages(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_languages(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.StopwordsSet.languages)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& StopwordsSet::languages()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.StopwordsSet.languages)
  return _internal_languages();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
StopwordsSet::mutable_languages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.StopwordsSet.languages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_languages();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
StopwordsSet::_internal_languages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.languages_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
StopwordsSet::_internal_mutable_languages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.languages_;
}

// repeated string custom = 2;
inline int StopwordsSet::_internal_custom_size() const {
  return _internal_custom().size();
}
inline int StopwordsSet::custom_size() const {
  return _internal_custom_size();
}
inline void StopwordsSet::clear_custom() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.custom_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::std::string* PROTOBUF_NONNULL StopwordsSet::add_custom()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_custom()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add_mutable:qdrant.StopwordsSet.custom)
  return _s;
}
inline const ::std::string& StopwordsSet::custom(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.StopwordsSet.custom)
  return _internal_custom().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL StopwordsSet::mutable_custom(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.StopwordsSet.custom)
  return _internal_mutable_custom()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void StopwordsSet::set_custom(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_custom()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:qdrant.StopwordsSet.custom)
}
template <typename Arg_, typename... Args_>
inline void StopwordsSet::add_custom(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_custom(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:qdrant.StopwordsSet.custom)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& StopwordsSet::custom()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.StopwordsSet.custom)
  return _internal_custom();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
StopwordsSet::mutable_custom() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.StopwordsSet.custom)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_custom();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
StopwordsSet::_internal_custom() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.custom_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
StopwordsSet::_internal_mutable_custom() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.custom_;
}

// -------------------------------------------------------------------

// TextIndexParams

// .qdrant.TokenizerType tokenizer = 1;
inline void TextIndexParams::clear_tokenizer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tokenizer_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::qdrant::TokenizerType TextIndexParams::tokenizer() const {
  // @@protoc_insertion_point(field_get:qdrant.TextIndexParams.tokenizer)
  return _internal_tokenizer();
}
inline void TextIndexParams::set_tokenizer(::qdrant::TokenizerType value) {
  _internal_set_tokenizer(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.TextIndexParams.tokenizer)
}
inline ::qdrant::TokenizerType TextIndexParams::_internal_tokenizer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::TokenizerType>(_impl_.tokenizer_);
}
inline void TextIndexParams::_internal_set_tokenizer(::qdrant::TokenizerType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tokenizer_ = value;
}

// optional bool lowercase = 2;
inline bool TextIndexParams::has_lowercase() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void TextIndexParams::clear_lowercase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lowercase_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool TextIndexParams::lowercase() const {
  // @@protoc_insertion_point(field_get:qdrant.TextIndexParams.lowercase)
  return _internal_lowercase();
}
inline void TextIndexParams::set_lowercase(bool value) {
  _internal_set_lowercase(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.TextIndexParams.lowercase)
}
inline bool TextIndexParams::_internal_lowercase() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lowercase_;
}
inline void TextIndexParams::_internal_set_lowercase(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lowercase_ = value;
}

// optional uint64 min_token_len = 3;
inline bool TextIndexParams::has_min_token_len() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void TextIndexParams::clear_min_token_len() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_token_len_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint64_t TextIndexParams::min_token_len() const {
  // @@protoc_insertion_point(field_get:qdrant.TextIndexParams.min_token_len)
  return _internal_min_token_len();
}
inline void TextIndexParams::set_min_token_len(::uint64_t value) {
  _internal_set_min_token_len(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.TextIndexParams.min_token_len)
}
inline ::uint64_t TextIndexParams::_internal_min_token_len() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_token_len_;
}
inline void TextIndexParams::_internal_set_min_token_len(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_token_len_ = value;
}

// optional uint64 max_token_len = 4;
inline bool TextIndexParams::has_max_token_len() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  return value;
}
inline void TextIndexParams::clear_max_token_len() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_token_len_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline ::uint64_t TextIndexParams::max_token_len() const {
  // @@protoc_insertion_point(field_get:qdrant.TextIndexParams.max_token_len)
  return _internal_max_token_len();
}
inline void TextIndexParams::set_max_token_len(::uint64_t value) {
  _internal_set_max_token_len(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  // @@protoc_insertion_point(field_set:qdrant.TextIndexParams.max_token_len)
}
inline ::uint64_t TextIndexParams::_internal_max_token_len() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_token_len_;
}
inline void TextIndexParams::_internal_set_max_token_len(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_token_len_ = value;
}

// optional bool on_disk = 5;
inline bool TextIndexParams::has_on_disk() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void TextIndexParams::clear_on_disk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool TextIndexParams::on_disk() const {
  // @@protoc_insertion_point(field_get:qdrant.TextIndexParams.on_disk)
  return _internal_on_disk();
}
inline void TextIndexParams::set_on_disk(bool value) {
  _internal_set_on_disk(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.TextIndexParams.on_disk)
}
inline bool TextIndexParams::_internal_on_disk() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_disk_;
}
inline void TextIndexParams::_internal_set_on_disk(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = value;
}

// optional .qdrant.StopwordsSet stopwords = 6;
inline bool TextIndexParams::has_stopwords() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.stopwords_ != nullptr);
  return value;
}
inline void TextIndexParams::clear_stopwords() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stopwords_ != nullptr) _impl_.stopwords_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::StopwordsSet& TextIndexParams::_internal_stopwords() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::StopwordsSet* p = _impl_.stopwords_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::StopwordsSet&>(::qdrant::_StopwordsSet_default_instance_);
}
inline const ::qdrant::StopwordsSet& TextIndexParams::stopwords() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.TextIndexParams.stopwords)
  return _internal_stopwords();
}
inline void TextIndexParams::unsafe_arena_set_allocated_stopwords(
    ::qdrant::StopwordsSet* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stopwords_);
  }
  _impl_.stopwords_ = reinterpret_cast<::qdrant::StopwordsSet*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.TextIndexParams.stopwords)
}
inline ::qdrant::StopwordsSet* PROTOBUF_NULLABLE TextIndexParams::release_stopwords() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::StopwordsSet* released = _impl_.stopwords_;
  _impl_.stopwords_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::StopwordsSet* PROTOBUF_NULLABLE TextIndexParams::unsafe_arena_release_stopwords() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.TextIndexParams.stopwords)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::StopwordsSet* temp = _impl_.stopwords_;
  _impl_.stopwords_ = nullptr;
  return temp;
}
inline ::qdrant::StopwordsSet* PROTOBUF_NONNULL TextIndexParams::_internal_mutable_stopwords() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stopwords_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::StopwordsSet>(GetArena());
    _impl_.stopwords_ = reinterpret_cast<::qdrant::StopwordsSet*>(p);
  }
  return _impl_.stopwords_;
}
inline ::qdrant::StopwordsSet* PROTOBUF_NONNULL TextIndexParams::mutable_stopwords()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::StopwordsSet* _msg = _internal_mutable_stopwords();
  // @@protoc_insertion_point(field_mutable:qdrant.TextIndexParams.stopwords)
  return _msg;
}
inline void TextIndexParams::set_allocated_stopwords(::qdrant::StopwordsSet* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stopwords_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.stopwords_ = reinterpret_cast<::qdrant::StopwordsSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.TextIndexParams.stopwords)
}

// optional bool phrase_matching = 7;
inline bool TextIndexParams::has_phrase_matching() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  return value;
}
inline void TextIndexParams::clear_phrase_matching() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phrase_matching_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline bool TextIndexParams::phrase_matching() const {
  // @@protoc_insertion_point(field_get:qdrant.TextIndexParams.phrase_matching)
  return _internal_phrase_matching();
}
inline void TextIndexParams::set_phrase_matching(bool value) {
  _internal_set_phrase_matching(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:qdrant.TextIndexParams.phrase_matching)
}
inline bool TextIndexParams::_internal_phrase_matching() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.phrase_matching_;
}
inline void TextIndexParams::_internal_set_phrase_matching(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phrase_matching_ = value;
}

// optional .qdrant.StemmingAlgorithm stemmer = 8;
inline bool TextIndexParams::has_stemmer() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.stemmer_ != nullptr);
  return value;
}
inline void TextIndexParams::clear_stemmer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stemmer_ != nullptr) _impl_.stemmer_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::StemmingAlgorithm& TextIndexParams::_internal_stemmer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::StemmingAlgorithm* p = _impl_.stemmer_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::StemmingAlgorithm&>(::qdrant::_StemmingAlgorithm_default_instance_);
}
inline const ::qdrant::StemmingAlgorithm& TextIndexParams::stemmer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.TextIndexParams.stemmer)
  return _internal_stemmer();
}
inline void TextIndexParams::unsafe_arena_set_allocated_stemmer(
    ::qdrant::StemmingAlgorithm* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stemmer_);
  }
  _impl_.stemmer_ = reinterpret_cast<::qdrant::StemmingAlgorithm*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.TextIndexParams.stemmer)
}
inline ::qdrant::StemmingAlgorithm* PROTOBUF_NULLABLE TextIndexParams::release_stemmer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::StemmingAlgorithm* released = _impl_.stemmer_;
  _impl_.stemmer_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::StemmingAlgorithm* PROTOBUF_NULLABLE TextIndexParams::unsafe_arena_release_stemmer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.TextIndexParams.stemmer)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::StemmingAlgorithm* temp = _impl_.stemmer_;
  _impl_.stemmer_ = nullptr;
  return temp;
}
inline ::qdrant::StemmingAlgorithm* PROTOBUF_NONNULL TextIndexParams::_internal_mutable_stemmer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stemmer_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::StemmingAlgorithm>(GetArena());
    _impl_.stemmer_ = reinterpret_cast<::qdrant::StemmingAlgorithm*>(p);
  }
  return _impl_.stemmer_;
}
inline ::qdrant::StemmingAlgorithm* PROTOBUF_NONNULL TextIndexParams::mutable_stemmer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::StemmingAlgorithm* _msg = _internal_mutable_stemmer();
  // @@protoc_insertion_point(field_mutable:qdrant.TextIndexParams.stemmer)
  return _msg;
}
inline void TextIndexParams::set_allocated_stemmer(::qdrant::StemmingAlgorithm* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stemmer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.stemmer_ = reinterpret_cast<::qdrant::StemmingAlgorithm*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.TextIndexParams.stemmer)
}

// -------------------------------------------------------------------

// StemmingAlgorithm

// .qdrant.SnowballParams snowball = 1;
inline bool StemmingAlgorithm::has_snowball() const {
  return stemming_params_case() == kSnowball;
}
inline bool StemmingAlgorithm::_internal_has_snowball() const {
  return stemming_params_case() == kSnowball;
}
inline void StemmingAlgorithm::set_has_snowball() {
  _impl_._oneof_case_[0] = kSnowball;
}
inline void StemmingAlgorithm::clear_snowball() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (stemming_params_case() == kSnowball) {
    if (GetArena() == nullptr) {
      delete _impl_.stemming_params_.snowball_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.stemming_params_.snowball_);
    }
    clear_has_stemming_params();
  }
}
inline ::qdrant::SnowballParams* PROTOBUF_NULLABLE StemmingAlgorithm::release_snowball() {
  // @@protoc_insertion_point(field_release:qdrant.StemmingAlgorithm.snowball)
  if (stemming_params_case() == kSnowball) {
    clear_has_stemming_params();
    auto* temp = _impl_.stemming_params_.snowball_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stemming_params_.snowball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::SnowballParams& StemmingAlgorithm::_internal_snowball() const {
  return stemming_params_case() == kSnowball ? static_cast<const ::qdrant::SnowballParams&>(*_impl_.stemming_params_.snowball_)
                     : reinterpret_cast<const ::qdrant::SnowballParams&>(::qdrant::_SnowballParams_default_instance_);
}
inline const ::qdrant::SnowballParams& StemmingAlgorithm::snowball() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.StemmingAlgorithm.snowball)
  return _internal_snowball();
}
inline ::qdrant::SnowballParams* PROTOBUF_NULLABLE StemmingAlgorithm::unsafe_arena_release_snowball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.StemmingAlgorithm.snowball)
  if (stemming_params_case() == kSnowball) {
    clear_has_stemming_params();
    auto* temp = _impl_.stemming_params_.snowball_;
    _impl_.stemming_params_.snowball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StemmingAlgorithm::unsafe_arena_set_allocated_snowball(
    ::qdrant::SnowballParams* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_stemming_params();
  if (value) {
    set_has_snowball();
    _impl_.stemming_params_.snowball_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.StemmingAlgorithm.snowball)
}
inline ::qdrant::SnowballParams* PROTOBUF_NONNULL StemmingAlgorithm::_internal_mutable_snowball() {
  if (stemming_params_case() != kSnowball) {
    clear_stemming_params();
    set_has_snowball();
    _impl_.stemming_params_.snowball_ = 
        ::google::protobuf::Message::DefaultConstruct<::qdrant::SnowballParams>(GetArena());
  }
  return _impl_.stemming_params_.snowball_;
}
inline ::qdrant::SnowballParams* PROTOBUF_NONNULL StemmingAlgorithm::mutable_snowball()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::SnowballParams* _msg = _internal_mutable_snowball();
  // @@protoc_insertion_point(field_mutable:qdrant.StemmingAlgorithm.snowball)
  return _msg;
}

inline bool StemmingAlgorithm::has_stemming_params() const {
  return stemming_params_case() != STEMMING_PARAMS_NOT_SET;
}
inline void StemmingAlgorithm::clear_has_stemming_params() {
  _impl_._oneof_case_[0] = STEMMING_PARAMS_NOT_SET;
}
inline StemmingAlgorithm::StemmingParamsCase StemmingAlgorithm::stemming_params_case() const {
  return StemmingAlgorithm::StemmingParamsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SnowballParams

// string language = 1;
inline void SnowballParams::clear_language() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.language_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& SnowballParams::language() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.SnowballParams.language)
  return _internal_language();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SnowballParams::set_language(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.language_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.SnowballParams.language)
}
inline ::std::string* PROTOBUF_NONNULL SnowballParams::mutable_language()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:qdrant.SnowballParams.language)
  return _s;
}
inline const ::std::string& SnowballParams::_internal_language() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.language_.Get();
}
inline void SnowballParams::_internal_set_language(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.language_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SnowballParams::_internal_mutable_language() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.language_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SnowballParams::release_language() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.SnowballParams.language)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.language_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.language_.Set("", GetArena());
  }
  return released;
}
inline void SnowballParams::set_allocated_language(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.language_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.SnowballParams.language)
}

// -------------------------------------------------------------------

// BoolIndexParams

// optional bool on_disk = 1;
inline bool BoolIndexParams::has_on_disk() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void BoolIndexParams::clear_on_disk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool BoolIndexParams::on_disk() const {
  // @@protoc_insertion_point(field_get:qdrant.BoolIndexParams.on_disk)
  return _internal_on_disk();
}
inline void BoolIndexParams::set_on_disk(bool value) {
  _internal_set_on_disk(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.BoolIndexParams.on_disk)
}
inline bool BoolIndexParams::_internal_on_disk() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_disk_;
}
inline void BoolIndexParams::_internal_set_on_disk(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = value;
}

// -------------------------------------------------------------------

// DatetimeIndexParams

// optional bool on_disk = 1;
inline bool DatetimeIndexParams::has_on_disk() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void DatetimeIndexParams::clear_on_disk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool DatetimeIndexParams::on_disk() const {
  // @@protoc_insertion_point(field_get:qdrant.DatetimeIndexParams.on_disk)
  return _internal_on_disk();
}
inline void DatetimeIndexParams::set_on_disk(bool value) {
  _internal_set_on_disk(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.DatetimeIndexParams.on_disk)
}
inline bool DatetimeIndexParams::_internal_on_disk() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_disk_;
}
inline void DatetimeIndexParams::_internal_set_on_disk(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = value;
}

// optional bool is_principal = 2;
inline bool DatetimeIndexParams::has_is_principal() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void DatetimeIndexParams::clear_is_principal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_principal_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool DatetimeIndexParams::is_principal() const {
  // @@protoc_insertion_point(field_get:qdrant.DatetimeIndexParams.is_principal)
  return _internal_is_principal();
}
inline void DatetimeIndexParams::set_is_principal(bool value) {
  _internal_set_is_principal(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.DatetimeIndexParams.is_principal)
}
inline bool DatetimeIndexParams::_internal_is_principal() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_principal_;
}
inline void DatetimeIndexParams::_internal_set_is_principal(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_principal_ = value;
}

// -------------------------------------------------------------------

// UuidIndexParams

// optional bool is_tenant = 1;
inline bool UuidIndexParams::has_is_tenant() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void UuidIndexParams::clear_is_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_tenant_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool UuidIndexParams::is_tenant() const {
  // @@protoc_insertion_point(field_get:qdrant.UuidIndexParams.is_tenant)
  return _internal_is_tenant();
}
inline void UuidIndexParams::set_is_tenant(bool value) {
  _internal_set_is_tenant(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.UuidIndexParams.is_tenant)
}
inline bool UuidIndexParams::_internal_is_tenant() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_tenant_;
}
inline void UuidIndexParams::_internal_set_is_tenant(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_tenant_ = value;
}

// optional bool on_disk = 2;
inline bool UuidIndexParams::has_on_disk() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void UuidIndexParams::clear_on_disk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool UuidIndexParams::on_disk() const {
  // @@protoc_insertion_point(field_get:qdrant.UuidIndexParams.on_disk)
  return _internal_on_disk();
}
inline void UuidIndexParams::set_on_disk(bool value) {
  _internal_set_on_disk(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.UuidIndexParams.on_disk)
}
inline bool UuidIndexParams::_internal_on_disk() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_disk_;
}
inline void UuidIndexParams::_internal_set_on_disk(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_disk_ = value;
}

// -------------------------------------------------------------------

// PayloadIndexParams

// .qdrant.KeywordIndexParams keyword_index_params = 3;
inline bool PayloadIndexParams::has_keyword_index_params() const {
  return index_params_case() == kKeywordIndexParams;
}
inline bool PayloadIndexParams::_internal_has_keyword_index_params() const {
  return index_params_case() == kKeywordIndexParams;
}
inline void PayloadIndexParams::set_has_keyword_index_params() {
  _impl_._oneof_case_[0] = kKeywordIndexParams;
}
inline void PayloadIndexParams::clear_keyword_index_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (index_params_case() == kKeywordIndexParams) {
    if (GetArena() == nullptr) {
      delete _impl_.index_params_.keyword_index_params_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.index_params_.keyword_index_params_);
    }
    clear_has_index_params();
  }
}
inline ::qdrant::KeywordIndexParams* PROTOBUF_NULLABLE PayloadIndexParams::release_keyword_index_params() {
  // @@protoc_insertion_point(field_release:qdrant.PayloadIndexParams.keyword_index_params)
  if (index_params_case() == kKeywordIndexParams) {
    clear_has_index_params();
    auto* temp = reinterpret_cast<::qdrant::KeywordIndexParams*>(_impl_.index_params_.keyword_index_params_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.index_params_.keyword_index_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::KeywordIndexParams& PayloadIndexParams::_internal_keyword_index_params() const {
  return index_params_case() == kKeywordIndexParams ? static_cast<const ::qdrant::KeywordIndexParams&>(*reinterpret_cast<::qdrant::KeywordIndexParams*>(_impl_.index_params_.keyword_index_params_))
                     : reinterpret_cast<const ::qdrant::KeywordIndexParams&>(::qdrant::_KeywordIndexParams_default_instance_);
}
inline const ::qdrant::KeywordIndexParams& PayloadIndexParams::keyword_index_params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PayloadIndexParams.keyword_index_params)
  return _internal_keyword_index_params();
}
inline ::qdrant::KeywordIndexParams* PROTOBUF_NULLABLE PayloadIndexParams::unsafe_arena_release_keyword_index_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PayloadIndexParams.keyword_index_params)
  if (index_params_case() == kKeywordIndexParams) {
    clear_has_index_params();
    auto* temp = reinterpret_cast<::qdrant::KeywordIndexParams*>(_impl_.index_params_.keyword_index_params_);
    _impl_.index_params_.keyword_index_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PayloadIndexParams::unsafe_arena_set_allocated_keyword_index_params(
    ::qdrant::KeywordIndexParams* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_index_params();
  if (value) {
    set_has_keyword_index_params();
    _impl_.index_params_.keyword_index_params_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PayloadIndexParams.keyword_index_params)
}
inline ::qdrant::KeywordIndexParams* PROTOBUF_NONNULL PayloadIndexParams::_internal_mutable_keyword_index_params() {
  if (index_params_case() != kKeywordIndexParams) {
    clear_index_params();
    set_has_keyword_index_params();
    _impl_.index_params_.keyword_index_params_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::KeywordIndexParams>(GetArena()));
  }
  return reinterpret_cast<::qdrant::KeywordIndexParams*>(_impl_.index_params_.keyword_index_params_);
}
inline ::qdrant::KeywordIndexParams* PROTOBUF_NONNULL PayloadIndexParams::mutable_keyword_index_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::KeywordIndexParams* _msg = _internal_mutable_keyword_index_params();
  // @@protoc_insertion_point(field_mutable:qdrant.PayloadIndexParams.keyword_index_params)
  return _msg;
}

// .qdrant.IntegerIndexParams integer_index_params = 2;
inline bool PayloadIndexParams::has_integer_index_params() const {
  return index_params_case() == kIntegerIndexParams;
}
inline bool PayloadIndexParams::_internal_has_integer_index_params() const {
  return index_params_case() == kIntegerIndexParams;
}
inline void PayloadIndexParams::set_has_integer_index_params() {
  _impl_._oneof_case_[0] = kIntegerIndexParams;
}
inline void PayloadIndexParams::clear_integer_index_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (index_params_case() == kIntegerIndexParams) {
    if (GetArena() == nullptr) {
      delete _impl_.index_params_.integer_index_params_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.index_params_.integer_index_params_);
    }
    clear_has_index_params();
  }
}
inline ::qdrant::IntegerIndexParams* PROTOBUF_NULLABLE PayloadIndexParams::release_integer_index_params() {
  // @@protoc_insertion_point(field_release:qdrant.PayloadIndexParams.integer_index_params)
  if (index_params_case() == kIntegerIndexParams) {
    clear_has_index_params();
    auto* temp = reinterpret_cast<::qdrant::IntegerIndexParams*>(_impl_.index_params_.integer_index_params_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.index_params_.integer_index_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::IntegerIndexParams& PayloadIndexParams::_internal_integer_index_params() const {
  return index_params_case() == kIntegerIndexParams ? static_cast<const ::qdrant::IntegerIndexParams&>(*reinterpret_cast<::qdrant::IntegerIndexParams*>(_impl_.index_params_.integer_index_params_))
                     : reinterpret_cast<const ::qdrant::IntegerIndexParams&>(::qdrant::_IntegerIndexParams_default_instance_);
}
inline const ::qdrant::IntegerIndexParams& PayloadIndexParams::integer_index_params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PayloadIndexParams.integer_index_params)
  return _internal_integer_index_params();
}
inline ::qdrant::IntegerIndexParams* PROTOBUF_NULLABLE PayloadIndexParams::unsafe_arena_release_integer_index_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PayloadIndexParams.integer_index_params)
  if (index_params_case() == kIntegerIndexParams) {
    clear_has_index_params();
    auto* temp = reinterpret_cast<::qdrant::IntegerIndexParams*>(_impl_.index_params_.integer_index_params_);
    _impl_.index_params_.integer_index_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PayloadIndexParams::unsafe_arena_set_allocated_integer_index_params(
    ::qdrant::IntegerIndexParams* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_index_params();
  if (value) {
    set_has_integer_index_params();
    _impl_.index_params_.integer_index_params_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PayloadIndexParams.integer_index_params)
}
inline ::qdrant::IntegerIndexParams* PROTOBUF_NONNULL PayloadIndexParams::_internal_mutable_integer_index_params() {
  if (index_params_case() != kIntegerIndexParams) {
    clear_index_params();
    set_has_integer_index_params();
    _impl_.index_params_.integer_index_params_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::IntegerIndexParams>(GetArena()));
  }
  return reinterpret_cast<::qdrant::IntegerIndexParams*>(_impl_.index_params_.integer_index_params_);
}
inline ::qdrant::IntegerIndexParams* PROTOBUF_NONNULL PayloadIndexParams::mutable_integer_index_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::IntegerIndexParams* _msg = _internal_mutable_integer_index_params();
  // @@protoc_insertion_point(field_mutable:qdrant.PayloadIndexParams.integer_index_params)
  return _msg;
}

// .qdrant.FloatIndexParams float_index_params = 4;
inline bool PayloadIndexParams::has_float_index_params() const {
  return index_params_case() == kFloatIndexParams;
}
inline bool PayloadIndexParams::_internal_has_float_index_params() const {
  return index_params_case() == kFloatIndexParams;
}
inline void PayloadIndexParams::set_has_float_index_params() {
  _impl_._oneof_case_[0] = kFloatIndexParams;
}
inline void PayloadIndexParams::clear_float_index_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (index_params_case() == kFloatIndexParams) {
    if (GetArena() == nullptr) {
      delete _impl_.index_params_.float_index_params_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.index_params_.float_index_params_);
    }
    clear_has_index_params();
  }
}
inline ::qdrant::FloatIndexParams* PROTOBUF_NULLABLE PayloadIndexParams::release_float_index_params() {
  // @@protoc_insertion_point(field_release:qdrant.PayloadIndexParams.float_index_params)
  if (index_params_case() == kFloatIndexParams) {
    clear_has_index_params();
    auto* temp = reinterpret_cast<::qdrant::FloatIndexParams*>(_impl_.index_params_.float_index_params_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.index_params_.float_index_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::FloatIndexParams& PayloadIndexParams::_internal_float_index_params() const {
  return index_params_case() == kFloatIndexParams ? static_cast<const ::qdrant::FloatIndexParams&>(*reinterpret_cast<::qdrant::FloatIndexParams*>(_impl_.index_params_.float_index_params_))
                     : reinterpret_cast<const ::qdrant::FloatIndexParams&>(::qdrant::_FloatIndexParams_default_instance_);
}
inline const ::qdrant::FloatIndexParams& PayloadIndexParams::float_index_params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PayloadIndexParams.float_index_params)
  return _internal_float_index_params();
}
inline ::qdrant::FloatIndexParams* PROTOBUF_NULLABLE PayloadIndexParams::unsafe_arena_release_float_index_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PayloadIndexParams.float_index_params)
  if (index_params_case() == kFloatIndexParams) {
    clear_has_index_params();
    auto* temp = reinterpret_cast<::qdrant::FloatIndexParams*>(_impl_.index_params_.float_index_params_);
    _impl_.index_params_.float_index_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PayloadIndexParams::unsafe_arena_set_allocated_float_index_params(
    ::qdrant::FloatIndexParams* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_index_params();
  if (value) {
    set_has_float_index_params();
    _impl_.index_params_.float_index_params_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PayloadIndexParams.float_index_params)
}
inline ::qdrant::FloatIndexParams* PROTOBUF_NONNULL PayloadIndexParams::_internal_mutable_float_index_params() {
  if (index_params_case() != kFloatIndexParams) {
    clear_index_params();
    set_has_float_index_params();
    _impl_.index_params_.float_index_params_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::FloatIndexParams>(GetArena()));
  }
  return reinterpret_cast<::qdrant::FloatIndexParams*>(_impl_.index_params_.float_index_params_);
}
inline ::qdrant::FloatIndexParams* PROTOBUF_NONNULL PayloadIndexParams::mutable_float_index_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::FloatIndexParams* _msg = _internal_mutable_float_index_params();
  // @@protoc_insertion_point(field_mutable:qdrant.PayloadIndexParams.float_index_params)
  return _msg;
}

// .qdrant.GeoIndexParams geo_index_params = 5;
inline bool PayloadIndexParams::has_geo_index_params() const {
  return index_params_case() == kGeoIndexParams;
}
inline bool PayloadIndexParams::_internal_has_geo_index_params() const {
  return index_params_case() == kGeoIndexParams;
}
inline void PayloadIndexParams::set_has_geo_index_params() {
  _impl_._oneof_case_[0] = kGeoIndexParams;
}
inline void PayloadIndexParams::clear_geo_index_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (index_params_case() == kGeoIndexParams) {
    if (GetArena() == nullptr) {
      delete _impl_.index_params_.geo_index_params_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.index_params_.geo_index_params_);
    }
    clear_has_index_params();
  }
}
inline ::qdrant::GeoIndexParams* PROTOBUF_NULLABLE PayloadIndexParams::release_geo_index_params() {
  // @@protoc_insertion_point(field_release:qdrant.PayloadIndexParams.geo_index_params)
  if (index_params_case() == kGeoIndexParams) {
    clear_has_index_params();
    auto* temp = reinterpret_cast<::qdrant::GeoIndexParams*>(_impl_.index_params_.geo_index_params_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.index_params_.geo_index_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::GeoIndexParams& PayloadIndexParams::_internal_geo_index_params() const {
  return index_params_case() == kGeoIndexParams ? static_cast<const ::qdrant::GeoIndexParams&>(*reinterpret_cast<::qdrant::GeoIndexParams*>(_impl_.index_params_.geo_index_params_))
                     : reinterpret_cast<const ::qdrant::GeoIndexParams&>(::qdrant::_GeoIndexParams_default_instance_);
}
inline const ::qdrant::GeoIndexParams& PayloadIndexParams::geo_index_params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PayloadIndexParams.geo_index_params)
  return _internal_geo_index_params();
}
inline ::qdrant::GeoIndexParams* PROTOBUF_NULLABLE PayloadIndexParams::unsafe_arena_release_geo_index_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PayloadIndexParams.geo_index_params)
  if (index_params_case() == kGeoIndexParams) {
    clear_has_index_params();
    auto* temp = reinterpret_cast<::qdrant::GeoIndexParams*>(_impl_.index_params_.geo_index_params_);
    _impl_.index_params_.geo_index_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PayloadIndexParams::unsafe_arena_set_allocated_geo_index_params(
    ::qdrant::GeoIndexParams* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_index_params();
  if (value) {
    set_has_geo_index_params();
    _impl_.index_params_.geo_index_params_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PayloadIndexParams.geo_index_params)
}
inline ::qdrant::GeoIndexParams* PROTOBUF_NONNULL PayloadIndexParams::_internal_mutable_geo_index_params() {
  if (index_params_case() != kGeoIndexParams) {
    clear_index_params();
    set_has_geo_index_params();
    _impl_.index_params_.geo_index_params_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::GeoIndexParams>(GetArena()));
  }
  return reinterpret_cast<::qdrant::GeoIndexParams*>(_impl_.index_params_.geo_index_params_);
}
inline ::qdrant::GeoIndexParams* PROTOBUF_NONNULL PayloadIndexParams::mutable_geo_index_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::GeoIndexParams* _msg = _internal_mutable_geo_index_params();
  // @@protoc_insertion_point(field_mutable:qdrant.PayloadIndexParams.geo_index_params)
  return _msg;
}

// .qdrant.TextIndexParams text_index_params = 1;
inline bool PayloadIndexParams::has_text_index_params() const {
  return index_params_case() == kTextIndexParams;
}
inline bool PayloadIndexParams::_internal_has_text_index_params() const {
  return index_params_case() == kTextIndexParams;
}
inline void PayloadIndexParams::set_has_text_index_params() {
  _impl_._oneof_case_[0] = kTextIndexParams;
}
inline void PayloadIndexParams::clear_text_index_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (index_params_case() == kTextIndexParams) {
    if (GetArena() == nullptr) {
      delete _impl_.index_params_.text_index_params_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.index_params_.text_index_params_);
    }
    clear_has_index_params();
  }
}
inline ::qdrant::TextIndexParams* PROTOBUF_NULLABLE PayloadIndexParams::release_text_index_params() {
  // @@protoc_insertion_point(field_release:qdrant.PayloadIndexParams.text_index_params)
  if (index_params_case() == kTextIndexParams) {
    clear_has_index_params();
    auto* temp = reinterpret_cast<::qdrant::TextIndexParams*>(_impl_.index_params_.text_index_params_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.index_params_.text_index_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::TextIndexParams& PayloadIndexParams::_internal_text_index_params() const {
  return index_params_case() == kTextIndexParams ? static_cast<const ::qdrant::TextIndexParams&>(*reinterpret_cast<::qdrant::TextIndexParams*>(_impl_.index_params_.text_index_params_))
                     : reinterpret_cast<const ::qdrant::TextIndexParams&>(::qdrant::_TextIndexParams_default_instance_);
}
inline const ::qdrant::TextIndexParams& PayloadIndexParams::text_index_params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PayloadIndexParams.text_index_params)
  return _internal_text_index_params();
}
inline ::qdrant::TextIndexParams* PROTOBUF_NULLABLE PayloadIndexParams::unsafe_arena_release_text_index_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PayloadIndexParams.text_index_params)
  if (index_params_case() == kTextIndexParams) {
    clear_has_index_params();
    auto* temp = reinterpret_cast<::qdrant::TextIndexParams*>(_impl_.index_params_.text_index_params_);
    _impl_.index_params_.text_index_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PayloadIndexParams::unsafe_arena_set_allocated_text_index_params(
    ::qdrant::TextIndexParams* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_index_params();
  if (value) {
    set_has_text_index_params();
    _impl_.index_params_.text_index_params_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PayloadIndexParams.text_index_params)
}
inline ::qdrant::TextIndexParams* PROTOBUF_NONNULL PayloadIndexParams::_internal_mutable_text_index_params() {
  if (index_params_case() != kTextIndexParams) {
    clear_index_params();
    set_has_text_index_params();
    _impl_.index_params_.text_index_params_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::TextIndexParams>(GetArena()));
  }
  return reinterpret_cast<::qdrant::TextIndexParams*>(_impl_.index_params_.text_index_params_);
}
inline ::qdrant::TextIndexParams* PROTOBUF_NONNULL PayloadIndexParams::mutable_text_index_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::TextIndexParams* _msg = _internal_mutable_text_index_params();
  // @@protoc_insertion_point(field_mutable:qdrant.PayloadIndexParams.text_index_params)
  return _msg;
}

// .qdrant.BoolIndexParams bool_index_params = 6;
inline bool PayloadIndexParams::has_bool_index_params() const {
  return index_params_case() == kBoolIndexParams;
}
inline bool PayloadIndexParams::_internal_has_bool_index_params() const {
  return index_params_case() == kBoolIndexParams;
}
inline void PayloadIndexParams::set_has_bool_index_params() {
  _impl_._oneof_case_[0] = kBoolIndexParams;
}
inline void PayloadIndexParams::clear_bool_index_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (index_params_case() == kBoolIndexParams) {
    if (GetArena() == nullptr) {
      delete _impl_.index_params_.bool_index_params_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.index_params_.bool_index_params_);
    }
    clear_has_index_params();
  }
}
inline ::qdrant::BoolIndexParams* PROTOBUF_NULLABLE PayloadIndexParams::release_bool_index_params() {
  // @@protoc_insertion_point(field_release:qdrant.PayloadIndexParams.bool_index_params)
  if (index_params_case() == kBoolIndexParams) {
    clear_has_index_params();
    auto* temp = reinterpret_cast<::qdrant::BoolIndexParams*>(_impl_.index_params_.bool_index_params_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.index_params_.bool_index_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::BoolIndexParams& PayloadIndexParams::_internal_bool_index_params() const {
  return index_params_case() == kBoolIndexParams ? static_cast<const ::qdrant::BoolIndexParams&>(*reinterpret_cast<::qdrant::BoolIndexParams*>(_impl_.index_params_.bool_index_params_))
                     : reinterpret_cast<const ::qdrant::BoolIndexParams&>(::qdrant::_BoolIndexParams_default_instance_);
}
inline const ::qdrant::BoolIndexParams& PayloadIndexParams::bool_index_params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PayloadIndexParams.bool_index_params)
  return _internal_bool_index_params();
}
inline ::qdrant::BoolIndexParams* PROTOBUF_NULLABLE PayloadIndexParams::unsafe_arena_release_bool_index_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PayloadIndexParams.bool_index_params)
  if (index_params_case() == kBoolIndexParams) {
    clear_has_index_params();
    auto* temp = reinterpret_cast<::qdrant::BoolIndexParams*>(_impl_.index_params_.bool_index_params_);
    _impl_.index_params_.bool_index_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PayloadIndexParams::unsafe_arena_set_allocated_bool_index_params(
    ::qdrant::BoolIndexParams* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_index_params();
  if (value) {
    set_has_bool_index_params();
    _impl_.index_params_.bool_index_params_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PayloadIndexParams.bool_index_params)
}
inline ::qdrant::BoolIndexParams* PROTOBUF_NONNULL PayloadIndexParams::_internal_mutable_bool_index_params() {
  if (index_params_case() != kBoolIndexParams) {
    clear_index_params();
    set_has_bool_index_params();
    _impl_.index_params_.bool_index_params_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::BoolIndexParams>(GetArena()));
  }
  return reinterpret_cast<::qdrant::BoolIndexParams*>(_impl_.index_params_.bool_index_params_);
}
inline ::qdrant::BoolIndexParams* PROTOBUF_NONNULL PayloadIndexParams::mutable_bool_index_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::BoolIndexParams* _msg = _internal_mutable_bool_index_params();
  // @@protoc_insertion_point(field_mutable:qdrant.PayloadIndexParams.bool_index_params)
  return _msg;
}

// .qdrant.DatetimeIndexParams datetime_index_params = 7;
inline bool PayloadIndexParams::has_datetime_index_params() const {
  return index_params_case() == kDatetimeIndexParams;
}
inline bool PayloadIndexParams::_internal_has_datetime_index_params() const {
  return index_params_case() == kDatetimeIndexParams;
}
inline void PayloadIndexParams::set_has_datetime_index_params() {
  _impl_._oneof_case_[0] = kDatetimeIndexParams;
}
inline void PayloadIndexParams::clear_datetime_index_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (index_params_case() == kDatetimeIndexParams) {
    if (GetArena() == nullptr) {
      delete _impl_.index_params_.datetime_index_params_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.index_params_.datetime_index_params_);
    }
    clear_has_index_params();
  }
}
inline ::qdrant::DatetimeIndexParams* PROTOBUF_NULLABLE PayloadIndexParams::release_datetime_index_params() {
  // @@protoc_insertion_point(field_release:qdrant.PayloadIndexParams.datetime_index_params)
  if (index_params_case() == kDatetimeIndexParams) {
    clear_has_index_params();
    auto* temp = reinterpret_cast<::qdrant::DatetimeIndexParams*>(_impl_.index_params_.datetime_index_params_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.index_params_.datetime_index_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::DatetimeIndexParams& PayloadIndexParams::_internal_datetime_index_params() const {
  return index_params_case() == kDatetimeIndexParams ? static_cast<const ::qdrant::DatetimeIndexParams&>(*reinterpret_cast<::qdrant::DatetimeIndexParams*>(_impl_.index_params_.datetime_index_params_))
                     : reinterpret_cast<const ::qdrant::DatetimeIndexParams&>(::qdrant::_DatetimeIndexParams_default_instance_);
}
inline const ::qdrant::DatetimeIndexParams& PayloadIndexParams::datetime_index_params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PayloadIndexParams.datetime_index_params)
  return _internal_datetime_index_params();
}
inline ::qdrant::DatetimeIndexParams* PROTOBUF_NULLABLE PayloadIndexParams::unsafe_arena_release_datetime_index_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PayloadIndexParams.datetime_index_params)
  if (index_params_case() == kDatetimeIndexParams) {
    clear_has_index_params();
    auto* temp = reinterpret_cast<::qdrant::DatetimeIndexParams*>(_impl_.index_params_.datetime_index_params_);
    _impl_.index_params_.datetime_index_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PayloadIndexParams::unsafe_arena_set_allocated_datetime_index_params(
    ::qdrant::DatetimeIndexParams* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_index_params();
  if (value) {
    set_has_datetime_index_params();
    _impl_.index_params_.datetime_index_params_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PayloadIndexParams.datetime_index_params)
}
inline ::qdrant::DatetimeIndexParams* PROTOBUF_NONNULL PayloadIndexParams::_internal_mutable_datetime_index_params() {
  if (index_params_case() != kDatetimeIndexParams) {
    clear_index_params();
    set_has_datetime_index_params();
    _impl_.index_params_.datetime_index_params_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::DatetimeIndexParams>(GetArena()));
  }
  return reinterpret_cast<::qdrant::DatetimeIndexParams*>(_impl_.index_params_.datetime_index_params_);
}
inline ::qdrant::DatetimeIndexParams* PROTOBUF_NONNULL PayloadIndexParams::mutable_datetime_index_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::DatetimeIndexParams* _msg = _internal_mutable_datetime_index_params();
  // @@protoc_insertion_point(field_mutable:qdrant.PayloadIndexParams.datetime_index_params)
  return _msg;
}

// .qdrant.UuidIndexParams uuid_index_params = 8;
inline bool PayloadIndexParams::has_uuid_index_params() const {
  return index_params_case() == kUuidIndexParams;
}
inline bool PayloadIndexParams::_internal_has_uuid_index_params() const {
  return index_params_case() == kUuidIndexParams;
}
inline void PayloadIndexParams::set_has_uuid_index_params() {
  _impl_._oneof_case_[0] = kUuidIndexParams;
}
inline void PayloadIndexParams::clear_uuid_index_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (index_params_case() == kUuidIndexParams) {
    if (GetArena() == nullptr) {
      delete _impl_.index_params_.uuid_index_params_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.index_params_.uuid_index_params_);
    }
    clear_has_index_params();
  }
}
inline ::qdrant::UuidIndexParams* PROTOBUF_NULLABLE PayloadIndexParams::release_uuid_index_params() {
  // @@protoc_insertion_point(field_release:qdrant.PayloadIndexParams.uuid_index_params)
  if (index_params_case() == kUuidIndexParams) {
    clear_has_index_params();
    auto* temp = reinterpret_cast<::qdrant::UuidIndexParams*>(_impl_.index_params_.uuid_index_params_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.index_params_.uuid_index_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::UuidIndexParams& PayloadIndexParams::_internal_uuid_index_params() const {
  return index_params_case() == kUuidIndexParams ? static_cast<const ::qdrant::UuidIndexParams&>(*reinterpret_cast<::qdrant::UuidIndexParams*>(_impl_.index_params_.uuid_index_params_))
                     : reinterpret_cast<const ::qdrant::UuidIndexParams&>(::qdrant::_UuidIndexParams_default_instance_);
}
inline const ::qdrant::UuidIndexParams& PayloadIndexParams::uuid_index_params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PayloadIndexParams.uuid_index_params)
  return _internal_uuid_index_params();
}
inline ::qdrant::UuidIndexParams* PROTOBUF_NULLABLE PayloadIndexParams::unsafe_arena_release_uuid_index_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.PayloadIndexParams.uuid_index_params)
  if (index_params_case() == kUuidIndexParams) {
    clear_has_index_params();
    auto* temp = reinterpret_cast<::qdrant::UuidIndexParams*>(_impl_.index_params_.uuid_index_params_);
    _impl_.index_params_.uuid_index_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PayloadIndexParams::unsafe_arena_set_allocated_uuid_index_params(
    ::qdrant::UuidIndexParams* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_index_params();
  if (value) {
    set_has_uuid_index_params();
    _impl_.index_params_.uuid_index_params_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PayloadIndexParams.uuid_index_params)
}
inline ::qdrant::UuidIndexParams* PROTOBUF_NONNULL PayloadIndexParams::_internal_mutable_uuid_index_params() {
  if (index_params_case() != kUuidIndexParams) {
    clear_index_params();
    set_has_uuid_index_params();
    _impl_.index_params_.uuid_index_params_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::UuidIndexParams>(GetArena()));
  }
  return reinterpret_cast<::qdrant::UuidIndexParams*>(_impl_.index_params_.uuid_index_params_);
}
inline ::qdrant::UuidIndexParams* PROTOBUF_NONNULL PayloadIndexParams::mutable_uuid_index_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::UuidIndexParams* _msg = _internal_mutable_uuid_index_params();
  // @@protoc_insertion_point(field_mutable:qdrant.PayloadIndexParams.uuid_index_params)
  return _msg;
}

inline bool PayloadIndexParams::has_index_params() const {
  return index_params_case() != INDEX_PARAMS_NOT_SET;
}
inline void PayloadIndexParams::clear_has_index_params() {
  _impl_._oneof_case_[0] = INDEX_PARAMS_NOT_SET;
}
inline PayloadIndexParams::IndexParamsCase PayloadIndexParams::index_params_case() const {
  return PayloadIndexParams::IndexParamsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PayloadSchemaInfo

// .qdrant.PayloadSchemaType data_type = 1;
inline void PayloadSchemaInfo::clear_data_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_type_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::qdrant::PayloadSchemaType PayloadSchemaInfo::data_type() const {
  // @@protoc_insertion_point(field_get:qdrant.PayloadSchemaInfo.data_type)
  return _internal_data_type();
}
inline void PayloadSchemaInfo::set_data_type(::qdrant::PayloadSchemaType value) {
  _internal_set_data_type(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.PayloadSchemaInfo.data_type)
}
inline ::qdrant::PayloadSchemaType PayloadSchemaInfo::_internal_data_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::PayloadSchemaType>(_impl_.data_type_);
}
inline void PayloadSchemaInfo::_internal_set_data_type(::qdrant::PayloadSchemaType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_type_ = value;
}

// optional .qdrant.PayloadIndexParams params = 2;
inline bool PayloadSchemaInfo::has_params() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.params_ != nullptr);
  return value;
}
inline void PayloadSchemaInfo::clear_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ != nullptr) _impl_.params_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::PayloadIndexParams& PayloadSchemaInfo::_internal_params() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::PayloadIndexParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::PayloadIndexParams&>(::qdrant::_PayloadIndexParams_default_instance_);
}
inline const ::qdrant::PayloadIndexParams& PayloadSchemaInfo::params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.PayloadSchemaInfo.params)
  return _internal_params();
}
inline void PayloadSchemaInfo::unsafe_arena_set_allocated_params(
    ::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = reinterpret_cast<::qdrant::PayloadIndexParams*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.PayloadSchemaInfo.params)
}
inline ::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE PayloadSchemaInfo::release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PayloadIndexParams* released = _impl_.params_;
  _impl_.params_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE PayloadSchemaInfo::unsafe_arena_release_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.PayloadSchemaInfo.params)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PayloadIndexParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::qdrant::PayloadIndexParams* PROTOBUF_NONNULL PayloadSchemaInfo::_internal_mutable_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.params_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::PayloadIndexParams>(GetArena());
    _impl_.params_ = reinterpret_cast<::qdrant::PayloadIndexParams*>(p);
  }
  return _impl_.params_;
}
inline ::qdrant::PayloadIndexParams* PROTOBUF_NONNULL PayloadSchemaInfo::mutable_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::PayloadIndexParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:qdrant.PayloadSchemaInfo.params)
  return _msg;
}
inline void PayloadSchemaInfo::set_allocated_params(::qdrant::PayloadIndexParams* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.params_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.params_ = reinterpret_cast<::qdrant::PayloadIndexParams*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.PayloadSchemaInfo.params)
}

// optional uint64 points = 3;
inline bool PayloadSchemaInfo::has_points() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void PayloadSchemaInfo::clear_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.points_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint64_t PayloadSchemaInfo::points() const {
  // @@protoc_insertion_point(field_get:qdrant.PayloadSchemaInfo.points)
  return _internal_points();
}
inline void PayloadSchemaInfo::set_points(::uint64_t value) {
  _internal_set_points(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.PayloadSchemaInfo.points)
}
inline ::uint64_t PayloadSchemaInfo::_internal_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.points_;
}
inline void PayloadSchemaInfo::_internal_set_points(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.points_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CollectionInfo

// .qdrant.CollectionStatus status = 1;
inline void CollectionInfo::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::qdrant::CollectionStatus CollectionInfo::status() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionInfo.status)
  return _internal_status();
}
inline void CollectionInfo::set_status(::qdrant::CollectionStatus value) {
  _internal_set_status(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionInfo.status)
}
inline ::qdrant::CollectionStatus CollectionInfo::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::CollectionStatus>(_impl_.status_);
}
inline void CollectionInfo::_internal_set_status(::qdrant::CollectionStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// .qdrant.OptimizerStatus optimizer_status = 2;
inline bool CollectionInfo::has_optimizer_status() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.optimizer_status_ != nullptr);
  return value;
}
inline void CollectionInfo::clear_optimizer_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.optimizer_status_ != nullptr) _impl_.optimizer_status_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::OptimizerStatus& CollectionInfo::_internal_optimizer_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::OptimizerStatus* p = _impl_.optimizer_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::OptimizerStatus&>(::qdrant::_OptimizerStatus_default_instance_);
}
inline const ::qdrant::OptimizerStatus& CollectionInfo::optimizer_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionInfo.optimizer_status)
  return _internal_optimizer_status();
}
inline void CollectionInfo::unsafe_arena_set_allocated_optimizer_status(
    ::qdrant::OptimizerStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.optimizer_status_);
  }
  _impl_.optimizer_status_ = reinterpret_cast<::qdrant::OptimizerStatus*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CollectionInfo.optimizer_status)
}
inline ::qdrant::OptimizerStatus* PROTOBUF_NULLABLE CollectionInfo::release_optimizer_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::OptimizerStatus* released = _impl_.optimizer_status_;
  _impl_.optimizer_status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::OptimizerStatus* PROTOBUF_NULLABLE CollectionInfo::unsafe_arena_release_optimizer_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CollectionInfo.optimizer_status)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::OptimizerStatus* temp = _impl_.optimizer_status_;
  _impl_.optimizer_status_ = nullptr;
  return temp;
}
inline ::qdrant::OptimizerStatus* PROTOBUF_NONNULL CollectionInfo::_internal_mutable_optimizer_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.optimizer_status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::OptimizerStatus>(GetArena());
    _impl_.optimizer_status_ = reinterpret_cast<::qdrant::OptimizerStatus*>(p);
  }
  return _impl_.optimizer_status_;
}
inline ::qdrant::OptimizerStatus* PROTOBUF_NONNULL CollectionInfo::mutable_optimizer_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::OptimizerStatus* _msg = _internal_mutable_optimizer_status();
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionInfo.optimizer_status)
  return _msg;
}
inline void CollectionInfo::set_allocated_optimizer_status(::qdrant::OptimizerStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.optimizer_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.optimizer_status_ = reinterpret_cast<::qdrant::OptimizerStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CollectionInfo.optimizer_status)
}

// uint64 segments_count = 4;
inline void CollectionInfo::clear_segments_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segments_count_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint64_t CollectionInfo::segments_count() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionInfo.segments_count)
  return _internal_segments_count();
}
inline void CollectionInfo::set_segments_count(::uint64_t value) {
  _internal_set_segments_count(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionInfo.segments_count)
}
inline ::uint64_t CollectionInfo::_internal_segments_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segments_count_;
}
inline void CollectionInfo::_internal_set_segments_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segments_count_ = value;
}

// .qdrant.CollectionConfig config = 7;
inline bool CollectionInfo::has_config() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.config_ != nullptr);
  return value;
}
inline void CollectionInfo::clear_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.config_ != nullptr) _impl_.config_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::CollectionConfig& CollectionInfo::_internal_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::CollectionConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::CollectionConfig&>(::qdrant::_CollectionConfig_default_instance_);
}
inline const ::qdrant::CollectionConfig& CollectionInfo::config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionInfo.config)
  return _internal_config();
}
inline void CollectionInfo::unsafe_arena_set_allocated_config(
    ::qdrant::CollectionConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = reinterpret_cast<::qdrant::CollectionConfig*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CollectionInfo.config)
}
inline ::qdrant::CollectionConfig* PROTOBUF_NULLABLE CollectionInfo::release_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::CollectionConfig* released = _impl_.config_;
  _impl_.config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::CollectionConfig* PROTOBUF_NULLABLE CollectionInfo::unsafe_arena_release_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CollectionInfo.config)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::CollectionConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::qdrant::CollectionConfig* PROTOBUF_NONNULL CollectionInfo::_internal_mutable_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::CollectionConfig>(GetArena());
    _impl_.config_ = reinterpret_cast<::qdrant::CollectionConfig*>(p);
  }
  return _impl_.config_;
}
inline ::qdrant::CollectionConfig* PROTOBUF_NONNULL CollectionInfo::mutable_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::CollectionConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionInfo.config)
  return _msg;
}
inline void CollectionInfo::set_allocated_config(::qdrant::CollectionConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.config_ = reinterpret_cast<::qdrant::CollectionConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CollectionInfo.config)
}

// map<string, .qdrant.PayloadSchemaInfo> payload_schema = 8;
inline int CollectionInfo::_internal_payload_schema_size() const {
  return _internal_payload_schema().size();
}
inline int CollectionInfo::payload_schema_size() const {
  return _internal_payload_schema_size();
}
inline void CollectionInfo::clear_payload_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_schema_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::PayloadSchemaInfo>& CollectionInfo::_internal_payload_schema() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_schema_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::qdrant::PayloadSchemaInfo>& CollectionInfo::payload_schema() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:qdrant.CollectionInfo.payload_schema)
  return _internal_payload_schema();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::PayloadSchemaInfo>* PROTOBUF_NONNULL CollectionInfo::_internal_mutable_payload_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.payload_schema_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::qdrant::PayloadSchemaInfo>* PROTOBUF_NONNULL CollectionInfo::mutable_payload_schema()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_mutable_map:qdrant.CollectionInfo.payload_schema)
  return _internal_mutable_payload_schema();
}

// optional uint64 points_count = 9;
inline bool CollectionInfo::has_points_count() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void CollectionInfo::clear_points_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.points_count_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint64_t CollectionInfo::points_count() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionInfo.points_count)
  return _internal_points_count();
}
inline void CollectionInfo::set_points_count(::uint64_t value) {
  _internal_set_points_count(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionInfo.points_count)
}
inline ::uint64_t CollectionInfo::_internal_points_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.points_count_;
}
inline void CollectionInfo::_internal_set_points_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.points_count_ = value;
}

// optional uint64 indexed_vectors_count = 10;
inline bool CollectionInfo::has_indexed_vectors_count() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void CollectionInfo::clear_indexed_vectors_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.indexed_vectors_count_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::uint64_t CollectionInfo::indexed_vectors_count() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionInfo.indexed_vectors_count)
  return _internal_indexed_vectors_count();
}
inline void CollectionInfo::set_indexed_vectors_count(::uint64_t value) {
  _internal_set_indexed_vectors_count(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionInfo.indexed_vectors_count)
}
inline ::uint64_t CollectionInfo::_internal_indexed_vectors_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.indexed_vectors_count_;
}
inline void CollectionInfo::_internal_set_indexed_vectors_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.indexed_vectors_count_ = value;
}

// -------------------------------------------------------------------

// ChangeAliases

// repeated .qdrant.AliasOperations actions = 1;
inline int ChangeAliases::_internal_actions_size() const {
  return _internal_actions().size();
}
inline int ChangeAliases::actions_size() const {
  return _internal_actions_size();
}
inline void ChangeAliases::clear_actions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actions_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::AliasOperations* PROTOBUF_NONNULL ChangeAliases::mutable_actions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.ChangeAliases.actions)
  return _internal_mutable_actions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::AliasOperations>* PROTOBUF_NONNULL ChangeAliases::mutable_actions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.ChangeAliases.actions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_actions();
}
inline const ::qdrant::AliasOperations& ChangeAliases::actions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ChangeAliases.actions)
  return _internal_actions().Get(index);
}
inline ::qdrant::AliasOperations* PROTOBUF_NONNULL ChangeAliases::add_actions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::AliasOperations* _add =
      _internal_mutable_actions()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.ChangeAliases.actions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::AliasOperations>& ChangeAliases::actions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.ChangeAliases.actions)
  return _internal_actions();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::AliasOperations>&
ChangeAliases::_internal_actions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.actions_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::AliasOperations>* PROTOBUF_NONNULL
ChangeAliases::_internal_mutable_actions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.actions_;
}

// optional uint64 timeout = 2;
inline bool ChangeAliases::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void ChangeAliases::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint64_t ChangeAliases::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.ChangeAliases.timeout)
  return _internal_timeout();
}
inline void ChangeAliases::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.ChangeAliases.timeout)
}
inline ::uint64_t ChangeAliases::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void ChangeAliases::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// -------------------------------------------------------------------

// AliasOperations

// .qdrant.CreateAlias create_alias = 1;
inline bool AliasOperations::has_create_alias() const {
  return action_case() == kCreateAlias;
}
inline bool AliasOperations::_internal_has_create_alias() const {
  return action_case() == kCreateAlias;
}
inline void AliasOperations::set_has_create_alias() {
  _impl_._oneof_case_[0] = kCreateAlias;
}
inline void AliasOperations::clear_create_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kCreateAlias) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.create_alias_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.create_alias_);
    }
    clear_has_action();
  }
}
inline ::qdrant::CreateAlias* PROTOBUF_NULLABLE AliasOperations::release_create_alias() {
  // @@protoc_insertion_point(field_release:qdrant.AliasOperations.create_alias)
  if (action_case() == kCreateAlias) {
    clear_has_action();
    auto* temp = reinterpret_cast<::qdrant::CreateAlias*>(_impl_.action_.create_alias_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.create_alias_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::CreateAlias& AliasOperations::_internal_create_alias() const {
  return action_case() == kCreateAlias ? static_cast<const ::qdrant::CreateAlias&>(*reinterpret_cast<::qdrant::CreateAlias*>(_impl_.action_.create_alias_))
                     : reinterpret_cast<const ::qdrant::CreateAlias&>(::qdrant::_CreateAlias_default_instance_);
}
inline const ::qdrant::CreateAlias& AliasOperations::create_alias() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.AliasOperations.create_alias)
  return _internal_create_alias();
}
inline ::qdrant::CreateAlias* PROTOBUF_NULLABLE AliasOperations::unsafe_arena_release_create_alias() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.AliasOperations.create_alias)
  if (action_case() == kCreateAlias) {
    clear_has_action();
    auto* temp = reinterpret_cast<::qdrant::CreateAlias*>(_impl_.action_.create_alias_);
    _impl_.action_.create_alias_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AliasOperations::unsafe_arena_set_allocated_create_alias(
    ::qdrant::CreateAlias* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_create_alias();
    _impl_.action_.create_alias_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.AliasOperations.create_alias)
}
inline ::qdrant::CreateAlias* PROTOBUF_NONNULL AliasOperations::_internal_mutable_create_alias() {
  if (action_case() != kCreateAlias) {
    clear_action();
    set_has_create_alias();
    _impl_.action_.create_alias_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::CreateAlias>(GetArena()));
  }
  return reinterpret_cast<::qdrant::CreateAlias*>(_impl_.action_.create_alias_);
}
inline ::qdrant::CreateAlias* PROTOBUF_NONNULL AliasOperations::mutable_create_alias()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::CreateAlias* _msg = _internal_mutable_create_alias();
  // @@protoc_insertion_point(field_mutable:qdrant.AliasOperations.create_alias)
  return _msg;
}

// .qdrant.RenameAlias rename_alias = 2;
inline bool AliasOperations::has_rename_alias() const {
  return action_case() == kRenameAlias;
}
inline bool AliasOperations::_internal_has_rename_alias() const {
  return action_case() == kRenameAlias;
}
inline void AliasOperations::set_has_rename_alias() {
  _impl_._oneof_case_[0] = kRenameAlias;
}
inline void AliasOperations::clear_rename_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kRenameAlias) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.rename_alias_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.rename_alias_);
    }
    clear_has_action();
  }
}
inline ::qdrant::RenameAlias* PROTOBUF_NULLABLE AliasOperations::release_rename_alias() {
  // @@protoc_insertion_point(field_release:qdrant.AliasOperations.rename_alias)
  if (action_case() == kRenameAlias) {
    clear_has_action();
    auto* temp = reinterpret_cast<::qdrant::RenameAlias*>(_impl_.action_.rename_alias_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.rename_alias_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::RenameAlias& AliasOperations::_internal_rename_alias() const {
  return action_case() == kRenameAlias ? static_cast<const ::qdrant::RenameAlias&>(*reinterpret_cast<::qdrant::RenameAlias*>(_impl_.action_.rename_alias_))
                     : reinterpret_cast<const ::qdrant::RenameAlias&>(::qdrant::_RenameAlias_default_instance_);
}
inline const ::qdrant::RenameAlias& AliasOperations::rename_alias() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.AliasOperations.rename_alias)
  return _internal_rename_alias();
}
inline ::qdrant::RenameAlias* PROTOBUF_NULLABLE AliasOperations::unsafe_arena_release_rename_alias() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.AliasOperations.rename_alias)
  if (action_case() == kRenameAlias) {
    clear_has_action();
    auto* temp = reinterpret_cast<::qdrant::RenameAlias*>(_impl_.action_.rename_alias_);
    _impl_.action_.rename_alias_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AliasOperations::unsafe_arena_set_allocated_rename_alias(
    ::qdrant::RenameAlias* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_rename_alias();
    _impl_.action_.rename_alias_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.AliasOperations.rename_alias)
}
inline ::qdrant::RenameAlias* PROTOBUF_NONNULL AliasOperations::_internal_mutable_rename_alias() {
  if (action_case() != kRenameAlias) {
    clear_action();
    set_has_rename_alias();
    _impl_.action_.rename_alias_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::RenameAlias>(GetArena()));
  }
  return reinterpret_cast<::qdrant::RenameAlias*>(_impl_.action_.rename_alias_);
}
inline ::qdrant::RenameAlias* PROTOBUF_NONNULL AliasOperations::mutable_rename_alias()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::RenameAlias* _msg = _internal_mutable_rename_alias();
  // @@protoc_insertion_point(field_mutable:qdrant.AliasOperations.rename_alias)
  return _msg;
}

// .qdrant.DeleteAlias delete_alias = 3;
inline bool AliasOperations::has_delete_alias() const {
  return action_case() == kDeleteAlias;
}
inline bool AliasOperations::_internal_has_delete_alias() const {
  return action_case() == kDeleteAlias;
}
inline void AliasOperations::set_has_delete_alias() {
  _impl_._oneof_case_[0] = kDeleteAlias;
}
inline void AliasOperations::clear_delete_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kDeleteAlias) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.delete_alias_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.delete_alias_);
    }
    clear_has_action();
  }
}
inline ::qdrant::DeleteAlias* PROTOBUF_NULLABLE AliasOperations::release_delete_alias() {
  // @@protoc_insertion_point(field_release:qdrant.AliasOperations.delete_alias)
  if (action_case() == kDeleteAlias) {
    clear_has_action();
    auto* temp = reinterpret_cast<::qdrant::DeleteAlias*>(_impl_.action_.delete_alias_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.delete_alias_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::DeleteAlias& AliasOperations::_internal_delete_alias() const {
  return action_case() == kDeleteAlias ? static_cast<const ::qdrant::DeleteAlias&>(*reinterpret_cast<::qdrant::DeleteAlias*>(_impl_.action_.delete_alias_))
                     : reinterpret_cast<const ::qdrant::DeleteAlias&>(::qdrant::_DeleteAlias_default_instance_);
}
inline const ::qdrant::DeleteAlias& AliasOperations::delete_alias() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.AliasOperations.delete_alias)
  return _internal_delete_alias();
}
inline ::qdrant::DeleteAlias* PROTOBUF_NULLABLE AliasOperations::unsafe_arena_release_delete_alias() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.AliasOperations.delete_alias)
  if (action_case() == kDeleteAlias) {
    clear_has_action();
    auto* temp = reinterpret_cast<::qdrant::DeleteAlias*>(_impl_.action_.delete_alias_);
    _impl_.action_.delete_alias_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AliasOperations::unsafe_arena_set_allocated_delete_alias(
    ::qdrant::DeleteAlias* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_delete_alias();
    _impl_.action_.delete_alias_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.AliasOperations.delete_alias)
}
inline ::qdrant::DeleteAlias* PROTOBUF_NONNULL AliasOperations::_internal_mutable_delete_alias() {
  if (action_case() != kDeleteAlias) {
    clear_action();
    set_has_delete_alias();
    _impl_.action_.delete_alias_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::DeleteAlias>(GetArena()));
  }
  return reinterpret_cast<::qdrant::DeleteAlias*>(_impl_.action_.delete_alias_);
}
inline ::qdrant::DeleteAlias* PROTOBUF_NONNULL AliasOperations::mutable_delete_alias()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::DeleteAlias* _msg = _internal_mutable_delete_alias();
  // @@protoc_insertion_point(field_mutable:qdrant.AliasOperations.delete_alias)
  return _msg;
}

inline bool AliasOperations::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void AliasOperations::clear_has_action() {
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline AliasOperations::ActionCase AliasOperations::action_case() const {
  return AliasOperations::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateAlias

// string collection_name = 1;
inline void CreateAlias::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& CreateAlias::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateAlias.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CreateAlias::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.CreateAlias.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL CreateAlias::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateAlias.collection_name)
  return _s;
}
inline const ::std::string& CreateAlias::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void CreateAlias::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CreateAlias::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CreateAlias::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateAlias.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void CreateAlias::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateAlias.collection_name)
}

// string alias_name = 2;
inline void CreateAlias::clear_alias_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& CreateAlias::alias_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateAlias.alias_name)
  return _internal_alias_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CreateAlias::set_alias_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.alias_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.CreateAlias.alias_name)
}
inline ::std::string* PROTOBUF_NONNULL CreateAlias::mutable_alias_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_alias_name();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateAlias.alias_name)
  return _s;
}
inline const ::std::string& CreateAlias::_internal_alias_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alias_name_.Get();
}
inline void CreateAlias::_internal_set_alias_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CreateAlias::_internal_mutable_alias_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.alias_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CreateAlias::release_alias_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateAlias.alias_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.alias_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.alias_name_.Set("", GetArena());
  }
  return released;
}
inline void CreateAlias::set_allocated_alias_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.alias_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.alias_name_.IsDefault()) {
    _impl_.alias_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateAlias.alias_name)
}

// -------------------------------------------------------------------

// RenameAlias

// string old_alias_name = 1;
inline void RenameAlias::clear_old_alias_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_alias_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& RenameAlias::old_alias_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RenameAlias.old_alias_name)
  return _internal_old_alias_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RenameAlias::set_old_alias_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.old_alias_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.RenameAlias.old_alias_name)
}
inline ::std::string* PROTOBUF_NONNULL RenameAlias::mutable_old_alias_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_old_alias_name();
  // @@protoc_insertion_point(field_mutable:qdrant.RenameAlias.old_alias_name)
  return _s;
}
inline const ::std::string& RenameAlias::_internal_old_alias_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.old_alias_name_.Get();
}
inline void RenameAlias::_internal_set_old_alias_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_alias_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RenameAlias::_internal_mutable_old_alias_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.old_alias_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RenameAlias::release_old_alias_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RenameAlias.old_alias_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.old_alias_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.old_alias_name_.Set("", GetArena());
  }
  return released;
}
inline void RenameAlias::set_allocated_old_alias_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.old_alias_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.old_alias_name_.IsDefault()) {
    _impl_.old_alias_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.RenameAlias.old_alias_name)
}

// string new_alias_name = 2;
inline void RenameAlias::clear_new_alias_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_alias_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& RenameAlias::new_alias_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RenameAlias.new_alias_name)
  return _internal_new_alias_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RenameAlias::set_new_alias_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.new_alias_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.RenameAlias.new_alias_name)
}
inline ::std::string* PROTOBUF_NONNULL RenameAlias::mutable_new_alias_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_new_alias_name();
  // @@protoc_insertion_point(field_mutable:qdrant.RenameAlias.new_alias_name)
  return _s;
}
inline const ::std::string& RenameAlias::_internal_new_alias_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_alias_name_.Get();
}
inline void RenameAlias::_internal_set_new_alias_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_alias_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RenameAlias::_internal_mutable_new_alias_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.new_alias_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RenameAlias::release_new_alias_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RenameAlias.new_alias_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.new_alias_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.new_alias_name_.Set("", GetArena());
  }
  return released;
}
inline void RenameAlias::set_allocated_new_alias_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.new_alias_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.new_alias_name_.IsDefault()) {
    _impl_.new_alias_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.RenameAlias.new_alias_name)
}

// -------------------------------------------------------------------

// DeleteAlias

// string alias_name = 1;
inline void DeleteAlias::clear_alias_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& DeleteAlias::alias_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeleteAlias.alias_name)
  return _internal_alias_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DeleteAlias::set_alias_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.alias_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.DeleteAlias.alias_name)
}
inline ::std::string* PROTOBUF_NONNULL DeleteAlias::mutable_alias_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_alias_name();
  // @@protoc_insertion_point(field_mutable:qdrant.DeleteAlias.alias_name)
  return _s;
}
inline const ::std::string& DeleteAlias::_internal_alias_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alias_name_.Get();
}
inline void DeleteAlias::_internal_set_alias_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DeleteAlias::_internal_mutable_alias_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.alias_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DeleteAlias::release_alias_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeleteAlias.alias_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.alias_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.alias_name_.Set("", GetArena());
  }
  return released;
}
inline void DeleteAlias::set_allocated_alias_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.alias_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.alias_name_.IsDefault()) {
    _impl_.alias_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeleteAlias.alias_name)
}

// -------------------------------------------------------------------

// ListAliasesRequest

// -------------------------------------------------------------------

// ListCollectionAliasesRequest

// string collection_name = 1;
inline void ListCollectionAliasesRequest::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ListCollectionAliasesRequest::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ListCollectionAliasesRequest.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListCollectionAliasesRequest::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.ListCollectionAliasesRequest.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL ListCollectionAliasesRequest::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.ListCollectionAliasesRequest.collection_name)
  return _s;
}
inline const ::std::string& ListCollectionAliasesRequest::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void ListCollectionAliasesRequest::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListCollectionAliasesRequest::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListCollectionAliasesRequest::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ListCollectionAliasesRequest.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void ListCollectionAliasesRequest::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.ListCollectionAliasesRequest.collection_name)
}

// -------------------------------------------------------------------

// AliasDescription

// string alias_name = 1;
inline void AliasDescription::clear_alias_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& AliasDescription::alias_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.AliasDescription.alias_name)
  return _internal_alias_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AliasDescription::set_alias_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.alias_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.AliasDescription.alias_name)
}
inline ::std::string* PROTOBUF_NONNULL AliasDescription::mutable_alias_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_alias_name();
  // @@protoc_insertion_point(field_mutable:qdrant.AliasDescription.alias_name)
  return _s;
}
inline const ::std::string& AliasDescription::_internal_alias_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alias_name_.Get();
}
inline void AliasDescription::_internal_set_alias_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AliasDescription::_internal_mutable_alias_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.alias_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AliasDescription::release_alias_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.AliasDescription.alias_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.alias_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.alias_name_.Set("", GetArena());
  }
  return released;
}
inline void AliasDescription::set_allocated_alias_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.alias_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.alias_name_.IsDefault()) {
    _impl_.alias_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.AliasDescription.alias_name)
}

// string collection_name = 2;
inline void AliasDescription::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& AliasDescription::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.AliasDescription.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AliasDescription::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.AliasDescription.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL AliasDescription::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.AliasDescription.collection_name)
  return _s;
}
inline const ::std::string& AliasDescription::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void AliasDescription::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AliasDescription::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AliasDescription::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.AliasDescription.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void AliasDescription::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.AliasDescription.collection_name)
}

// -------------------------------------------------------------------

// ListAliasesResponse

// repeated .qdrant.AliasDescription aliases = 1;
inline int ListAliasesResponse::_internal_aliases_size() const {
  return _internal_aliases().size();
}
inline int ListAliasesResponse::aliases_size() const {
  return _internal_aliases_size();
}
inline void ListAliasesResponse::clear_aliases() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aliases_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::AliasDescription* PROTOBUF_NONNULL ListAliasesResponse::mutable_aliases(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.ListAliasesResponse.aliases)
  return _internal_mutable_aliases()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::AliasDescription>* PROTOBUF_NONNULL ListAliasesResponse::mutable_aliases()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.ListAliasesResponse.aliases)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_aliases();
}
inline const ::qdrant::AliasDescription& ListAliasesResponse::aliases(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ListAliasesResponse.aliases)
  return _internal_aliases().Get(index);
}
inline ::qdrant::AliasDescription* PROTOBUF_NONNULL ListAliasesResponse::add_aliases()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::AliasDescription* _add =
      _internal_mutable_aliases()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.ListAliasesResponse.aliases)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::AliasDescription>& ListAliasesResponse::aliases() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.ListAliasesResponse.aliases)
  return _internal_aliases();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::AliasDescription>&
ListAliasesResponse::_internal_aliases() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aliases_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::AliasDescription>* PROTOBUF_NONNULL
ListAliasesResponse::_internal_mutable_aliases() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.aliases_;
}

// double time = 2;
inline void ListAliasesResponse::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline double ListAliasesResponse::time() const {
  // @@protoc_insertion_point(field_get:qdrant.ListAliasesResponse.time)
  return _internal_time();
}
inline void ListAliasesResponse::set_time(double value) {
  _internal_set_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.ListAliasesResponse.time)
}
inline double ListAliasesResponse::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void ListAliasesResponse::_internal_set_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// CollectionClusterInfoRequest

// string collection_name = 1;
inline void CollectionClusterInfoRequest::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& CollectionClusterInfoRequest::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionClusterInfoRequest.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CollectionClusterInfoRequest::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.CollectionClusterInfoRequest.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL CollectionClusterInfoRequest::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionClusterInfoRequest.collection_name)
  return _s;
}
inline const ::std::string& CollectionClusterInfoRequest::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void CollectionClusterInfoRequest::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CollectionClusterInfoRequest::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CollectionClusterInfoRequest::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CollectionClusterInfoRequest.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void CollectionClusterInfoRequest::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.CollectionClusterInfoRequest.collection_name)
}

// -------------------------------------------------------------------

// ShardKey

// string keyword = 1;
inline bool ShardKey::has_keyword() const {
  return key_case() == kKeyword;
}
inline void ShardKey::set_has_keyword() {
  _impl_._oneof_case_[0] = kKeyword;
}
inline void ShardKey::clear_keyword() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (key_case() == kKeyword) {
    _impl_.key_.keyword_.Destroy();
    clear_has_key();
  }
}
inline const ::std::string& ShardKey::keyword() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ShardKey.keyword)
  return _internal_keyword();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ShardKey::set_keyword(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (key_case() != kKeyword) {
    clear_key();

    set_has_keyword();
    _impl_.key_.keyword_.InitDefault();
  }
  _impl_.key_.keyword_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.ShardKey.keyword)
}
inline ::std::string* PROTOBUF_NONNULL ShardKey::mutable_keyword()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  if (key_case() != kKeyword) {
    clear_key();

    set_has_keyword();
    _impl_.key_.keyword_.InitDefault();
  }
  ::std::string* _s = _internal_mutable_keyword();
  // @@protoc_insertion_point(field_mutable:qdrant.ShardKey.keyword)
  return _s;
}
inline const ::std::string& ShardKey::_internal_keyword() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (key_case() != kKeyword) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.key_.keyword_.Get();
}
inline void ShardKey::_internal_set_keyword(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.keyword_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ShardKey::_internal_mutable_keyword() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.keyword_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ShardKey::release_keyword() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ShardKey.keyword)
  if (key_case() != kKeyword) {
    return nullptr;
  }
  clear_has_key();
  return _impl_.key_.keyword_.Release();
}
inline void ShardKey::set_allocated_keyword(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_key()) {
    clear_key();
  }
  if (value != nullptr) {
    set_has_keyword();
    _impl_.key_.keyword_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.ShardKey.keyword)
}

// uint64 number = 2;
inline bool ShardKey::has_number() const {
  return key_case() == kNumber;
}
inline void ShardKey::set_has_number() {
  _impl_._oneof_case_[0] = kNumber;
}
inline void ShardKey::clear_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (key_case() == kNumber) {
    _impl_.key_.number_ = ::uint64_t{0u};
    clear_has_key();
  }
}
inline ::uint64_t ShardKey::number() const {
  // @@protoc_insertion_point(field_get:qdrant.ShardKey.number)
  return _internal_number();
}
inline void ShardKey::set_number(::uint64_t value) {
  if (key_case() != kNumber) {
    clear_key();
    set_has_number();
  }
  _impl_.key_.number_ = value;
  // @@protoc_insertion_point(field_set:qdrant.ShardKey.number)
}
inline ::uint64_t ShardKey::_internal_number() const {
  if (key_case() == kNumber) {
    return _impl_.key_.number_;
  }
  return ::uint64_t{0u};
}

inline bool ShardKey::has_key() const {
  return key_case() != KEY_NOT_SET;
}
inline void ShardKey::clear_has_key() {
  _impl_._oneof_case_[0] = KEY_NOT_SET;
}
inline ShardKey::KeyCase ShardKey::key_case() const {
  return ShardKey::KeyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LocalShardInfo

// uint32 shard_id = 1;
inline void LocalShardInfo::clear_shard_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint32_t LocalShardInfo::shard_id() const {
  // @@protoc_insertion_point(field_get:qdrant.LocalShardInfo.shard_id)
  return _internal_shard_id();
}
inline void LocalShardInfo::set_shard_id(::uint32_t value) {
  _internal_set_shard_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.LocalShardInfo.shard_id)
}
inline ::uint32_t LocalShardInfo::_internal_shard_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shard_id_;
}
inline void LocalShardInfo::_internal_set_shard_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = value;
}

// uint64 points_count = 2;
inline void LocalShardInfo::clear_points_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.points_count_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint64_t LocalShardInfo::points_count() const {
  // @@protoc_insertion_point(field_get:qdrant.LocalShardInfo.points_count)
  return _internal_points_count();
}
inline void LocalShardInfo::set_points_count(::uint64_t value) {
  _internal_set_points_count(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.LocalShardInfo.points_count)
}
inline ::uint64_t LocalShardInfo::_internal_points_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.points_count_;
}
inline void LocalShardInfo::_internal_set_points_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.points_count_ = value;
}

// .qdrant.ReplicaState state = 3;
inline void LocalShardInfo::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::qdrant::ReplicaState LocalShardInfo::state() const {
  // @@protoc_insertion_point(field_get:qdrant.LocalShardInfo.state)
  return _internal_state();
}
inline void LocalShardInfo::set_state(::qdrant::ReplicaState value) {
  _internal_set_state(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.LocalShardInfo.state)
}
inline ::qdrant::ReplicaState LocalShardInfo::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::ReplicaState>(_impl_.state_);
}
inline void LocalShardInfo::_internal_set_state(::qdrant::ReplicaState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = value;
}

// optional .qdrant.ShardKey shard_key = 4;
inline bool LocalShardInfo::has_shard_key() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_ != nullptr);
  return value;
}
inline void LocalShardInfo::clear_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_ != nullptr) _impl_.shard_key_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::ShardKey& LocalShardInfo::_internal_shard_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKey* p = _impl_.shard_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKey&>(::qdrant::_ShardKey_default_instance_);
}
inline const ::qdrant::ShardKey& LocalShardInfo::shard_key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.LocalShardInfo.shard_key)
  return _internal_shard_key();
}
inline void LocalShardInfo::unsafe_arena_set_allocated_shard_key(
    ::qdrant::ShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_);
  }
  _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.LocalShardInfo.shard_key)
}
inline ::qdrant::ShardKey* PROTOBUF_NULLABLE LocalShardInfo::release_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::ShardKey* released = _impl_.shard_key_;
  _impl_.shard_key_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKey* PROTOBUF_NULLABLE LocalShardInfo::unsafe_arena_release_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.LocalShardInfo.shard_key)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::ShardKey* temp = _impl_.shard_key_;
  _impl_.shard_key_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKey* PROTOBUF_NONNULL LocalShardInfo::_internal_mutable_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKey>(GetArena());
    _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(p);
  }
  return _impl_.shard_key_;
}
inline ::qdrant::ShardKey* PROTOBUF_NONNULL LocalShardInfo::mutable_shard_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::ShardKey* _msg = _internal_mutable_shard_key();
  // @@protoc_insertion_point(field_mutable:qdrant.LocalShardInfo.shard_key)
  return _msg;
}
inline void LocalShardInfo::set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.LocalShardInfo.shard_key)
}

// -------------------------------------------------------------------

// RemoteShardInfo

// uint32 shard_id = 1;
inline void RemoteShardInfo::clear_shard_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint32_t RemoteShardInfo::shard_id() const {
  // @@protoc_insertion_point(field_get:qdrant.RemoteShardInfo.shard_id)
  return _internal_shard_id();
}
inline void RemoteShardInfo::set_shard_id(::uint32_t value) {
  _internal_set_shard_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.RemoteShardInfo.shard_id)
}
inline ::uint32_t RemoteShardInfo::_internal_shard_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shard_id_;
}
inline void RemoteShardInfo::_internal_set_shard_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = value;
}

// uint64 peer_id = 2;
inline void RemoteShardInfo::clear_peer_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.peer_id_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint64_t RemoteShardInfo::peer_id() const {
  // @@protoc_insertion_point(field_get:qdrant.RemoteShardInfo.peer_id)
  return _internal_peer_id();
}
inline void RemoteShardInfo::set_peer_id(::uint64_t value) {
  _internal_set_peer_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.RemoteShardInfo.peer_id)
}
inline ::uint64_t RemoteShardInfo::_internal_peer_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.peer_id_;
}
inline void RemoteShardInfo::_internal_set_peer_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.peer_id_ = value;
}

// .qdrant.ReplicaState state = 3;
inline void RemoteShardInfo::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::qdrant::ReplicaState RemoteShardInfo::state() const {
  // @@protoc_insertion_point(field_get:qdrant.RemoteShardInfo.state)
  return _internal_state();
}
inline void RemoteShardInfo::set_state(::qdrant::ReplicaState value) {
  _internal_set_state(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.RemoteShardInfo.state)
}
inline ::qdrant::ReplicaState RemoteShardInfo::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::ReplicaState>(_impl_.state_);
}
inline void RemoteShardInfo::_internal_set_state(::qdrant::ReplicaState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = value;
}

// optional .qdrant.ShardKey shard_key = 4;
inline bool RemoteShardInfo::has_shard_key() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_ != nullptr);
  return value;
}
inline void RemoteShardInfo::clear_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_ != nullptr) _impl_.shard_key_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::ShardKey& RemoteShardInfo::_internal_shard_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKey* p = _impl_.shard_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKey&>(::qdrant::_ShardKey_default_instance_);
}
inline const ::qdrant::ShardKey& RemoteShardInfo::shard_key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.RemoteShardInfo.shard_key)
  return _internal_shard_key();
}
inline void RemoteShardInfo::unsafe_arena_set_allocated_shard_key(
    ::qdrant::ShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_);
  }
  _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.RemoteShardInfo.shard_key)
}
inline ::qdrant::ShardKey* PROTOBUF_NULLABLE RemoteShardInfo::release_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::ShardKey* released = _impl_.shard_key_;
  _impl_.shard_key_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKey* PROTOBUF_NULLABLE RemoteShardInfo::unsafe_arena_release_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.RemoteShardInfo.shard_key)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::ShardKey* temp = _impl_.shard_key_;
  _impl_.shard_key_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKey* PROTOBUF_NONNULL RemoteShardInfo::_internal_mutable_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKey>(GetArena());
    _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(p);
  }
  return _impl_.shard_key_;
}
inline ::qdrant::ShardKey* PROTOBUF_NONNULL RemoteShardInfo::mutable_shard_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::ShardKey* _msg = _internal_mutable_shard_key();
  // @@protoc_insertion_point(field_mutable:qdrant.RemoteShardInfo.shard_key)
  return _msg;
}
inline void RemoteShardInfo::set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.RemoteShardInfo.shard_key)
}

// -------------------------------------------------------------------

// ShardTransferInfo

// uint32 shard_id = 1;
inline void ShardTransferInfo::clear_shard_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint32_t ShardTransferInfo::shard_id() const {
  // @@protoc_insertion_point(field_get:qdrant.ShardTransferInfo.shard_id)
  return _internal_shard_id();
}
inline void ShardTransferInfo::set_shard_id(::uint32_t value) {
  _internal_set_shard_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.ShardTransferInfo.shard_id)
}
inline ::uint32_t ShardTransferInfo::_internal_shard_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shard_id_;
}
inline void ShardTransferInfo::_internal_set_shard_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = value;
}

// optional uint32 to_shard_id = 5;
inline bool ShardTransferInfo::has_to_shard_id() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void ShardTransferInfo::clear_to_shard_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_shard_id_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::uint32_t ShardTransferInfo::to_shard_id() const {
  // @@protoc_insertion_point(field_get:qdrant.ShardTransferInfo.to_shard_id)
  return _internal_to_shard_id();
}
inline void ShardTransferInfo::set_to_shard_id(::uint32_t value) {
  _internal_set_to_shard_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.ShardTransferInfo.to_shard_id)
}
inline ::uint32_t ShardTransferInfo::_internal_to_shard_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_shard_id_;
}
inline void ShardTransferInfo::_internal_set_to_shard_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_shard_id_ = value;
}

// uint64 from = 2;
inline void ShardTransferInfo::clear_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t ShardTransferInfo::from() const {
  // @@protoc_insertion_point(field_get:qdrant.ShardTransferInfo.from)
  return _internal_from();
}
inline void ShardTransferInfo::set_from(::uint64_t value) {
  _internal_set_from(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.ShardTransferInfo.from)
}
inline ::uint64_t ShardTransferInfo::_internal_from() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_;
}
inline void ShardTransferInfo::_internal_set_from(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_ = value;
}

// uint64 to = 3;
inline void ShardTransferInfo::clear_to() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint64_t ShardTransferInfo::to() const {
  // @@protoc_insertion_point(field_get:qdrant.ShardTransferInfo.to)
  return _internal_to();
}
inline void ShardTransferInfo::set_to(::uint64_t value) {
  _internal_set_to(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.ShardTransferInfo.to)
}
inline ::uint64_t ShardTransferInfo::_internal_to() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_;
}
inline void ShardTransferInfo::_internal_set_to(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_ = value;
}

// bool sync = 4;
inline void ShardTransferInfo::clear_sync() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sync_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline bool ShardTransferInfo::sync() const {
  // @@protoc_insertion_point(field_get:qdrant.ShardTransferInfo.sync)
  return _internal_sync();
}
inline void ShardTransferInfo::set_sync(bool value) {
  _internal_set_sync(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.ShardTransferInfo.sync)
}
inline bool ShardTransferInfo::_internal_sync() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sync_;
}
inline void ShardTransferInfo::_internal_set_sync(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sync_ = value;
}

// -------------------------------------------------------------------

// ReshardingInfo

// uint32 shard_id = 1;
inline void ReshardingInfo::clear_shard_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint32_t ReshardingInfo::shard_id() const {
  // @@protoc_insertion_point(field_get:qdrant.ReshardingInfo.shard_id)
  return _internal_shard_id();
}
inline void ReshardingInfo::set_shard_id(::uint32_t value) {
  _internal_set_shard_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.ReshardingInfo.shard_id)
}
inline ::uint32_t ReshardingInfo::_internal_shard_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shard_id_;
}
inline void ReshardingInfo::_internal_set_shard_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = value;
}

// uint64 peer_id = 2;
inline void ReshardingInfo::clear_peer_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.peer_id_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint64_t ReshardingInfo::peer_id() const {
  // @@protoc_insertion_point(field_get:qdrant.ReshardingInfo.peer_id)
  return _internal_peer_id();
}
inline void ReshardingInfo::set_peer_id(::uint64_t value) {
  _internal_set_peer_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.ReshardingInfo.peer_id)
}
inline ::uint64_t ReshardingInfo::_internal_peer_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.peer_id_;
}
inline void ReshardingInfo::_internal_set_peer_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.peer_id_ = value;
}

// optional .qdrant.ShardKey shard_key = 3;
inline bool ReshardingInfo::has_shard_key() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_ != nullptr);
  return value;
}
inline void ReshardingInfo::clear_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_ != nullptr) _impl_.shard_key_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::ShardKey& ReshardingInfo::_internal_shard_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKey* p = _impl_.shard_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKey&>(::qdrant::_ShardKey_default_instance_);
}
inline const ::qdrant::ShardKey& ReshardingInfo::shard_key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.ReshardingInfo.shard_key)
  return _internal_shard_key();
}
inline void ReshardingInfo::unsafe_arena_set_allocated_shard_key(
    ::qdrant::ShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_);
  }
  _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.ReshardingInfo.shard_key)
}
inline ::qdrant::ShardKey* PROTOBUF_NULLABLE ReshardingInfo::release_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::ShardKey* released = _impl_.shard_key_;
  _impl_.shard_key_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKey* PROTOBUF_NULLABLE ReshardingInfo::unsafe_arena_release_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.ReshardingInfo.shard_key)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::ShardKey* temp = _impl_.shard_key_;
  _impl_.shard_key_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKey* PROTOBUF_NONNULL ReshardingInfo::_internal_mutable_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKey>(GetArena());
    _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(p);
  }
  return _impl_.shard_key_;
}
inline ::qdrant::ShardKey* PROTOBUF_NONNULL ReshardingInfo::mutable_shard_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::ShardKey* _msg = _internal_mutable_shard_key();
  // @@protoc_insertion_point(field_mutable:qdrant.ReshardingInfo.shard_key)
  return _msg;
}
inline void ReshardingInfo::set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.ReshardingInfo.shard_key)
}

// .qdrant.ReshardingDirection direction = 4;
inline void ReshardingInfo::clear_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::qdrant::ReshardingDirection ReshardingInfo::direction() const {
  // @@protoc_insertion_point(field_get:qdrant.ReshardingInfo.direction)
  return _internal_direction();
}
inline void ReshardingInfo::set_direction(::qdrant::ReshardingDirection value) {
  _internal_set_direction(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.ReshardingInfo.direction)
}
inline ::qdrant::ReshardingDirection ReshardingInfo::_internal_direction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::ReshardingDirection>(_impl_.direction_);
}
inline void ReshardingInfo::_internal_set_direction(::qdrant::ReshardingDirection value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_ = value;
}

// -------------------------------------------------------------------

// CollectionClusterInfoResponse

// uint64 peer_id = 1;
inline void CollectionClusterInfoResponse::clear_peer_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.peer_id_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::uint64_t CollectionClusterInfoResponse::peer_id() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionClusterInfoResponse.peer_id)
  return _internal_peer_id();
}
inline void CollectionClusterInfoResponse::set_peer_id(::uint64_t value) {
  _internal_set_peer_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionClusterInfoResponse.peer_id)
}
inline ::uint64_t CollectionClusterInfoResponse::_internal_peer_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.peer_id_;
}
inline void CollectionClusterInfoResponse::_internal_set_peer_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.peer_id_ = value;
}

// uint64 shard_count = 2;
inline void CollectionClusterInfoResponse::clear_shard_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_count_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::uint64_t CollectionClusterInfoResponse::shard_count() const {
  // @@protoc_insertion_point(field_get:qdrant.CollectionClusterInfoResponse.shard_count)
  return _internal_shard_count();
}
inline void CollectionClusterInfoResponse::set_shard_count(::uint64_t value) {
  _internal_set_shard_count(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:qdrant.CollectionClusterInfoResponse.shard_count)
}
inline ::uint64_t CollectionClusterInfoResponse::_internal_shard_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shard_count_;
}
inline void CollectionClusterInfoResponse::_internal_set_shard_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_count_ = value;
}

// repeated .qdrant.LocalShardInfo local_shards = 3;
inline int CollectionClusterInfoResponse::_internal_local_shards_size() const {
  return _internal_local_shards().size();
}
inline int CollectionClusterInfoResponse::local_shards_size() const {
  return _internal_local_shards_size();
}
inline void CollectionClusterInfoResponse::clear_local_shards() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_shards_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::qdrant::LocalShardInfo* PROTOBUF_NONNULL CollectionClusterInfoResponse::mutable_local_shards(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionClusterInfoResponse.local_shards)
  return _internal_mutable_local_shards()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::LocalShardInfo>* PROTOBUF_NONNULL CollectionClusterInfoResponse::mutable_local_shards()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.CollectionClusterInfoResponse.local_shards)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_local_shards();
}
inline const ::qdrant::LocalShardInfo& CollectionClusterInfoResponse::local_shards(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionClusterInfoResponse.local_shards)
  return _internal_local_shards().Get(index);
}
inline ::qdrant::LocalShardInfo* PROTOBUF_NONNULL CollectionClusterInfoResponse::add_local_shards()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::LocalShardInfo* _add =
      _internal_mutable_local_shards()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.CollectionClusterInfoResponse.local_shards)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::LocalShardInfo>& CollectionClusterInfoResponse::local_shards() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.CollectionClusterInfoResponse.local_shards)
  return _internal_local_shards();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::LocalShardInfo>&
CollectionClusterInfoResponse::_internal_local_shards() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.local_shards_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::LocalShardInfo>* PROTOBUF_NONNULL
CollectionClusterInfoResponse::_internal_mutable_local_shards() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.local_shards_;
}

// repeated .qdrant.RemoteShardInfo remote_shards = 4;
inline int CollectionClusterInfoResponse::_internal_remote_shards_size() const {
  return _internal_remote_shards().size();
}
inline int CollectionClusterInfoResponse::remote_shards_size() const {
  return _internal_remote_shards_size();
}
inline void CollectionClusterInfoResponse::clear_remote_shards() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_shards_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::qdrant::RemoteShardInfo* PROTOBUF_NONNULL CollectionClusterInfoResponse::mutable_remote_shards(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionClusterInfoResponse.remote_shards)
  return _internal_mutable_remote_shards()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::RemoteShardInfo>* PROTOBUF_NONNULL CollectionClusterInfoResponse::mutable_remote_shards()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.CollectionClusterInfoResponse.remote_shards)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_remote_shards();
}
inline const ::qdrant::RemoteShardInfo& CollectionClusterInfoResponse::remote_shards(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionClusterInfoResponse.remote_shards)
  return _internal_remote_shards().Get(index);
}
inline ::qdrant::RemoteShardInfo* PROTOBUF_NONNULL CollectionClusterInfoResponse::add_remote_shards()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::RemoteShardInfo* _add =
      _internal_mutable_remote_shards()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:qdrant.CollectionClusterInfoResponse.remote_shards)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::RemoteShardInfo>& CollectionClusterInfoResponse::remote_shards() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.CollectionClusterInfoResponse.remote_shards)
  return _internal_remote_shards();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::RemoteShardInfo>&
CollectionClusterInfoResponse::_internal_remote_shards() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.remote_shards_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::RemoteShardInfo>* PROTOBUF_NONNULL
CollectionClusterInfoResponse::_internal_mutable_remote_shards() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.remote_shards_;
}

// repeated .qdrant.ShardTransferInfo shard_transfers = 5;
inline int CollectionClusterInfoResponse::_internal_shard_transfers_size() const {
  return _internal_shard_transfers().size();
}
inline int CollectionClusterInfoResponse::shard_transfers_size() const {
  return _internal_shard_transfers_size();
}
inline void CollectionClusterInfoResponse::clear_shard_transfers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_transfers_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::qdrant::ShardTransferInfo* PROTOBUF_NONNULL CollectionClusterInfoResponse::mutable_shard_transfers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionClusterInfoResponse.shard_transfers)
  return _internal_mutable_shard_transfers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ShardTransferInfo>* PROTOBUF_NONNULL CollectionClusterInfoResponse::mutable_shard_transfers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.CollectionClusterInfoResponse.shard_transfers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_shard_transfers();
}
inline const ::qdrant::ShardTransferInfo& CollectionClusterInfoResponse::shard_transfers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionClusterInfoResponse.shard_transfers)
  return _internal_shard_transfers().Get(index);
}
inline ::qdrant::ShardTransferInfo* PROTOBUF_NONNULL CollectionClusterInfoResponse::add_shard_transfers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::ShardTransferInfo* _add =
      _internal_mutable_shard_transfers()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:qdrant.CollectionClusterInfoResponse.shard_transfers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ShardTransferInfo>& CollectionClusterInfoResponse::shard_transfers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.CollectionClusterInfoResponse.shard_transfers)
  return _internal_shard_transfers();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ShardTransferInfo>&
CollectionClusterInfoResponse::_internal_shard_transfers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shard_transfers_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ShardTransferInfo>* PROTOBUF_NONNULL
CollectionClusterInfoResponse::_internal_mutable_shard_transfers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.shard_transfers_;
}

// repeated .qdrant.ReshardingInfo resharding_operations = 6;
inline int CollectionClusterInfoResponse::_internal_resharding_operations_size() const {
  return _internal_resharding_operations().size();
}
inline int CollectionClusterInfoResponse::resharding_operations_size() const {
  return _internal_resharding_operations_size();
}
inline void CollectionClusterInfoResponse::clear_resharding_operations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resharding_operations_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::qdrant::ReshardingInfo* PROTOBUF_NONNULL CollectionClusterInfoResponse::mutable_resharding_operations(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:qdrant.CollectionClusterInfoResponse.resharding_operations)
  return _internal_mutable_resharding_operations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ReshardingInfo>* PROTOBUF_NONNULL CollectionClusterInfoResponse::mutable_resharding_operations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.CollectionClusterInfoResponse.resharding_operations)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_resharding_operations();
}
inline const ::qdrant::ReshardingInfo& CollectionClusterInfoResponse::resharding_operations(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CollectionClusterInfoResponse.resharding_operations)
  return _internal_resharding_operations().Get(index);
}
inline ::qdrant::ReshardingInfo* PROTOBUF_NONNULL CollectionClusterInfoResponse::add_resharding_operations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::qdrant::ReshardingInfo* _add =
      _internal_mutable_resharding_operations()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_add:qdrant.CollectionClusterInfoResponse.resharding_operations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ReshardingInfo>& CollectionClusterInfoResponse::resharding_operations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.CollectionClusterInfoResponse.resharding_operations)
  return _internal_resharding_operations();
}
inline const ::google::protobuf::RepeatedPtrField<::qdrant::ReshardingInfo>&
CollectionClusterInfoResponse::_internal_resharding_operations() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resharding_operations_;
}
inline ::google::protobuf::RepeatedPtrField<::qdrant::ReshardingInfo>* PROTOBUF_NONNULL
CollectionClusterInfoResponse::_internal_mutable_resharding_operations() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.resharding_operations_;
}

// -------------------------------------------------------------------

// MoveShard

// uint32 shard_id = 1;
inline void MoveShard::clear_shard_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint32_t MoveShard::shard_id() const {
  // @@protoc_insertion_point(field_get:qdrant.MoveShard.shard_id)
  return _internal_shard_id();
}
inline void MoveShard::set_shard_id(::uint32_t value) {
  _internal_set_shard_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.MoveShard.shard_id)
}
inline ::uint32_t MoveShard::_internal_shard_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shard_id_;
}
inline void MoveShard::_internal_set_shard_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = value;
}

// optional uint32 to_shard_id = 5;
inline bool MoveShard::has_to_shard_id() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void MoveShard::clear_to_shard_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_shard_id_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::uint32_t MoveShard::to_shard_id() const {
  // @@protoc_insertion_point(field_get:qdrant.MoveShard.to_shard_id)
  return _internal_to_shard_id();
}
inline void MoveShard::set_to_shard_id(::uint32_t value) {
  _internal_set_to_shard_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.MoveShard.to_shard_id)
}
inline ::uint32_t MoveShard::_internal_to_shard_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_shard_id_;
}
inline void MoveShard::_internal_set_to_shard_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_shard_id_ = value;
}

// uint64 from_peer_id = 2;
inline void MoveShard::clear_from_peer_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_peer_id_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t MoveShard::from_peer_id() const {
  // @@protoc_insertion_point(field_get:qdrant.MoveShard.from_peer_id)
  return _internal_from_peer_id();
}
inline void MoveShard::set_from_peer_id(::uint64_t value) {
  _internal_set_from_peer_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.MoveShard.from_peer_id)
}
inline ::uint64_t MoveShard::_internal_from_peer_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_peer_id_;
}
inline void MoveShard::_internal_set_from_peer_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_peer_id_ = value;
}

// uint64 to_peer_id = 3;
inline void MoveShard::clear_to_peer_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_peer_id_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint64_t MoveShard::to_peer_id() const {
  // @@protoc_insertion_point(field_get:qdrant.MoveShard.to_peer_id)
  return _internal_to_peer_id();
}
inline void MoveShard::set_to_peer_id(::uint64_t value) {
  _internal_set_to_peer_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.MoveShard.to_peer_id)
}
inline ::uint64_t MoveShard::_internal_to_peer_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_peer_id_;
}
inline void MoveShard::_internal_set_to_peer_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_peer_id_ = value;
}

// optional .qdrant.ShardTransferMethod method = 4;
inline bool MoveShard::has_method() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void MoveShard::clear_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::qdrant::ShardTransferMethod MoveShard::method() const {
  // @@protoc_insertion_point(field_get:qdrant.MoveShard.method)
  return _internal_method();
}
inline void MoveShard::set_method(::qdrant::ShardTransferMethod value) {
  _internal_set_method(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.MoveShard.method)
}
inline ::qdrant::ShardTransferMethod MoveShard::_internal_method() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::ShardTransferMethod>(_impl_.method_);
}
inline void MoveShard::_internal_set_method(::qdrant::ShardTransferMethod value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_ = value;
}

// -------------------------------------------------------------------

// ReplicateShard

// uint32 shard_id = 1;
inline void ReplicateShard::clear_shard_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint32_t ReplicateShard::shard_id() const {
  // @@protoc_insertion_point(field_get:qdrant.ReplicateShard.shard_id)
  return _internal_shard_id();
}
inline void ReplicateShard::set_shard_id(::uint32_t value) {
  _internal_set_shard_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.ReplicateShard.shard_id)
}
inline ::uint32_t ReplicateShard::_internal_shard_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shard_id_;
}
inline void ReplicateShard::_internal_set_shard_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = value;
}

// optional uint32 to_shard_id = 5;
inline bool ReplicateShard::has_to_shard_id() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void ReplicateShard::clear_to_shard_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_shard_id_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::uint32_t ReplicateShard::to_shard_id() const {
  // @@protoc_insertion_point(field_get:qdrant.ReplicateShard.to_shard_id)
  return _internal_to_shard_id();
}
inline void ReplicateShard::set_to_shard_id(::uint32_t value) {
  _internal_set_to_shard_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.ReplicateShard.to_shard_id)
}
inline ::uint32_t ReplicateShard::_internal_to_shard_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_shard_id_;
}
inline void ReplicateShard::_internal_set_to_shard_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_shard_id_ = value;
}

// uint64 from_peer_id = 2;
inline void ReplicateShard::clear_from_peer_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_peer_id_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t ReplicateShard::from_peer_id() const {
  // @@protoc_insertion_point(field_get:qdrant.ReplicateShard.from_peer_id)
  return _internal_from_peer_id();
}
inline void ReplicateShard::set_from_peer_id(::uint64_t value) {
  _internal_set_from_peer_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.ReplicateShard.from_peer_id)
}
inline ::uint64_t ReplicateShard::_internal_from_peer_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_peer_id_;
}
inline void ReplicateShard::_internal_set_from_peer_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_peer_id_ = value;
}

// uint64 to_peer_id = 3;
inline void ReplicateShard::clear_to_peer_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_peer_id_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint64_t ReplicateShard::to_peer_id() const {
  // @@protoc_insertion_point(field_get:qdrant.ReplicateShard.to_peer_id)
  return _internal_to_peer_id();
}
inline void ReplicateShard::set_to_peer_id(::uint64_t value) {
  _internal_set_to_peer_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.ReplicateShard.to_peer_id)
}
inline ::uint64_t ReplicateShard::_internal_to_peer_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_peer_id_;
}
inline void ReplicateShard::_internal_set_to_peer_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_peer_id_ = value;
}

// optional .qdrant.ShardTransferMethod method = 4;
inline bool ReplicateShard::has_method() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void ReplicateShard::clear_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::qdrant::ShardTransferMethod ReplicateShard::method() const {
  // @@protoc_insertion_point(field_get:qdrant.ReplicateShard.method)
  return _internal_method();
}
inline void ReplicateShard::set_method(::qdrant::ShardTransferMethod value) {
  _internal_set_method(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.ReplicateShard.method)
}
inline ::qdrant::ShardTransferMethod ReplicateShard::_internal_method() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::ShardTransferMethod>(_impl_.method_);
}
inline void ReplicateShard::_internal_set_method(::qdrant::ShardTransferMethod value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_ = value;
}

// -------------------------------------------------------------------

// AbortShardTransfer

// uint32 shard_id = 1;
inline void AbortShardTransfer::clear_shard_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint32_t AbortShardTransfer::shard_id() const {
  // @@protoc_insertion_point(field_get:qdrant.AbortShardTransfer.shard_id)
  return _internal_shard_id();
}
inline void AbortShardTransfer::set_shard_id(::uint32_t value) {
  _internal_set_shard_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.AbortShardTransfer.shard_id)
}
inline ::uint32_t AbortShardTransfer::_internal_shard_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shard_id_;
}
inline void AbortShardTransfer::_internal_set_shard_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = value;
}

// optional uint32 to_shard_id = 4;
inline bool AbortShardTransfer::has_to_shard_id() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void AbortShardTransfer::clear_to_shard_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_shard_id_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint32_t AbortShardTransfer::to_shard_id() const {
  // @@protoc_insertion_point(field_get:qdrant.AbortShardTransfer.to_shard_id)
  return _internal_to_shard_id();
}
inline void AbortShardTransfer::set_to_shard_id(::uint32_t value) {
  _internal_set_to_shard_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.AbortShardTransfer.to_shard_id)
}
inline ::uint32_t AbortShardTransfer::_internal_to_shard_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_shard_id_;
}
inline void AbortShardTransfer::_internal_set_to_shard_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_shard_id_ = value;
}

// uint64 from_peer_id = 2;
inline void AbortShardTransfer::clear_from_peer_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_peer_id_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t AbortShardTransfer::from_peer_id() const {
  // @@protoc_insertion_point(field_get:qdrant.AbortShardTransfer.from_peer_id)
  return _internal_from_peer_id();
}
inline void AbortShardTransfer::set_from_peer_id(::uint64_t value) {
  _internal_set_from_peer_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.AbortShardTransfer.from_peer_id)
}
inline ::uint64_t AbortShardTransfer::_internal_from_peer_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_peer_id_;
}
inline void AbortShardTransfer::_internal_set_from_peer_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_peer_id_ = value;
}

// uint64 to_peer_id = 3;
inline void AbortShardTransfer::clear_to_peer_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_peer_id_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint64_t AbortShardTransfer::to_peer_id() const {
  // @@protoc_insertion_point(field_get:qdrant.AbortShardTransfer.to_peer_id)
  return _internal_to_peer_id();
}
inline void AbortShardTransfer::set_to_peer_id(::uint64_t value) {
  _internal_set_to_peer_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.AbortShardTransfer.to_peer_id)
}
inline ::uint64_t AbortShardTransfer::_internal_to_peer_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_peer_id_;
}
inline void AbortShardTransfer::_internal_set_to_peer_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_peer_id_ = value;
}

// -------------------------------------------------------------------

// RestartTransfer

// uint32 shard_id = 1;
inline void RestartTransfer::clear_shard_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint32_t RestartTransfer::shard_id() const {
  // @@protoc_insertion_point(field_get:qdrant.RestartTransfer.shard_id)
  return _internal_shard_id();
}
inline void RestartTransfer::set_shard_id(::uint32_t value) {
  _internal_set_shard_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.RestartTransfer.shard_id)
}
inline ::uint32_t RestartTransfer::_internal_shard_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shard_id_;
}
inline void RestartTransfer::_internal_set_shard_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = value;
}

// optional uint32 to_shard_id = 5;
inline bool RestartTransfer::has_to_shard_id() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void RestartTransfer::clear_to_shard_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_shard_id_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::uint32_t RestartTransfer::to_shard_id() const {
  // @@protoc_insertion_point(field_get:qdrant.RestartTransfer.to_shard_id)
  return _internal_to_shard_id();
}
inline void RestartTransfer::set_to_shard_id(::uint32_t value) {
  _internal_set_to_shard_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:qdrant.RestartTransfer.to_shard_id)
}
inline ::uint32_t RestartTransfer::_internal_to_shard_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_shard_id_;
}
inline void RestartTransfer::_internal_set_to_shard_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_shard_id_ = value;
}

// uint64 from_peer_id = 2;
inline void RestartTransfer::clear_from_peer_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_peer_id_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t RestartTransfer::from_peer_id() const {
  // @@protoc_insertion_point(field_get:qdrant.RestartTransfer.from_peer_id)
  return _internal_from_peer_id();
}
inline void RestartTransfer::set_from_peer_id(::uint64_t value) {
  _internal_set_from_peer_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.RestartTransfer.from_peer_id)
}
inline ::uint64_t RestartTransfer::_internal_from_peer_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_peer_id_;
}
inline void RestartTransfer::_internal_set_from_peer_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_peer_id_ = value;
}

// uint64 to_peer_id = 3;
inline void RestartTransfer::clear_to_peer_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_peer_id_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint64_t RestartTransfer::to_peer_id() const {
  // @@protoc_insertion_point(field_get:qdrant.RestartTransfer.to_peer_id)
  return _internal_to_peer_id();
}
inline void RestartTransfer::set_to_peer_id(::uint64_t value) {
  _internal_set_to_peer_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.RestartTransfer.to_peer_id)
}
inline ::uint64_t RestartTransfer::_internal_to_peer_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_peer_id_;
}
inline void RestartTransfer::_internal_set_to_peer_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_peer_id_ = value;
}

// .qdrant.ShardTransferMethod method = 4;
inline void RestartTransfer::clear_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::qdrant::ShardTransferMethod RestartTransfer::method() const {
  // @@protoc_insertion_point(field_get:qdrant.RestartTransfer.method)
  return _internal_method();
}
inline void RestartTransfer::set_method(::qdrant::ShardTransferMethod value) {
  _internal_set_method(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.RestartTransfer.method)
}
inline ::qdrant::ShardTransferMethod RestartTransfer::_internal_method() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::qdrant::ShardTransferMethod>(_impl_.method_);
}
inline void RestartTransfer::_internal_set_method(::qdrant::ShardTransferMethod value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_ = value;
}

// -------------------------------------------------------------------

// Replica

// uint32 shard_id = 1;
inline void Replica::clear_shard_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint32_t Replica::shard_id() const {
  // @@protoc_insertion_point(field_get:qdrant.Replica.shard_id)
  return _internal_shard_id();
}
inline void Replica::set_shard_id(::uint32_t value) {
  _internal_set_shard_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.Replica.shard_id)
}
inline ::uint32_t Replica::_internal_shard_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shard_id_;
}
inline void Replica::_internal_set_shard_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shard_id_ = value;
}

// uint64 peer_id = 2;
inline void Replica::clear_peer_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.peer_id_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t Replica::peer_id() const {
  // @@protoc_insertion_point(field_get:qdrant.Replica.peer_id)
  return _internal_peer_id();
}
inline void Replica::set_peer_id(::uint64_t value) {
  _internal_set_peer_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.Replica.peer_id)
}
inline ::uint64_t Replica::_internal_peer_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.peer_id_;
}
inline void Replica::_internal_set_peer_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.peer_id_ = value;
}

// -------------------------------------------------------------------

// CreateShardKey

// .qdrant.ShardKey shard_key = 1;
inline bool CreateShardKey::has_shard_key() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_ != nullptr);
  return value;
}
inline void CreateShardKey::clear_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_ != nullptr) _impl_.shard_key_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::ShardKey& CreateShardKey::_internal_shard_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKey* p = _impl_.shard_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKey&>(::qdrant::_ShardKey_default_instance_);
}
inline const ::qdrant::ShardKey& CreateShardKey::shard_key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateShardKey.shard_key)
  return _internal_shard_key();
}
inline void CreateShardKey::unsafe_arena_set_allocated_shard_key(
    ::qdrant::ShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_);
  }
  _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CreateShardKey.shard_key)
}
inline ::qdrant::ShardKey* PROTOBUF_NULLABLE CreateShardKey::release_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ShardKey* released = _impl_.shard_key_;
  _impl_.shard_key_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKey* PROTOBUF_NULLABLE CreateShardKey::unsafe_arena_release_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateShardKey.shard_key)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ShardKey* temp = _impl_.shard_key_;
  _impl_.shard_key_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKey* PROTOBUF_NONNULL CreateShardKey::_internal_mutable_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKey>(GetArena());
    _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(p);
  }
  return _impl_.shard_key_;
}
inline ::qdrant::ShardKey* PROTOBUF_NONNULL CreateShardKey::mutable_shard_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::ShardKey* _msg = _internal_mutable_shard_key();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateShardKey.shard_key)
  return _msg;
}
inline void CreateShardKey::set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateShardKey.shard_key)
}

// optional uint32 shards_number = 2;
inline bool CreateShardKey::has_shards_number() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void CreateShardKey::clear_shards_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shards_number_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint32_t CreateShardKey::shards_number() const {
  // @@protoc_insertion_point(field_get:qdrant.CreateShardKey.shards_number)
  return _internal_shards_number();
}
inline void CreateShardKey::set_shards_number(::uint32_t value) {
  _internal_set_shards_number(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.CreateShardKey.shards_number)
}
inline ::uint32_t CreateShardKey::_internal_shards_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shards_number_;
}
inline void CreateShardKey::_internal_set_shards_number(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shards_number_ = value;
}

// optional uint32 replication_factor = 3;
inline bool CreateShardKey::has_replication_factor() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void CreateShardKey::clear_replication_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_factor_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint32_t CreateShardKey::replication_factor() const {
  // @@protoc_insertion_point(field_get:qdrant.CreateShardKey.replication_factor)
  return _internal_replication_factor();
}
inline void CreateShardKey::set_replication_factor(::uint32_t value) {
  _internal_set_replication_factor(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:qdrant.CreateShardKey.replication_factor)
}
inline ::uint32_t CreateShardKey::_internal_replication_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replication_factor_;
}
inline void CreateShardKey::_internal_set_replication_factor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_factor_ = value;
}

// repeated uint64 placement = 4;
inline int CreateShardKey::_internal_placement_size() const {
  return _internal_placement().size();
}
inline int CreateShardKey::placement_size() const {
  return _internal_placement_size();
}
inline void CreateShardKey::clear_placement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.placement_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t CreateShardKey::placement(int index) const {
  // @@protoc_insertion_point(field_get:qdrant.CreateShardKey.placement)
  return _internal_placement().Get(index);
}
inline void CreateShardKey::set_placement(int index, ::uint64_t value) {
  _internal_mutable_placement()->Set(index, value);
  // @@protoc_insertion_point(field_set:qdrant.CreateShardKey.placement)
}
inline void CreateShardKey::add_placement(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_placement()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:qdrant.CreateShardKey.placement)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& CreateShardKey::placement() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:qdrant.CreateShardKey.placement)
  return _internal_placement();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL CreateShardKey::mutable_placement()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:qdrant.CreateShardKey.placement)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_placement();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
CreateShardKey::_internal_placement() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.placement_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL
CreateShardKey::_internal_mutable_placement() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.placement_;
}

// -------------------------------------------------------------------

// DeleteShardKey

// .qdrant.ShardKey shard_key = 1;
inline bool DeleteShardKey::has_shard_key() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.shard_key_ != nullptr);
  return value;
}
inline void DeleteShardKey::clear_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_ != nullptr) _impl_.shard_key_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::qdrant::ShardKey& DeleteShardKey::_internal_shard_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::ShardKey* p = _impl_.shard_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::ShardKey&>(::qdrant::_ShardKey_default_instance_);
}
inline const ::qdrant::ShardKey& DeleteShardKey::shard_key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeleteShardKey.shard_key)
  return _internal_shard_key();
}
inline void DeleteShardKey::unsafe_arena_set_allocated_shard_key(
    ::qdrant::ShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_);
  }
  _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DeleteShardKey.shard_key)
}
inline ::qdrant::ShardKey* PROTOBUF_NULLABLE DeleteShardKey::release_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::ShardKey* released = _impl_.shard_key_;
  _impl_.shard_key_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::ShardKey* PROTOBUF_NULLABLE DeleteShardKey::unsafe_arena_release_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeleteShardKey.shard_key)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::ShardKey* temp = _impl_.shard_key_;
  _impl_.shard_key_ = nullptr;
  return temp;
}
inline ::qdrant::ShardKey* PROTOBUF_NONNULL DeleteShardKey::_internal_mutable_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shard_key_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::ShardKey>(GetArena());
    _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(p);
  }
  return _impl_.shard_key_;
}
inline ::qdrant::ShardKey* PROTOBUF_NONNULL DeleteShardKey::mutable_shard_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::qdrant::ShardKey* _msg = _internal_mutable_shard_key();
  // @@protoc_insertion_point(field_mutable:qdrant.DeleteShardKey.shard_key)
  return _msg;
}
inline void DeleteShardKey::set_allocated_shard_key(::qdrant::ShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shard_key_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.shard_key_ = reinterpret_cast<::qdrant::ShardKey*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeleteShardKey.shard_key)
}

// -------------------------------------------------------------------

// UpdateCollectionClusterSetupRequest

// string collection_name = 1;
inline void UpdateCollectionClusterSetupRequest::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& UpdateCollectionClusterSetupRequest::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollectionClusterSetupRequest.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateCollectionClusterSetupRequest::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.UpdateCollectionClusterSetupRequest.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL UpdateCollectionClusterSetupRequest::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateCollectionClusterSetupRequest.collection_name)
  return _s;
}
inline const ::std::string& UpdateCollectionClusterSetupRequest::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void UpdateCollectionClusterSetupRequest::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UpdateCollectionClusterSetupRequest::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UpdateCollectionClusterSetupRequest::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.UpdateCollectionClusterSetupRequest.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void UpdateCollectionClusterSetupRequest::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.UpdateCollectionClusterSetupRequest.collection_name)
}

// .qdrant.MoveShard move_shard = 2;
inline bool UpdateCollectionClusterSetupRequest::has_move_shard() const {
  return operation_case() == kMoveShard;
}
inline bool UpdateCollectionClusterSetupRequest::_internal_has_move_shard() const {
  return operation_case() == kMoveShard;
}
inline void UpdateCollectionClusterSetupRequest::set_has_move_shard() {
  _impl_._oneof_case_[0] = kMoveShard;
}
inline void UpdateCollectionClusterSetupRequest::clear_move_shard() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kMoveShard) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.move_shard_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.move_shard_);
    }
    clear_has_operation();
  }
}
inline ::qdrant::MoveShard* PROTOBUF_NULLABLE UpdateCollectionClusterSetupRequest::release_move_shard() {
  // @@protoc_insertion_point(field_release:qdrant.UpdateCollectionClusterSetupRequest.move_shard)
  if (operation_case() == kMoveShard) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::MoveShard*>(_impl_.operation_.move_shard_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.move_shard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::MoveShard& UpdateCollectionClusterSetupRequest::_internal_move_shard() const {
  return operation_case() == kMoveShard ? static_cast<const ::qdrant::MoveShard&>(*reinterpret_cast<::qdrant::MoveShard*>(_impl_.operation_.move_shard_))
                     : reinterpret_cast<const ::qdrant::MoveShard&>(::qdrant::_MoveShard_default_instance_);
}
inline const ::qdrant::MoveShard& UpdateCollectionClusterSetupRequest::move_shard() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollectionClusterSetupRequest.move_shard)
  return _internal_move_shard();
}
inline ::qdrant::MoveShard* PROTOBUF_NULLABLE UpdateCollectionClusterSetupRequest::unsafe_arena_release_move_shard() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.UpdateCollectionClusterSetupRequest.move_shard)
  if (operation_case() == kMoveShard) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::MoveShard*>(_impl_.operation_.move_shard_);
    _impl_.operation_.move_shard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateCollectionClusterSetupRequest::unsafe_arena_set_allocated_move_shard(
    ::qdrant::MoveShard* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_move_shard();
    _impl_.operation_.move_shard_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdateCollectionClusterSetupRequest.move_shard)
}
inline ::qdrant::MoveShard* PROTOBUF_NONNULL UpdateCollectionClusterSetupRequest::_internal_mutable_move_shard() {
  if (operation_case() != kMoveShard) {
    clear_operation();
    set_has_move_shard();
    _impl_.operation_.move_shard_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::MoveShard>(GetArena()));
  }
  return reinterpret_cast<::qdrant::MoveShard*>(_impl_.operation_.move_shard_);
}
inline ::qdrant::MoveShard* PROTOBUF_NONNULL UpdateCollectionClusterSetupRequest::mutable_move_shard()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::MoveShard* _msg = _internal_mutable_move_shard();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateCollectionClusterSetupRequest.move_shard)
  return _msg;
}

// .qdrant.ReplicateShard replicate_shard = 3;
inline bool UpdateCollectionClusterSetupRequest::has_replicate_shard() const {
  return operation_case() == kReplicateShard;
}
inline bool UpdateCollectionClusterSetupRequest::_internal_has_replicate_shard() const {
  return operation_case() == kReplicateShard;
}
inline void UpdateCollectionClusterSetupRequest::set_has_replicate_shard() {
  _impl_._oneof_case_[0] = kReplicateShard;
}
inline void UpdateCollectionClusterSetupRequest::clear_replicate_shard() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kReplicateShard) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.replicate_shard_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.replicate_shard_);
    }
    clear_has_operation();
  }
}
inline ::qdrant::ReplicateShard* PROTOBUF_NULLABLE UpdateCollectionClusterSetupRequest::release_replicate_shard() {
  // @@protoc_insertion_point(field_release:qdrant.UpdateCollectionClusterSetupRequest.replicate_shard)
  if (operation_case() == kReplicateShard) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::ReplicateShard*>(_impl_.operation_.replicate_shard_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.replicate_shard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::ReplicateShard& UpdateCollectionClusterSetupRequest::_internal_replicate_shard() const {
  return operation_case() == kReplicateShard ? static_cast<const ::qdrant::ReplicateShard&>(*reinterpret_cast<::qdrant::ReplicateShard*>(_impl_.operation_.replicate_shard_))
                     : reinterpret_cast<const ::qdrant::ReplicateShard&>(::qdrant::_ReplicateShard_default_instance_);
}
inline const ::qdrant::ReplicateShard& UpdateCollectionClusterSetupRequest::replicate_shard() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollectionClusterSetupRequest.replicate_shard)
  return _internal_replicate_shard();
}
inline ::qdrant::ReplicateShard* PROTOBUF_NULLABLE UpdateCollectionClusterSetupRequest::unsafe_arena_release_replicate_shard() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.UpdateCollectionClusterSetupRequest.replicate_shard)
  if (operation_case() == kReplicateShard) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::ReplicateShard*>(_impl_.operation_.replicate_shard_);
    _impl_.operation_.replicate_shard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateCollectionClusterSetupRequest::unsafe_arena_set_allocated_replicate_shard(
    ::qdrant::ReplicateShard* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_replicate_shard();
    _impl_.operation_.replicate_shard_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdateCollectionClusterSetupRequest.replicate_shard)
}
inline ::qdrant::ReplicateShard* PROTOBUF_NONNULL UpdateCollectionClusterSetupRequest::_internal_mutable_replicate_shard() {
  if (operation_case() != kReplicateShard) {
    clear_operation();
    set_has_replicate_shard();
    _impl_.operation_.replicate_shard_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::ReplicateShard>(GetArena()));
  }
  return reinterpret_cast<::qdrant::ReplicateShard*>(_impl_.operation_.replicate_shard_);
}
inline ::qdrant::ReplicateShard* PROTOBUF_NONNULL UpdateCollectionClusterSetupRequest::mutable_replicate_shard()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::ReplicateShard* _msg = _internal_mutable_replicate_shard();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateCollectionClusterSetupRequest.replicate_shard)
  return _msg;
}

// .qdrant.AbortShardTransfer abort_transfer = 4;
inline bool UpdateCollectionClusterSetupRequest::has_abort_transfer() const {
  return operation_case() == kAbortTransfer;
}
inline bool UpdateCollectionClusterSetupRequest::_internal_has_abort_transfer() const {
  return operation_case() == kAbortTransfer;
}
inline void UpdateCollectionClusterSetupRequest::set_has_abort_transfer() {
  _impl_._oneof_case_[0] = kAbortTransfer;
}
inline void UpdateCollectionClusterSetupRequest::clear_abort_transfer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kAbortTransfer) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.abort_transfer_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.abort_transfer_);
    }
    clear_has_operation();
  }
}
inline ::qdrant::AbortShardTransfer* PROTOBUF_NULLABLE UpdateCollectionClusterSetupRequest::release_abort_transfer() {
  // @@protoc_insertion_point(field_release:qdrant.UpdateCollectionClusterSetupRequest.abort_transfer)
  if (operation_case() == kAbortTransfer) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::AbortShardTransfer*>(_impl_.operation_.abort_transfer_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.abort_transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::AbortShardTransfer& UpdateCollectionClusterSetupRequest::_internal_abort_transfer() const {
  return operation_case() == kAbortTransfer ? static_cast<const ::qdrant::AbortShardTransfer&>(*reinterpret_cast<::qdrant::AbortShardTransfer*>(_impl_.operation_.abort_transfer_))
                     : reinterpret_cast<const ::qdrant::AbortShardTransfer&>(::qdrant::_AbortShardTransfer_default_instance_);
}
inline const ::qdrant::AbortShardTransfer& UpdateCollectionClusterSetupRequest::abort_transfer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollectionClusterSetupRequest.abort_transfer)
  return _internal_abort_transfer();
}
inline ::qdrant::AbortShardTransfer* PROTOBUF_NULLABLE UpdateCollectionClusterSetupRequest::unsafe_arena_release_abort_transfer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.UpdateCollectionClusterSetupRequest.abort_transfer)
  if (operation_case() == kAbortTransfer) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::AbortShardTransfer*>(_impl_.operation_.abort_transfer_);
    _impl_.operation_.abort_transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateCollectionClusterSetupRequest::unsafe_arena_set_allocated_abort_transfer(
    ::qdrant::AbortShardTransfer* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_abort_transfer();
    _impl_.operation_.abort_transfer_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdateCollectionClusterSetupRequest.abort_transfer)
}
inline ::qdrant::AbortShardTransfer* PROTOBUF_NONNULL UpdateCollectionClusterSetupRequest::_internal_mutable_abort_transfer() {
  if (operation_case() != kAbortTransfer) {
    clear_operation();
    set_has_abort_transfer();
    _impl_.operation_.abort_transfer_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::AbortShardTransfer>(GetArena()));
  }
  return reinterpret_cast<::qdrant::AbortShardTransfer*>(_impl_.operation_.abort_transfer_);
}
inline ::qdrant::AbortShardTransfer* PROTOBUF_NONNULL UpdateCollectionClusterSetupRequest::mutable_abort_transfer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::AbortShardTransfer* _msg = _internal_mutable_abort_transfer();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateCollectionClusterSetupRequest.abort_transfer)
  return _msg;
}

// .qdrant.Replica drop_replica = 5;
inline bool UpdateCollectionClusterSetupRequest::has_drop_replica() const {
  return operation_case() == kDropReplica;
}
inline bool UpdateCollectionClusterSetupRequest::_internal_has_drop_replica() const {
  return operation_case() == kDropReplica;
}
inline void UpdateCollectionClusterSetupRequest::set_has_drop_replica() {
  _impl_._oneof_case_[0] = kDropReplica;
}
inline void UpdateCollectionClusterSetupRequest::clear_drop_replica() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kDropReplica) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.drop_replica_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.drop_replica_);
    }
    clear_has_operation();
  }
}
inline ::qdrant::Replica* PROTOBUF_NULLABLE UpdateCollectionClusterSetupRequest::release_drop_replica() {
  // @@protoc_insertion_point(field_release:qdrant.UpdateCollectionClusterSetupRequest.drop_replica)
  if (operation_case() == kDropReplica) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::Replica*>(_impl_.operation_.drop_replica_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.drop_replica_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::Replica& UpdateCollectionClusterSetupRequest::_internal_drop_replica() const {
  return operation_case() == kDropReplica ? static_cast<const ::qdrant::Replica&>(*reinterpret_cast<::qdrant::Replica*>(_impl_.operation_.drop_replica_))
                     : reinterpret_cast<const ::qdrant::Replica&>(::qdrant::_Replica_default_instance_);
}
inline const ::qdrant::Replica& UpdateCollectionClusterSetupRequest::drop_replica() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollectionClusterSetupRequest.drop_replica)
  return _internal_drop_replica();
}
inline ::qdrant::Replica* PROTOBUF_NULLABLE UpdateCollectionClusterSetupRequest::unsafe_arena_release_drop_replica() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.UpdateCollectionClusterSetupRequest.drop_replica)
  if (operation_case() == kDropReplica) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::Replica*>(_impl_.operation_.drop_replica_);
    _impl_.operation_.drop_replica_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateCollectionClusterSetupRequest::unsafe_arena_set_allocated_drop_replica(
    ::qdrant::Replica* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_drop_replica();
    _impl_.operation_.drop_replica_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdateCollectionClusterSetupRequest.drop_replica)
}
inline ::qdrant::Replica* PROTOBUF_NONNULL UpdateCollectionClusterSetupRequest::_internal_mutable_drop_replica() {
  if (operation_case() != kDropReplica) {
    clear_operation();
    set_has_drop_replica();
    _impl_.operation_.drop_replica_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::Replica>(GetArena()));
  }
  return reinterpret_cast<::qdrant::Replica*>(_impl_.operation_.drop_replica_);
}
inline ::qdrant::Replica* PROTOBUF_NONNULL UpdateCollectionClusterSetupRequest::mutable_drop_replica()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::Replica* _msg = _internal_mutable_drop_replica();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateCollectionClusterSetupRequest.drop_replica)
  return _msg;
}

// .qdrant.CreateShardKey create_shard_key = 7;
inline bool UpdateCollectionClusterSetupRequest::has_create_shard_key() const {
  return operation_case() == kCreateShardKey;
}
inline bool UpdateCollectionClusterSetupRequest::_internal_has_create_shard_key() const {
  return operation_case() == kCreateShardKey;
}
inline void UpdateCollectionClusterSetupRequest::set_has_create_shard_key() {
  _impl_._oneof_case_[0] = kCreateShardKey;
}
inline void UpdateCollectionClusterSetupRequest::clear_create_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kCreateShardKey) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.create_shard_key_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.create_shard_key_);
    }
    clear_has_operation();
  }
}
inline ::qdrant::CreateShardKey* PROTOBUF_NULLABLE UpdateCollectionClusterSetupRequest::release_create_shard_key() {
  // @@protoc_insertion_point(field_release:qdrant.UpdateCollectionClusterSetupRequest.create_shard_key)
  if (operation_case() == kCreateShardKey) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::CreateShardKey*>(_impl_.operation_.create_shard_key_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.create_shard_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::CreateShardKey& UpdateCollectionClusterSetupRequest::_internal_create_shard_key() const {
  return operation_case() == kCreateShardKey ? static_cast<const ::qdrant::CreateShardKey&>(*reinterpret_cast<::qdrant::CreateShardKey*>(_impl_.operation_.create_shard_key_))
                     : reinterpret_cast<const ::qdrant::CreateShardKey&>(::qdrant::_CreateShardKey_default_instance_);
}
inline const ::qdrant::CreateShardKey& UpdateCollectionClusterSetupRequest::create_shard_key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollectionClusterSetupRequest.create_shard_key)
  return _internal_create_shard_key();
}
inline ::qdrant::CreateShardKey* PROTOBUF_NULLABLE UpdateCollectionClusterSetupRequest::unsafe_arena_release_create_shard_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.UpdateCollectionClusterSetupRequest.create_shard_key)
  if (operation_case() == kCreateShardKey) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::CreateShardKey*>(_impl_.operation_.create_shard_key_);
    _impl_.operation_.create_shard_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateCollectionClusterSetupRequest::unsafe_arena_set_allocated_create_shard_key(
    ::qdrant::CreateShardKey* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_create_shard_key();
    _impl_.operation_.create_shard_key_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdateCollectionClusterSetupRequest.create_shard_key)
}
inline ::qdrant::CreateShardKey* PROTOBUF_NONNULL UpdateCollectionClusterSetupRequest::_internal_mutable_create_shard_key() {
  if (operation_case() != kCreateShardKey) {
    clear_operation();
    set_has_create_shard_key();
    _impl_.operation_.create_shard_key_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::CreateShardKey>(GetArena()));
  }
  return reinterpret_cast<::qdrant::CreateShardKey*>(_impl_.operation_.create_shard_key_);
}
inline ::qdrant::CreateShardKey* PROTOBUF_NONNULL UpdateCollectionClusterSetupRequest::mutable_create_shard_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::CreateShardKey* _msg = _internal_mutable_create_shard_key();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateCollectionClusterSetupRequest.create_shard_key)
  return _msg;
}

// .qdrant.DeleteShardKey delete_shard_key = 8;
inline bool UpdateCollectionClusterSetupRequest::has_delete_shard_key() const {
  return operation_case() == kDeleteShardKey;
}
inline bool UpdateCollectionClusterSetupRequest::_internal_has_delete_shard_key() const {
  return operation_case() == kDeleteShardKey;
}
inline void UpdateCollectionClusterSetupRequest::set_has_delete_shard_key() {
  _impl_._oneof_case_[0] = kDeleteShardKey;
}
inline void UpdateCollectionClusterSetupRequest::clear_delete_shard_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kDeleteShardKey) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.delete_shard_key_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.delete_shard_key_);
    }
    clear_has_operation();
  }
}
inline ::qdrant::DeleteShardKey* PROTOBUF_NULLABLE UpdateCollectionClusterSetupRequest::release_delete_shard_key() {
  // @@protoc_insertion_point(field_release:qdrant.UpdateCollectionClusterSetupRequest.delete_shard_key)
  if (operation_case() == kDeleteShardKey) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::DeleteShardKey*>(_impl_.operation_.delete_shard_key_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.delete_shard_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::DeleteShardKey& UpdateCollectionClusterSetupRequest::_internal_delete_shard_key() const {
  return operation_case() == kDeleteShardKey ? static_cast<const ::qdrant::DeleteShardKey&>(*reinterpret_cast<::qdrant::DeleteShardKey*>(_impl_.operation_.delete_shard_key_))
                     : reinterpret_cast<const ::qdrant::DeleteShardKey&>(::qdrant::_DeleteShardKey_default_instance_);
}
inline const ::qdrant::DeleteShardKey& UpdateCollectionClusterSetupRequest::delete_shard_key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollectionClusterSetupRequest.delete_shard_key)
  return _internal_delete_shard_key();
}
inline ::qdrant::DeleteShardKey* PROTOBUF_NULLABLE UpdateCollectionClusterSetupRequest::unsafe_arena_release_delete_shard_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.UpdateCollectionClusterSetupRequest.delete_shard_key)
  if (operation_case() == kDeleteShardKey) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::DeleteShardKey*>(_impl_.operation_.delete_shard_key_);
    _impl_.operation_.delete_shard_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateCollectionClusterSetupRequest::unsafe_arena_set_allocated_delete_shard_key(
    ::qdrant::DeleteShardKey* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_delete_shard_key();
    _impl_.operation_.delete_shard_key_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdateCollectionClusterSetupRequest.delete_shard_key)
}
inline ::qdrant::DeleteShardKey* PROTOBUF_NONNULL UpdateCollectionClusterSetupRequest::_internal_mutable_delete_shard_key() {
  if (operation_case() != kDeleteShardKey) {
    clear_operation();
    set_has_delete_shard_key();
    _impl_.operation_.delete_shard_key_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::DeleteShardKey>(GetArena()));
  }
  return reinterpret_cast<::qdrant::DeleteShardKey*>(_impl_.operation_.delete_shard_key_);
}
inline ::qdrant::DeleteShardKey* PROTOBUF_NONNULL UpdateCollectionClusterSetupRequest::mutable_delete_shard_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::DeleteShardKey* _msg = _internal_mutable_delete_shard_key();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateCollectionClusterSetupRequest.delete_shard_key)
  return _msg;
}

// .qdrant.RestartTransfer restart_transfer = 9;
inline bool UpdateCollectionClusterSetupRequest::has_restart_transfer() const {
  return operation_case() == kRestartTransfer;
}
inline bool UpdateCollectionClusterSetupRequest::_internal_has_restart_transfer() const {
  return operation_case() == kRestartTransfer;
}
inline void UpdateCollectionClusterSetupRequest::set_has_restart_transfer() {
  _impl_._oneof_case_[0] = kRestartTransfer;
}
inline void UpdateCollectionClusterSetupRequest::clear_restart_transfer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kRestartTransfer) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.restart_transfer_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.restart_transfer_);
    }
    clear_has_operation();
  }
}
inline ::qdrant::RestartTransfer* PROTOBUF_NULLABLE UpdateCollectionClusterSetupRequest::release_restart_transfer() {
  // @@protoc_insertion_point(field_release:qdrant.UpdateCollectionClusterSetupRequest.restart_transfer)
  if (operation_case() == kRestartTransfer) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::RestartTransfer*>(_impl_.operation_.restart_transfer_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.restart_transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qdrant::RestartTransfer& UpdateCollectionClusterSetupRequest::_internal_restart_transfer() const {
  return operation_case() == kRestartTransfer ? static_cast<const ::qdrant::RestartTransfer&>(*reinterpret_cast<::qdrant::RestartTransfer*>(_impl_.operation_.restart_transfer_))
                     : reinterpret_cast<const ::qdrant::RestartTransfer&>(::qdrant::_RestartTransfer_default_instance_);
}
inline const ::qdrant::RestartTransfer& UpdateCollectionClusterSetupRequest::restart_transfer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollectionClusterSetupRequest.restart_transfer)
  return _internal_restart_transfer();
}
inline ::qdrant::RestartTransfer* PROTOBUF_NULLABLE UpdateCollectionClusterSetupRequest::unsafe_arena_release_restart_transfer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qdrant.UpdateCollectionClusterSetupRequest.restart_transfer)
  if (operation_case() == kRestartTransfer) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::qdrant::RestartTransfer*>(_impl_.operation_.restart_transfer_);
    _impl_.operation_.restart_transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateCollectionClusterSetupRequest::unsafe_arena_set_allocated_restart_transfer(
    ::qdrant::RestartTransfer* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_restart_transfer();
    _impl_.operation_.restart_transfer_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.UpdateCollectionClusterSetupRequest.restart_transfer)
}
inline ::qdrant::RestartTransfer* PROTOBUF_NONNULL UpdateCollectionClusterSetupRequest::_internal_mutable_restart_transfer() {
  if (operation_case() != kRestartTransfer) {
    clear_operation();
    set_has_restart_transfer();
    _impl_.operation_.restart_transfer_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::qdrant::RestartTransfer>(GetArena()));
  }
  return reinterpret_cast<::qdrant::RestartTransfer*>(_impl_.operation_.restart_transfer_);
}
inline ::qdrant::RestartTransfer* PROTOBUF_NONNULL UpdateCollectionClusterSetupRequest::mutable_restart_transfer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::qdrant::RestartTransfer* _msg = _internal_mutable_restart_transfer();
  // @@protoc_insertion_point(field_mutable:qdrant.UpdateCollectionClusterSetupRequest.restart_transfer)
  return _msg;
}

// optional uint64 timeout = 6;
inline bool UpdateCollectionClusterSetupRequest::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void UpdateCollectionClusterSetupRequest::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint64_t UpdateCollectionClusterSetupRequest::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollectionClusterSetupRequest.timeout)
  return _internal_timeout();
}
inline void UpdateCollectionClusterSetupRequest::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:qdrant.UpdateCollectionClusterSetupRequest.timeout)
}
inline ::uint64_t UpdateCollectionClusterSetupRequest::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void UpdateCollectionClusterSetupRequest::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

inline bool UpdateCollectionClusterSetupRequest::has_operation() const {
  return operation_case() != OPERATION_NOT_SET;
}
inline void UpdateCollectionClusterSetupRequest::clear_has_operation() {
  _impl_._oneof_case_[0] = OPERATION_NOT_SET;
}
inline UpdateCollectionClusterSetupRequest::OperationCase UpdateCollectionClusterSetupRequest::operation_case() const {
  return UpdateCollectionClusterSetupRequest::OperationCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateCollectionClusterSetupResponse

// bool result = 1;
inline void UpdateCollectionClusterSetupResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool UpdateCollectionClusterSetupResponse::result() const {
  // @@protoc_insertion_point(field_get:qdrant.UpdateCollectionClusterSetupResponse.result)
  return _internal_result();
}
inline void UpdateCollectionClusterSetupResponse::set_result(bool value) {
  _internal_set_result(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.UpdateCollectionClusterSetupResponse.result)
}
inline bool UpdateCollectionClusterSetupResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline void UpdateCollectionClusterSetupResponse::_internal_set_result(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// -------------------------------------------------------------------

// CreateShardKeyRequest

// string collection_name = 1;
inline void CreateShardKeyRequest::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& CreateShardKeyRequest::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateShardKeyRequest.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CreateShardKeyRequest::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.CreateShardKeyRequest.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL CreateShardKeyRequest::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateShardKeyRequest.collection_name)
  return _s;
}
inline const ::std::string& CreateShardKeyRequest::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void CreateShardKeyRequest::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CreateShardKeyRequest::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CreateShardKeyRequest::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateShardKeyRequest.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void CreateShardKeyRequest::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateShardKeyRequest.collection_name)
}

// .qdrant.CreateShardKey request = 2;
inline bool CreateShardKeyRequest::has_request() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.request_ != nullptr);
  return value;
}
inline void CreateShardKeyRequest::clear_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.request_ != nullptr) _impl_.request_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::CreateShardKey& CreateShardKeyRequest::_internal_request() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::CreateShardKey* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::CreateShardKey&>(::qdrant::_CreateShardKey_default_instance_);
}
inline const ::qdrant::CreateShardKey& CreateShardKeyRequest::request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.CreateShardKeyRequest.request)
  return _internal_request();
}
inline void CreateShardKeyRequest::unsafe_arena_set_allocated_request(
    ::qdrant::CreateShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = reinterpret_cast<::qdrant::CreateShardKey*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.CreateShardKeyRequest.request)
}
inline ::qdrant::CreateShardKey* PROTOBUF_NULLABLE CreateShardKeyRequest::release_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::CreateShardKey* released = _impl_.request_;
  _impl_.request_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::CreateShardKey* PROTOBUF_NULLABLE CreateShardKeyRequest::unsafe_arena_release_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.CreateShardKeyRequest.request)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::CreateShardKey* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::qdrant::CreateShardKey* PROTOBUF_NONNULL CreateShardKeyRequest::_internal_mutable_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.request_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::CreateShardKey>(GetArena());
    _impl_.request_ = reinterpret_cast<::qdrant::CreateShardKey*>(p);
  }
  return _impl_.request_;
}
inline ::qdrant::CreateShardKey* PROTOBUF_NONNULL CreateShardKeyRequest::mutable_request()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::CreateShardKey* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:qdrant.CreateShardKeyRequest.request)
  return _msg;
}
inline void CreateShardKeyRequest::set_allocated_request(::qdrant::CreateShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.request_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.request_ = reinterpret_cast<::qdrant::CreateShardKey*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.CreateShardKeyRequest.request)
}

// optional uint64 timeout = 3;
inline bool CreateShardKeyRequest::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void CreateShardKeyRequest::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint64_t CreateShardKeyRequest::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.CreateShardKeyRequest.timeout)
  return _internal_timeout();
}
inline void CreateShardKeyRequest::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.CreateShardKeyRequest.timeout)
}
inline ::uint64_t CreateShardKeyRequest::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void CreateShardKeyRequest::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// -------------------------------------------------------------------

// DeleteShardKeyRequest

// string collection_name = 1;
inline void DeleteShardKeyRequest::clear_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& DeleteShardKeyRequest::collection_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeleteShardKeyRequest.collection_name)
  return _internal_collection_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DeleteShardKeyRequest::set_collection_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.collection_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:qdrant.DeleteShardKeyRequest.collection_name)
}
inline ::std::string* PROTOBUF_NONNULL DeleteShardKeyRequest::mutable_collection_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:qdrant.DeleteShardKeyRequest.collection_name)
  return _s;
}
inline const ::std::string& DeleteShardKeyRequest::_internal_collection_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_name_.Get();
}
inline void DeleteShardKeyRequest::_internal_set_collection_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DeleteShardKeyRequest::_internal_mutable_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DeleteShardKeyRequest::release_collection_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeleteShardKeyRequest.collection_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.collection_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  return released;
}
inline void DeleteShardKeyRequest::set_allocated_collection_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.collection_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collection_name_.IsDefault()) {
    _impl_.collection_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeleteShardKeyRequest.collection_name)
}

// .qdrant.DeleteShardKey request = 2;
inline bool DeleteShardKeyRequest::has_request() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.request_ != nullptr);
  return value;
}
inline void DeleteShardKeyRequest::clear_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.request_ != nullptr) _impl_.request_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::qdrant::DeleteShardKey& DeleteShardKeyRequest::_internal_request() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::qdrant::DeleteShardKey* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::qdrant::DeleteShardKey&>(::qdrant::_DeleteShardKey_default_instance_);
}
inline const ::qdrant::DeleteShardKey& DeleteShardKeyRequest::request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:qdrant.DeleteShardKeyRequest.request)
  return _internal_request();
}
inline void DeleteShardKeyRequest::unsafe_arena_set_allocated_request(
    ::qdrant::DeleteShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = reinterpret_cast<::qdrant::DeleteShardKey*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qdrant.DeleteShardKeyRequest.request)
}
inline ::qdrant::DeleteShardKey* PROTOBUF_NULLABLE DeleteShardKeyRequest::release_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::DeleteShardKey* released = _impl_.request_;
  _impl_.request_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::qdrant::DeleteShardKey* PROTOBUF_NULLABLE DeleteShardKeyRequest::unsafe_arena_release_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:qdrant.DeleteShardKeyRequest.request)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::DeleteShardKey* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::qdrant::DeleteShardKey* PROTOBUF_NONNULL DeleteShardKeyRequest::_internal_mutable_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.request_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::qdrant::DeleteShardKey>(GetArena());
    _impl_.request_ = reinterpret_cast<::qdrant::DeleteShardKey*>(p);
  }
  return _impl_.request_;
}
inline ::qdrant::DeleteShardKey* PROTOBUF_NONNULL DeleteShardKeyRequest::mutable_request()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::qdrant::DeleteShardKey* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:qdrant.DeleteShardKeyRequest.request)
  return _msg;
}
inline void DeleteShardKeyRequest::set_allocated_request(::qdrant::DeleteShardKey* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.request_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.request_ = reinterpret_cast<::qdrant::DeleteShardKey*>(value);
  // @@protoc_insertion_point(field_set_allocated:qdrant.DeleteShardKeyRequest.request)
}

// optional uint64 timeout = 3;
inline bool DeleteShardKeyRequest::has_timeout() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void DeleteShardKeyRequest::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint64_t DeleteShardKeyRequest::timeout() const {
  // @@protoc_insertion_point(field_get:qdrant.DeleteShardKeyRequest.timeout)
  return _internal_timeout();
}
inline void DeleteShardKeyRequest::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:qdrant.DeleteShardKeyRequest.timeout)
}
inline ::uint64_t DeleteShardKeyRequest::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void DeleteShardKeyRequest::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// -------------------------------------------------------------------

// CreateShardKeyResponse

// bool result = 1;
inline void CreateShardKeyResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool CreateShardKeyResponse::result() const {
  // @@protoc_insertion_point(field_get:qdrant.CreateShardKeyResponse.result)
  return _internal_result();
}
inline void CreateShardKeyResponse::set_result(bool value) {
  _internal_set_result(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.CreateShardKeyResponse.result)
}
inline bool CreateShardKeyResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline void CreateShardKeyResponse::_internal_set_result(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// -------------------------------------------------------------------

// DeleteShardKeyResponse

// bool result = 1;
inline void DeleteShardKeyResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool DeleteShardKeyResponse::result() const {
  // @@protoc_insertion_point(field_get:qdrant.DeleteShardKeyResponse.result)
  return _internal_result();
}
inline void DeleteShardKeyResponse::set_result(bool value) {
  _internal_set_result(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:qdrant.DeleteShardKeyResponse.result)
}
inline bool DeleteShardKeyResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline void DeleteShardKeyResponse::_internal_set_result(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace qdrant


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::qdrant::MaxOptimizationThreads_Setting> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::MaxOptimizationThreads_Setting>() {
  return ::qdrant::MaxOptimizationThreads_Setting_descriptor();
}
template <>
struct is_proto_enum<::qdrant::BinaryQuantizationQueryEncoding_Setting> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::BinaryQuantizationQueryEncoding_Setting>() {
  return ::qdrant::BinaryQuantizationQueryEncoding_Setting_descriptor();
}
template <>
struct is_proto_enum<::qdrant::Datatype> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::Datatype>() {
  return ::qdrant::Datatype_descriptor();
}
template <>
struct is_proto_enum<::qdrant::Modifier> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::Modifier>() {
  return ::qdrant::Modifier_descriptor();
}
template <>
struct is_proto_enum<::qdrant::MultiVectorComparator> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::MultiVectorComparator>() {
  return ::qdrant::MultiVectorComparator_descriptor();
}
template <>
struct is_proto_enum<::qdrant::Distance> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::Distance>() {
  return ::qdrant::Distance_descriptor();
}
template <>
struct is_proto_enum<::qdrant::CollectionStatus> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::CollectionStatus>() {
  return ::qdrant::CollectionStatus_descriptor();
}
template <>
struct is_proto_enum<::qdrant::PayloadSchemaType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::PayloadSchemaType>() {
  return ::qdrant::PayloadSchemaType_descriptor();
}
template <>
struct is_proto_enum<::qdrant::QuantizationType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::QuantizationType>() {
  return ::qdrant::QuantizationType_descriptor();
}
template <>
struct is_proto_enum<::qdrant::CompressionRatio> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::CompressionRatio>() {
  return ::qdrant::CompressionRatio_descriptor();
}
template <>
struct is_proto_enum<::qdrant::BinaryQuantizationEncoding> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::BinaryQuantizationEncoding>() {
  return ::qdrant::BinaryQuantizationEncoding_descriptor();
}
template <>
struct is_proto_enum<::qdrant::ShardingMethod> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::ShardingMethod>() {
  return ::qdrant::ShardingMethod_descriptor();
}
template <>
struct is_proto_enum<::qdrant::TokenizerType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::TokenizerType>() {
  return ::qdrant::TokenizerType_descriptor();
}
template <>
struct is_proto_enum<::qdrant::ReplicaState> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::ReplicaState>() {
  return ::qdrant::ReplicaState_descriptor();
}
template <>
struct is_proto_enum<::qdrant::ReshardingDirection> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::ReshardingDirection>() {
  return ::qdrant::ReshardingDirection_descriptor();
}
template <>
struct is_proto_enum<::qdrant::ShardTransferMethod> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::qdrant::ShardTransferMethod>() {
  return ::qdrant::ShardTransferMethod_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // collections_2eproto_2epb_2eh
